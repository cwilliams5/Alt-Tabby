; AUTO-GENERATED by tools/shader_bundle.ps1 -- DO NOT EDIT
; Source: src/shaders/
; Regenerate: powershell -File tools/shader_bundle.ps1
#Requires AutoHotkey v2.0
#Warn VarUnset, Off

global SHADER_NAMES := ["None", "002-Blue", "2D Clouds", "4D Lava Lamp", "70s Melt", "Abstract Glassy Field", "Abstract Painting", "Abstract Shine", "Abstract Vortex", "Accretion", "Alien Skin", "Alien Spawning Pool", "Another Windows Terminal Shader", "Ascend", "Balatro Background (Optimized)", "Balatro Twist", "Base Warp fBM", "Bent horizon", "Black Hole Accretion Disk", "BloodCells", "Blue Moon Ocean", "Blurry Circles", "BMtesting04", "BMtest2", "Bokeh Expe 03", "Bokeh Gradient", "Bokeh Lights", "Bokeh Parallax", "Brainfall", "Bubbles!", "Cheap Ocean", "Chill Smoke Orb", "Clearly a bug", "Cloud 3D", "color breath Screensaver", "Color Fade Pattern", "Colorfog", "Colorful FBM Domain Warping", "Colorful Fractal Thingy 2", "cosmic fbm noise", "crumpledWave", "Cube Wave 3", "Damask Rose", "Deterioration", "Digital Brain", "Digital Rain", "Disco Inferno", "Domain Warped FBM Noise", "Domain Warping Learn", "Domain Warping: Oil", "Domain Warping Test", "001-DrawCircle", "Drifting Waves", "Dune (Sand Worm)", "Enter The Matrix", "Exit the Matrix", "Explosive Turbulent Noise", "Faking Gold and Murder", "Fate Beckons", "FBM Domain Warping", "fBM Noise", "Fire", "Flower of Fractal", "Fork The Drive", "Fractal Galaxy Parallax", "Galvanize", "Galvanize Tunnel", "Gargantua Render", "Glasswall", "Glassy with odd rotation", "Glittery", "Glowing Marbling Black", "Gold Agate", "Grey Liquid", "Happy Little Windows Terminal", "Hell", "Holographic liquid", "Horizon Zero Dawn Clouds 2D", "HUD Matrix", "In Space", "Inside the Matrix", "Interstellar", "Is it still raymarching?", "Iso Screensaver", "Iterating caustics", "Jasz Universe", "Kaleidoscope Crystal", "Kaleidoscope Tunnel", "Lazer Beamz", "Limestone Cave", "LineSynapse", "Liquid Warp", "Mandelbox Sweeper", "Metal Vortex", "MONSTER", "5 Nanoseconds After BigBang", "Nebula Flight", "Nebula for Natalee", "Nebula Smoke", "Nebula - Space", "Neon Cubes", "Neon Plasma Storm", "Noise Accident", "Noise animation - Electric", "Noise animation - Flow", "Noise_Cristal", "Noise_Oil", "Nox", "O!", "Oily Thing", "Optical Spaghetti", "Organic Texture", "Overstimulated Neurons", "Paint 1", "Paint Archipelago", "Palace of Mind", "Path to the colorful infinity", "Perhaps a screensaver", "Phantom Star", "Pinwheel Triangles ScreenSaver", "Playing with FBM", "Power Chain Saw Man", "Pretty Colors", "Pretty Hip", "Processing Data (CineShader ed.)", "Protean Clouds", "Rainbow Screensaver Animation", "Raindrops on Glass", "Is it still raymarching?", "Reflective truchet'", "Retro Screensaver Lines", "Rocaille", "Rotating Torus", "Sailing Beyond - Hyper Tunnel", "Satinlike (Simple FBM Warp)", "Satori", "Screensaver Warped Grad Waves", "Sea Adventure", "shadetober #29 (injured)", "Simple Screensaver", "SIMPLEX 3D + FBM", "Singularity", "Smoke Flythrough", "Snow is Falling", "Soft Whisper", "SpaceEYE2", "Spirals for Windows Terminal", "Star New", "Star Shine", "Starfield Screensaver", "Starfield Sim v2.0", "starfield with fbm", "Starleidoscope", "Starship", "Sun Surface", "Surveillance", "Tentacles of Light", "Tileable Water Caustic", "Tiles, Interesting Patterns", "Toxic Lake", "Triangle Noise", "Turbulence Texture", "Ultra Liquid Bokeh", "Underwater Caustics", "Vista-Esque Wallpaper", "Volumetric Fire", "Voronoi Burning", "Warped Liquid Metal", "Warped noise with shadows", "Wavy hexagon", "Worley Noise Waters", "Worm City", "Zippy Zaps"]
global SHADER_KEYS := ["", "002Blue", "2dClouds", "4dLavaLamp", "70sMelt", "abstractGlassyField", "abstractPainting", "abstractShine", "abstractVortex", "accretion", "alienSkin", "alienSpawningPool", "anotherWindowsTerminalShader", "ascend", "balatroBackground", "balatroTwist", "baseWarpFbm", "bentHorizon", "blackHoleAccretionDisk", "bloodCells", "blueMoonOcean", "blurryCircles", "bmTesting04", "bmtest2", "bokehExpe03", "bokehGradient", "bokehLights", "bokehParallax", "brainfall", "bubbles", "cheapOcean", "chillSmokeOrb", "clearlyABug", "cloud3d", "colorBreathScreensaver", "colorFadePattern", "colorfog", "colorfulFbmDomainWarping", "colorfulFractalThingy2", "cosmicFbmNoise", "crumpledWave", "cubeWave3", "damaskRose", "deterioration", "digitalBrain", "digitalRain", "discoInferno", "domainWarpedFbmNoise", "domainWarpingLearn", "domainWarpingOil", "domainWarpingTest", "drawCircle", "driftingWaves", "duneSandworm", "enterTheMatrix", "exitTheMatrix", "explosiveTurbulentNoise", "fakingGoldAndMurder", "fateBeckons", "fbmDomainWarping", "fbmNoise", "fire", "flowerOfFractal", "forkTheDrive", "fractalGalaxyParallax", "galvanize", "galvanizeTunnel", "gargantuaRender", "glasswall", "glassyWithOddRotation", "glittery", "glowingMarblingBlack", "goldAgate", "greyLiquid", "happyLittleWindowsTerminal", "hell", "holographicLiquid", "horizonZeroDawnClouds2d", "hudMatrix", "inSpace", "insideTheMatrix", "interstellar", "isItStillRaymarching", "isoScreensaver", "iteratingCaustics", "jaszUniverse", "kaleidoscopeCrystal", "kaleidoscopeTunnel", "lazerBeamz", "limestoneCave", "lineSynapse", "liquidWarp", "mandelboxSweeper", "metalVortex", "monster", "nanosecondsAfterBigbang", "nebulaFlight", "nebulaForNatalee", "nebulaSmoke", "nebulaSpace", "neonCubes", "neonPlasmaStorm", "noiseAccident", "noiseAnimationElectric", "noiseAnimationFlow", "noiseCristal", "noiseOil", "nox", "oVortex", "oilyThing", "opticalSpaghetti", "organicTexture", "overstimulatedNeurons", "paint1", "paintArchipelago", "palaceOfMind", "pathToTheColorfulInfinity", "perhapsAScreensaver", "phantomStar", "pinwheelTrianglesScreensaver", "playingWithFbm", "powerChainSawMan", "prettyColors", "prettyHip", "processingData", "proteanClouds", "rainbowScreensaverAnimation", "raindropsGlass", "raymarchingWaves", "reflectiveTruchet", "retroScreensaverLines", "rocaille", "rotatingTorus", "sailingBeyondHyperTunnel", "satinlike", "satori", "screensaverWarpedGradWaves", "seaAdventure", "shadetober29Injured", "simpleScreensaver", "simplex3dFbm", "singularity", "smokeFlythrough", "snowIsFalling", "softWhisper", "spaceEye2", "spiralsForWindowsTerminal", "starNew", "starShine", "starfieldScreensaver", "starfieldSimV2", "starfieldWithFbm", "starleidoscope", "starship", "sunSurface", "surveillance", "tentaclesOfLight", "tileableWaterCaustic", "tilesInterestingPatterns", "toxicLake", "triangleNoise", "turbulenceTexture", "ultraLiquidBokeh", "underwaterCaustics", "vistaEsqueWallpaper", "volumetricFire", "voronoiBurning", "warpedLiquidMetal", "warpedNoiseWithShadows", "wavyHexagon", "worleyNoiseWaters", "wormCity", "zippyZaps"]

Shader_RegisterAll() {
    Shader_Register("002Blue", _Shader_HLSL_002Blue(), _Shader_Meta_002Blue())
    Shader_Register("2dClouds", _Shader_HLSL_2dClouds(), _Shader_Meta_2dClouds())
    Shader_Register("4dLavaLamp", _Shader_HLSL_4dLavaLamp(), _Shader_Meta_4dLavaLamp())
    Shader_Register("70sMelt", _Shader_HLSL_70sMelt(), _Shader_Meta_70sMelt())
    Shader_Register("abstractGlassyField", _Shader_HLSL_AbstractGlassyField(), _Shader_Meta_AbstractGlassyField())
    Shader_Register("abstractPainting", _Shader_HLSL_AbstractPainting(), _Shader_Meta_AbstractPainting())
    Shader_Register("abstractShine", _Shader_HLSL_AbstractShine(), _Shader_Meta_AbstractShine())
    Shader_Register("abstractVortex", _Shader_HLSL_AbstractVortex(), _Shader_Meta_AbstractVortex())
    Shader_Register("accretion", _Shader_HLSL_Accretion(), _Shader_Meta_Accretion())
    Shader_Register("alienSkin", _Shader_HLSL_AlienSkin(), _Shader_Meta_AlienSkin())
    Shader_Register("alienSpawningPool", _Shader_HLSL_AlienSpawningPool(), _Shader_Meta_AlienSpawningPool())
    Shader_Register("anotherWindowsTerminalShader", _Shader_HLSL_AnotherWindowsTerminalShader(), _Shader_Meta_AnotherWindowsTerminalShader())
    Shader_Register("ascend", _Shader_HLSL_Ascend(), _Shader_Meta_Ascend())
    Shader_Register("balatroBackground", _Shader_HLSL_BalatroBackground(), _Shader_Meta_BalatroBackground())
    Shader_Register("balatroTwist", _Shader_HLSL_BalatroTwist(), _Shader_Meta_BalatroTwist())
    Shader_Register("baseWarpFbm", _Shader_HLSL_BaseWarpFbm(), _Shader_Meta_BaseWarpFbm())
    Shader_Register("bentHorizon", _Shader_HLSL_BentHorizon(), _Shader_Meta_BentHorizon())
    Shader_Register("blackHoleAccretionDisk", _Shader_HLSL_BlackHoleAccretionDisk(), _Shader_Meta_BlackHoleAccretionDisk())
    Shader_Register("bloodCells", _Shader_HLSL_BloodCells(), _Shader_Meta_BloodCells())
    Shader_Register("blueMoonOcean", _Shader_HLSL_BlueMoonOcean(), _Shader_Meta_BlueMoonOcean())
    Shader_Register("blurryCircles", _Shader_HLSL_BlurryCircles(), _Shader_Meta_BlurryCircles())
    Shader_Register("bmTesting04", _Shader_HLSL_BmTesting04(), _Shader_Meta_BmTesting04())
    Shader_Register("bmtest2", _Shader_HLSL_Bmtest2(), _Shader_Meta_Bmtest2())
    Shader_Register("bokehExpe03", _Shader_HLSL_BokehExpe03(), _Shader_Meta_BokehExpe03())
    Shader_Register("bokehGradient", _Shader_HLSL_BokehGradient(), _Shader_Meta_BokehGradient())
    Shader_Register("bokehLights", _Shader_HLSL_BokehLights(), _Shader_Meta_BokehLights())
    Shader_Register("bokehParallax", _Shader_HLSL_BokehParallax(), _Shader_Meta_BokehParallax())
    Shader_Register("brainfall", _Shader_HLSL_Brainfall(), _Shader_Meta_Brainfall())
    Shader_Register("bubbles", _Shader_HLSL_Bubbles(), _Shader_Meta_Bubbles())
    Shader_Register("cheapOcean", _Shader_HLSL_CheapOcean(), _Shader_Meta_CheapOcean())
    Shader_Register("chillSmokeOrb", _Shader_HLSL_ChillSmokeOrb(), _Shader_Meta_ChillSmokeOrb())
    Shader_Register("clearlyABug", _Shader_HLSL_ClearlyABug(), _Shader_Meta_ClearlyABug())
    Shader_Register("cloud3d", _Shader_HLSL_Cloud3d(), _Shader_Meta_Cloud3d())
    Shader_Register("colorBreathScreensaver", _Shader_HLSL_ColorBreathScreensaver(), _Shader_Meta_ColorBreathScreensaver())
    Shader_Register("colorFadePattern", _Shader_HLSL_ColorFadePattern(), _Shader_Meta_ColorFadePattern())
    Shader_Register("colorfog", _Shader_HLSL_Colorfog(), _Shader_Meta_Colorfog())
    Shader_Register("colorfulFbmDomainWarping", _Shader_HLSL_ColorfulFbmDomainWarping(), _Shader_Meta_ColorfulFbmDomainWarping())
    Shader_Register("colorfulFractalThingy2", _Shader_HLSL_ColorfulFractalThingy2(), _Shader_Meta_ColorfulFractalThingy2())
    Shader_Register("cosmicFbmNoise", _Shader_HLSL_CosmicFbmNoise(), _Shader_Meta_CosmicFbmNoise())
    Shader_Register("crumpledWave", _Shader_HLSL_CrumpledWave(), _Shader_Meta_CrumpledWave())
    Shader_Register("cubeWave3", _Shader_HLSL_CubeWave3(), _Shader_Meta_CubeWave3())
    Shader_Register("damaskRose", _Shader_HLSL_DamaskRose(), _Shader_Meta_DamaskRose())
    Shader_Register("deterioration", _Shader_HLSL_Deterioration(), _Shader_Meta_Deterioration())
    Shader_Register("digitalBrain", _Shader_HLSL_DigitalBrain(), _Shader_Meta_DigitalBrain())
    Shader_Register("digitalRain", _Shader_HLSL_DigitalRain(), _Shader_Meta_DigitalRain())
    Shader_Register("discoInferno", _Shader_HLSL_DiscoInferno(), _Shader_Meta_DiscoInferno())
    Shader_Register("domainWarpedFbmNoise", _Shader_HLSL_DomainWarpedFbmNoise(), _Shader_Meta_DomainWarpedFbmNoise())
    Shader_Register("domainWarpingLearn", _Shader_HLSL_DomainWarpingLearn(), _Shader_Meta_DomainWarpingLearn())
    Shader_Register("domainWarpingOil", _Shader_HLSL_DomainWarpingOil(), _Shader_Meta_DomainWarpingOil())
    Shader_Register("domainWarpingTest", _Shader_HLSL_DomainWarpingTest(), _Shader_Meta_DomainWarpingTest())
    Shader_Register("drawCircle", _Shader_HLSL_DrawCircle(), _Shader_Meta_DrawCircle())
    Shader_Register("driftingWaves", _Shader_HLSL_DriftingWaves(), _Shader_Meta_DriftingWaves())
    Shader_Register("duneSandworm", _Shader_HLSL_DuneSandworm(), _Shader_Meta_DuneSandworm())
    Shader_Register("enterTheMatrix", _Shader_HLSL_EnterTheMatrix(), _Shader_Meta_EnterTheMatrix())
    Shader_Register("exitTheMatrix", _Shader_HLSL_ExitTheMatrix(), _Shader_Meta_ExitTheMatrix())
    Shader_Register("explosiveTurbulentNoise", _Shader_HLSL_ExplosiveTurbulentNoise(), _Shader_Meta_ExplosiveTurbulentNoise())
    Shader_Register("fakingGoldAndMurder", _Shader_HLSL_FakingGoldAndMurder(), _Shader_Meta_FakingGoldAndMurder())
    Shader_Register("fateBeckons", _Shader_HLSL_FateBeckons(), _Shader_Meta_FateBeckons())
    Shader_Register("fbmDomainWarping", _Shader_HLSL_FbmDomainWarping(), _Shader_Meta_FbmDomainWarping())
    Shader_Register("fbmNoise", _Shader_HLSL_FbmNoise(), _Shader_Meta_FbmNoise())
    Shader_Register("fire", _Shader_HLSL_Fire(), _Shader_Meta_Fire())
    Shader_Register("flowerOfFractal", _Shader_HLSL_FlowerOfFractal(), _Shader_Meta_FlowerOfFractal())
    Shader_Register("forkTheDrive", _Shader_HLSL_ForkTheDrive(), _Shader_Meta_ForkTheDrive())
    Shader_Register("fractalGalaxyParallax", _Shader_HLSL_FractalGalaxyParallax(), _Shader_Meta_FractalGalaxyParallax())
    Shader_Register("galvanize", _Shader_HLSL_Galvanize(), _Shader_Meta_Galvanize())
    Shader_Register("galvanizeTunnel", _Shader_HLSL_GalvanizeTunnel(), _Shader_Meta_GalvanizeTunnel())
    Shader_Register("gargantuaRender", _Shader_HLSL_GargantuaRender(), _Shader_Meta_GargantuaRender())
    Shader_Register("glasswall", _Shader_HLSL_Glasswall(), _Shader_Meta_Glasswall())
    Shader_Register("glassyWithOddRotation", _Shader_HLSL_GlassyWithOddRotation(), _Shader_Meta_GlassyWithOddRotation())
    Shader_Register("glittery", _Shader_HLSL_Glittery(), _Shader_Meta_Glittery())
    Shader_Register("glowingMarblingBlack", _Shader_HLSL_GlowingMarblingBlack(), _Shader_Meta_GlowingMarblingBlack())
    Shader_Register("goldAgate", _Shader_HLSL_GoldAgate(), _Shader_Meta_GoldAgate())
    Shader_Register("greyLiquid", _Shader_HLSL_GreyLiquid(), _Shader_Meta_GreyLiquid())
    Shader_Register("happyLittleWindowsTerminal", _Shader_HLSL_HappyLittleWindowsTerminal(), _Shader_Meta_HappyLittleWindowsTerminal())
    Shader_Register("hell", _Shader_HLSL_Hell(), _Shader_Meta_Hell())
    Shader_Register("holographicLiquid", _Shader_HLSL_HolographicLiquid(), _Shader_Meta_HolographicLiquid())
    Shader_Register("horizonZeroDawnClouds2d", _Shader_HLSL_HorizonZeroDawnClouds2d(), _Shader_Meta_HorizonZeroDawnClouds2d())
    Shader_Register("hudMatrix", _Shader_HLSL_HudMatrix(), _Shader_Meta_HudMatrix())
    Shader_Register("inSpace", _Shader_HLSL_InSpace(), _Shader_Meta_InSpace())
    Shader_Register("insideTheMatrix", _Shader_HLSL_InsideTheMatrix(), _Shader_Meta_InsideTheMatrix())
    Shader_Register("interstellar", _Shader_HLSL_Interstellar(), _Shader_Meta_Interstellar())
    Shader_Register("isItStillRaymarching", _Shader_HLSL_IsItStillRaymarching(), _Shader_Meta_IsItStillRaymarching())
    Shader_Register("isoScreensaver", _Shader_HLSL_IsoScreensaver(), _Shader_Meta_IsoScreensaver())
    Shader_Register("iteratingCaustics", _Shader_HLSL_IteratingCaustics(), _Shader_Meta_IteratingCaustics())
    Shader_Register("jaszUniverse", _Shader_HLSL_JaszUniverse(), _Shader_Meta_JaszUniverse())
    Shader_Register("kaleidoscopeCrystal", _Shader_HLSL_KaleidoscopeCrystal(), _Shader_Meta_KaleidoscopeCrystal())
    Shader_Register("kaleidoscopeTunnel", _Shader_HLSL_KaleidoscopeTunnel(), _Shader_Meta_KaleidoscopeTunnel())
    Shader_Register("lazerBeamz", _Shader_HLSL_LazerBeamz(), _Shader_Meta_LazerBeamz())
    Shader_Register("limestoneCave", _Shader_HLSL_LimestoneCave(), _Shader_Meta_LimestoneCave())
    Shader_Register("lineSynapse", _Shader_HLSL_LineSynapse(), _Shader_Meta_LineSynapse())
    Shader_Register("liquidWarp", _Shader_HLSL_LiquidWarp(), _Shader_Meta_LiquidWarp())
    Shader_Register("mandelboxSweeper", _Shader_HLSL_MandelboxSweeper(), _Shader_Meta_MandelboxSweeper())
    Shader_Register("metalVortex", _Shader_HLSL_MetalVortex(), _Shader_Meta_MetalVortex())
    Shader_Register("monster", _Shader_HLSL_Monster(), _Shader_Meta_Monster())
    Shader_Register("nanosecondsAfterBigbang", _Shader_HLSL_NanosecondsAfterBigbang(), _Shader_Meta_NanosecondsAfterBigbang())
    Shader_Register("nebulaFlight", _Shader_HLSL_NebulaFlight(), _Shader_Meta_NebulaFlight())
    Shader_Register("nebulaForNatalee", _Shader_HLSL_NebulaForNatalee(), _Shader_Meta_NebulaForNatalee())
    Shader_Register("nebulaSmoke", _Shader_HLSL_NebulaSmoke(), _Shader_Meta_NebulaSmoke())
    Shader_Register("nebulaSpace", _Shader_HLSL_NebulaSpace(), _Shader_Meta_NebulaSpace())
    Shader_Register("neonCubes", _Shader_HLSL_NeonCubes(), _Shader_Meta_NeonCubes())
    Shader_Register("neonPlasmaStorm", _Shader_HLSL_NeonPlasmaStorm(), _Shader_Meta_NeonPlasmaStorm())
    Shader_Register("noiseAccident", _Shader_HLSL_NoiseAccident(), _Shader_Meta_NoiseAccident())
    Shader_Register("noiseAnimationElectric", _Shader_HLSL_NoiseAnimationElectric(), _Shader_Meta_NoiseAnimationElectric())
    Shader_Register("noiseAnimationFlow", _Shader_HLSL_NoiseAnimationFlow(), _Shader_Meta_NoiseAnimationFlow())
    Shader_Register("noiseCristal", _Shader_HLSL_NoiseCristal(), _Shader_Meta_NoiseCristal())
    Shader_Register("noiseOil", _Shader_HLSL_NoiseOil(), _Shader_Meta_NoiseOil())
    Shader_Register("nox", _Shader_HLSL_Nox(), _Shader_Meta_Nox())
    Shader_Register("oVortex", _Shader_HLSL_OVortex(), _Shader_Meta_OVortex())
    Shader_Register("oilyThing", _Shader_HLSL_OilyThing(), _Shader_Meta_OilyThing())
    Shader_Register("opticalSpaghetti", _Shader_HLSL_OpticalSpaghetti(), _Shader_Meta_OpticalSpaghetti())
    Shader_Register("organicTexture", _Shader_HLSL_OrganicTexture(), _Shader_Meta_OrganicTexture())
    Shader_Register("overstimulatedNeurons", _Shader_HLSL_OverstimulatedNeurons(), _Shader_Meta_OverstimulatedNeurons())
    Shader_Register("paint1", _Shader_HLSL_Paint1(), _Shader_Meta_Paint1())
    Shader_Register("paintArchipelago", _Shader_HLSL_PaintArchipelago(), _Shader_Meta_PaintArchipelago())
    Shader_Register("palaceOfMind", _Shader_HLSL_PalaceOfMind(), _Shader_Meta_PalaceOfMind())
    Shader_Register("pathToTheColorfulInfinity", _Shader_HLSL_PathToTheColorfulInfinity(), _Shader_Meta_PathToTheColorfulInfinity())
    Shader_Register("perhapsAScreensaver", _Shader_HLSL_PerhapsAScreensaver(), _Shader_Meta_PerhapsAScreensaver())
    Shader_Register("phantomStar", _Shader_HLSL_PhantomStar(), _Shader_Meta_PhantomStar())
    Shader_Register("pinwheelTrianglesScreensaver", _Shader_HLSL_PinwheelTrianglesScreensaver(), _Shader_Meta_PinwheelTrianglesScreensaver())
    Shader_Register("playingWithFbm", _Shader_HLSL_PlayingWithFbm(), _Shader_Meta_PlayingWithFbm())
    Shader_Register("powerChainSawMan", _Shader_HLSL_PowerChainSawMan(), _Shader_Meta_PowerChainSawMan())
    Shader_Register("prettyColors", _Shader_HLSL_PrettyColors(), _Shader_Meta_PrettyColors())
    Shader_Register("prettyHip", _Shader_HLSL_PrettyHip(), _Shader_Meta_PrettyHip())
    Shader_Register("processingData", _Shader_HLSL_ProcessingData(), _Shader_Meta_ProcessingData())
    Shader_Register("proteanClouds", _Shader_HLSL_ProteanClouds(), _Shader_Meta_ProteanClouds())
    Shader_Register("rainbowScreensaverAnimation", _Shader_HLSL_RainbowScreensaverAnimation(), _Shader_Meta_RainbowScreensaverAnimation())
    Shader_Register("raindropsGlass", _Shader_HLSL_RaindropsGlass(), _Shader_Meta_RaindropsGlass())
    Shader_Register("raymarchingWaves", _Shader_HLSL_RaymarchingWaves(), _Shader_Meta_RaymarchingWaves())
    Shader_Register("reflectiveTruchet", _Shader_HLSL_ReflectiveTruchet(), _Shader_Meta_ReflectiveTruchet())
    Shader_Register("retroScreensaverLines", _Shader_HLSL_RetroScreensaverLines(), _Shader_Meta_RetroScreensaverLines())
    Shader_Register("rocaille", _Shader_HLSL_Rocaille(), _Shader_Meta_Rocaille())
    Shader_Register("rotatingTorus", _Shader_HLSL_RotatingTorus(), _Shader_Meta_RotatingTorus())
    Shader_Register("sailingBeyondHyperTunnel", _Shader_HLSL_SailingBeyondHyperTunnel(), _Shader_Meta_SailingBeyondHyperTunnel())
    Shader_Register("satinlike", _Shader_HLSL_Satinlike(), _Shader_Meta_Satinlike())
    Shader_Register("satori", _Shader_HLSL_Satori(), _Shader_Meta_Satori())
    Shader_Register("screensaverWarpedGradWaves", _Shader_HLSL_ScreensaverWarpedGradWaves(), _Shader_Meta_ScreensaverWarpedGradWaves())
    Shader_Register("seaAdventure", _Shader_HLSL_SeaAdventure(), _Shader_Meta_SeaAdventure())
    Shader_Register("shadetober29Injured", _Shader_HLSL_Shadetober29Injured(), _Shader_Meta_Shadetober29Injured())
    Shader_Register("simpleScreensaver", _Shader_HLSL_SimpleScreensaver(), _Shader_Meta_SimpleScreensaver())
    Shader_Register("simplex3dFbm", _Shader_HLSL_Simplex3dFbm(), _Shader_Meta_Simplex3dFbm())
    Shader_Register("singularity", _Shader_HLSL_Singularity(), _Shader_Meta_Singularity())
    Shader_Register("smokeFlythrough", _Shader_HLSL_SmokeFlythrough(), _Shader_Meta_SmokeFlythrough())
    Shader_Register("snowIsFalling", _Shader_HLSL_SnowIsFalling(), _Shader_Meta_SnowIsFalling())
    Shader_Register("softWhisper", _Shader_HLSL_SoftWhisper(), _Shader_Meta_SoftWhisper())
    Shader_Register("spaceEye2", _Shader_HLSL_SpaceEye2(), _Shader_Meta_SpaceEye2())
    Shader_Register("spiralsForWindowsTerminal", _Shader_HLSL_SpiralsForWindowsTerminal(), _Shader_Meta_SpiralsForWindowsTerminal())
    Shader_Register("starNew", _Shader_HLSL_StarNew(), _Shader_Meta_StarNew())
    Shader_Register("starShine", _Shader_HLSL_StarShine(), _Shader_Meta_StarShine())
    Shader_Register("starfieldScreensaver", _Shader_HLSL_StarfieldScreensaver(), _Shader_Meta_StarfieldScreensaver())
    Shader_Register("starfieldSimV2", _Shader_HLSL_StarfieldSimV2(), _Shader_Meta_StarfieldSimV2())
    Shader_Register("starfieldWithFbm", _Shader_HLSL_StarfieldWithFbm(), _Shader_Meta_StarfieldWithFbm())
    Shader_Register("starleidoscope", _Shader_HLSL_Starleidoscope(), _Shader_Meta_Starleidoscope())
    Shader_Register("starship", _Shader_HLSL_Starship(), _Shader_Meta_Starship())
    Shader_Register("sunSurface", _Shader_HLSL_SunSurface(), _Shader_Meta_SunSurface())
    Shader_Register("surveillance", _Shader_HLSL_Surveillance(), _Shader_Meta_Surveillance())
    Shader_Register("tentaclesOfLight", _Shader_HLSL_TentaclesOfLight(), _Shader_Meta_TentaclesOfLight())
    Shader_Register("tileableWaterCaustic", _Shader_HLSL_TileableWaterCaustic(), _Shader_Meta_TileableWaterCaustic())
    Shader_Register("tilesInterestingPatterns", _Shader_HLSL_TilesInterestingPatterns(), _Shader_Meta_TilesInterestingPatterns())
    Shader_Register("toxicLake", _Shader_HLSL_ToxicLake(), _Shader_Meta_ToxicLake())
    Shader_Register("triangleNoise", _Shader_HLSL_TriangleNoise(), _Shader_Meta_TriangleNoise())
    Shader_Register("turbulenceTexture", _Shader_HLSL_TurbulenceTexture(), _Shader_Meta_TurbulenceTexture())
    Shader_Register("ultraLiquidBokeh", _Shader_HLSL_UltraLiquidBokeh(), _Shader_Meta_UltraLiquidBokeh())
    Shader_Register("underwaterCaustics", _Shader_HLSL_UnderwaterCaustics(), _Shader_Meta_UnderwaterCaustics())
    Shader_Register("vistaEsqueWallpaper", _Shader_HLSL_VistaEsqueWallpaper(), _Shader_Meta_VistaEsqueWallpaper())
    Shader_Register("volumetricFire", _Shader_HLSL_VolumetricFire(), _Shader_Meta_VolumetricFire())
    Shader_Register("voronoiBurning", _Shader_HLSL_VoronoiBurning(), _Shader_Meta_VoronoiBurning())
    Shader_Register("warpedLiquidMetal", _Shader_HLSL_WarpedLiquidMetal(), _Shader_Meta_WarpedLiquidMetal())
    Shader_Register("warpedNoiseWithShadows", _Shader_HLSL_WarpedNoiseWithShadows(), _Shader_Meta_WarpedNoiseWithShadows())
    Shader_Register("wavyHexagon", _Shader_HLSL_WavyHexagon(), _Shader_Meta_WavyHexagon())
    Shader_Register("worleyNoiseWaters", _Shader_HLSL_WorleyNoiseWaters(), _Shader_Meta_WorleyNoiseWaters())
    Shader_Register("wormCity", _Shader_HLSL_WormCity(), _Shader_Meta_WormCity())
    Shader_Register("zippyZaps", _Shader_HLSL_ZippyZaps(), _Shader_Meta_ZippyZaps())
}

_Shader_HLSL_002Blue() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float sdSphere(float3 pos, float size) {
    return length(pos) - size;
}

float sdBox(float3 pos, float3 size) {
    pos = abs(pos) - size;
    return max(max(pos.x, pos.y), pos.z);
}

float sdOctahedron(float3 p, float s) {
    p = abs(p);
    float m = p.x + p.y + p.z - s;
    float3 q;
    if (3.0 * p.x < m) q = p.xyz;
    else if (3.0 * p.y < m) q = p.yzx;
    else if (3.0 * p.z < m) q = p.zxy;
    else return m * 0.57735027;

    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);
    return length(float3(q.x, q.y - s + k, q.z - k));
}

float2x2 rot(float a) {
    float s = sin(a);
    float c = cos(a);
    return float2x2(c, s, -s, c);
}

float3 repeat(float3 pos, float3 span) {
    return abs(fmod(pos, span)) - span * 0.5;
}

float getDistance(float3 pos, float2 uv) {
    float3 originalPos = pos;

    for (int i = 0; i < 3; i++) {
        pos = abs(pos) - 4.5;
        pos.xz = mul(pos.xz, rot(1.0));
        pos.yz = mul(pos.yz, rot(1.0));
    }

    pos = repeat(pos, float3(4.0, 4.0, 4.0));

    float d0 = abs(originalPos.x) - 0.1;
    float d1 = sdBox(pos, float3(0.8, 0.8, 0.8));

    pos.xy = mul(pos.xy, rot(lerp(1.0, 2.0, abs(sin(time)))));
    float size = lerp(1.1, 1.3, abs(uv.y) * abs(uv.x));
    float d2 = sdSphere(pos, size);
    float dd2 = sdOctahedron(pos, 1.8);
    float ddd2 = lerp(d2, dd2, abs(sin(time)));

    return max(max(d1, -ddd2), -d0);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 p = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);

    // camera
    float3 cameraOrigin = float3(0.0, 0.0, -10.0 + time * 4.0);
    float3 cameraTarget = float3(cos(time) + sin(time / 2.0) * 10.0, exp(sin(time)) * 2.0, 3.0 + time * 4.0);
    float3 upDirection = float3(0.0, 1.0, 0.0);
    float3 cameraDir = normalize(cameraTarget - cameraOrigin);
    float3 cameraRight = normalize(cross(upDirection, cameraOrigin));
    float3 cameraUp = cross(cameraDir, cameraRight);
    float3 rayDirection = normalize(cameraRight * p.x + cameraUp * p.y + cameraDir);

    float depth = 0.0;
    float ac = 0.0;
    float3 rayPos = float3(0.0, 0.0, 0.0);
    float d = 0.0;

    for (int i = 0; i < 80; i++) {
        rayPos = cameraOrigin + rayDirection * depth;
        d = getDistance(rayPos, p);

        if (abs(d) < 0.0001) {
            break;
        }

        ac += exp(-d * lerp(5.0, 10.0, abs(sin(time))));
        depth += d;
    }

    float3 col = float3(0.0, 0.3, 0.7);
    ac *= 1.2 * (resolution.x / resolution.y - abs(p.x));
    float3 finalCol = col * ac * 0.06;

    // Post-processing
    float lum = dot(finalCol, float3(0.299, 0.587, 0.114));
    finalCol = lerp(finalCol, float3(lum, lum, lum), desaturate);
    finalCol = finalCol * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(finalCol.r, max(finalCol.g, finalCol.b));
    return float4(finalCol * a, a);
}

    )"
}

_Shader_Meta_002Blue() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_2dClouds() {
    return "
    (
// 2D Clouds - drift (Shadertoy 4tdSWr)
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float cloudscale = 1.1;
static const float speed = 0.03;
static const float clouddark = 0.5;
static const float cloudlight = 0.3;
static const float cloudcover = 0.2;
static const float cloudalpha = 8.0;
static const float skytint = 0.5;
static const float3 skycolour1 = float3(0.2, 0.4, 0.6);
static const float3 skycolour2 = float3(0.4, 0.7, 1.0);

static const float2x2 m = float2x2( 1.6, 1.2, -1.2, 1.6 );

float2 hash( float2 p ) {
    p = float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

float noise( in float2 p ) {
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;
    float2 i = floor(p + (p.x + p.y) * K1);
    float2 a = p - i + (i.x + i.y) * K2;
    float2 o = (a.x > a.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float2 b = a - o + K2;
    float2 c = a - 1.0 + 2.0 * K2;
    float3 h = max(0.5 - float3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
    float3 n = h * h * h * h * float3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));
    return dot(n, (float3)70.0);
}

float fbm(float2 n) {
    float total = 0.0, amplitude = 0.1;
    for (int i = 0; i < 7; i++) {
        total += noise(n) * amplitude;
        n = mul(n, m);
        amplitude *= 0.4;
    }
    return total;
}

// -----------------------------------------------

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 p = fragCoord.xy / resolution.xy;
    float2 uv = p * float2(resolution.x / resolution.y, 1.0);
    float t = time * speed;
    float q = fbm(uv * cloudscale * 0.5);

    //ridged noise shape
    float r = 0.0;
    uv *= cloudscale;
    uv -= q - t;
    float weight = 0.8;
    for (int i = 0; i < 8; i++) {
        r += abs(weight * noise(uv));
        uv = mul(uv, m) + t;
        weight *= 0.7;
    }

    //noise shape
    float f = 0.0;
    uv = p * float2(resolution.x / resolution.y, 1.0);
    uv *= cloudscale;
    uv -= q - t;
    weight = 0.7;
    for (int j = 0; j < 8; j++) {
        f += weight * noise(uv);
        uv = mul(uv, m) + t;
        weight *= 0.6;
    }

    f *= r + f;

    //noise colour
    float c = 0.0;
    t = time * speed * 2.0;
    uv = p * float2(resolution.x / resolution.y, 1.0);
    uv *= cloudscale * 2.0;
    uv -= q - t;
    weight = 0.4;
    for (int k = 0; k < 7; k++) {
        c += weight * noise(uv);
        uv = mul(uv, m) + t;
        weight *= 0.6;
    }

    //noise ridge colour
    float c1 = 0.0;
    t = time * speed * 3.0;
    uv = p * float2(resolution.x / resolution.y, 1.0);
    uv *= cloudscale * 3.0;
    uv -= q - t;
    weight = 0.4;
    for (int l = 0; l < 7; l++) {
        c1 += abs(weight * noise(uv));
        uv = mul(uv, m) + t;
        weight *= 0.6;
    }

    c += c1;

    float3 skycolour = lerp(skycolour2, skycolour1, p.y);
    float3 cloudcolour = float3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight * c), 0.0, 1.0);

    f = cloudcover + cloudalpha * f * r;

    float3 result = lerp(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));

    // Darken/desaturate post-processing
    float lum = dot(result, float3(0.299, 0.587, 0.114));
    result = lerp(result, float3(lum, lum, lum), desaturate);
    result = result * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(result.r, max(result.g, result.b));
    return float4(result * a, a);
}

    )"
}

_Shader_Meta_2dClouds() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_4dLavaLamp() {
    return "
    (
// The MIT License
// Copyright (c) 2013 Inigo Quilez
// substantial refactoring by 2021 Alalalat
// Converted from Shadertoy GLSL to Alt-Tabby HLSL

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2 hash(float2 p)
{
    p = float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

float noise(float2 p)
{
    const float K1 = 0.366025404; // (sqrt(3)-1)/2
    const float K2 = 0.211324865; // (3-sqrt(3))/6

    float2 i = floor(p + (p.x + p.y) * K1);
    float2 a = p - i + (i.x + i.y) * K2;
    float m = step(a.y, a.x);
    float2 o = float2(m, 1.0 - m);
    float2 b = a - o + K2;
    float2 c = a - 1.0 + 2.0 * K2;
    float3 h = max(0.5 - float3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
    float3 n = h * h * h * h * float3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));
    return dot(n, float3(70.0, 70.0, 70.0));
}

float maximum3(float3 p)
{
    float mx = p.x;
    if (p.y > mx) mx = p.y;
    if (p.z > mx) mx = p.z;
    return mx;
}

float minimum3(float3 p)
{
    float mn = p.x;
    if (p.y < mn) mn = p.y;
    if (p.z < mn) mn = p.z;
    return mn;
}

float3 normalize2(float3 grosscolor)
{
    grosscolor = grosscolor * grosscolor * grosscolor;
    float mx = maximum3(grosscolor);
    float mn = minimum3(grosscolor);
    return grosscolor.xyz / (mx + mn);
}

float2 rotate(float2 oldpoint, float angle)
{
    float left, right;

    left = cos(angle) * oldpoint.x;
    left -= sin(angle) * oldpoint.y;
    right = sin(angle) * oldpoint.x;
    right += cos(angle) * oldpoint.y;

    return float2(left, right);
}

float noise4(float2 uv)
{
    float f = 0.5;
    float frequency = 1.75;
    float amplitude = 0.5;
    for (int i = 0; i < 7; i++) {
        f += amplitude * noise(frequency * uv - rotate(float2(log(time + 3.0), log(time + 3.0) / 999.0), time / 9999.0));
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return f;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 p = fragCoord.xy / resolution.xy;

    float2 uv = p * float2(resolution.x / resolution.y, 0.8);
    uv = rotate(uv, log(time) / -7.0);

    float interval = 10.0;
    float3 dblue = interval * float3(1.8, 2.6, 2.6);
    float3 cyan = interval * float3(0.0, 2.1, 2.0);
    float3 magenta = interval * float3(1.8, 1.0, 1.8);

    float f = 0.0;

    float3 color = float3(0.75, 0.75, 0.75);
    f = noise4(uv + noise4(uv) * (log(time + 1.0) + (time / 60.0)));
    color += f * normalize2(dblue);

    f = noise4(f * rotate(uv, sin(time / 11.0)) + f * noise4(f * uv));
    color += f * normalize2(cyan);

    f = noise4(f * rotate(uv, time / 7.0) + f * noise4(uv) * noise4(uv));
    color += f * normalize2(magenta);

    color = normalize2(color);

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_4dLavaLamp() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60}
}

_Shader_HLSL_70sMelt() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float cosRange(float amt, float range, float minimum) {
    return (((1.0 + cos(radians(amt))) * 0.5) * range) + minimum;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    static const int zoom = 40;
    static const float brightness = 0.975;
    float t = time * 1.25;
    float2 uv = fragCoord.xy / resolution.xy;
    float2 p = (2.0 * fragCoord.xy - resolution.xy) / max(resolution.x, resolution.y);
    float ct = cosRange(t * 5.0, 3.0, 1.1);
    float xBoost = cosRange(t * 0.2, 5.0, 5.0);
    float yBoost = cosRange(t * 0.1, 10.0, 5.0);
    float fScale = cosRange(t * 15.5, 1.25, 0.5);

    for (int i = 1; i < zoom; i++) {
        float fi = float(i);
        float2 newp = p;
        newp.x += 0.25 / fi * sin(fi * p.y + t * cos(ct) * 0.5 / 20.0 + 0.005 * fi) * fScale + xBoost;
        newp.y += 0.25 / fi * sin(fi * p.x + t * ct * 0.3 / 40.0 + 0.03 * float(i + 15)) * fScale + yBoost;
        p = newp;
    }

    float3 col = float3(0.5 * sin(3.0 * p.x) + 0.5, 0.5 * sin(3.0 * p.y) + 0.5, sin(p.x + p.y));
    col *= brightness;

    // Vignette border
    float vigAmt = 5.0;
    float vignette = (1.0 - vigAmt * (uv.y - 0.5) * (uv.y - 0.5)) * (1.0 - vigAmt * (uv.x - 0.5) * (uv.x - 0.5));
    float extrusion = (col.x + col.y + col.z) / 4.0;
    extrusion *= 1.5;
    extrusion *= vignette;

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from original extrusion, premultiply
    float a = saturate(extrusion);
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_70sMelt() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_AbstractGlassyField() {
    return "
    (
// Abstract Glassy Field - Converted from Shadertoy (4ttGDH)
// Author: Shane - License: CC BY-NC-SA 3.0
// Raymarched blobby field with fake glass refraction and glow

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);
Texture2D iChannel1 : register(t1);
SamplerState samp1 : register(s1);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define FAR 50.

// GLSL mod: x - y * floor(x/y) (differs from HLSL fmod for negatives)
float glsl_mod(float x, float y) { return x - y * floor(x / y); }
float4 glsl_mod4(float4 x, float y) { return x - y * floor(x / y); }

// Tri-planar blending for iChannel0
// Based on GPU Gems 3 - Ryan Geiss
float3 tpl0(in float3 p, in float3 n) {
    n = max(abs(n) - .2, 0.001);
    n /= dot(n, (float3)1);
    float3 tx = iChannel0.Sample(samp0, p.zy).xyz;
    float3 ty = iChannel0.Sample(samp0, p.xz).xyz;
    float3 tz = iChannel0.Sample(samp0, p.xy).xyz;
    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);
}

// Tri-planar blending for iChannel1
float3 tpl1(in float3 p, in float3 n) {
    n = max(abs(n) - .2, 0.001);
    n /= dot(n, (float3)1);
    float3 tx = iChannel1.Sample(samp1, p.zy).xyz;
    float3 ty = iChannel1.Sample(samp1, p.xz).xyz;
    float3 tz = iChannel1.Sample(samp1, p.xy).xyz;
    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);
}

// Camera path
float3 camPath(float t) {
    float a = sin(t * 0.11);
    float b = cos(t * 0.14);
    return float3(a*4. - b*1.5, b*1.7 + a*1.5, t);
}

// Spherized sinusoidal distance field
float map(float3 p) {
    p.xy -= camPath(p.z).xy;

    const float TAU = 6.2831853;
    float3 q = p.zxy;
    p = cos(glsl_mod4(float4(p*.315*1.25 + sin(glsl_mod4(float4(q*.875*1.25, 0), TAU).xyz), 0), TAU).xyz);

    float n = length(p);
    return (n - 1.025)*1.33;
}

// Ambient occlusion (based on IQ)
float cao(in float3 p, in float3 n) {
    float sca = 1., occ = 0.;
    [loop]
    for (float i = 0.; i < 5.; i++) {
        float hr = .01 + i*.35/4.;
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= .7;
    }
    return clamp(1. - occ, 0., 1.);
}

// Normal via central differences
float3 nr(float3 p) {
    const float2 e = float2(.002, 0);
    return normalize(float3(map(p + e.xyy) - map(p - e.xyy),
                            map(p + e.yxy) - map(p - e.yxy),
                            map(p + e.yyx) - map(p - e.yyx)));
}

// Raymarcher with glow accumulation
float trace(in float3 ro, in float3 rd, inout float ac) {
    ac = 0.;
    float t = 0., h;
    [loop]
    for (int i = 0; i < 128; i++) {
        h = map(ro + rd*t);
        if (abs(h) < .001*(t*.25 + 1.) || t > FAR) break;
        t += h;
        if (abs(h) < .35) ac += (.35 - abs(h))/24.;
    }
    return min(t, FAR);
}

// Soft shadows
float sha(in float3 ro, in float3 rd, in float start, in float end, in float k) {
    float shade = 1.;
    float dist = start;
    [loop]
    for (int i = 0; i < 24; i++) {
        float h = map(ro + rd*dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));
        dist += clamp(h, .01, .2);
        if (abs(h) < .001 || dist > end) break;
    }
    return min(max(shade, 0.) + .4, 1.);
}

// Texture bump mapping using iChannel0 tri-planar
float3 db0(in float3 p, in float3 n, float bf) {
    const float2 e = float2(.001, 0);

    float3 m0 = tpl0(p - e.xyy, n);
    float3 m1 = tpl0(p - e.yxy, n);
    float3 m2 = tpl0(p - e.yyx, n);

    float3 lum = float3(.299, .587, .114);
    float3 g = float3(dot(m0, lum), dot(m1, lum), dot(m2, lum));
    g = (g - dot(tpl0(p, n), lum)) / e.x;
    g -= n*dot(n, g);

    return normalize(n + g*bf);
}

// 3D value noise (IQ)
float n3D(float3 p) {
    const float3 s = float3(7, 157, 113);
    float3 ip = floor(p); p -= ip;
    float4 h = float4(0., s.yz, s.y + s.z) + dot(ip, s);
    p = p*p*(3. - 2.*p);
    h = lerp(frac(sin(glsl_mod4(h, 6.231589))*43758.5453),
             frac(sin(glsl_mod4(h + s.x, 6.231589))*43758.5453), p.x);
    h.xy = lerp(h.xz, h.yw, p.y);
    return lerp(h.x, h.y, p.z);
}

// Environment mapping via iChannel1 tri-planar
float3 envMap(float3 rd, float3 n) {
    float3 col = tpl1(rd*4., n);
    return smoothstep(0., 1., col);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Screen coordinates
    float2 u = (fragCoord - resolution.xy*.5) / resolution.y;

    // Camera setup
    float speed = 4.;
    float3 o = camPath(time*speed);
    float3 lk = camPath(time*speed + .25);
    float3 l = camPath(time*speed + 2.) + float3(0, 1, 0);

    // Ray direction with lens distortion
    float FOV = 3.14159/2.;
    float3 fwd = normalize(lk - o);
    float3 rgt = normalize(float3(fwd.z, 0, -fwd.x));
    float3 up = cross(fwd, rgt);

    float3 r = fwd + FOV*(u.x*rgt + u.y*up);
    r = normalize(float3(r.xy, (r.z - length(r.xy)*.125)));

    // Raymarch
    float accum;
    float t = trace(o, r, accum);

    float3 col = (float3)0;

    if (t < FAR) {
        float3 p = o + r*t;
        float3 n = nr(p);
        float3 svn = n;

        // Texture bump
        float sz = 1./3.;
        n = db0(p*sz, n, .1/(1. + t*.25/FAR));

        l -= p;
        float d = max(length(l), 0.001);
        l /= d;

        float at = 1./(1. + d*.05 + d*d*.0125);

        float ao = cao(p, n);
        float sh = sha(p, l, 0.04, d, 16.);

        float di = max(dot(l, n), 0.);
        float sp = pow(max(dot(reflect(r, n), l), 0.), 64.);
        float fr = clamp(1.0 + dot(r, n), .0, 1.);

        float3 tx = (float3).05;

        // Simple coloring
        col = tx*(di*.1 + ao*.25) + float3(.5, .7, 1)*sp*2. + float3(1, .7, .4)*pow(fr, 8.)*.25;

        // Fake reflection and refraction
        float3 halfN = svn*.5 + n*.5;
        float3 refl = envMap(normalize(reflect(r, halfN)), halfN);
        float3 refr = envMap(normalize(refract(r, halfN, 1./1.35)), halfN);

        float3 refCol = lerp(refr, refl, pow(fr, 5.));

        col += refCol*((di*di*.25 + .75) + ao*.25)*1.5;

        // Hue variation for depth
        col = lerp(col.xzy, col, di*.85 + .15);

        // Glow
        float3 accCol = float3(1, .3, .1)*accum;
        float3 gc = pow(min(float3(1.5, 1, 1)*accum, 1.), float3(1, 2.5, 12.))*.5 + accCol*.5;
        col += col*gc*12.;

        // Purple electric charge
        float hi = abs(glsl_mod(t/1. + time/3., 8.) - 8./2.)*2.;
        float3 cCol = float3(.01, .05, 1)*col*1./(.001 + hi*hi*.2);
        col += lerp(cCol.yxz, cCol, n3D(p*3.));

        // Shading
        col *= ao*sh*at;
    }

    // Fog
    float3 fog = float3(.125, .04, .05)*(r.y*.5 + .5);
    col = lerp(col, fog, smoothstep(0., .95, t/FAR));

    // Vignette
    u = fragCoord / resolution.xy;
    col = lerp((float3)0, col, pow(16.0*u.x*u.y*(1.0 - u.x)*(1.0 - u.y), .125)*.5 + .5);

    // Gamma correction
    col = sqrt(clamp(col, 0., 1.));

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_AbstractGlassyField() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "abstract_glassy_field_i0.png"}, {index: 1, file: "abstract_glassy_field_i1.jpg"}], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_AbstractPainting() {
    return "
    (
// Abstract Painting
//  Converted from Shadertoy: https://www.shadertoy.com/view/4dVfW3
//  Author: FlorianDuf
//  Inspired by: https://iquilezles.org/articles/warp & https://thebookofshaders.com/

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define OCTAVES 5

float rand(float2 st)
{
    return frac(sin(dot(st,
                        float2(12.9898, 78.233))) *
        43758.5453123);
}

float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    // Four corners in 2D of a tile
    float a = rand(i);
    float b = rand(i + float2(1.0, 0.0));
    float c = rand(i + float2(0.0, 1.0));
    float d = rand(i + float2(1.0, 1.0));

    float2 u = smoothstep(0.0, 1.0, f);

    return lerp(a, b, u.x) +
            (c - a) * u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

float fbm(float2 st) {
    float value = 0.0;
    float amplitude = 0.5;

    for (int i = 0; i < OCTAVES; i++) {
        value += amplitude * noise(st);
        st *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

float pattern(float2 p, out float2 q, out float2 r)
{
    q.x = fbm(p + float2(0.0, 0.0));
    q.y = fbm(p + float2(5.2, 1.3));

    q += float2(sin(time * 0.25), sin(time * 0.3538));

    r.x = fbm(p + 4.0 * q + float2(1.7, 9.2));
    r.y = fbm(p + 4.0 * q + float2(8.3, 2.8));

    r += float2(sin(time * 0.125), sin(time * 0.43538));

    return fbm(p + 4.0 * r);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = 10.0 * fragCoord / resolution.x;

    float2 q, r;
    float val = pattern(uv, q, r);
    float3 col = (float3)0.0;

    // TYPE 0: art effect
    col = lerp(float3(q * 0.1, 0.0), float3(r, 0.5 * sin(time) + 0.5), val);

    // Darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_AbstractPainting() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_AbstractShine() {
    return "
    (
// Converted from Shadertoy: Abstract Shine by Frostbyte_
// https://www.shadertoy.com/view/w3yyzc
// SPDX-License-Identifier: CC-BY-NC-SA-4.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2x2 rot(float a) {
    float4 c = cos(a + float4(0, 33, 11, 0));
    return float2x2(c.x, c.z, c.y, c.w);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float i = 0.0, s, t = time;
    float4 o = (float4)0;
    float3 p = float3(0, 0, t);
    float3 d = normalize(float3(2.0 * fragCoord - resolution, resolution.y));

    for (; i < 10.0; i += 1.0)
    {
        p.xy = mul(rot(-p.z * 0.01 - time * 0.05), p.xy);
        s = 0.0;
        s = max(s, 15.0 * (-length(p.xy) + 3.0));
        s += abs(p.y * 0.004 + sin(t - p.x * 0.5) * 0.9 + 1.0);
        p += d * s;
        o += (1.0 + sin(i * 0.9 + length(p.xy * 0.1) + float4(9, 1.5, 1, 1))) / s;
    }
    o /= 1e2;

    float3 color = o.rgb;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_AbstractShine() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_AbstractVortex() {
    return "
    (
// Abstract Vortex by Frostbyte_ — https://www.shadertoy.com/view/wcyBD3
// Low raymarch count volumetric vortex (CC BY-NC-SA 4.0)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// 2D rotation matrix
// GLSL mat2(c,-s,s,c)*v → HLSL mul(v, float2x2(c,-s,s,c))
float2 rot2d(float2 v, float t) {
    float s = sin(t), c = cos(t);
    return mul(v, float2x2(c, -s, s, c));
}

// ACES tonemap
// GLSL M*v → HLSL mul(v, M) for same constructor args
float3 acesTonemap(float3 c) {
    static const float3x3 m1 = float3x3(
        0.59719, 0.07600, 0.02840,
        0.35458, 0.90834, 0.13383,
        0.04823, 0.01566, 0.83777);
    static const float3x3 m2 = float3x3(
        1.60475, -0.10208, -0.00327,
        -0.53108, 1.10813, -0.07276,
        -0.07367, -0.00605, 1.07602);
    float3 v = mul(c, m1);
    float3 a = v * (v + 0.0245786) - 0.000090537;
    float3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
    return mul(a / b, m2);
}

// Xor's Dot Noise
float dotNoise(float3 p) {
    static const float PHI = 1.618033988;
    static const float3x3 GOLD = float3x3(
        -0.571464913, +0.814921382, +0.096597072,
        -0.278044873, -0.303026659, +0.911518454,
        +0.772087367, +0.494042493, +0.399753815);
    // GLSL: GOLD*p (M*v) → HLSL: mul(p, GOLD)
    // GLSL: p*GOLD (v*M) → HLSL: mul(GOLD, p)
    return dot(cos(mul(p, GOLD)), sin(mul(GOLD, PHI * p)));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float t = time;
    float3 p = float3(0.0, 0.0, t);
    float3 l = (float3)0;
    float3 d = normalize(float3(2.0 * fragCoord - resolution, resolution.y));

    [unroll]
    for (float i = 0.0; i < 10.0; i++) {
        float3 b = p;
        b.xy = rot2d(sin(b.xy), t * 1.5 + b.z * 3.0);
        float s = 0.001 + abs(dotNoise(b * 12.0) / 12.0 - dotNoise(b)) * 0.4;
        s = max(s, 2.0 - length(p.xy));
        s += abs(p.y * 0.75 + sin(p.z + t * 0.1 + p.x * 1.5)) * 0.2;
        p += d * s;
        l += (1.0 + sin(i + length(p.xy * 0.1) + float3(3, 1.5, 1))) / s;
    }

    float3 color = acesTonemap(l * l / 6e2);

    // Apply darken/desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_AbstractVortex() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 40}
}

_Shader_HLSL_Accretion() {
    return "
    (
/*
    Accretion by @XorDev
    Ported from Shadertoy: https://www.shadertoy.com/view/WcKXDV

    Refraction effect from adding raymarch iterator to turbulence.
*/

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float4 O = (float4)0;
    float z = 0.0;
    float d = 0.0;

    // Raymarch 20 steps
    for (float i = 0.0; i < 20.0; i += 1.0)
    {
        // Sample point (from ray direction)
        float3 p = z * normalize(float3(fragCoord + fragCoord, 0.0) - float3(resolution.x, resolution.y, resolution.x)) + 0.1;

        // Polar coordinates and additional transformations
        p = float3(atan2(p.y / 0.2, p.x) * 2.0, p.z / 3.0, length(p.xy) - 5.0 - z * 0.2);

        // Apply turbulence and refraction effect
        for (d = 0.0; d < 7.0; d += 1.0)
            p += sin(p.yzx * (d + 1.0) + time + 0.3 * (i + 1.0)) / (d + 1.0);

        // Distance to cylinder and waves with refraction
        d = length(float4(0.4 * cos(p) - 0.4, p.z));
        z += d;

        // Coloring and brightness
        O += (1.0 + cos(p.x + (i + 1.0) * 0.4 + z + float4(6.0, 1.0, 2.0, 0.0))) / d;
    }

    // Tanh tonemap
    O = tanh(O * O / 400.0);

    float3 color = O.rgb;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_Accretion() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_AlienSkin() {
    return "
    (
// License CC0: Alien skin
//  Converted from Shadertoy: https://www.shadertoy.com/view/wtBcRW
//  Author: mrange
//  More playing around with warped FBMs
//  https://iquilezles.org/articles/warp

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI  3.141592654
#define TAU (2.0*PI)

void rot(inout float2 p, float a) {
    float c = cos(a);
    float s = sin(a);
    p = float2(c*p.x + s*p.y, -s*p.x + c*p.y);
}

float hash(float2 co) {
    return frac(sin(dot(co.xy, float2(12.9898, 58.233))) * 13758.5453);
}

float psin(float a) {
    return 0.5 + 0.5*sin(a);
}

float onoise(float2 x) {
    x *= 0.5;
    float a = sin(x.x);
    float b = sin(x.y);
    float c = lerp(a, b, psin(TAU*tanh(a*b+a+b)));
    return c;
}

float vnoise(float2 x) {
    float2 i = floor(x);
    float2 w = frac(x);

    // quintic interpolation
    float2 u = w*w*w*(w*(w*6.0-15.0)+10.0);

    float a = hash(i+float2(0.0, 0.0));
    float b = hash(i+float2(1.0, 0.0));
    float c = hash(i+float2(0.0, 1.0));
    float d = hash(i+float2(1.0, 1.0));

    float k0 =   a;
    float k1 =   b - a;
    float k2 =   c - a;
    float k3 =   d - c + a - b;

    float aa = lerp(a, b, u.x);
    float bb = lerp(c, d, u.x);
    float cc = lerp(aa, bb, u.y);

    return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;
}

float fbm(float2 p, int mx) {
    float2 op = p;
    const float aa = 0.45;
    const float pp = 2.03;
    const float2 oo = -float2(1.23, 1.5);
    const float rr = 1.2;

    float h = 0.0;
    float d = 0.0;
    float a = 1.0;

    for (int i = 0; i < mx; ++i) {
        h += a*onoise(p);
        d += a;
        a *= aa;
        p += oo;
        p *= pp;
        rot(p, rr);
    }

    return lerp((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));
}

float warp(float2 p) {
    const int mx1 = 8;
    const int mx2 = 3;
    const int mx3 = 3;
    float2 v = float2(fbm(p, mx1), fbm(p+0.7*float2(1.0, 1.0), mx1));

    rot(v, 1.0+time*0.1);

    float2 vv = float2(fbm(p + 3.7*v, mx2), fbm(p + -2.7*v.yx+0.7*float2(1.0, 1.0), mx2));

    rot(vv, -1.0+time*0.2315);

    return fbm(p + 1.4*vv, mx3);
}

float height(float2 p) {
    float a = 0.005*time;
    p += 5.0*float2(cos(a), sin(sqrt(0.5)*a));
    p *= 2.0;
    p += 13.0;
    float h = warp(p);
    float rs = 3.0;
    return 0.4*tanh(rs*h)/rs;
}

float3 normal(float2 p) {
    float2 eps = -float2(2.0/resolution.y, 0.0);

    float3 n;
    n.x = height(p + eps.xy) - height(p - eps.xy);
    n.y = 2.0*eps.x;
    n.z = height(p + eps.yx) - height(p - eps.yx);

    return normalize(n);
}

float3 postProcess(float3 col, float2 q) {
    col = pow(saturate(col), (float3)0.75);
    col = col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast
    col = lerp(col, (float3)dot(col, (float3)0.33), -0.4);  // saturation
    col *= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.7);  // vignetting
    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 q = fragCoord/resolution.xy;
    float2 p = -1.0 + 2.0 * q;
    p.x *= resolution.x/resolution.y;

    const float3 lp1 = float3(0.8, -0.75, 0.8);
    const float3 lp2 = float3(0.0, -1.5, -1.0);

    float h = height(p);
    float3 pp = float3(p.x, h, p.y);
    float3 ld1 = normalize(lp1 - pp);
    float3 ld2 = normalize(lp2 - pp);

    float3 n = normal(p);
    float diff1 = max(dot(ld1, n), 0.0);
    float diff2 = max(dot(ld2, n), 0.0);

    const float3 baseCol1 = float3(0.6, 0.8, 1.0);
    const float3 baseCol2 = sqrt(baseCol1.zyx);

    float3 col = (float3)0.0;
    col += baseCol1*pow(diff1, 16.0);
    col += 0.1*baseCol1*pow(diff1, 4.0);
    col += 0.15*baseCol2*pow(diff2, 8.0);
    col += 0.015*baseCol2*pow(diff2, 2.0);

    col = saturate(col);
    col = lerp(0.05*baseCol1, col, 1.0 - (1.0 - 0.5*diff1)*exp(-2.0*smoothstep(-0.1, 0.05, h)));

    col = postProcess(col, q);

    // Darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_AlienSkin() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 30, timeOffsetMax: 90, timeAccumulate: true}
}

_Shader_HLSL_AlienSpawningPool() {
    return "
    (
// 'Alien Spawning Pool' by @christinacoffin
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
// Converted from https://www.shadertoy.com/view/MtffW8

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float noise(float2 x)
{
    x.x += 0.3 * cos(x.y + (time * 0.3));
    x.y += 0.3 * sin(x.x);
    float2 p = floor(x);
    float2 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);

    float4 a_vec = iChannel0.SampleLevel(samp0, (p + float2(0.5, 0.5)) / 256.0, 0);
    float4 b_vec = iChannel0.SampleLevel(samp0, (p + float2(1.5, 0.5)) / 256.0, 0);
    float4 c_vec = iChannel0.SampleLevel(samp0, (p + float2(0.5, 1.5)) / 256.0, 0);
    float4 d_vec = iChannel0.SampleLevel(samp0, (p + float2(1.5, 1.5)) / 256.0, 0);

    float a = a_vec.x;
    float b = b_vec.x;
    float c = c_vec.x;
    float d = d_vec.x;

    return lerp(lerp(a, b, f.x), lerp(c, d, f.x), f.y);
}

static const float2x2 mtx = float2x2(0.480, 0.60, -0.60, 0.480);

float fbm4(float2 p)
{
    float f = 0.0;

    f += 0.15000 * (-1.0 + 2.0 * noise(p)); p = mul(mtx, p) * 2.02;
    f += 0.2500  * (-1.0 + 2.0 * noise(p)); p = mul(mtx, p) * 2.03;
    f += 0.1250  * (-1.0 + 2.0 * noise(p)); p = mul(mtx, p) * 2.01;
    f += 0.0625  * (-1.0 + 2.0 * noise(p));

    return f / 0.9375;
}

float fbm6(float2 p)
{
    float f = 0.0;

    f += 0.500000  * noise(p); p = mul(mtx, p) * 2.02;
    f += 0.250000  * noise(p); p = mul(mtx, p) * 2.03;
    f += 0.63125000 * noise(p); p = mul(mtx, p) * 2.01;
    f += 0.062500  * noise(p); p = mul(mtx, p) * 2.04;
    f += 0.031250  * noise(p); p = mul(mtx, p) * 2.01;
    f += 0.015625  * noise(p);

    return f / 0.996875;
}

float func(float2 q, out float2 o, out float2 n)
{
    float ql = length(q);
    q.x += 0.015 * sin(0.11 * time + ql * 14.0);
    q.y += 0.035 * sin(0.13 * time + ql * 14.0);
    q *= 0.7 + 0.2 * cos(0.05 * time);

    q = (q + 1.0) * 0.5;

    o.x = 0.5 + 0.5 * fbm4(2.0 * q);
    o.y = 0.5 + 0.5 * fbm4(2.0 * q + float2(5.2, 5.2));

    float ol = length(o * o);
    o.x += 0.003 * sin(0.911 * time * ol) / ol;
    o.y += 0.002 * sin(0.913 * time * ol) / ol;

    n.x = fbm6(4.0 * o + float2(9.2, 9.2));
    n.y = fbm6(4.0 * o + float2(5.7, 5.7));

    float2 p = 11.0 * q + 3.0 * n;

    float f = 0.5 + 0.85 * fbm4(p);

    f = lerp(f, f * f * f * -3.5, -f * abs(n.x));

    float g = 0.5 + 0.5 * sin(1.0 * p.x) * sin(1.0 * p.y);
    f *= 1.0 - 0.5 * pow(g, 7.0);

    return f;
}

float funcs(float2 q)
{
    float2 t1, t2;
    return func(q, t1, t2);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float2 p = fragCoord.xy / resolution.xy;
    float2 q = (-resolution.xy + 2.0 * fragCoord.xy) / resolution.y;
    float2 o, n;
    float f = func(q, o, n);
    float3 col = (float3)(-0.91620);
    col = lerp(float3(0.2, 0.1, 0.4), col, f);
    col = lerp(float3(0.2, 0.1, 0.4), col * float3(0.13, 0.05, 0.05), f);
    col = lerp(col, float3(0.19, 0.9, 0.9), dot(n, n) * n.x * 1.357);
    col = lerp(col, float3(0.5, 0.2, 0.2), 0.5 * o.y * o.y);
    col += 0.05 * lerp(col, float3(0.9, 0.9, 0.9), dot(n, n));
    col = lerp(col, float3(0.0, 0.2, 0.4), 0.5 * smoothstep(1.02, 1.3, abs(n.y) + abs(n.x * n.x)));
    col *= f * (5.92 + (1.1 * cos(time)));

    col = lerp(col, float3(-1.0, 0.2, 0.4), 0.5 * smoothstep(1.02, 1.3, abs(n.y) + abs(n.x * n.x)));
    col = lerp(col, float3(0.40, 0.92, 0.4), 0.5 * smoothstep(0.602, 1.93, abs(n.y) + abs(n.x * n.x)));

    float2 ex = -1.0 * float2(2.0 / resolution.x, 0.0);
    float2 ey = -1.0 * float2(0.0, 2.0 / resolution.y);
    float3 nor = normalize(float3(funcs(q + ex) - f, ex.x, funcs(q + ey) - f));
    float3 lig = normalize(float3(0.19, -0.2, -0.4));
    float dif = clamp(0.03 + 0.7 * dot(nor, lig), 0.0, 1.0);

    float3 bdrf;
    bdrf  = float3(0.85, 0.90, 0.95) * (nor.y * 0.5 + 0.5);
    bdrf += float3(0.15, 0.10, 0.05) * dif;
    col *= bdrf / f;
    col = (float3)0.8 - col;
    col = col * col;
    col *= float3(0.8, 1.15, 1.2);
    col *= 0.45 + 0.5 * sqrt(16.0 * p.x * p.y * p.y * (2.0 - p.x) * (1.0 - p.y)) * float3(1.0, 0.3, 0.0);

    col = clamp(col, 0.0, 1.0);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_AlienSpawningPool() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "alien_spawning_pool_i0.png"}], timeOffsetMin: 40, timeOffsetMax: 120, timeAccumulate: true}
}

_Shader_HLSL_AnotherWindowsTerminalShader() {
    return "
    (
// CC0: Another windows terminal shader
//  Created this based on an old shader as a background in windows terminal
//  Original: https://www.shadertoy.com/view/DdSGzy by mrange

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI          3.141592654
#define TAU         (2.0*PI)
#define ROT(a)      float2x2(cos(a), sin(a), -sin(a), cos(a))

// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
static const float4 hsv2rgb_K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
float3 hsv2rgb(float3 c) {
    float3 p = abs(frac(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
    return c.z * lerp(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
}
// Macro version of above to enable compile-time constants
#define HSV2RGB(c)  (c.z * lerp(hsv2rgb_K.xxx, clamp(abs(frac(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

static const float2x2 rot0 = ROT(0.0);
static float2x2 g_rot0;
static float2x2 g_rot1;

// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
float3 sRGB(float3 t) {
    return lerp(1.055 * pow(t, (float3)(1.0 / 2.4)) - 0.055, 12.92 * t, step(t, (float3)0.0031308));
}

// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
float3 aces_approx(float3 v) {
    v = max(v, 0.0);
    v *= 0.6f;
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0f, 1.0f);
}

float apolloian(float3 p, float s) {
    float scale = 1.0;
    for (int i = 0; i < 5; ++i) {
        p = -1.0 + 2.0 * frac(0.5 * p + 0.5);
        float r2 = dot(p, p);
        float k = s / r2;
        p *= k;
        scale *= k;
    }

    float3 ap = abs(p / scale);
    float d = length(ap.xy);
    d = min(d, ap.z);

    return d;
}

float df(float2 p) {
    float fz = lerp(0.75, 1.0, smoothstep(-0.9, 0.9, cos(TAU * time / 300.0)));
    float z = 1.55 * fz;
    p /= z;
    float3 p3 = float3(p, 0.1);
    p3.xz = mul(p3.xz, g_rot0);
    p3.yz = mul(p3.yz, g_rot1);
    float d = apolloian(p3, 1.0 / fz);
    d *= z;
    return d;
}

float3 effect(float2 p, float2 pp) {
    g_rot0 = ROT(0.1 * time);
    g_rot1 = ROT(0.123 * time);

    float aa = 2.0 / resolution.y;

    float d = df(p);
    float3 bcol0 = HSV2RGB(float3(0.55, 0.85, 0.85));
    float3 bcol1 = HSV2RGB(float3(0.33, 0.85, 0.025));
    float3 col = 0.1 * bcol0;
    col += bcol1 / sqrt(abs(d));
    col += bcol0 * smoothstep(aa, -aa, (d - 0.001));

    col *= smoothstep(1.5, 0.5, length(pp));

    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 q = fragCoord / resolution.xy;
    float2 p = -1.0 + 2.0 * q;
    float2 pp = p;
    p.x *= resolution.x / resolution.y;
    float3 col = effect(p, pp);
    col = aces_approx(col);
    col = sqrt(col);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_AnotherWindowsTerminalShader() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_Ascend() {
    return "
    (
// Ascend by bug
// License: CC BY-NC-SA 4.0
// https://www.shadertoy.com/view/33KBDm
// De-golfed and converted from GLSL

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float3 tanh_approx(float3 x) {
    float3 x2 = x * x;
    return x * (27.0 + x2) / (27.0 + 9.0 * x2);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float3 o = (float3)0;
    float3 p = (float3)0;
    float3 q = (float3)0;
    float3 R = float3(resolution, 1.0);

    float i = 0, d = 0, a = 0, l = 0, k = 0, s = 0, x = 0;

    for (i = 0; i < 100; i += 1.0) {
        // Inner loop: build p, compute distances
        // p = normalize(vec3(P+P,R.y)-R)*i*.05
        p = normalize(float3(fragCoord + fragCoord, R.y) - R) * i * 0.05;
        p.z -= 3.0;
        q = p - float3(1.5, 0.7, 0);
        s = length(q);
        q.y = p.y - min(p.y, 0.7);
        l = length(q);
        p.y += time;
        d = min(length(p.xz), 1.0 - p.z);
        a = 0.01;

        [unroll]
        for (; a < 3.0; a += a) {
            // p.zy *= .1*mat2(8,6,-6,8)
            // GLSL mat2(8,6,-6,8) fills column-major: col0=(8,6), col1=(-6,8)
            // vec2 * mat2: result = (v.x*col0[0]+v.y*col1[0], v.x*col0[1]+v.y*col1[1])
            //   new_z = 0.1*(8*p.z + (-6)*p.y)
            //   new_y = 0.1*(6*p.z + 8*p.y)
            float pz = p.z, py = p.y;
            p.z = 0.1 * (8.0 * pz - 6.0 * py);
            p.y = 0.1 * (6.0 * pz + 8.0 * py);

            // d -= N(4.,.2) = abs(dot(sin(p/a*4.), p-p+a*.2))
            // p-p = 0, so p-p+a*.2 = vec3(a*.2)
            d -= abs(dot(sin(p / a * 4.0), (float3)(a * 0.2)));
            // l -= N(5.,.01)
            l -= abs(dot(sin(p / a * 5.0), (float3)(a * 0.01)));
        }

        // Outer loop increment expression (expanded V macro calls):

        // V * mix(vec3(0,1.5,3), q=vec3(3,1,.7), x=max(2.-l,0.)*.8)
        // First: V expands to: d = min(d,0.), k += a = d*k-d, o += a/exp(s*1.3)*(1.+d)
        d = min(d, 0.0);
        a = d * k - d;
        k += a;
        x = max(2.0 - l, 0.0) * 0.8;
        q = float3(3, 1, 0.7);
        o += a / exp(s * 1.3) * (1.0 + d)
            * lerp(float3(0, 1.5, 3), q, x);

        // d = l
        d = l;

        // V * q * 20.
        d = min(d, 0.0);
        a = d * k - d;
        k += a;
        o += a / exp(s * 1.3) * (1.0 + d) * q * 20.0;

        // o += (x-x*k)/s/4e2
        o += (x - x * k) / s / 400.0;
    }

    float3 col = tanh_approx(o);

    // darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_Ascend() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_BalatroBackground() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define MID_FLASH 0.0
#define VORT_SPEED 0.8
#define VORT_OFFSET 0.0
#define PIXEL_SIZE_FAC 700.0

static const float4 BLUE  = float4(pow(float3(0.0, 157.0/255.0, 255.0/255.0), (float3)2.2), 1.0);
static const float4 RED   = float4(pow(float3(254.0/255.0, 95.0/255.0, 85.0/255.0), (float3)2.2), 1.0);
static const float4 BLACK = float4(pow(0.6 * float3(79.0/255.0, 99.0/255.0, 103.0/255.0), (float3)2.2), 1.0);

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float res_len = length(resolution.xy);

    // Convert to UV coords and floor for pixel effect
    float pixel_size = res_len / PIXEL_SIZE_FAC;
    float2 uv = (floor(fragCoord.xy * (1.0 / pixel_size)) * pixel_size - 0.5 * resolution.xy) / res_len;
    float uv_len = length(uv);

    // Adding in a center swirl, changes with time
    float speed = time * VORT_SPEED;
    float clamped_speed = min(6.0, speed);
    float new_pixel_angle = atan2(uv.y, uv.x) + (2.2 + 0.4 * clamped_speed) * uv_len - 1.0 - speed * 0.05 - clamped_speed * speed * 0.02 + VORT_OFFSET;
    float2 mid = normalize(resolution.xy) * 0.5;
    float2 sv = float2(uv_len * cos(new_pixel_angle) + mid.x, uv_len * sin(new_pixel_angle) + mid.y) - mid;

    // Now add the smoke effect to the swirled UV
    sv *= 30.0;
    speed = time * 6.0 * VORT_SPEED + VORT_OFFSET + 1033.0;
    float2 uv2 = float2(sv.x + sv.y, sv.x + sv.y);

    [unroll]
    for (int i = 0; i < 5; i++) {
        uv2 += sin(max(sv.x, sv.y)) + sv;
        sv  += 0.5 * float2(cos(5.1123314 + 0.353 * uv2.y + speed * 0.131121), sin(uv2.x - 0.113 * speed));
        sv  -= cos(sv.x + sv.y) - sin(sv.x * 0.711 - sv.y);
    }

    // Make the smoke amount range from 0 - 2
    float smoke_res = min(2.0, max(-2.0, 1.5 + length(sv) * 0.12 - 0.17 * min(10.0, time * 1.2 - 4.0)));
    float smoke_adj = (smoke_res - 0.2) * 0.6 + 0.2;
    smoke_res = lerp(smoke_adj, smoke_res, step(0.2, smoke_res));

    float c1p = max(0.0, 1.0 - 2.0 * abs(1.0 - smoke_res));
    float c2p = max(0.0, 1.0 - 2.0 * smoke_res);
    float cb = 1.0 - min(1.0, c1p + c2p);
    float4 ret_col = RED * c1p + BLUE * c2p + float4(cb * BLACK.rgb, cb * RED.a);
    float max_cp = max(c1p, c2p);
    float mod_flash = max(MID_FLASH * 0.8, max_cp * 5.0 - 4.4) + MID_FLASH * max_cp;
    float4 final_col = ret_col * (1.0 - mod_flash) + mod_flash;
    float3 color = pow(final_col.rgb, (float3)(1.0 / 2.2));

    // Desaturate and darken
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_BalatroBackground() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30}
}

_Shader_HLSL_BalatroTwist() {
    return "
    (
// Balatro Twist - yufengjie (Shadertoy 3c3SWH)
// https://www.shadertoy.com/view/3c3SWH
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI 3.141596
#define PI2 (PI * 2.0)

float2 hash(float2 p) {
    p = float2(dot(p, float2(127.1, 311.7)),
               dot(p, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

float noise(float2 p) {
    const float K1 = 0.366025404; // (sqrt(3)-1)/2
    const float K2 = 0.211324865; // (3-sqrt(3))/6

    float2 i = floor(p + (p.x + p.y) * K1);
    float2 a = p - i + (i.x + i.y) * K2;
    float2 o = (a.x > a.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float2 b = a - o + K2;
    float2 c = a - 1.0 + 2.0 * K2;

    float3 h = max(0.5 - float3(dot(a, a), dot(b, b), dot(c, c)), 0.0);

    float3 n = h * h * h * h * float3(
        dot(a, hash(i + 0.0)),
        dot(b, hash(i + o)),
        dot(c, hash(i + 1.0)));


    return dot(n, (float3)70.0);
}

float fbm(float2 p) {
    float a = 0.5;
    float n = 0.0;

    for (float i = 0.0; i < 8.0; i++) {
        n += a * noise(p);
        p *= 2.0;
        a *= 0.5;
    }
    return n;
}

float2x2 rotate(float ang) {
    float s = sin(ang);
    float c = cos(ang);
    return float2x2(c, -s, s, c);
}

float3 glow(float v, float r, float ins, float3 col) {
    float dist = pow(r / v, ins);
    return 1.0 - exp(-dist * col);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = (fragCoord * 2.0 - resolution) / resolution.y;

    uv *= 2.0;
    float2 p = uv;

    float l = length(uv) - time * 0.3;
    p = mul(rotate(l), p);

    float n = noise(uv);
    p += n * 0.5;

    float3 c1 = float3(0.57, 0.12, 0.1);
    float3 c2 = float3(0.153, 0.541, 0.769);

    n = fbm(p * 0.4);
    float3 col = glow(n, 0.2, 2.0, c1);

    n = fbm(mul(rotate(0.1), p * 0.2));
    c2 = glow(n, 0.3, 2.0, c2);

    col = col * c2;

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_BalatroTwist() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_BaseWarpFbm() {
    return "
    (
// Base Warp fBM - converted from Shadertoy (tdG3Rd)
// Author: trinketMage - License: CC BY-NC-SA 3.0
// Domain warping fBM from iq: https://iquilezles.org/articles/warp/warp.htm
// With transform_rose colormap from colormap-shaders

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float colormap_red(float x) {
    if (x < 0.0) {
        return 54.0 / 255.0;
    } else if (x < 20049.0 / 82979.0) {
        return (829.79 * x + 54.51) / 255.0;
    } else {
        return 1.0;
    }
}

float colormap_green(float x) {
    if (x < 20049.0 / 82979.0) {
        return 0.0;
    } else if (x < 327013.0 / 810990.0) {
        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;
    } else if (x <= 1.0) {
        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;
    } else {
        return 1.0;
    }
}

float colormap_blue(float x) {
    if (x < 0.0) {
        return 54.0 / 255.0;
    } else if (x < 7249.0 / 82979.0) {
        return (829.79 * x + 54.51) / 255.0;
    } else if (x < 20049.0 / 82979.0) {
        return 127.0 / 255.0;
    } else if (x < 327013.0 / 810990.0) {
        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;
    } else {
        return 1.0;
    }
}

float4 colormap(float x) {
    return float4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
}

float rand(float2 n) {
    return frac(sin(dot(n, float2(12.9898, 4.1414))) * 43758.5453);
}

float noise(float2 p) {
    float2 ip = floor(p);
    float2 u = frac(p);
    u = u * u * (3.0 - 2.0 * u);

    float res = lerp(
        lerp(rand(ip), rand(ip + float2(1.0, 0.0)), u.x),
        lerp(rand(ip + float2(0.0, 1.0)), rand(ip + float2(1.0, 1.0)), u.x), u.y);
    return res * res;
}

static const float2x2 mtx = float2x2(0.80, 0.60, -0.60, 0.80);

float fbm(float2 p) {
    float f = 0.0;

    f += 0.500000 * noise(p + time); p = mul(p, mtx) * 2.02;
    f += 0.031250 * noise(p); p = mul(p, mtx) * 2.01;
    f += 0.250000 * noise(p); p = mul(p, mtx) * 2.03;
    f += 0.125000 * noise(p); p = mul(p, mtx) * 2.01;
    f += 0.062500 * noise(p); p = mul(p, mtx) * 2.04;
    f += 0.015625 * noise(p + sin(time));

    return f / 0.96875;
}

float pattern(in float2 p) {
    return fbm(p + fbm(p + fbm(p)));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = fragCoord / resolution.x;
    float shade = pattern(uv);
    float3 color = colormap(shade).rgb;

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from shade, premultiply
    float a = saturate(shade);
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_BaseWarpFbm() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 20, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_BentHorizon() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI 3.14159265359
#define TWO_PI 6.28318530718
#define FBM_ITER 5

float2 viewport(float2 uv, float2 r) {
    return (uv * 2.0 - r) / min(r.x, r.y);
}

float rand1(float x, int s) {
    return frac(sin(x + (float)s) * 43758.5453123);
}

float rand2(float2 uv, int seed) {
    return frac(sin(dot(uv.xy, float2(12.9898, 78.233)) + (float)seed) * 43758.5453123);
}

float noise1(float x, int s) {
    float xi = floor(x);
    float xf = frac(x);
    return lerp(rand1(xi, s), rand1(xi + 1.0, s), smoothstep(0.0, 1.0, xf));
}

float noise2(float2 p, int s) {
    float2 pi = floor(p);
    float2 pf = frac(p);

    float2 o = float2(0, 1);

    float bl = rand2(pi, s);
    float br = rand2(pi + o.yx, s);
    float tl = rand2(pi + o.xy, s);
    float tr = rand2(pi + o.yy, s);

    float2 w = smoothstep(0.0, 1.0, pf);

    float t = lerp(tl, tr, w.x);
    float b = lerp(bl, br, w.x);

    return lerp(b, t, w.y);
}

float fbm(float2 p, int seed) {
    float v = 0.0;
    float a = 0.5;
    for (int i = 0; i < FBM_ITER; i++) {
        v += a * noise2(p, seed);
        p *= 2.0;
        a *= 0.5;
    }
    return v;
}

float3 gradient(float t, float3 a, float3 b, float3 c, float3 d) {
    return a + b * cos(TWO_PI * (c * t + d));
}

float cosine_interp(float x, float s) {
    float y = cos(frac(x) * PI);
    return floor(x) + 0.5 - (0.5 * pow(abs(y), 1.0 / s) * sign(y));
}

float noise0(float x) {
    return noise1(x, 0);
}

float2x2 rot2(float a) {
    float c = cos(a);
    float s = sin(a);
    return float2x2(c, -s, s, c);
}

float map(float3 p) {
    float t = time * 0.5;
    p.z += t;
    t *= 0.125;
    float n = fbm(p.xz, 0);
    n = pow(n, 3.0 + sin(t));
    float g = p.y + 2.0;
    g -= n;
    g = min(g, 3.3 - g);
    return g;
}

static const float3 c3 = float3(0.05, 0.05, 0.05);
static const float3 c4 = float3(0.52, 0.57, 0.59);

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 uv = viewport(fragCoord.xy, resolution.xy);
    float t = time * 0.1;

    float3 ro = float3(0, 0, -3);
    float3 rd = normalize(float3(uv, 1));
    rd.xz = mul(rd.xz, rot2(sin(t)));
    float3 p = (float3)0;

    float d = 0.0;
    float dt = 0.0;

    float j = 0.0;

    float m = 0.1;
    float an = cos(t * 0.05) * m;

    for (int i = 0; i < 30; i++) {
        p = ro + rd * d;
        p.xy = mul(p.xy, rot2(d * an));
        dt = map(p);
        d += dt;
        j = (float)i;
        if (dt < 0.001 || d > 100.0) {
            break;
        }
    }

    float glow = sin(noise0(t * 5.0)) * 0.005 + 0.02;
    d += j * (0.33 + glow * 5.0);
    float a = smoothstep(0.0, 30.0, d);
    float phase = cosine_interp(length(p.zy * 0.1), 2.0);

    float g = sin(time * 0.125) * 0.25 + 0.35;
    float3 c12 = float3(g, g, g);
    float3 col1 = gradient(phase, c12, c12, c3, c4) * d * 0.2;

    float3 col2 = lerp(float3(0.9, 0.9, 0.56), float3(0.95, 0.65, 0.38), sin(noise0(t * 5.0 + uv.x * 0.3)) * 0.5 + 0.5) * d * glow;
    float3 col = lerp(col1, col2, a);

    // Darken / desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_BentHorizon() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60}
}

_Shader_HLSL_BlackHoleAccretionDisk() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

#define AA 1

#define _Speed 3.0
#define _Steps 12.0
#define _Size 0.3

float hash1(float x) { return frac(sin(x) * 152754.742); }
float hash2(float2 x) { return hash1(x.x + hash1(x.y)); }

float value(float2 p, float f)
{
    float bl = hash2(floor(p * f + float2(0.0, 0.0)));
    float br = hash2(floor(p * f + float2(1.0, 0.0)));
    float tl = hash2(floor(p * f + float2(0.0, 1.0)));
    float tr = hash2(floor(p * f + float2(1.0, 1.0)));

    float2 fr = frac(p * f);
    fr = (3.0 - 2.0 * fr) * fr * fr;
    float b = lerp(bl, br, fr.x);
    float t = lerp(tl, tr, fr.x);
    return lerp(b, t, fr.y);
}

float4 background(float3 ray)
{
    float2 uv = ray.xy;

    if (abs(ray.x) > 0.5)
        uv.x = ray.z;
    else if (abs(ray.y) > 0.5)
        uv.y = ray.z;

    float brightness = value(uv * 3.0, 100.0);
    float color = value(uv * 2.0, 20.0);
    brightness = pow(brightness, 256.0);

    brightness = brightness * 100.0;
    brightness = clamp(brightness, 0.0, 1.0);

    float3 stars = brightness * lerp(float3(1.0, 0.6, 0.2), float3(0.2, 0.6, 1.0), color);

    float4 nebulae = iChannel0.Sample(samp0, uv * 1.5);
    nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz;
    nebulae.xyz *= 0.25;

    nebulae *= nebulae;
    nebulae *= nebulae;
    nebulae *= nebulae;
    nebulae *= nebulae;

    nebulae.xyz += stars;
    return nebulae;
}

float4 raymarchDisk(float3 ray, float3 zeroPos)
{
    float3 position = zeroPos;
    float lengthPos = length(position.xz);
    float dist = min(1.0, lengthPos * (1.0 / _Size) * 0.5) * _Size * 0.4 * (1.0 / _Steps) / abs(ray.y);

    position += dist * _Steps * ray * 0.5;

    float2 deltaPos;
    deltaPos.x = -zeroPos.z * 0.01 + zeroPos.x;
    deltaPos.y = zeroPos.x * 0.01 + zeroPos.z;
    deltaPos = normalize(deltaPos - zeroPos.xz);

    float parallel = dot(ray.xz, deltaPos);
    parallel /= sqrt(lengthPos);
    parallel *= 0.5;
    float redShift = parallel + 0.3;
    redShift *= redShift;

    redShift = clamp(redShift, 0.0, 1.0);

    float disMix = clamp((lengthPos - _Size * 2.0) * (1.0 / _Size) * 0.24, 0.0, 1.0);
    float3 insideCol = lerp(float3(1.0, 0.8, 0.0), float3(0.5, 0.13, 0.02) * 0.2, disMix);

    insideCol *= lerp(float3(0.4, 0.2, 0.1), float3(1.6, 2.4, 4.0), redShift);
    insideCol *= 1.25;
    redShift += 0.12;
    redShift *= redShift;

    float4 o = (float4)0;

    for (float i = 0.0; i < _Steps; i++)
    {
        position -= dist * ray;

        float intensity = clamp(1.0 - abs((i - 0.8) * (1.0 / _Steps) * 2.0), 0.0, 1.0);
        float lp = length(position.xz);
        float distMult = 1.0;

        distMult *= clamp((lp - _Size * 0.75) * (1.0 / _Size) * 1.5, 0.0, 1.0);
        distMult *= clamp((_Size * 10.0 - lp) * (1.0 / _Size) * 0.20, 0.0, 1.0);
        distMult *= distMult;

        float u = lp + time * _Size * 0.3 + intensity * _Size * 0.2;

        float2 xy;
        float rot = fmod(time * _Speed, 8192.0);
        xy.x = -position.z * sin(rot) + position.x * cos(rot);
        xy.y = position.x * sin(rot) + position.z * cos(rot);

        float x = abs(xy.x / xy.y);
        float angle = 0.02 * atan(x);

        static const float f = 70.0;
        float noise = value(float2(angle, u * (1.0 / _Size) * 0.05), f);
        noise = noise * 0.66 + 0.33 * value(float2(angle, u * (1.0 / _Size) * 0.05), f * 2.0);

        float extraWidth = noise * 1.0 * (1.0 - clamp(i * (1.0 / _Steps) * 2.0 - 1.0, 0.0, 1.0));

        float alpha = clamp(noise * (intensity + extraWidth) * ((1.0 / _Size) * 10.0 + 0.01) * dist * distMult, 0.0, 1.0);

        float3 col = 2.0 * lerp(float3(0.3, 0.2, 0.15) * insideCol, insideCol, min(1.0, intensity * 2.0));
        o = clamp(float4(col * alpha + o.rgb * (1.0 - alpha), o.a * (1.0 - alpha) + alpha), (float4)0, (float4)1);

        lp *= (1.0 / _Size);

        o.rgb += redShift * (intensity * 1.0 + 0.5) * (1.0 / _Steps) * 100.0 * distMult / (lp * lp);
    }

    o.rgb = clamp(o.rgb - 0.005, 0.0, 1.0);
    return o;
}

void DoRotate(inout float3 v, float2 a)
{
    v.yz = cos(a.y) * v.yz + sin(a.y) * float2(-1, 1) * v.zy;
    v.xz = cos(a.x) * v.xz + sin(a.x) * float2(-1, 1) * v.zx;
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float4 colOut = (float4)0;

    float2 fragCoordRot;
    fragCoordRot.x = fragCoord.x * 0.985 + fragCoord.y * 0.174;
    fragCoordRot.y = fragCoord.y * 0.985 - fragCoord.x * 0.174;
    fragCoordRot += float2(-0.06, 0.12) * resolution.xy;

    // Gentle time-based camera motion replacing iMouse
    float fakeMx = (sin(time * 0.05) * 0.3 + 0.5) * resolution.y;
    float fakeMy = (cos(time * 0.03) * 0.15 + 0.4) * resolution.y;

    for (int j = 0; j < AA; j++)
    for (int i = 0; i < AA; i++)
    {
        float3 ray = normalize(float3((fragCoordRot - resolution.xy * 0.5 + float2(i, j) / (float)AA) / resolution.x, 1.0));
        float zDist = 20.0 * fakeMx / resolution.y - 10.0;
        float3 pos = float3(0.0, 0.05, -zDist * zDist * 0.05);
        float2 angle = float2(time * 0.1, 0.2);
        angle.y = (2.0 * fakeMy / resolution.y) * 3.14 + 0.1 + 3.14;
        float dist = length(pos);
        DoRotate(pos, angle);
        angle.xy -= min(0.3 / dist, 3.14) * float2(1.0, 0.5);
        DoRotate(ray, angle);

        float4 col = (float4)0;
        float4 glow = (float4)0;
        float4 outCol = (float4)100.0;

        for (int disks = 0; disks < 20; disks++)
        {
            for (int h = 0; h < 6; h++)
            {
                float dotpos = dot(pos, pos);
                float invDist = rsqrt(dotpos);
                float centDist = dotpos * invDist;
                float stepDist = 0.92 * abs(pos.y / ray.y);
                float farLimit = centDist * 0.5;
                float closeLimit = centDist * 0.1 + 0.05 * centDist * centDist * (1.0 / _Size);
                stepDist = min(stepDist, min(farLimit, closeLimit));

                float invDistSqr = invDist * invDist;
                float bendForce = stepDist * invDistSqr * _Size * 0.625;
                ray = normalize(ray - (bendForce * invDist) * pos);
                pos += stepDist * ray;

                glow += float4(1.2, 1.1, 1.0, 1.0) * (0.01 * stepDist * invDistSqr * invDistSqr * clamp(centDist * 2.0 - 1.2, 0.0, 1.0));
            }

            float dist2 = length(pos);

            if (dist2 < _Size * 0.1)
            {
                outCol = float4(col.rgb * col.a + glow.rgb * (1.0 - col.a), 1.0);
                break;
            }
            else if (dist2 > _Size * 1000.0)
            {
                float4 bg = background(ray);
                outCol = float4(col.rgb * col.a + bg.rgb * (1.0 - col.a) + glow.rgb * (1.0 - col.a), 1.0);
                break;
            }
            else if (abs(pos.y) <= _Size * 0.002)
            {
                float4 diskCol = raymarchDisk(ray, pos);
                pos.y = 0.0;
                pos += abs(_Size * 0.001 / ray.y) * ray;
                col = float4(diskCol.rgb * (1.0 - col.a) + col.rgb, col.a + diskCol.a * (1.0 - col.a));
            }
        }

        if (outCol.r == 100.0)
            outCol = float4(col.rgb + glow.rgb * (col.a + glow.a), 1.0);

        col = outCol;
        col.rgb = pow(col.rgb, (float3)0.6);

        colOut += col / (float)(AA * AA);
    }

    float3 color = colOut.rgb;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_BlackHoleAccretionDisk() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "black_hole_accretion_disk_i0.jpg"}], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_BloodCells() {
    return "
    (
// BloodCells - converted from Shadertoy (4ttXzj) by kuvkar
// https://www.shadertoy.com/view/4ttXzj
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float BEAT = 4.0;

float smin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

float cells(float2 uv) {
    uv = lerp(sin(uv + float2(1.57, 0)), sin(uv.yx * 1.4 + float2(1.57, 0)), 0.75);
    return uv.x * uv.y * 0.3 + 0.7;
}

float fbm(float2 uv) {
    float f = 200.0;
    float2 r = float2(0.9, 0.45);
    float2 tmp;
    float T = 100.0 + time * 1.3;
    T += sin(time * BEAT) * 0.1;

    for (int i = 1; i < 8; ++i) {
        uv.y -= T * 0.5;
        uv.x -= T * 0.4;
        tmp = uv;

        uv.x = tmp.x * r.x - tmp.y * r.y;
        uv.y = tmp.x * r.y + tmp.y * r.x;
        float m = cells(uv);
        f = smin(f, m, 0.07);
    }
    return 1.0 - f;
}

float3 g(float2 uv) {
    float2 off = float2(0.0, 0.03);
    float t = fbm(uv);
    float x = t - fbm(uv + off.yx);
    float y = t - fbm(uv + off);
    float s = 0.0025;
    float3 xv = float3(s, x, 0);
    float3 yv = float3(0, y, s);
    return normalize(cross(xv, -yv)).xzy;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float3 ld = normalize(float3(1.0, 2.0, 3.0));

    float2 uv = fragCoord / resolution;
    uv -= (float2)0.5;
    float a = resolution.x / resolution.y;
    uv.y /= a;
    float2 ouv = uv;
    float B = sin(time * BEAT);
    uv = lerp(uv, uv * sin(B), 0.035);
    float2 _uv = uv * 25.0;
    float f = fbm(_uv);

    // base color
    float4 fragColor = (float4)f;
    fragColor.rgb *= float3(1.0, 0.3 + B * 0.05, 0.1 + B * 0.05);

    float3 v = normalize(float3(uv, 1.0));
    float3 grad = g(_uv);

    // spec
    float3 H = normalize(ld + v);
    float S = max(0.0, dot(grad, H));
    S = pow(S, 4.0) * 0.2;
    fragColor.rgb += S * float3(0.4, 0.7, 0.7);

    // rim
    float R = 1.0 - clamp(dot(grad, v), 0.0, 1.0);
    fragColor.rgb = lerp(fragColor.rgb, float3(0.8, 0.8, 1.0), smoothstep(-0.2, 2.9, R));

    // edges
    fragColor.rgb = lerp(fragColor.rgb, (float3)0.0, smoothstep(0.45, 0.55, max(abs(ouv.y * a), abs(ouv.x))));

    // contrast
    fragColor = smoothstep(0.0, 1.0, fragColor);

    float3 color = fragColor.rgb;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_BloodCells() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 40, timeAccumulate: true}
}

_Shader_HLSL_BlueMoonOcean() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 u = (fragCoord - resolution.xy / 2.) / resolution.y;
    float i = 0, d = 0, s, t = time;
    float3 p;
    float4 o = (float4)0;

    for (; i++ < 1e2; ) {
        p = float3(u * d, d + t);
        s = .15;
        while (s < 1.) {
            p += cos(t + p.yzx * .6) * sin(p.z * .1) * .2;
            p.y += sin(t + p.x) * .03;
            p += abs(dot(sin(p * s * 24.), (float3).01)) / s;
            s *= 1.5;
        }
        s = .03 + abs(2. + p.y) * .3;
        d += s;
        o += float4(1, 2, 4, 0) / s;
    }

    u -= .35;
    o = tanh(o / 7e3 / dot(u, u));

    float3 col = o.rgb;

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_BlueMoonOcean() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60}
}

_Shader_HLSL_BlurryCircles() {
    return "
    (
// Blurry Circles - converted from Shadertoy (wlBGDG)
// Author: LJ (@LJ_1102) - License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// GLSL mod: always returns positive (a - b*floor(a/b))
float2 glsl_mod(float2 a, float b) {
    return a - b * floor(a / b);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 w = resolution.xy;
    float2 p = fragCoord.xy / w.xy * 2.0 - 1.0;
    float2 o = p;
    p.x *= w.x / w.y;
    float3 d = (float3)0.0;
    float t = time * 0.1;
    float e = length(o);
    float k = o.y + o.x;

    for (int i = 0; i < 40; i++) {
        float a = (float)i;
        float r = frac(sin(a * 9.7)) * 0.8;
        p = glsl_mod(p + float2(sin(a + a - t), cos(t + a) + t * 0.1), 2.0) - 1.0;
        float l = length(p);
        float3 baseCol = lerp(
            float3(0.6, 0.46, 0.4),
            float3(0.25, 0.15, 0.3) + float3(0.0, k, k) * 0.25,
            a / 40.0);
        float3 colPow = pow(baseCol, (float3)3.0);
        float ring = pow(max(1.0 - abs(l - r + e * 0.2), 0.0), 25.0) * 0.2;
        float fill = smoothstep(r, r - e * 0.2, l);
        d += colPow * (ring + fill);
    }

    float3 color = sqrt(d) * 1.4;

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_BlurryCircles() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_BmTesting04() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define NUM_OCTAVES 5

static const float3 baseColor = float3(0.90, 0.745, 0.9);

float random(in float2 st) {
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

float noise(in float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    float a = random(i + float2(0.0, 0.0));
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float fbm(in float2 st) {
    float v = 0.0;
    float a = 0.5;

    for (int i = 0; i < NUM_OCTAVES; i++) {
        v += a * noise(st);
        st = st * 2.0;
        a *= 0.5;
    }

    return v;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 st = fragCoord / resolution.xy;

    float2 q = (float2)0.0;
    q.x = fbm(st + (float2)0.0);
    q.y = fbm(st + (float2)1.0);

    float2 r = (float2)0.0;
    r.x = fbm(st + 1.0 * q + float2(1.7, 9.2) + 0.15 * time);
    r.y = fbm(st + 1.0 * q + float2(8.3, 2.8) + 0.12 * time);

    float f = fbm(st + r);

    float coef = (f * f * f + 0.6 * f * f + 0.5 * f);

    float3 color = coef * baseColor;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_BmTesting04() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_Bmtest2() {
    return "
    (
// BMtest2 by thebtype
// Ported from https://www.shadertoy.com/view/NtdyRj
// Domain warping based on IQ's warp tutorial

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

float noise_val(float2 x) {
    float2 p = floor(x);
    float2 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    float a = iChannel0.SampleLevel(samp0, (p + float2(0.5, 0.5)) / 256.0, 0.0).x;
    float b = iChannel0.SampleLevel(samp0, (p + float2(1.5, 0.5)) / 256.0, 0.0).x;
    float c = iChannel0.SampleLevel(samp0, (p + float2(0.5, 1.5)) / 256.0, 0.0).x;
    float d = iChannel0.SampleLevel(samp0, (p + float2(1.5, 1.5)) / 256.0, 0.0).x;
    return lerp(lerp(a, b, f.x), lerp(c, d, f.x), f.y);
}

static const float2x2 mtx = float2x2(0.80, 0.60, -0.60, 0.80);

float fbm(float2 p) {
    float f = 0.0;
    f += 0.500000 * noise_val(p); p = mul(p, mtx) * 2.02;
    f += 0.250000 * noise_val(p); p = mul(p, mtx) * 2.03;
    f += 0.125000 * noise_val(p); p = mul(p, mtx) * 2.01;
    f += 0.062500 * noise_val(p); p = mul(p, mtx) * 2.04;
    f += 0.031250 * noise_val(p); p = mul(p, mtx) * 2.01;
    f += 0.015625 * noise_val(p);
    return f / 0.96875;
}

float pattern(float2 p, float t, float2 uv, out float2 q, out float2 r, out float2 g) {
    q = float2(fbm(p), fbm(p + float2(10, 1.3)));
    r = float2(fbm(p + 4.0 * q + (float2)t + float2(1.7, 9.2)),
               fbm(p + 4.0 * q + (float2)t + float2(8.3, 2.8)));
    g = float2(fbm(p + 2.0 * r + (float2)(t * 20.0) + float2(2, 6)),
               fbm(p + 2.0 * r + (float2)(t * 10.0) + float2(5, 3)));
    return fbm(p + 5.5 * g + (float2)(-t * 7.0));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution;

    float2 q, r, g;
    float n = pattern(fragCoord * (float2)0.004, time * 0.007, uv, q, r, g);

    // Base color from main noise
    float3 col = lerp(float3(0.1, 0.4, 0.4), float3(0.5, 0.7, 0.0), smoothstep(0.0, 1.0, n));

    // Lower-octave color mixes
    col = lerp(col, float3(0.35, 0.0, 0.1), dot(q, q));
    col = lerp(col, float3(0, 0.2, 1), 0.2 * g.y * g.y);
    col = lerp(col, float3(0.3, 0, 0), smoothstep(0.0, 0.6, 0.6 * r.g * r.g));
    col = lerp(col, float3(0, 0.5, 0), 0.1 * g.x);

    // Dark outlines / contrast bands
    col = lerp(col, (float3)0, smoothstep(0.3, 0.5, n) * smoothstep(0.5, 0.3, n));
    col = lerp(col, (float3)0, smoothstep(0.7, 0.8, n) * smoothstep(0.8, 0.7, n));

    // Contrast
    col *= n * 2.0;

    // Vignette
    col *= 0.70 + 0.65 * sqrt(70.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y));

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col *= 1.0 - darken;

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_Bmtest2() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "bmtest2_i0.png"}], timeAccumulate: true}
}

_Shader_HLSL_BokehExpe03() {
    return "
    (
// Bokeh Expe 03 — converted from Shadertoy tl3BWs
// By YitingLiu, based on BigWings bokeh tutorial
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define S(x, y, t) smoothstep(x, y, t)

struct ray {
    float3 o, d;
};

ray GetRay(float2 uv, float3 camPos, float3 lookat, float zoom) {
    ray a;
    a.o = camPos;

    float3 f = normalize(lookat - camPos);
    float3 r = cross(float3(0, 1, 0), f);
    float3 u = cross(f, r);
    float3 c = a.o + f * zoom;
    float3 i = c + uv.x * r + uv.y * u;
    a.d = normalize(i - a.o);

    return a;
}

float4 N14(float t) {
    return frac(sin(t * float4(123., 1024., 3456., 9575.)) * float4(2348., 125., 2518., 6578.));
}

float N(float t) {
    return frac(sin(t * 1258.) * 6527.);
}

float3 ClosetPoint(ray r, float3 p) {
    return r.o + max(0., dot(p - r.o, r.d)) * r.d;
}

float DistRay(ray r, float3 p) {
    return length(p - ClosetPoint(r, p));
}

float Bokeh(ray r, float3 p, float size, float blur) {
    size *= length(p);
    float d = DistRay(r, p);
    float c = S(size, size * (1. - blur), d);
    c *= lerp(.6, 1., S(size * .8, size, d));
    return c;
}

float3 Streetlights(ray r, float t) {
    float side = step(r.d.x, 0.);
    r.d.x = abs(r.d.x) - .08;

    float m = 0.;

    [loop] for (int si = 0; si < 10; si++) {
        float i = si * 0.1;
        float ti = frac(t + i + side * 0.1 * .5);
        float3 p = float3(2., 2., 100. - ti * 100.);
        m += Bokeh(r, p, .1, .1) * ti * ti * ti * ti;
    }
    return float3(1., .7, .3) * m;
}

float3 Envlights(ray r, float t) {
    float side = step(r.d.x, 0.);
    r.d.x = abs(r.d.x) - .08;

    float3 c = (float3)0;

    [loop] for (int ei = 0; ei < 10; ei++) {
        float i = ei * 0.1;
        float ti = frac(t + i + side * 0.1 * .5);

        float4 n = N14(i + side * 100.);

        float fade = ti * ti * ti * ti;
        float occlusion = sin(ti * 6.28 * 10. * n.x) * .5 + .5;
        fade = occlusion;

        float x = lerp(2.5, 10., n.x);
        float y = lerp(.1, 1.5, n.y);

        float3 p = float3(x, y, 50. - ti * 50.);
        float3 col = n.wzy;
        c += Bokeh(r, p, .1, .1) * fade * col * .2;
    }
    return c;
}

float3 Headlights(ray r, float t) {
    t *= .5;

    float w1 = .35;
    float w2 = w1 * 1.2;

    float m = 0.;

    [loop] for (int hi = 0; hi < 30; hi++) {
        float i = hi / 30.;

        float n = N(i);
        if (n > .1) continue;

        float ti = frac(t + i);
        float z = 100. - ti * 100.;
        float fade = ti * ti * ti * ti;

        float focus = S(.8, 1., ti);
        float size = lerp(.05, .03, focus);

        m += Bokeh(r, float3(-1. - w1, .15, z), size, .1) * fade;
        m += Bokeh(r, float3(-1. + w1, .15, z), size, .1) * fade;

        m += Bokeh(r, float3(-1. - w2, .15, z), size, .1) * fade;
        m += Bokeh(r, float3(-1. + w2, .15, z), size, .1) * fade;

        float ref = 0.;
        ref += Bokeh(r, float3(-1. - w2, -.15, z), size * 3., 1.) * fade;
        ref += Bokeh(r, float3(-1. + w2, -.15, z), size * 3., 1.) * fade;

        m += ref * focus;
    }

    return float3(.9, .9, 1.) * m;
}

float3 Taillights(ray r, float t) {
    t *= .8;

    float w1 = .25;
    float w2 = w1 * 1.2;

    float m = 0.;

    [loop] for (int ti_idx = 0; ti_idx < 15; ti_idx++) {
        float i = ti_idx / 15.;

        float n = N(i);
        if (n > .1) continue;

        float lane = step(.5, n);

        float ti = frac(t + i);
        float z = 100. - ti * 100.;
        float fade = ti * ti * ti * ti * ti;

        float focus = S(.9, 1., ti);
        float size = lerp(.05, .03, focus);

        float laneShift = S(.99, .96, ti);
        float x = 1.5 - lane * laneShift;

        float blink = step(0., sin(t * 10000.)) * 7. * lane * step(.96, ti);

        m += Bokeh(r, float3(x - w1, .15, z), size, .1) * fade;
        m += Bokeh(r, float3(x + w1, .15, z), size, .1) * fade;

        m += Bokeh(r, float3(x - w2, .15, z), size, .1) * fade;
        m += Bokeh(r, float3(x + w2, .15, z), size, .1) * fade * (1. + blink);

        float ref = 0.;
        ref += Bokeh(r, float3(x - w2, -.15, z), size * 3., 1.) * fade;
        ref += Bokeh(r, float3(x + w2, -.15, z), size * 3., 1.) * fade * (1. + blink * .1);

        m += ref * focus;
    }

    return float3(1., .1, .03) * m;
}

float2 Rain(float2 uv, float t) {
    t *= 40.;

    float2 a = float2(3., 1.);
    float2 st = uv * a;
    st.y += t * .2;
    float2 id = floor(st);

    float n = frac(sin(id.x * 716.34) * 768.34);

    uv.y += n;
    st.y += n;

    id = floor(st);
    st = frac(st) - .5;

    t += frac(sin(id.x * 76.34 + id.y * 1453.7) * 768.35) * 6.283;

    float y = -sin(t + sin(t + sin(t) * .5)) * .43;
    float2 p1 = float2(0., y);

    float2 o1 = (st - p1) / a;
    float d = length(o1);

    float m1 = S(.07, .0, d);

    float2 o2 = frac(uv * a.x * float2(1., 2.) - .5) / float2(1., 2.);
    d = length(o2);
    float m2 = S(.3 * (.5 - st.y), .0, d) * S(-.1, .1, st.y - p1.y);

    return float2(m1 * o1 * 50. + m2 * o2 * 10.);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float2 uv = fragCoord.xy / resolution.xy;
    uv -= .5;
    uv.x *= resolution.x / resolution.y;

    // iMouse zeroed — just a time scrub offset, shader animates via time
    float t = time * .05;

    float3 camPos = float3(.5, .18, 0.);
    float3 lookat = float3(.5, .22, 1.);

    float2 rainDistort = Rain(uv * 5., t) * .5;
    rainDistort += Rain(uv * 7., t) * .5;

    // water ripple effect
    uv.x += sin(uv.y * 70.) * .005;
    uv.y += sin(uv.x * 170.) * .003;

    ray r = GetRay(uv - rainDistort * .5, camPos, lookat, 2.);

    float3 col = Streetlights(r, t);
    col += Headlights(r, t);
    col += Taillights(r, t);
    col += Envlights(r, t);

    col += (r.d.y + .25) * float3(.2, .1, .5);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_BokehExpe03() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_BokehGradient() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float animationProgress = 1.0;
static const float bloomIntensity = 2.1;
static const float baseCircleSize = 0.3;
static const float3 primaryColor = float3(0.2, 0.2, 0.9);
static const float3 secondaryColor = float3(0.8, 0.4, 0.9);
static const float3 accentColor = float3(0.4, 0.9, 0.6);

static const float overlayAlpha = 0.5;
static const float circleOpacity = 0.4;
static const float softness = 0.2;
static const float moveSpeed = 0.6;
static const float sizeVariation = 0.5;

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Shader already flips Y internally
    float2 flippedCoord = float2(fragCoord.x, resolution.y - fragCoord.y);
    float2 uv = flippedCoord / resolution.xy;

    float effectStrength = smoothstep(0.0, 1.0, animationProgress);

    float t = time * moveSpeed;

    // Circle 1
    float2 pos1 = float2(0.3, 0.4) + float2(sin(t) * 0.08, cos(t * 1.2) * 0.06) * effectStrength;
    float radius1 = baseCircleSize * (1.2 + sin(t * 2.1) * sizeVariation) * effectStrength;
    float dist1 = distance(uv, pos1);
    float circle1 = 1.0 - smoothstep(radius1 - softness, radius1 + softness, dist1);

    // Circle 2
    float2 pos2 = float2(0.7, 0.6) + float2(cos(t + 1.0) * 0.07, sin(t * 0.8 + 2.0) * 0.09) * effectStrength;
    float radius2 = baseCircleSize * (0.9 + cos(t * 1.8 + 1.5) * sizeVariation) * effectStrength;
    float dist2 = distance(uv, pos2);
    float circle2 = 1.0 - smoothstep(radius2 - softness, radius2 + softness, dist2);

    // Circle 3
    float2 pos3 = float2(0.5, 0.3) + float2(sin(t * 1.3 + 3.0) * 0.06, cos(t + 4.0) * 0.08) * effectStrength;
    float radius3 = baseCircleSize * (1.1 + sin(t * 2.5 + 2.0) * sizeVariation) * effectStrength;
    float dist3 = distance(uv, pos3);
    float circle3 = 1.0 - smoothstep(radius3 - softness, radius3 + softness, dist3);

    // Circle 4
    float2 pos4 = float2(0.2, 0.7) + float2(cos(t * 0.9 + 5.0) * 0.09, sin(t * 1.1 + 1.0) * 0.05) * effectStrength;
    float radius4 = baseCircleSize * (1.0 + cos(t * 1.9 + 3.5) * sizeVariation) * effectStrength;
    float dist4 = distance(uv, pos4);
    float circle4 = 1.0 - smoothstep(radius4 - softness, radius4 + softness, dist4);

    // Circle 5
    float2 pos5 = float2(0.8, 0.2) + float2(sin(t * 1.4 + 2.5) * 0.07, cos(t * 0.7 + 3.5) * 0.06) * effectStrength;
    float radius5 = baseCircleSize * (0.8 + sin(t * 2.2 + 4.0) * sizeVariation) * effectStrength;
    float dist5 = distance(uv, pos5);
    float circle5 = 1.0 - smoothstep(radius5 - softness, radius5 + softness, dist5);

    // Circle 6
    float2 pos6 = float2(0.6, 0.8) + float2(cos(t * 1.6 + 4.5) * 0.08, sin(t * 0.6 + 2.5) * 0.07) * effectStrength;
    float radius6 = baseCircleSize * (1.3 + cos(t * 1.7 + 5.0) * sizeVariation) * effectStrength;
    float dist6 = distance(uv, pos6);
    float circle6 = 1.0 - smoothstep(radius6 - softness, radius6 + softness, dist6);

    // Circle 7
    float2 pos7 = float2(0.4, 0.6) + float2(sin(t * 0.8 + 6.0) * 0.05, cos(t * 1.5 + 1.5) * 0.09) * effectStrength;
    float radius7 = baseCircleSize * (1.1 + sin(t * 2.8 + 1.0) * sizeVariation) * effectStrength;
    float dist7 = distance(uv, pos7);
    float circle7 = 1.0 - smoothstep(radius7 - softness, radius7 + softness, dist7);

    // Circle 8
    float2 pos8 = float2(0.1, 0.5) + float2(cos(t * 1.2 + 3.5) * 0.06, sin(t * 0.9 + 4.5) * 0.08) * effectStrength;
    float radius8 = baseCircleSize * (0.9 + cos(t * 2.0 + 2.5) * sizeVariation) * effectStrength;
    float dist8 = distance(uv, pos8);
    float circle8 = 1.0 - smoothstep(radius8 - softness, radius8 + softness, dist8);

    // Color overlays per circle
    float3 overlay1 = primaryColor * circle1 * circleOpacity;
    float3 overlay2 = secondaryColor * circle2 * circleOpacity * 0.9;
    float3 overlay3 = accentColor * circle3 * circleOpacity * 0.8;
    float3 overlay4 = primaryColor * circle4 * circleOpacity * 0.7;
    float3 overlay5 = secondaryColor * circle5 * circleOpacity * 0.8;
    float3 overlay6 = accentColor * circle6 * circleOpacity * 0.6;
    float3 overlay7 = primaryColor * circle7 * circleOpacity * 0.7;
    float3 overlay8 = secondaryColor * circle8 * circleOpacity * 0.5;

    float3 totalOverlay = overlay1 + overlay2 + overlay3 + overlay4 + overlay5 + overlay6 + overlay7 + overlay8;

    // Bloom
    float3 bloomColor = (float3)0.0;

    float bloom1 = circle1 * 0.5;
    bloomColor += primaryColor * bloom1 * (1.0 - smoothstep(0.0, radius1 + 0.05, dist1));

    float bloom3 = circle3 * 0.4;
    bloomColor += accentColor * bloom3 * (1.0 - smoothstep(0.0, radius3 + 0.05, dist3));

    float bloom5 = circle5 * 0.3;
    bloomColor += secondaryColor * bloom5 * (1.0 - smoothstep(0.0, radius5 + 0.05, dist5));

    bloomColor *= bloomIntensity * 0.3;

    // Total alpha
    float totalAlpha = (circle1 + circle2 + circle3 + circle4 + circle5 + circle6 + circle7 + circle8) * circleOpacity * overlayAlpha * effectStrength;
    totalAlpha = saturate(totalAlpha);

    float3 color = totalOverlay + bloomColor;

    // Saturation boost
    float luminance = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(float3(luminance, luminance, luminance), color, 1.2);

    // Vignette on alpha
    float2 center = float2(0.5, 0.5);
    float vignette = 1.0 - pow(distance(uv, center) * 0.9, 1.2);
    vignette = clamp(vignette, 0.6, 1.0);
    totalAlpha *= vignette;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Premultiply with shader's own alpha
    return float4(color * totalAlpha, totalAlpha);
}
    )"
}

_Shader_Meta_BokehGradient() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_BokehLights() {
    return "
    (
// Bokeh Lights
//  Converted from Shadertoy: https://www.shadertoy.com/view/4lXXD2
//  Author: inferno (based on BigWIngs)
//  License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float3 worldUp = float3(0., 1., 0.);
static const float twopi = 6.283185307179586;

static const int NUM_LIGHTS = 150;
static const float _FocalDistance = 0.0035;
static const float _DOF = 1.0;
static const float _ZOOM = 0.6;

struct Ray {
    float3 o;
    float3 d;
};

struct Camera {
    float3 p;
    float3 fwd;
    float3 left;
    float3 up;
    float3 lookAt;
    float zoom;
};

static Ray eyeRay;
static Camera cam;

float hash(float n) {
    return frac(sin(n) * 1751.5453);
}

float2 hash2(float n) {
    float2 n2 = float2(n, -n + 2.1323);
    return frac(sin(n2) * 1751.5453);
}

float cubicPulse(float c, float w, float x) {
    x = abs(x - c);
    if (x > w) return 0.;
    x /= w;
    return 1. - x * x * (3. - 2. * x);
}

// Direct rotation math (avoids GLSL/HLSL matrix convention issues)
float3 rotate_y(float3 v, float angle) {
    float ca = cos(angle); float sa = sin(angle);
    return float3(ca * v.x - sa * v.z, v.y, sa * v.x + ca * v.z);
}

float3 rotate_x(float3 v, float angle) {
    float ca = cos(angle); float sa = sin(angle);
    return float3(v.x, ca * v.y - sa * v.z, sa * v.y + ca * v.z);
}

float3 ClosestPoint(Ray r, float3 p) {
    return r.o + max(1., dot(p - r.o, r.d)) * r.d;
}

float hash3(float n) {
    return frac(sin(n) * 753.5453123);
}

float vnoise(float3 x) {
    float3 p = floor(x);
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);

    float n = p.x + p.y * 157.0 + 113.0 * p.z;
    return lerp(lerp(lerp(hash3(n + 0.0), hash3(n + 1.0), f.x),
                     lerp(hash3(n + 157.0), hash3(n + 158.0), f.x), f.y),
                lerp(lerp(hash3(n + 113.0), hash3(n + 114.0), f.x),
                     lerp(hash3(n + 270.0), hash3(n + 271.0), f.x), f.y), f.z);
}

float Bokeh(Ray r, float3 p) {
    float dist = length(p - ClosestPoint(r, p));

    float distFromCam = length(p - eyeRay.o);
    float focus = cubicPulse(_FocalDistance, _DOF, distFromCam);

    float3 inFocus = float3(0.2, -0.1, 1.);
    float3 outFocus = float3(0.25, 0.2, 0.05);

    float3 thisFocus = lerp(outFocus, inFocus, focus);

    return smoothstep(thisFocus.x, thisFocus.y, dist) * thisFocus.z;
}

float3 Lights(Ray r, float t) {
    float3 col = (float3)0.;

    float height = 4.;
    float halfHeight = height / 2.;

    for (int i = 0; i < NUM_LIGHTS; i++) {
        float fi = (float)i;
        float c = fi / (float)NUM_LIGHTS;
        c *= twopi;

        float2 xy = hash2(fi) * 10. - 5.;
        float y = frac(c) * height - halfHeight;

        float3 pos = float3(xy.x, y, xy.y);
        pos += float3(vnoise(fi * pos * time * 0.0006), vnoise(fi * pos * time * 0.0002), 0.0);

        float glitter = 1. + clamp((sin(c + t * 3.) - 0.9) * 50., 0., 100.);

        col += Bokeh(r, pos) * glitter * lerp(float3(2.5, 2.2, 1.9), float3(0.7, 1.6, 3.0), 0.5 + 0.5 * sin(fi * 1.2 + 1.9));
    }
    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord.xy / resolution.xy) - 0.5;
    uv.y *= resolution.y / resolution.x;

    // Gentle time-based camera sweep (replaces iMouse)
    float mx = 0.5 + sin(time * 0.05) * 0.2;
    float my = 0.5 + cos(time * 0.035) * 0.15;

    float t = time;
    float speed = 0.004;
    float st = sin(t * speed);
    float ct = cos(t * speed);

    cam.p = float3(st, st, ct) * float3(4., 3.5, 4.);
    cam.p = normalize(cam.p);

    cam.p = rotate_x(cam.p, my * 2.0 + 5.2);
    cam.p = rotate_y(cam.p, mx * 3.0);

    cam.lookAt = (float3)0.;
    cam.fwd = normalize(cam.lookAt - cam.p);
    cam.left = cross(worldUp, cam.fwd);
    cam.up = cross(cam.fwd, cam.left);
    cam.zoom = _ZOOM;

    float3 screenCenter = cam.p + cam.fwd * cam.zoom;
    float3 screenPoint = screenCenter + cam.left * uv.x + cam.up * uv.y;

    eyeRay.o = cam.p;
    eyeRay.d = normalize(screenPoint - cam.p);

    float3 col = (float3)0.;
    col += Lights(eyeRay, t * 0.2);
    col += 0.05;

    // Darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_BokehLights() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_BokehParallax() {
    return "
    (
// Bokeh Parallax — based on https://www.shadertoy.com/view/4s2yW1
// Original by knarkowicz

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// GLSL mod: x - y * floor(x/y), differs from HLSL fmod for negatives
float glsl_mod(float x, float y) { return x - y * floor(x / y); }
float2 glsl_mod(float2 x, float y) { return x - y * floor(x / y); }

void Rotate(inout float2 p, float a)
{
    p = cos(a) * p + sin(a) * float2(p.y, -p.x);
}

float Circle(float2 p, float r)
{
    return (length(p / r) - 1.0) * r;
}

float Rand(float2 c)
{
    return frac(sin(dot(c.xy, float2(12.9898, 78.233))) * 43758.5453);
}

void BokehLayer(inout float3 color, float2 p, float3 c)
{
    float wrap = 450.0;
    if (glsl_mod(floor(p.y / wrap + 0.5), 2.0) == 0.0)
    {
        p.x += wrap * 0.5;
    }

    float2 p2 = glsl_mod(p + 0.5 * wrap, wrap) - 0.5 * wrap;
    float2 cell = floor(p / wrap + 0.5);
    float cellR = Rand(cell);

    c *= frac(cellR * 3.33 + 3.33);
    float radius = lerp(30.0, 70.0, frac(cellR * 7.77 + 7.77));
    p2.x *= lerp(0.9, 1.1, frac(cellR * 11.13 + 11.13));
    p2.y *= lerp(0.9, 1.1, frac(cellR * 17.17 + 17.17));

    float sdf = Circle(p2, radius);
    float circle = 1.0 - smoothstep(0.0, 1.0, sdf * 0.04);
    float glow = exp(-sdf * 0.025) * 0.3 * (1.0 - circle);
    color += c * (circle + glow);
}

float4 PSMain(PSInput input) : SV_Target {
    // Y-flip: background gradient has vertical direction
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 uv = fragCoord.xy / resolution.xy;
    float2 p = (2.0 * fragCoord - resolution.xy) / resolution.x * 1000.0;

    // background
    float3 color = lerp(float3(0.3, 0.1, 0.3), float3(0.1, 0.4, 0.5), dot(uv, float2(0.2, 0.7)));

    float t = time - 15.0;

    Rotate(p, 0.2 + t * 0.03);
    BokehLayer(color, p + float2(-50.0 * t + 0.0, 0.0), 3.0 * float3(0.4, 0.1, 0.2));
    Rotate(p, 0.3 - t * 0.05);
    BokehLayer(color, p + float2(-70.0 * t + 33.0, -33.0), 3.5 * float3(0.6, 0.4, 0.2));
    Rotate(p, 0.5 + t * 0.07);
    BokehLayer(color, p + float2(-60.0 * t + 55.0, 55.0), 3.0 * float3(0.4, 0.3, 0.2));
    Rotate(p, 0.9 - t * 0.03);
    BokehLayer(color, p + float2(-25.0 * t + 77.0, 77.0), 3.0 * float3(0.4, 0.2, 0.1));
    Rotate(p, 0.0 + t * 0.05);
    BokehLayer(color, p + float2(-15.0 * t + 99.0, 99.0), 3.0 * float3(0.2, 0.0, 0.4));

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float outA = max(color.r, max(color.g, color.b));
    return float4(color * outA, outA);
}

    )"
}

_Shader_Meta_BokehParallax() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_Brainfall() {
    return "
    (
// Brainfall — based on https://www.shadertoy.com/view/XXG3zG
// Original by panna_pudi

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float PI = 3.14159265359;
static const float TAU = 2.0 * PI;

float3 PBRNeutralToneMapping(float3 color) {
    const float startCompression = 0.8 - 0.04;
    const float desat = 0.15;

    float x = min(color.r, min(color.g, color.b));
    float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
    color -= offset;

    float peak = max(color.r, max(color.g, color.b));
    if (peak < startCompression)
        return color;

    const float d = 1.0 - startCompression;
    float newPeak = 1.0 - d * d / (peak + d - startCompression);
    color *= newPeak / peak;

    float g = 1.0 - 1.0 / (desat * (peak - newPeak) + 1.0);
    return lerp(color, (float3)newPeak, g);
}

// Rotation matrix — same constructor args as GLSL for mul(v, m) pattern
float2x2 rot(float x) {
    float c = cos(x), s = sin(x);
    return float2x2(c, -s, s, c);
}

float zuzoise(float2 uv, float t) {
    float2 sine_acc = (float2)0;
    float2 res = (float2)0;
    float scale = 5.0;

    float2x2 m = rot(1.0);

    for (float i = 0.0; i < 15.0; i++) {
        uv = mul(uv, m);
        sine_acc = mul(sine_acc, m);
        float2 layer = uv * scale * i + sine_acc - t;
        sine_acc += sin(layer);
        res += (cos(layer) * 0.5 + 0.5) / scale;
        scale *= 1.2;
    }
    return dot(res, (float2)1);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord / resolution - 0.5)
                * float2(resolution.x / resolution.y, 1.0);
    uv *= 0.2;

    float t = time;

    float a = sin(t * 0.1) * sin(t * 0.13 + dot(uv, uv) * 1.5) * 4.0;
    uv = mul(uv, rot(a));

    float3 sp = float3(uv, 0.0);

    const float L = 7.0;
    const float gfreq = 0.7;
    float sum = 0.0;

    float th = PI * 0.7071 / L;
    float cs = cos(th), si = sin(th);
    // Transposed constructor args for mul(M, v) pattern
    float2x2 M = float2x2(cs, si, -si, cs);

    float3 col = (float3)0;

    float f = 0.0;
    float2 offs = (float2)0.2;

    for (float i = 0.0; i < L; i++) {
        float s = frac((i - t * 2.0) / L);
        float e = exp2(s * L) * gfreq;

        float amp = (1.0 - cos(s * TAU)) / 3.0;

        float tmod = t * 3.0;
        tmod = tmod - sin(tmod);
        f += zuzoise(mul(M, sp.xy) * e + offs, tmod) * amp;

        sum += amp;

        M = mul(M, M);
    }

    sum = max(sum, 0.001);

    f /= sum;

    col = float3(1.0, 0.0, 0.5) * smoothstep(1.37, 1.5, f);
    col += float3(0.0, 1.0, 0.5) * pow(smoothstep(1.0, 1.54, f), 10.0);
    col += float3(0.20, 0.20, 0.20) * smoothstep(0.0, 4.59, f - 0.12);

    col = PBRNeutralToneMapping(col);

    col = pow(col, (float3)0.4545);

    float3 color = col;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float outA = max(color.r, max(color.g, color.b));
    return float4(color * outA, outA);
}

    )"
}

_Shader_Meta_Brainfall() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 40, timeOffsetMax: 120, timeAccumulate: true}
}

_Shader_HLSL_Bubbles() {
    return "
    (
// Created by inigo quilez - iq/2013 : https://www.shadertoy.com/view/4dl3zn
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
// Messed up by Weyland
// Converted from Shadertoy GLSL to Alt-Tabby HLSL

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float2 uv = -1.0 + 2.0 * fragCoord.xy / resolution.xy;
    uv.x *= resolution.x / resolution.y;

    // background
    float3 color = float3(1.0, 1.0, 1.0);

    // bubbles
    for (int i = 0; i < 64; i++)
    {
        // bubble seeds
        float pha =      sin(float(i) * 546.13 + 1.0) * 0.5 + 0.5;
        float siz = pow( sin(float(i) * 651.74 + 5.0) * 0.5 + 0.5, 4.0 );
        float pox =      sin(float(i) * 321.55 + 4.1) * resolution.x / resolution.y;

        // bubble size, position and color
        float rad = 0.1 + 0.5 * siz + sin(time / 6.0 + pha * 500.0 + siz) / 20.0;
        float2 pos = float2( pox + sin(time / 10.0 + pha + siz), -1.0 - rad + (2.0 + 2.0 * rad)
                             * fmod(pha + 0.1 * (time / 5.0) * (0.2 + 0.8 * siz), 1.0));
        float dis = length( uv - pos );
        float3 col = lerp( float3(0.194 * sin(time / 6.0), 0.3, 0.0),
                           float3(1.1 * sin(time / 9.0), 0.4, 0.8),
                           0.5 + 0.5 * sin(float(i) * 1.2 + 1.9));
        // render
        float f = length(uv - pos) / rad;
        f = sqrt(clamp(1.0 + (sin((time / 7.0) + pha * 500.0 + siz) * 0.5) - f * f, 0.0, 1.0));
        color -= col.zyx * (1.0 - smoothstep( rad * 0.95, rad, dis )) * f;
    }

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_Bubbles() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_CheapOcean() {
    return "
    (
// Cheap Ocean - converted from Shadertoy (NdtXDN) by Krischan
// https://www.shadertoy.com/view/NdtXDN
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2x2 rotate2D(float r) {
    return float2x2(cos(r), sin(r), -sin(r), cos(r));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float e = 0, f = 0, s = 0, g = 0, k = 0.01;
    float o = 1;

    for (int i = 0; i < 100; i++) {
        s = 2.0;
        g += min(f, max(0.03, e)) * 0.3;
        float3 p = float3((fragCoord - resolution / s) / resolution.y * g, g - s);
        p.yz = mul(rotate2D(-0.8), p.yz);
        p.y *= 2.5;
        p.z += time * 1.3;
        e = p.y;
        f = p.y;
        for (; s < 50.0;) {
            s /= 0.66;
            p.xz = mul(rotate2D(s), p.xz);
            e += abs(dot(sin(p * s) / s, (float3)0.6));
            f += abs(dot(sin(p.xz * s * 0.33 + time * 0.5) / s, (float2)1.0));
        }

        if (f > k * k)
            o += e * o * k;
        else
            o += -exp(-f * f) * o * k;
    }

    float3 color = o * float3(0.33, 0.7, 0.85);

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_CheapOcean() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_ChillSmokeOrb() {
    return "
    (
// Converted from Shadertoy: Chill Smoke Orb by diatribes
// https://www.shadertoy.com/view/tflBDM

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2x2 rot(float angle) {
    float4 c = cos(angle + float4(0, 33, 11, 0));
    return float2x2(c.x, c.z, c.y, c.w);
}

float orb(float3 p, float gtime) {
    float t = gtime * 4.0;
    return length(p - float3(
        sin(sin(t * 0.2) + t * 0.4) * 6.0,
        1.0 + sin(sin(t * 0.5) + t * 0.2) * 4.0,
        12.0 + gtime + cos(t * 0.3) * 8.0));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float d = 0.0, a, e = 0.0, s = 0.0, t = time;
    float4 o = (float4)0;

    // scale coords
    float2 uv = (2.0 * fragCoord - resolution) / resolution.y;

    // camera movement
    uv += float2(cos(t * 0.1) * 0.3, cos(t * 0.3) * 0.1);

    for (float i = 0.0; i < 128.0; i += 1.0)
    {
        // ray position
        float3 p = float3(uv * d, d + t);

        // entity (orb)
        e = orb(p, time) - 0.1;

        // spin by t, twist by p.z
        p.xy = mul(rot(0.1 * t + p.z / 8.0), p.xy);

        // mirrored planes 4 units apart
        s = 4.0 - abs(p.y);

        // noise octaves
        for (a = 0.8; a < 32.0; a += a)
        {
            // apply turbulence
            p += cos(0.7 * t + p.yzx) * 0.2;

            // apply noise
            s -= abs(dot(sin(0.1 * t + p * a), (float3)0.6)) / a;
        }

        // accumulate distance
        e = max(0.5 * e, 0.01);
        s = min(0.03 + 0.2 * abs(s), e);
        d += s;

        // grayscale color and orb light
        o += 1.0 / (s + e * 3.0);
    }

    // tanh tonemap
    o = tanh(o / 1e1);

    float3 color = o.rgb;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float al = max(color.r, max(color.g, color.b));
    return float4(color * al, al);
}

    )"
}

_Shader_Meta_ChillSmokeOrb() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60}
}

_Shader_HLSL_ClearlyABug() {
    return "
    (
// CC0: Clearly a bug - mrange
// https://www.shadertoy.com/view/33cGDj

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float i = 0.0;
    float d = 0.0;
    float z = frac(dot(fragCoord, sin(fragCoord))) - 0.5;
    float4 o = (float4)0;
    float4 p = (float4)0;
    float4 O = (float4)0;

    float2 r = resolution;
    [loop] for (; ++i < 77.0; z += 0.6 * d) {
        p = float4(z * normalize(float3(fragCoord - 0.5 * r, r.y)), 0.1 * time);
        p.z += time;
        O = p;

        // Rotation matrix 1 — fractal pattern transform
        float4 cv1 = cos(2.0 + O.z + float4(0, 11, 33, 0));
        p.xy = mul(float2x2(cv1.x, cv1.z, cv1.y, cv1.w), p.xy);

        // Rotation matrix 2 — the happy accident bug
        float4 cv2 = cos(O + float4(0, 11, 33, 0));
        p.xy = mul(float2x2(cv2.x, cv2.z, cv2.y, cv2.w), p.xy);

        // Color palette from position + space distortion
        O = (1.0 + sin(0.5 * O.z + length(p - O) + float4(0, 4, 3, 6)))
            / (0.5 + 2.0 * dot(O.xy, O.xy));

        // Domain repetition
        p = abs(frac(p) - 0.5);

        // Distance to nearest surface (cylinder + 2 planes)
        d = abs(min(length(p.xy) - 0.125, min(p.x, p.y) + 1e-3)) + 1e-3;

        // Accumulate lighting
        o += O.w / d * O;
    }

    // HDR tone mapping
    float3 color = tanh(o.rgb / 2e4);

    // Darken / desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_ClearlyABug() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_Cloud3d() {
    return "
    (
// Cloud 3D — based on https://www.shadertoy.com/view/4sXGRM

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float3 skytop = float3(0.05, 0.2, 0.5);
static const float3 light = normalize(float3(0.1, 0.25, 0.9));
static const float2 cloudrange = float2(0.0, 10000.0);

// GLSL mat3 is column-major; HLSL float3x3 is row-major — constructor args transposed
static const float3x3 m = float3x3(
     0.00, -1.60, -1.20,
     1.60,  0.72, -0.96,
     1.20, -0.96,  1.28);

float hash(float n) {
    return frac(cos(n) * 114514.1919);
}

float noise(float3 x) {
    float3 p = floor(x);
    float3 f = smoothstep(0.0, 1.0, frac(x));
    float n = p.x + p.y * 10.0 + p.z * 100.0;
    return lerp(
        lerp(lerp(hash(n + 0.0), hash(n + 1.0), f.x),
             lerp(hash(n + 10.0), hash(n + 11.0), f.x), f.y),
        lerp(lerp(hash(n + 100.0), hash(n + 101.0), f.x),
             lerp(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);
}

float fbm(float3 p) {
    float f = 0.5000 * noise(p);
    p = mul(m, p);
    f += 0.2500 * noise(p);
    p = mul(m, p);
    f += 0.1666 * noise(p);
    p = mul(m, p);
    f += 0.0834 * noise(p);
    return f;
}

float3 get_camera(float t) {
    return float3(5000.0 * sin(1.0 * t), 5000.0 + 1500.0 * sin(0.5 * t), 6000.0 * t);
}

float4 PSMain(PSInput input) : SV_Target {
    // Y-flip: clouds have gravity/up direction
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 uv = 2.0 * fragCoord.xy / resolution.xy - 1.0;
    uv.x *= resolution.x / resolution.y;

    float camTime = time + 57.5;
    float3 campos = get_camera(camTime);
    float3 camtar = get_camera(camTime + 0.4);

    float3 front = normalize(camtar - campos);
    float3 right = normalize(cross(front, float3(0.0, 1.0, 0.0)));
    float3 up = normalize(cross(right, front));
    float3 fragAt = normalize(uv.x * right + uv.y * up + front);

    // clouds
    float4 sum = (float4)0;
    for (float depth = 0.0; depth < 100000.0; depth += 200.0) {
        float3 ray = campos + fragAt * depth;
        if (cloudrange.x < ray.y && ray.y < cloudrange.y) {
            float a = smoothstep(0.5, 1.0, fbm(ray * 0.00025));
            float3 localcolor = lerp(float3(1.1, 1.05, 1.0), float3(0.3, 0.3, 0.2), a);
            a = (1.0 - sum.a) * a;
            sum += float4(localcolor * a, a);
        }
    }

    float alpha = smoothstep(0.7, 1.0, sum.a);
    sum.rgb /= sum.a + 0.0001;

    float sundot = clamp(dot(fragAt, light), 0.0, 1.0);
    float3 col = 0.8 * skytop;
    col += 0.47 * float3(1.6, 1.4, 1.0) * pow(sundot, 350.0);
    col += 0.4 * float3(0.8, 0.9, 1.0) * pow(sundot, 2.0);

    sum.rgb -= 0.6 * float3(0.8, 0.75, 0.7) * pow(sundot, 13.0) * alpha;
    sum.rgb += 0.2 * float3(1.3, 1.2, 1.0) * pow(sundot, 5.0) * (1.0 - alpha);

    col = lerp(col, sum.rgb, sum.a);

    float3 color = col;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float outA = max(color.r, max(color.g, color.b));
    return float4(color * outA, outA);
}

    )"
}

_Shader_Meta_Cloud3d() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_ColorBreathScreensaver() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Normalize and center pixel coordinates
    float2 uv = (fragCoord * 2.0 - resolution) / resolution.y;

    // Round mask
    float dMask = 1.0 - length(uv);
    dMask = smoothstep(0.25, 1.0, clamp(dMask, 0.0, 1.0)) * pow(abs(sin(time * 0.888) * 1.5), 3.0);

    // Time varying pixel color using deformed uvs
    float3 col = 0.5 + 0.5 * cos(time * 1.0123 + uv.xyx + float3(0, 2, 4));

    // Output to screen
    float3 color = col * dMask;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from mask — premultiplied
    float a = dMask;
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_ColorBreathScreensaver() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_ColorFadePattern() {
    return "
    (
// Color Fade Pattern - IceSelkie (Shadertoy wsfSDN)
// https://www.shadertoy.com/view/wsfSDN
// Converted from GLSL to HLSL for Alt-Tabby
// Note: Dead ray marcher scaffolding removed (march() always returned 1.0)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float getLight(float3 pt) {
    return pt.z - 1.0;
}

float3 getColor(float3 pt) {
    pt.z = pt.x + pt.y * 0.3;
    return 0.5 + 0.5 * cos((0.3 * time * float3(1.0, 0.95, 1.06)) + pt.xyz * 0.2);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Normalized pixel coordinates (-1 to 1)
    float2 uv = (fragCoord - 0.5 * resolution) / resolution.y;

    // Camera location & look direction
    float3 cam = float3(0, 0, 1);
    float3 look = normalize(float3(uv.x, uv.y, 1));

    // march() always returns 1.0 in original
    float d = 1.0;
    float3 pt = cam + d * look;
    float3 col = getLight(pt) * getColor(pt);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_ColorFadePattern() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_Colorfog() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define NUM_OCTAVES 4
#define pi 3.14159265

static float focus = 0.0;
static float focus2 = 0.0;

float random(float2 p) {
    return frac(sin(dot(p, float2(12.0, 90.0))) * 5e5);
}

float2x2 rot2(float an) {
    float cc = cos(an), ss = sin(an);
    return float2x2(cc, ss, -ss, cc);
}

float noise(float3 p) {
    float2 i = floor(p.yz);
    float2 f = frac(p.yz);
    float a = random(i + float2(0.0, 0.0));
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);
}

float fbm3d(float3 p) {
    float v = 0.0;
    float a = 0.35;

    for (int i = 0; i < NUM_OCTAVES; i++) {
        v += a * noise(p);
        a *= 0.25 * (1.2 + focus + focus2);
    }
    return v;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (2.0 * fragCoord - resolution.xy) / resolution.y * 2.5;

    float aspectRatio = resolution.x / resolution.y;

    float3 rd = normalize(float3(uv, -1.2));
    float3 ro = (float3)0;

    float delta = time / 1.5;

    rd.yz = mul(rot2(-delta / 2.0), rd.yz);
    rd.xz = mul(rot2(delta * 3.0), rd.xz);
    float3 p = ro + rd;

    float bass = 1.5 + 0.5 * max(0.0, 2.0 * sin(time * 3.0));

    float2 nudge = float2(aspectRatio * cos(time * 1.5), sin(time * 1.5));

    focus = length(uv + nudge);
    focus = 2.0 / (1.0 + focus) * bass;

    focus2 = length(uv - nudge);
    focus2 = 4.0 / (1.0 + focus2 * focus2) / bass;

    float3 q = float3(fbm3d(p), fbm3d(p.yzx), fbm3d(p.zxy));

    float f = fbm3d(p + q);

    float3 col = q;
    col *= 20.0 * f;

    col.r += 5.0 * focus; col.g += 3.5 * focus;
    col.b += 7.0 * focus2; col.r -= 3.5 * focus2;
    col /= 25.0;

    // Apply darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_Colorfog() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_ColorfulFbmDomainWarping() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// GLSL-compatible mod (always positive)
float glsl_mod(float x, float y) { return x - y * floor(x / y); }
float3 glsl_mod3(float3 x, float y) { return x - y * floor(x / y); }

float random(in float2 st) {
    return frac(sin(dot(st.xy,
                        float2(12.9898, 78.233))) *
                43758.5453123);
}

float noise(in float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    float a = random(i);
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(a, b, u.x) +
        (c - a) * u.y * (1.0 - u.x) +
        (d - b) * u.x * u.y;
}

#define OCTAVES 16

float fbm(in float2 st) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 2.0;

    for (int i = 0; i < OCTAVES; i++) {
        value += amplitude * noise(st);
        st *= 3.0;
        amplitude *= 0.5;
    }
    return value;
}

float fbmWarp2(in float2 st, out float2 q, out float2 r) {
    q.x = fbm(st + float2(0.0, 0.0));
    q.y = fbm(st + float2(5.2, 1.3));

    r.x = fbm(st + 4.0 * q + float2(1.7, 9.2) + 0.7 * time);
    r.y = fbm(st + 4.0 * q + float2(8.3, 2.8) + 0.7 * time);

    return fbm(st + 4.0 * r);
}

float3 hsb2rgb(in float3 c) {
    float3 rgb = clamp(abs(glsl_mod3(c.x * 6.0 + float3(0.0, 4.0, 2.0),
                                     6.0) - 3.0) - 1.0,
                       0.0,
                       1.0);
    rgb = rgb * rgb * (3.0 - 2.0 * rgb);
    return c.z * lerp((float3)1.0, rgb, c.y);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 st = fragCoord.xy / resolution.xy;
    st.x *= resolution.x / resolution.y;

    float3 color = (float3)0.0;
    float2 q = (float2)0.0;
    float2 r = (float2)0.0;
    float height = fbmWarp2(st * 10.0, q, r);

    color += hsb2rgb(float3(0.3, 1.0 - (0.5 * sin(time) + 0.5), height));
    color = lerp(color, hsb2rgb(float3(0.0, q.x, 0.2 + (0.2 * sin(0.7 * time) + 0.2))), length(q));
    color = lerp(color, hsb2rgb(float3(0.58, r.x, 0.0 + (0.25 * sin(0.3 * time) + 0.25))), r.y);

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_ColorfulFbmDomainWarping() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_ColorfulFractalThingy2() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float3 palette(float t) {
    float3 a = float3(0.2, 0.4, 0.6);
    float3 b = float3(0.1, 0.2, 0.3);
    float3 c = float3(0.3, 0.5, 0.7);

    return a + b * sin(6.0 * (c * t + a));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord * 1000.0 / resolution.xy) / resolution.y;
    float2 uv0 = sin(uv * 2.5);

    float3 finalColor = (float3)0.5;

    for (float i = 0.0; i < 3.3; i++) {
        uv = uv * 1.5 + sin(uv.yx * 3.0) * 1.5;

        float dist = length(uv) * exp(-length(uv0 * 0.5));

        float3 col = palette(length(uv0) + i * 0.3 + time * 0.3);

        dist = sin(dist * 3.33 + time * 1.0) / 15.0;
        dist = abs(dist);
        dist = pow(0.025 / dist, 1.5);

        finalColor += col - dist;
    }

    // Darken/desaturate post-processing
    float lum = dot(finalColor, float3(0.299, 0.587, 0.114));
    finalColor = lerp(finalColor, float3(lum, lum, lum), desaturate);
    finalColor = finalColor * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(finalColor.r, max(finalColor.g, finalColor.b));
    return float4(finalColor * a, a);
}

    )"
}

_Shader_Meta_ColorfulFractalThingy2() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_CosmicFbmNoise() {
    return "
    (
// cosmic fbm noise — nayk (Shadertoy 4csyRl)
// CC BY-NC-SA 3.0
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float F3 = 0.3333333;
static const float G3 = 0.1666667;

static const float PI_VAL = 3.141592;
static const float TWOPI = 6.283184;

float3 random3(float3 c) {
    float j = 4096.0 * sin(dot(c, float3(17.0, 59.4, 15.0)));
    float3 r;
    r.z = frac(512.0 * j);
    j *= 0.125;
    r.x = frac(512.0 * j);
    j *= 0.125;
    r.y = frac(512.0 * j);
    return r - 0.5;
}

float simplex3d(float3 p) {
    float3 s = floor(p + dot(p, (float3)F3));
    float3 x = p - s + dot(s, (float3)G3);

    float3 e = step((float3)0.0, x - x.yzx);
    float3 i1 = e * (1.0 - e.zxy);
    float3 i2 = 1.0 - e.zxy * (1.0 - e);

    float3 x1 = x - i1 + G3;
    float3 x2 = x - i2 + 2.0 * G3;
    float3 x3 = x - 1.0 + 3.0 * G3;

    float4 w, d;
    w.x = dot(x, x);
    w.y = dot(x1, x1);
    w.z = dot(x2, x2);
    w.w = dot(x3, x3);

    w = max(0.6 - w, 0.0);

    d.x = dot(random3(s), x);
    d.y = dot(random3(s + i1), x1);
    d.z = dot(random3(s + i2), x2);
    d.w = dot(random3(s + 1.0), x3);

    w *= w;
    w *= w;
    d *= w;

    return dot(d, (float4)52.0);
}

float random_2d(float2 st) {
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

float noise_2d(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    float a = random_2d(i);
    float b = random_2d(i + float2(1.0, 0.0));
    float c = random_2d(i + float2(0.0, 1.0));
    float d = random_2d(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
}

float fbm(float2 p) {
    float nVal = 0.0;
    float amp = 0.45;
    [unroll]
    for (int i = 0; i < 4; i++) {
        nVal += amp * simplex3d(float3(p, 0.2 * time));
        nVal += amp * noise_2d(p + time);
        p *= 3.0;
        amp *= 0.45;
    }
    return nVal;
}

#define ITERATIONS 12
#define FORMUPARAM 0.53

#define VOLSTEPS 20
#define STEPSIZE 0.1

#define ZOOM 0.800
#define TILE 0.850

#define BRIGHTNESS 0.0015
#define DARKMATTER 0.300
#define DISTFADING 0.730

#define SATURATION 0.850

float happy_star(float2 uv, float anim) {
    uv = abs(uv);
    float2 pos = min(uv.xy / uv.yx, anim);
    float p = (2.0 - pos.x - pos.y);
    return (2.0 + p * (p * p - 1.5)) / (uv.x + uv.y);
}

float2x2 rotMat(float r) {
    float c = cos(r);
    float s = sin(r);
    return float2x2(c, -s, s, c);
}

float abs1d(float x) { return abs(frac(x) - 0.5); }
float2 abs2d(float2 v) { return abs(frac(v) - 0.5); }
float sin1d(float p) { return sin(p * TWOPI) * 0.25 + 0.25; }

static const float D2R = PI_VAL / 180.0;
static const float OC = 15.0;

float3 Oilnoise(float2 pos, float3 RGB) {
    float2 q = (float2)1.0;
    float result = 0.0;
    float t = time * 0.1 + ((0.25 + 0.05 * sin(time * 0.1)) / (length(pos.xy) + 0.07)) * 2.2;
    float si = sin(t);
    float co = cos(t);
    float2x2 ma = float2x2(co, si, -si, co);
    float s = 14.2;

    float gain = 0.44;
    float2 aPos = abs2d(pos) * 0.0;

    for (float i = 0.0; i < OC; i++) {
        pos = mul(pos, rotMat(D2R * 30.0));

        float tm = (sin(time) * 0.5 + 0.5) * 0.2 + time * 0.8;
        q = pos * s + tm;
        q = pos * s + aPos + tm;
        q = cos(q);
        q = mul(q, ma);
        result += sin1d(dot(q, float2(0.3, 0.3))) * gain;

        s *= 1.07;
        aPos += cos(smoothstep(0.0, 0.15, q));
        aPos = mul(aPos, rotMat(D2R * 1.0));
        aPos *= 1.232;
    }

    result = pow(result, 4.504);
    return clamp(RGB / abs1d(dot(q, float2(-0.240, 0.000))) * 0.5 / result, (float3)0.0, (float3)1.0);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = (fragCoord - 0.5 * resolution.xy) / resolution.y;
    float2 uv2 = (fragCoord - 0.5 * resolution.xy) / resolution.y;
    float2 uv3 = (fragCoord - 0.5 * resolution.xy) / resolution.y;
    uv3.x += 0.5;
    uv3.y += 0.2;
    float3 col = (float3)0.0;

    uv2.x += 0.1 * cos(time);
    uv2.y += 0.1 * sin(time);
    uv.y *= resolution.y / resolution.x;
    float3 dir = float3(uv * ZOOM, 1.0);
    float2 uPos = (fragCoord.xy / resolution.y);
    uPos -= float2((resolution.x / resolution.y) / 2.0, 0.5);

    float multiplier = 0.0005;
    static const float step2 = 0.006;
    static const float loop_count = 80.0;
    static const float timeSCale = 0.5;

    float3 blueGodColor = (float3)0.0;
    for (float i = 1.0; i < loop_count; i++) {
        float t = time * timeSCale - step2 * i * i;
        float2 pt = float2(0.75 * sin(t), 0.5 * sin(t));
        pt += float2(0.75 * cos(t * 4.0), 0.5 * sin(t * 3.0));
        pt /= 11.0 * sin(i);
        float componentColor = multiplier / ((uPos.x - pt.x) * (uPos.x - pt.x) + (uPos.y - pt.y) * (uPos.y - pt.y)) / i;
        blueGodColor += float3(componentColor / 3.0, componentColor / 3.0, componentColor);
    }

    float3 color = (float3)0.0;
    color += pow(blueGodColor, float3(0.1, 0.3, 0.8));

    float3 from = float3(1.0, 0.5, 0.5);
    float2 uv0 = uv;
    float3 col2 = (float3)0.0;
    float2 st = (fragCoord / resolution.xy);
    st.x = ((st.x - 0.5) * (resolution.x / resolution.y)) + 0.5;

    float t2 = time * 0.1 + ((0.25 + 0.05 * sin(time * 0.1)) / (length(uv3.xy) + 0.57)) * 25.2;
    float si = sin(t2);
    float co = cos(t2);
    float2x2 ma = float2x2(co, si, -si, co);

    st *= 3.0;

    float3 rgb = float3(0.30, 0.8, 1.200);

    float2 pix = 1.0 / resolution.xy;
    float2 aaST = st + pix * float2(1.5, 0.5);
    col2 += Oilnoise(aaST, rgb);

    float scale = 5.0;
    uv *= scale;
    uv2 *= 2.0 * (cos(time * 2.0) - 2.5);
    float anim = sin(time * 12.0) * 0.1 + 1.0;

    // Idea from IQ — nested fbm
    float fbm1 = fbm(uv);
    float fbm2 = fbm(uv + fbm1);
    float fbm3 = fbm(uv + fbm2);
    col += 3.0 * (fbm3 - 0.4) * (1.5 - length(uv0));

    col *= float3(0.9, 0.9, 1.0);
    float s = 0.1, fade = 1.0;
    float3 v = (float3)0.0;
    for (int r = 0; r < VOLSTEPS; r++) {
        float3 p = from + s * dir + 0.5;

        p = abs((float3)TILE - fmod(p, (float3)(TILE * 2.0)));
        float pa, a;
        pa = 0.0;
        a = 0.0;
        for (int i = 0; i < ITERATIONS; i++) {
            p = abs(p) / dot(p, p) - FORMUPARAM;
            float cosT = cos(time * 0.05);
            float sinT = sin(time * 0.05);
            p.xy = mul(p.xy, float2x2(cosT, sinT, -sinT, cosT));
            a += abs(length(p) - pa);
            pa = length(p);
        }
        float dm = max(0.0, DARKMATTER - a * a * 0.001);
        a *= a * a;
        if (r > 6) fade *= 1.2 - dm;
        v += fade;
        v += float3(s, s * s, s * s * s * s) * a * BRIGHTNESS * fade;
        fade *= DISTFADING;
        s += STEPSIZE;
    }
    v = lerp((float3)length(v), v, SATURATION);

    float3 finalColor = v * 0.03 + col + col2 + color * 2.0;
    finalColor += happy_star(mul(uv3, ma), anim) * float3(0.15 + 0.1 * cos(time), 0.2, 0.15 + 0.1 * sin(time)) * 0.3;
    finalColor += happy_star(uv2, anim) * float3(0.25 + 0.1 * cos(time), 0.2 + 0.1 * sin(time), 0.15) * 0.5;
    finalColor *= happy_star(uv2, anim) * float3(0.25 + 0.1 * cos(time), 0.2 + 0.1 * sin(time), 0.15) * 2.0;

    // Darken/desaturate post-processing
    float lum = dot(finalColor, float3(0.299, 0.587, 0.114));
    finalColor = lerp(finalColor, (float3)lum, desaturate);
    finalColor = finalColor * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a_out = max(finalColor.r, max(finalColor.g, finalColor.b));
    return float4(finalColor * a_out, a_out);
}

    )"
}

_Shader_Meta_CosmicFbmNoise() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 40, timeOffsetMax: 120, timeAccumulate: true}
}

_Shader_HLSL_CrumpledWave() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float2 uv = (2.0 * fragCoord - resolution.xy) / min(resolution.x, resolution.y);

    for (float i = 1.0; i < 8.0; i++) {
        uv.y += i * 0.1 / i *
            sin(uv.x * i * i + time * 0.5) * sin(uv.y * i * i + time * 0.5);
    }

    float3 col;
    col.r = uv.y - 0.1;
    col.g = uv.y + 0.3;
    col.b = uv.y + 0.95;

    // Apply darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_CrumpledWave() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_CubeWave3() {
    return "
    (
// Cube Wave 3 - FabriceNeyret2 (Shadertoy lcSGDD)
// https://www.shadertoy.com/view/lcSGDD
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float segment(float2 p, float2 a, float2 b) {
    p -= a;
    b -= a;
    return length(p - b * clamp(dot(p, b) / dot(b, b), 0.0, 1.0));
}

// rot(a) macro: cos(a+vec4(0,pi/2,-pi/2,0)) = (cos(a),-sin(a),sin(a),cos(a))
// GLSL mat2(vec4) fills column-major; HLSL float2x2 fills row-major.
// With mul(M,v), row-major (cos,-sin,sin,cos) gives same result as GLSL v*M column-major.
float2x2 rot(float a) {
    float4 v = cos(a + float4(0, 1.57, -1.57, 0));
    return float2x2(v.x, v.y, v.z, v.w);
}

static float gt;

float2 T(float3 p) {
    p.xy = mul(rot(-gt), p.xy);
    p.xz = mul(rot(0.785), p.xz);
    p.yz = mul(rot(-0.625), p.yz);
    return p.xy;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 R = resolution;
    float2 U = 10.0 * fragCoord / R.y;
    float2 M = float2(2, 2.3);
    float2 I = floor(U / M) * M;
    float2 J, X;
    U = fmod(U, M);
    float4 O = (float4)0;

    for (int k = 0; k < 4; k++) {
        X = float2(k % 2, k / 2) * M;
        J = I + X;
        if ((int)(J.x / M.x) % 2 > 0) X.y += 1.15;
        gt = tanh(-0.2 * (J.x + J.y) + fmod(2.0 * time, 10.0) - 1.6) * 0.785;
        for (float a = 0.0; a < 6.0; a += 1.57) {
            float3 A = float3(cos(a), sin(a), 0.7);
            float3 B = float3(-A.y, A.x, 0.7);
            O += smoothstep(15.0 / R.y, 0.0, segment(U - X, T(A), T(B)));
            O += smoothstep(15.0 / R.y, 0.0, segment(U - X, T(A), T(A * float3(1, 1, -1))));
            A.z = -A.z; B.z = -B.z;
            O += smoothstep(15.0 / R.y, 0.0, segment(U - X, T(A), T(B)));
        }
    }

    float3 col = O.rgb;

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float al = max(col.r, max(col.g, col.b));
    return float4(col * al, al);
}

    )"
}

_Shader_Meta_CubeWave3() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_DamaskRose() {
    return "
    (
// CC0: Windows Terminal Damask Rose
// Original by mrange - https://www.shadertoy.com/view/flKfzh

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI          3.141592654
#define PI_2        (0.5*PI)
#define TAU         (2.0*PI)
// GLSL mat2 is column-major; HLSL float2x2 is row-major — transposed
#define ROT(a)      float2x2(cos(a), -sin(a), sin(a), cos(a))

// Using standard atan2; uncomment FASTATAN line and switch to use atan_approx
//#define FASTATAN
#if defined(FASTATAN)
#define ATAN atan_approx
#else
#define ATAN atan2
#endif

static const float hf = 0.015;

// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
static const float4 hsv2rgb_K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
float3 hsv2rgb(float3 c) {
    float3 p = abs(frac(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
    return c.z * lerp(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
}
// Macro version of above to enable compile-time constants
#define HSV2RGB(c)  (c.z * lerp(hsv2rgb_K.xxx, clamp(abs(frac(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
float3 sRGB(float3 t) {
    return lerp(1.055 * pow(t, (float3)(1.0 / 2.4)) - 0.055, 12.92 * t, step(t, (float3)0.0031308));
}

// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
float3 aces_approx(float3 v) {
    v = max(v, 0.0);
    v *= 0.6f;
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0f, 1.0f);
}

// License: Unknown, author: Unknown, found: don't remember
float tanh_approx(float x) {
    float x2 = x * x;
    return clamp(x * (27.0 + x2) / (27.0 + 9.0 * x2), -1.0, 1.0);
}

// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV
float atan_approx(float y, float x) {
    float cosatan2 = x / (abs(x) + abs(y));
    float t = PI_2 - cosatan2 * PI_2;
    return y < 0.0 ? -t : t;
}

// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
float pmin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

float pabs(float a, float k) {
    return -pmin(a, -a, k);
}

float height(float2 p) {
    float tm = time;
    const float xm = 0.5 * 0.005123;
    float ym = lerp(0.125, 0.25, 0.5 - 0.5 * cos(TAU * time / 600.0));

    p *= 0.4;

    float d = length(p);
    float c = 1E6;
    float x = pow(d, 0.1);
    float y = (ATAN(p.x, p.y) + 0.05 * tm - 2.0 * d) / TAU;

    for (float i = 0.0; i < 3.0; ++i) {
        float v = length(frac(float2(x - tm * i * xm, frac(y + i * ym) * 0.5) * 20.0) * 2.0 - 1.0);
        c = pmin(c, v, 0.125);
    }

    float h = (-hf + hf * (pabs(tanh_approx(5.5 * d - 80.0 * c * c * d * d * (0.55 - d)) - 0.25 * d, 0.25)));
    return h;
}

float3 get_normal(float2 p) {
    float2 e = float2(4.0 / resolution.y, 0);

    float3 n;
    n.x = height(p + e.xy) - height(p - e.xy);
    n.y = -2.0 * e.x;
    n.z = height(p + e.yx) - height(p - e.yx);

    return normalize(n);
}

float3 get_color(float2 p) {
    const float ss = 1.25;
    const float hh = 1.95;

    float3 lp1 = -float3(1.0, hh, -1.0) * float3(ss, 1.0, ss);
    float3 lp2 = -float3(-1.0, hh, -1.0) * float3(ss, 1.0, ss);

    float3 lcol1 = HSV2RGB(float3(0.30, 0.35, 2.0));
    float3 lcol2 = HSV2RGB(float3(0.57, 0.6, 2.0));
    float3 mat = HSV2RGB(float3(0.55, 0.9, 0.05));
    const float spe = 16.0;

    float h = height(p);
    float3 n = get_normal(p);

    float3 ro = float3(0.0, 8.0, 0.0);

    float3 po = float3(p.x, 0.0, p.y);
    float3 rd = normalize(ro - po);

    float3 ld1 = normalize(lp1 - po);
    float3 ld2 = normalize(lp2 - po);

    float diff1 = max(dot(n, ld1), 0.0);
    float diff2 = max(dot(n, ld2), 0.0);

    float3 rn = n;
    float3 ref = reflect(rd, rn);
    float ref1 = max(dot(ref, ld1), 0.0);
    float ref2 = max(dot(ref, ld2), 0.0);

    float dm = tanh_approx(abs(h) * 120.0);
    float rm = dm;
    dm *= dm;

    float3 lpow1 = dm * mat * lcol1;
    float3 lpow2 = dm * mat * lcol2;

    float3 col = (float3)0.0;
    col += diff1 * diff1 * lpow1;
    col += diff2 * diff2 * lpow2;

    col += rm * pow(ref1, spe) * lcol1;
    col += rm * pow(ref2, spe) * lcol2;

    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 q = fragCoord / resolution;
    float2 p = -1.0 + 2.0 * q;
    p.x *= resolution.x / resolution.y;
    float3 col = get_color(p);

    col = aces_approx(col);
    col = sRGB(col);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_DamaskRose() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 20, timeOffsetMax: 90}
}

_Shader_HLSL_Deterioration() {
    return "
    (
// Deterioration - converted from Shadertoy (3dBSW3)
// Author: Blokatt - License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2x2 rot(float a) {
    return float2x2(
        cos(a), -sin(a),
        sin(a), cos(a));
}

float rand(float2 uv) {
    return frac(sin(dot(float2(12.9898, 78.233), uv)) * 43758.5453123);
}

float valueNoise(float2 uv) {
    float2 i = frac(uv);
    float2 f = floor(uv);
    float a = rand(f);
    float b = rand(f + float2(1.0, 0.0));
    float c = rand(f + float2(0.0, 1.0));
    float d = rand(f + float2(1.0, 1.0));
    return lerp(lerp(a, b, i.x), lerp(c, d, i.x), i.y);
}

float fbm(float2 uv) {
    float v = 0.0;
    float amp = 0.75;
    float z = (20.0 * sin(time * 0.2)) + 30.0;

    for (int i = 0; i < 10; ++i) {
        v += valueNoise(uv + (z * uv * 0.05) + (time * 0.1)) * amp;
        uv *= 3.25;
        amp *= 0.5;
    }

    return v;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = fragCoord / resolution.xy - 0.5;
    float2 oldUV = uv;
    uv.x *= resolution.x / resolution.y;
    float2x2 r = rot(time * 0.02);
    uv = mul(uv, r);
    float2x2 angle = rot(fbm(uv));

    float3 col = float3(
        fbm(mul(angle, float2(5.456, -2.8112)) + uv),
        fbm(mul(angle, float2(5.476, -2.8122)) + uv),
        fbm(mul(angle, float2(5.486, -2.8132)) + uv));
    col -= smoothstep(0.1, 1.0, length(oldUV));

    // Darken / desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_Deterioration() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_DigitalBrain() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

// rotate position around axis
float2 rotate(float2 p, float a)
{
    return float2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
}

// 1D random numbers
float rand(float n)
{
    return frac(sin(n) * 43758.5453123);
}

// 2D random numbers
float2 rand2(float2 p)
{
    return frac(float2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));
}

// 1D noise
float noise1(float p)
{
    float fl = floor(p);
    float fc = frac(p);
    return lerp(rand(fl), rand(fl + 1.0), fc);
}

// voronoi distance noise, based on iq's articles
float voronoi(float2 x)
{
    float2 p = floor(x);
    float2 f = frac(x);

    float2 res = (float2)8.0;
    for (int j = -1; j <= 1; j++)
    {
        for (int i = -1; i <= 1; i++)
        {
            float2 b = float2(i, j);
            float2 r = b - f + rand2(p + b);

            // chebyshev distance, one of many ways to do this
            float d = max(abs(r.x), abs(r.y));

            if (d < res.x)
            {
                res.y = res.x;
                res.x = d;
            }
            else if (d < res.y)
            {
                res.y = d;
            }
        }
    }
    return res.y - res.x;
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float flicker = noise1(time * 2.0) * 0.8 + 0.4;

    float2 uv = fragCoord.xy / resolution.xy;
    uv = (uv - 0.5) * 2.0;
    float2 suv = uv;
    uv.x *= resolution.x / resolution.y;

    float v = 0.0;

    // a bit of camera movement
    uv *= 0.6 + sin(time * 0.1) * 0.4;
    uv = rotate(uv, sin(time * 0.3) * 1.0);
    uv += time * 0.4;

    // add some noise octaves
    float a = 0.6, f = 1.0;

    for (int i = 0; i < 3; i++)
    {
        float v1 = voronoi(uv * f + 5.0);
        float v2 = 0.0;

        // make the moving electrons-effect for higher octaves
        if (i > 0)
        {
            // of course everything based on voronoi
            v2 = voronoi(uv * f * 0.5 + 50.0 + time);

            float va = 1.0 - smoothstep(0.0, 0.1, v1);
            float vb = 1.0 - smoothstep(0.0, 0.08, v2);
            v += a * pow(va * (0.5 + vb), 2.0);
        }

        // make sharp edges
        v1 = 1.0 - smoothstep(0.0, 0.3, v1);

        // noise is used as intensity map
        v2 = a * (noise1(v1 * 5.5 + 0.1));

        // octave 0's intensity changes a bit
        if (i == 0)
            v += v2 * flicker;
        else
            v += v2;

        f *= 3.0;
        a *= 0.7;
    }

    // slight vignetting
    v *= exp(-0.6 * length(suv)) * 1.2;

    // use texture channel0 for color
    float3 cexp = iChannel0.Sample(samp0, uv * 0.001).xyz * 3.0 + iChannel0.Sample(samp0, uv * 0.01).xyz;
    cexp *= 1.4;

    float3 col = float3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;

    // alpha from brightness, darken/desaturate, premultiply
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);
    float al = max(col.r, max(col.g, col.b));
    return float4(col * al, al);
}

    )"
}

_Shader_Meta_DigitalBrain() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "digital_brain_i0.png"}], timeAccumulate: true}
}

_Shader_HLSL_DigitalRain() {
    return "
    (
// Digital Rain by WillKirkby
// https://www.shadertoy.com/view/ldccW4
// Converted from Shadertoy GLSL to HLSL for Alt-Tabby
// License: CC BY-NC-SA 3.0
// Y-axis: flipped (rain falls downward)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
Texture2D iChannel1 : register(t1);
SamplerState samp0 : register(s0);
SamplerState samp1 : register(s1);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// iChannel1 is 256x256
static const float2 iChannel1Res = float2(256.0, 256.0);

float text(float2 fragCoord)
{
    float2 uv = fmod(fragCoord.xy, 16.0) * 0.0625;
    float2 block = fragCoord * 0.0625 - uv;
    uv = uv * 0.8 + 0.1;
    uv += floor(iChannel1.Sample(samp1, block / iChannel1Res + time * 0.002).xy * 16.0);
    uv *= 0.0625;
    uv.x = -uv.x;
    return iChannel0.Sample(samp0, uv).r;
}

float3 rain(float2 fragCoord)
{
    fragCoord.x -= fmod(fragCoord.x, 16.0);

    float offset = sin(fragCoord.x * 15.0);
    float speed = cos(fragCoord.x * 3.0) * 0.3 + 0.7;

    float y = frac(fragCoord.y / resolution.y + time * speed + offset);
    return float3(0.1, 1.0, 0.35) / (y * 20.0);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float3 color = text(fragCoord) * rain(fragCoord);

    // Desaturate / darken
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_DigitalRain() {
    return {opacity: 0.45, iChannels: [{index: 0, file: "digital_rain_i0.png"}, {index: 1, file: "digital_rain_i1.png"}]}
}

_Shader_HLSL_DiscoInferno() {
    return "
    (
// Disco Inferno by orblivius
// Ported from https://www.shadertoy.com/view/MXdSzl
// Fork of star shine by nayk (https://shadertoy.com/view/MXdSzX)
// Cubemap iChannel0 replaced with procedural environment map

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define TAU 6.283185
#define PI 3.14159265359

#define iterations 17
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom 0.800
#define tile 0.850

#define brightness 0.0015
#define darkmatter_val 0.300
#define distfading 0.730
#define saturation_val 0.850

#define SIZE 2.8
#define RADIUS 0.5
#define INNER_FADE 0.04
#define OUTER_FADE 0.01
#define SPEED_VAL 0.21
#define BORDER 0.21

float2x2 rot2(float a) {
    float4 c = cos(a + float4(0, 11, 33, 0));
    return float2x2(c.x, c.y, c.z, c.w);
}

float3 glsl_mod(float3 x, float3 y) {
    return x - y * floor(x / y);
}

// Procedural environment map replacing cubemap iChannel0
float4 envMap(float3 dir) {
    float3 col = float3(0.2, 0.1, 0.3);
    col += 0.3 * float3(
        0.5 + 0.5 * sin(dir.x * 3.0 + time),
        0.5 + 0.5 * sin(dir.y * 3.0 + time * 1.3),
        0.5 + 0.5 * sin(dir.z * 3.0 + time * 0.7));
    return float4(col, 1.0);
}

float aafi(float2 p) {
    float fi = atan2(p.y, p.x);
    fi += step(p.y, 0.0) * TAU;
    return fi;
}

float2 lonlat(float3 p) {
    float lon = aafi(p.xy) / TAU;
    float lat = aafi(float2(p.z, length(p.xy))) / PI;
    return float2(lon, lat);
}

float3 pointOnSphere(float2 ll, float r) {
    float f1 = ll.x * TAU;
    float f2 = ll.y * PI;
    float z = r * cos(f2);
    float d = abs(r * sin(f2));
    float x = d * cos(f1);
    float y = d * sin(f1);
    return float3(x, y, z);
}

float sdDiscoBall(float3 pos, float r) {
    float2 ll = lonlat(pos);
    float n = 15.0;
    float n2 = 30.0;
    ll.x = floor(ll.x * n2);
    ll.y = floor(ll.y * n);
    float3 a = pointOnSphere(float2(ll.x / n2, ll.y / n), r);
    float3 b = pointOnSphere(float2(ll.x / n2, (ll.y + 1.0) / n), r);
    float3 c = pointOnSphere(float2((ll.x + 1.0) / n2, (ll.y + 1.0) / n), r);
    float d = dot(normalize(cross(b - a, c - a)), pos - a);
    return abs(d * 0.9);
}

float sdf(float3 pos) {
    return sdDiscoBall(pos * 0.2, 0.05);
}

float random_val(float2 p) {
    float3 p3 = frac(float3(p.x, p.y, p.x) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

float noise_val(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);
    float a = random_val(i);
    float b = random_val(i + float2(1.0, 0.0));
    float c = random_val(i + float2(0.0, 1.0));
    float d = random_val(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
}

float light_val(float2 pos, float size, float radius, float inner_fade, float outer_fade) {
    float len = length(pos / size);
    return pow(clamp(1.0 - pow(clamp(len - radius, 0.0, 1.0), 1.0 / inner_fade), 0.0, 1.0), 1.0 / outer_fade);
}

float flare(float angle, float alpha, float t) {
    float n = noise_val(float2(t + 0.5 + abs(angle) + pow(alpha, 0.6),
                               t - abs(angle) + pow(alpha + 0.1, 0.6)) * 7.0);
    float sp = 15.0 + sin(t * 2.0 + n * 4.0 + angle * 20.0 + alpha * n) * (0.8 + alpha * 0.6 * n);
    float ro = sin(angle * 20.0 + sin(angle * 15.0 + alpha * 4.0 + t * 30.0 + n * 5.0 + alpha * 4.0))
             * (0.5 + alpha * 1.5);
    float g = pow((2.0 + sin(sp + n * 1.5 * alpha + ro) * 1.4) * n * 4.0, n * (1.5 - 0.8 * alpha));
    g *= alpha * alpha * alpha * 0.5;
    g += alpha * 0.7 + g * g * g;
    return g;
}

float happy_star(float2 uv, float anim) {
    uv = abs(uv);
    float2 pos = min(uv.xy / uv.yx, anim);
    float p = 2.0 - pos.x - pos.y;
    return (2.0 + p * (p * p - 1.5)) / (uv.x + uv.y);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord - resolution * 0.5) / resolution.y;
    float f = 0.0;
    float f2 = 0.0;

    float3 dir = float3(uv * zoom, 1.0);
    float3 from_pt = float3(1.0, 0.5, 0.5);

    // Volumetric star field rendering
    float s2 = 0.1;
    float fade = 1.0;
    float3 v = (float3)0;
    [loop]
    for (int r = 0; r < volsteps; r++) {
        float3 p = from_pt + s2 * dir * 0.5;
        p = abs((float3)tile - glsl_mod(p, (float3)(tile * 2.0)));
        float pa = 0.0;
        float a = 0.0;
        [loop]
        for (int i = 0; i < iterations; i++) {
            p = abs(p) / dot(p, p) - formuparam;
            float ct = cos(time * 0.05);
            float st2 = sin(time * 0.05);
            p.xy = mul(float2x2(ct, st2, -st2, ct), p.xy);
            a += abs(length(p) - pa);
            pa = length(p);
        }
        float dm = max(0.0, darkmatter_val - a * a * 0.001);
        a *= a * a;
        if (r > 6) fade *= 1.0 - dm;
        v += fade;
        v += float3(s2, s2 * s2, s2 * s2 * s2 * s2) * a * brightness * fade;
        fade *= distfading;
        s2 += stepsize;
    }
    v = lerp((float3)length(v), v, saturation_val);
    uv *= 0.5;

    // Flare effects
    float t = time * SPEED_VAL;
    float alpha = light_val(uv, SIZE, RADIUS, INNER_FADE, OUTER_FADE);
    float angle = atan2(uv.x, uv.y);
    float l = length(uv * v.xy * 0.01);
    if (l < BORDER) {
        t *= 0.8;
        alpha = 1.0 - pow((BORDER - l) / BORDER, 0.22) * 0.7;
        alpha = clamp(alpha - light_val(uv, 0.02, 0.0, 0.3, 0.7) * 0.55, 0.0, 1.0);
        f = flare(angle, alpha, -t * 0.5 + alpha);
        f2 = flare(angle, alpha * 1.2, -t + alpha * 0.5 + 0.38134);
    }

    // Disco ball raymarching
    float3 R = float3(resolution, 1.0);
    float3 e = float3(1e-3, 0, 0);
    float3 N, D, p, q;
    D = normalize(float3(fragCoord, -18.0 * R.y) - R);
    p = float3(1.5, 0.85, 30.5);
    // Demo mode camera (no mouse)
    float3 C = 3.0 * cos(0.3 * time + float3(0, 11, 0));
    p.yz = mul(rot2(-C.y), p.yz);
    p.xz = mul(rot2(-C.x - 1.57), p.xz);
    D.yz = mul(rot2(-C.y), D.yz);
    D.xz = mul(rot2(-C.x - 1.57), D.xz);

    float4 O = (float4)1;
    q = p;
    [loop]
    while (O.x > 0.0 && t > 0.01) {
        q = p;
        t = min(t, sdf(q));
        p += 0.5 * t * D;
        O -= 0.01;
    }

    N = float3(sdf(q + e), sdf(q + e.yxy), sdf(q + e.yyx)) - t;
    if (O.x < 0.0) {
        O = 0.5 * envMap(D);
    } else {
        O += envMap(reflect(D, N / length(N)));
    }

    f = flare(angle, alpha, t) * 1.3;

    O += float4(
        f * (1.0 + sin(angle - t * 4.0) * 0.3) + f2 * f2 * f2,
        f * alpha + f2 * f2 * 2.0,
        f * alpha * 0.5 + f2 * (1.0 + sin(angle + t * 4.0) * 0.3),
        1.0);

    // Star overlay
    uv *= 2.0 * (cos(time * 2.0) - 2.5);
    float anim = sin(time * 12.0) * 0.1 + 1.0;
    O *= 0.5 * float4(happy_star(uv, anim) * float3(0.55, 0.5, 1.15), 1.0);
    O += 0.5 * float4(happy_star(uv, anim) * float3(0.55, 0.5, 1.15) * 0.01, 1.0);

    float3 color = O.rgb;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color *= 1.0 - darken;

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_DiscoInferno() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 30, timeOffsetMax: 90, timeAccumulate: true}
}

_Shader_HLSL_DomainWarpedFbmNoise() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const int octaves = 6;

float2 random2(float2 st) {
    float2 t = float2(iChannel0.Sample(samp0, st / 1023.0).x, iChannel0.Sample(samp0, st / 1023.0 + 0.5).x);
    return t * t * 4.0;
}

// Value Noise by Inigo Quilez - iq/2013
float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(lerp(dot(random2(i + float2(0.0, 0.0)), f - float2(0.0, 0.0)),
                     dot(random2(i + float2(1.0, 0.0)), f - float2(1.0, 0.0)), u.x),
                lerp(dot(random2(i + float2(0.0, 1.0)), f - float2(0.0, 1.0)),
                     dot(random2(i + float2(1.0, 1.0)), f - float2(1.0, 1.0)), u.x), u.y);
}

float fbm1(in float2 _st) {
    float v = 0.0;
    float a = 0.5;
    float2 shift = (float2)100.0;
    // Rotate to reduce axial bias
    float2x2 rot = float2x2(cos(0.5), sin(0.5),
                             -sin(0.5), cos(0.5));
    for (int i = 0; i < octaves; ++i) {
        v += a * noise(_st);
        _st = mul(rot, _st) * 2.0 + shift;
        a *= 0.4;
    }
    return v;
}

float pattern(float2 uv, float t, inout float2 q, inout float2 r) {
    q = float2(fbm1(uv * 0.1 + float2(0.0, 0.0)),
               fbm1(uv + float2(5.2, 1.3)));

    r = float2(fbm1(uv * 0.1 + 4.0 * q + float2(1.7 - t / 2.0, 9.2)),
               fbm1(uv + 4.0 * q + float2(8.3 - t / 2.0, 2.8)));

    float2 s = float2(fbm1(uv + 5.0 * r + float2(21.7 - t / 2.0, 90.2)),
                      fbm1(uv * 0.05 + 5.0 * r + float2(80.3 - t / 2.0, 20.8))) * 0.25;

    return fbm1(uv * 0.05 + 4.0 * s);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord - 0.5 * resolution.xy) / min(resolution.y, resolution.x);

    float t = time / 10.0;

    float2x2 rot = float2x2(cos(t / 10.0), sin(t / 10.0),
                             -sin(t / 10.0), cos(t / 10.0));

    uv = mul(rot, uv);
    uv *= 0.9 * sin(t) + 3.0;
    uv.x -= t / 5.0;

    float2 q = (float2)0.0;
    float2 r = (float2)0.0;

    float _pattern = pattern(uv, t, q, r);

    float3 colour = (float3)(_pattern * 2.0);
    colour.r -= dot(q, r) * 15.0;
    colour = lerp(colour, float3(pattern(r, t, q, r), dot(q, r) * 15.0, -0.1), 0.5);
    colour -= q.y * 1.5;
    colour = lerp(colour, float3(0.2, 0.2, 0.2), clamp(q.x, -1.0, 0.0) * 3.0);

    float3 col = -colour + abs(colour) * 2.0;
    float alphaOrig = 1.0 / length(q);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = saturate(alphaOrig) * max(col.r, max(col.g, col.b));
    return float4(col * saturate(alphaOrig), a);
}
    )"
}

_Shader_Meta_DomainWarpedFbmNoise() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "domain_warped_fbm_noise_i0.png"}]}
}

_Shader_HLSL_DomainWarpingLearn() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define octaves 6

float random(float2 uv) {
    return frac((sin(dot(uv.xy, float2(12.9898, 78.233)))) * 43758.5453123);
}

float noise(float2 uv) {
    float2 i = floor(uv);
    float2 f = frac(uv);

    float a = random(i);
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    float v1 = lerp(a, b, u.x);
    float v2 = lerp(c, d, u.x);
    return lerp(v1, v2, u.y);
}

float3 palette(float t) {
    float3 a = float3(0.000, 0.500, 0.500);
    float3 b = float3(0.000, 0.500, 0.500);
    float3 c = float3(0.000, 0.500, 0.333);
    float3 d = float3(0.000, 0.500, 0.667);
    return a + b * cos(6.28318 * (c * t + d));
}

float fbm(float2 uv) {
    float lacunarity = 2.0;
    float gain = 0.5;

    float amplitude = 0.5;
    float frequency = 1.0;

    float result = 0.0;

    for (int i = 0; i < octaves; i++) {
        result += amplitude * noise(frequency * uv);
        frequency *= lacunarity;
        amplitude *= gain;
    }
    return result;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord.xy - resolution.xy * 0.5) / resolution.y * 10.0;

    float uvt = sin(length(uv) - time);
    float2 uv2 = uv * fbm(uv) * uvt;

    float3 col = palette(fbm(uv2));

    // Apply darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_DomainWarpingLearn() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_DomainWarpingOil() {
    return "
    (
// Domain Warping: Oil — converted from Shadertoy (4sBfDw)
// Author: zaiyugi — License: CC BY-NC-SA 3.0
// Based on domain warping article by iq: https://iquilezles.org/articles/warp/warp.htm
// Simplex noise by Ian McEwan, Ashima Arts (MIT License)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define M_PI 3.14159265359

float3 mod289_3(float3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float4 mod289_4(float4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float4 permute(float4 x) {
    return mod289_4(((x * 34.0) + 1.0) * x);
}

float4 taylorInvSqrt(float4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(float3 v) {
    const float2 C = float2(1.0 / 6.0, 1.0 / 3.0);
    const float4 D = float4(0.0, 0.5, 1.0, 2.0);

    // First corner
    float3 i = floor(v + dot(v, C.yyy));
    float3 x0 = v - i + dot(i, C.xxx);

    // Other corners
    float3 g = step(x0.yzx, x0.xyz);
    float3 l = 1.0 - g;
    float3 i1 = min(g.xyz, l.zxy);
    float3 i2 = max(g.xyz, l.zxy);

    float3 x1 = x0 - i1 + C.xxx;
    float3 x2 = x0 - i2 + C.yyy;
    float3 x3 = x0 - D.yyy;

    // Permutations
    i = mod289_3(i);
    float4 p = permute(permute(permute(
        i.z + float4(0.0, i1.z, i2.z, 1.0))
        + i.y + float4(0.0, i1.y, i2.y, 1.0))
        + i.x + float4(0.0, i1.x, i2.x, 1.0));

    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    float n_ = 0.142857142857; // 1.0/7.0
    float3 ns = n_ * D.wyz - D.xzx;

    float4 j = p - 49.0 * floor(p * ns.z * ns.z);

    float4 x_ = floor(j * ns.z);
    float4 y_ = floor(j - 7.0 * x_);

    float4 x = x_ * ns.x + ns.yyyy;
    float4 y = y_ * ns.x + ns.yyyy;
    float4 h = 1.0 - abs(x) - abs(y);

    float4 b0 = float4(x.xy, y.xy);
    float4 b1 = float4(x.zw, y.zw);

    float4 s0 = floor(b0) * 2.0 + 1.0;
    float4 s1 = floor(b1) * 2.0 + 1.0;
    float4 sh = -step(h, (float4)0.0);

    float4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    float4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    float3 p0 = float3(a0.xy, h.x);
    float3 p1 = float3(a0.zw, h.y);
    float3 p2 = float3(a1.xy, h.z);
    float3 p3 = float3(a1.zw, h.w);

    // Normalise gradients
    float4 norm = taylorInvSqrt(float4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    // Mix final noise value
    float4 m = max(0.6 - float4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m * m, float4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
}

float fbm4(float3 p, float theta, float f, float lac, float r) {
    float3x3 mtx = float3x3(
        cos(theta), -sin(theta), 0.0,
        sin(theta),  cos(theta), 0.0,
        0.0,         0.0,        1.0);

    float lacunarity = lac;
    float roughness = r;
    float amp = 1.0;
    float total_amp = 0.0;

    float accum = 0.0;
    float3 X = p * f;
    for (int i = 0; i < 4; i++) {
        accum += amp * snoise(X);
        X *= (lacunarity + (snoise(X) + 0.1) * 0.006);
        X = mul(X, mtx);

        total_amp += amp;
        amp *= roughness;
    }

    return accum / total_amp;
}

float fbm8(float3 p, float theta, float f, float lac, float r) {
    float3x3 mtx = float3x3(
        cos(theta), -sin(theta), 0.0,
        sin(theta),  cos(theta), 0.0,
        0.0,         0.0,        1.0);

    float lacunarity = lac;
    float roughness = r;
    float amp = 1.0;
    float total_amp = 0.0;

    float accum = 0.0;
    float3 X = p * f;
    for (int i = 0; i < 8; i++) {
        accum += amp * snoise(X);
        X *= (lacunarity + (snoise(X) + 0.1) * 0.006);
        X = mul(X, mtx);

        total_amp += amp;
        amp *= roughness;
    }

    return accum / total_amp;
}

float turbulence(float val) {
    float n = 1.0 - abs(val);
    return n * n;
}

float pattern(in float3 p, inout float3 q, inout float3 r) {
    q.x = fbm4(p + 0.0, 0.0, 1.0, 2.0, 0.33);
    q.y = fbm4(p + 6.0, 0.0, 1.0, 2.0, 0.33);

    r.x = fbm8(p + q - 2.4, 0.0, 1.0, 3.0, 0.5);
    r.y = fbm8(p + q + 8.2, 0.0, 1.0, 3.0, 0.5);

    q.x = turbulence(q.x);
    q.y = turbulence(q.y);

    float f = fbm4(p + (1.0 * r), 0.0, 1.0, 2.0, 0.5);

    return f;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 st = fragCoord.xy / resolution.xy;
    float aspect = resolution.x / resolution.y;
    st.x *= aspect;

    float2 uv = st;

    float t = time * 0.1;

    float3 spectrum0 = float3(0.94, 0.02, 0.03);
    float3 spectrum1 = float3(0.04, 0.04, 0.22);
    float3 spectrum2 = float3(1.00, 0.80, 1.00);
    float3 spectrum3 = float3(0.20, 0.40, 0.50);

    uv -= 0.5;
    uv *= 3.5;

    float3 p = float3(uv.x, uv.y, t);
    float3 q = (float3)0.0;
    float3 r = (float3)0.0;
    float f = pattern(p, q, r);

    float3 color = (float3)0.0;
    color = lerp(spectrum1, spectrum3, pow(length(q), 4.0));
    color = lerp(color, spectrum0, pow(length(r), 1.4));
    color = lerp(color, spectrum2, f);

    color = pow(color, (float3)2.0);

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_DomainWarpingOil() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 20, timeOffsetMax: 80, timeAccumulate: true}
}

_Shader_HLSL_DomainWarpingTest() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define NUM_OCTAVES 5

static const float3 baseColor = float3(0, 0.745, 0.9);

float random(float2 st)
{
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

float noise(float2 st)
{
    float2 i = floor(st);
    float2 f = frac(st);

    float a = random(i + float2(0.0, 0.0));
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float fbm(float2 st)
{
    float v = 0.0;
    float a = 0.5;

    for (int i = 0; i < NUM_OCTAVES; i++)
    {
        v += a * noise(st);
        st = st * 2.0;
        a *= 0.5;
    }

    return v;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 st = fragCoord / resolution.xy;

    float2 q = float2(0.0, 0.0);
    q.x = fbm(st + float2(0.0, 0.0));
    q.y = fbm(st + float2(1.0, 1.0));

    float2 r = float2(0.0, 0.0);
    r.x = fbm(st + (1.0 * q) + float2(1.7, 9.2) + (0.15 * time));
    r.y = fbm(st + (1.0 * q) + float2(8.3, 2.8) + (0.12 * time));

    float f = fbm(st + r);

    float coef = (f * f * f + (0.6 * f * f) + (0.5 * f));

    float3 col = coef * baseColor;

    // Apply darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_DomainWarpingTest() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_DrawCircle() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float3 drawCircle(float2 pos, float radius, float width, float power, float4 color)
{
    float dist1 = length(pos);
    dist1 = frac((dist1 * 5.0) - frac(time));
    float dist2 = dist1 - radius;
    float intensity = pow(radius / abs(dist2), width);
    float3 col = color.rgb * intensity * power * max((0.8 - abs(dist2)), 0.0);
    return col;
}

float3 hsv2rgb(float h, float s, float v)
{
    float4 t = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(float3(h, h, h) + t.xyz) * 6.0 - float3(t.w, t.w, t.w));
    return v * lerp(float3(t.x, t.x, t.x), clamp(p - float3(t.x, t.x, t.x), 0.0, 1.0), s);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // -1.0 ~ 1.0
    float2 pos = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);

    float h = lerp(0.5, 0.65, length(pos));
    float4 color = float4(hsv2rgb(h, 1.0, 1.0), 1.0);
    float radius = 0.5;
    float width = 0.8;
    float power = 0.1;
    float3 finalColor = drawCircle(pos, radius, width, power, color);

    // Apply darken/desaturate
    float lum = dot(finalColor, float3(0.299, 0.587, 0.114));
    finalColor = lerp(finalColor, float3(lum, lum, lum), desaturate);
    finalColor = finalColor * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(finalColor.r, max(finalColor.g, finalColor.b));
    return float4(finalColor * a, a);
}

    )"
}

_Shader_Meta_DrawCircle() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_DriftingWaves() {
    return "
    (
// Drifting Waves — based on https://www.shadertoy.com/view/WXjcWK
// Original by panna_pudi
// Water technique by Tater (https://www.shadertoy.com/view/NlKGWK)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// --- Constants ---

static const float PI = 3.14159265359;

static const int MAT_WAVE = 2;
static const float MDIST = 60.0;
static const int ITERS_TRACE = 9;
static const int ITERS_NORM = 20;

static const float SCRL_SPEED = 1.5;
static const float2 SCRL_DIR = float2(1.0, 1.2);
static const float HOR_SCALE = 1.1;
static const float FREQ_SCALE = 1.28;
static const float TIME_SCALE = 1.095;
static const float WEIGHT_SCALE = 0.8;
static const float DRAG = 0.9;
static const float HEIGHT_DIV = 2.3;

static const float WAVE_ROT_ANGLE = 6.21;
// Same constructor args as GLSL for mul(v, m) pattern
static const float2x2 WAVE_ROT = float2x2(
    cos(WAVE_ROT_ANGLE), -sin(WAVE_ROT_ANGLE),
    sin(WAVE_ROT_ANGLE), cos(WAVE_ROT_ANGLE));
static const float WAVE_FREQ = 0.6;
static const float OCC_SPEED = 1.4;
static const float DX_DET = 0.65;

static const float2 sunrot_val = float2(-0.3, 0.10);

// --- Utilities (from Common) ---

// Rotation matrix — same constructor args as GLSL for mul(v, m) pattern
float2x2 rot(float a) {
    float c = cos(a), s = sin(a);
    return float2x2(c, -s, s, c);
}

float sd_plane(float3 p, float3 off, float3 n) { return dot(p - off, n); }

float luminance(float3 col) { return dot(col, float3(0.2126729, 0.7151522, 0.0721750)); }
float3 ReinhardExtLuma(float3 col, const float w) {
    float l = luminance(col);
    float n = l * (1.0 + l / (w * w));
    float ln = n / (1.0 + l);
    return col * ln / l;
}

// --- Hit struct ---

struct Hit {
    float t;
    float d;
    int mat;
};

Hit hit_default() { Hit h = { 0.001, 1e9, -1 }; return h; }
Hit hit_init(float dist, int mat) { Hit h = { 0.001, dist, mat }; return h; }
Hit hit_init(float t, float dist, int mat) { Hit h = { t, dist, mat }; return h; }
Hit _min(Hit a, Hit b) {
    if (a.d < b.d) return a;
    return b;
}

// --- Wave functions ---

float2 sd_wave_diff(float2 wave_pos, int iter_num, float t) {
    float2 res = (float2)0;
    float2 wave_dir = float2(1.0, 0.0);
    float wave_weight = 1.0;
    wave_pos += t * SCRL_SPEED * SCRL_DIR;
    wave_pos *= HOR_SCALE;
    float wave_freq = WAVE_FREQ;
    float wave_time = OCC_SPEED * t;
    for (int i = 0; i < iter_num; ++i) {
        wave_dir = mul(wave_dir, WAVE_ROT);
        float x = dot(wave_dir, wave_pos) * wave_freq + wave_time;
        float dx = exp(sin(x) - 1.0) * cos(x) * wave_weight;
        res += dx * wave_dir / pow(wave_weight, DX_DET);

        wave_freq *= FREQ_SCALE;
        wave_time *= TIME_SCALE;
        wave_pos -= wave_dir * dx * DRAG;
        wave_weight *= WEIGHT_SCALE;
    }

    float wave_sum = -(pow(WEIGHT_SCALE, (float)iter_num) - 1.0) * HEIGHT_DIV;
    return res / pow(wave_sum, 1.0 - DX_DET);
}

float3 sd_wave_normal(float3 p, float t) {
    float2 wavedx = -sd_wave_diff(p.xz, ITERS_NORM, t);
    return normalize(float3(wavedx.x, 1.0, wavedx.y));
}

float sd_wave(float2 wave_pos, int iter_num, float t) {
    float res = 0.0;
    float2 wave_dir = float2(1.0, 0.0);
    float wave_weight = 1.0;
    wave_pos += t * SCRL_SPEED * SCRL_DIR;
    wave_pos *= HOR_SCALE;
    float wave_freq = WAVE_FREQ;
    float wave_time = OCC_SPEED * t;
    for (int i = 0; i < iter_num; ++i) {
        wave_dir = mul(wave_dir, WAVE_ROT);
        float x = dot(wave_dir, wave_pos) * wave_freq + wave_time;
        float wave = exp(sin(x) - 1.0) * wave_weight;
        res += wave;

        wave_freq *= FREQ_SCALE;
        wave_time *= TIME_SCALE;
        wave_pos -= wave_dir * wave * DRAG * cos(x);
        wave_weight *= WEIGHT_SCALE;
    }

    float wave_sum = -(pow(WEIGHT_SCALE, (float)iter_num) - 1.0) * HEIGHT_DIV;
    return res / wave_sum;
}

// --- Scene ---

Hit map(float3 p) {
    float t = time * 0.8 + 50.0;
    Hit hit = hit_default();

    float wave = sd_wave(p.xz, ITERS_TRACE, t);
    float plane = sd_plane(p, (float3)0, float3(0.0, 1.0, 0.0));
    hit = _min(hit, hit_init(plane - wave, 2));

    return hit;
}

float3 get_norm(float3 p, Hit hit, float t) {
    if (hit.mat == MAT_WAVE) {
        return sd_wave_normal(p, t);
    } else {
        static const float3 e = float3(0.0001, 0, 0);
        float3 grad = float3(
            map(p - e.xyz).d,
            map(p - e.yxz).d,
            map(p - e.yzx).d);
        return normalize(hit.d - grad);
    }
}

Hit trace(float3 ro, float3 rd) {
    float t = 0.0;
    for (int i = 0; i < 60; ++i) {
        float3 pos = ro + rd * t;
        Hit hit = map(pos);
        float d = hit.d;
        if (d < 0.001) {
            return hit_init(t, d, hit.mat);
        }
        t += d;
        if (t > MDIST) {
            break;
        }
    }
    return hit_init(t, 1e9, -1);
}

float3x3 get_cam(float3 eye, float3 target) {
    float3 frw = normalize(target - eye);
    float3 up = normalize(cross(frw, float3(0.0, 1.0, 0.0)));
    float3 side = cross(frw, up);
    // GLSL mat3(col0, col1, col2) is column-major;
    // HLSL float3x3(row0, row1, row2) is row-major — transpose for mul(m, v)
    return transpose(float3x3(up, frw, side));
}

// --- Palette / Sky ---

float3 pal(float pt, float3 a, float3 b, float3 c, float3 d) {
    return a + b * cos(2.0 * PI * (c * pt + d));
}
float3 spc(float n, float bright) {
    return pal(n, (float3)bright, (float3)0.5, (float3)1.0, float3(0.0, 0.33, 0.67));
}

float3 sky(float3 rd) {
    float rad = 0.075;
    float3 col = (float3)0;

    float sky_palette = 0.08;
    rd.yz = mul(rd.yz, rot(sunrot_val.y));
    rd.xz = mul(rd.xz, rot(sunrot_val.x));
    float px = min(fwidth(rd).x, fwidth(rd).y);
    float sFade = px * 2.0;
    float zFade = rd.z * 0.5 + 0.5;

    float3 sc = spc(sky_palette - 0.1, 0.6) * 0.85;
    float a = length(rd.xy);
    float3 sun = smoothstep(a - px - sFade, a + px + sFade, rad) * sc * zFade * 3.0;
    col += sun;
    col += rad / (rad + pow(a, 1.7)) * sc * zFade;
    col = col + lerp(col, spc(sky_palette + 0.1, 0.8), saturate(1.0 - length(col))) * 0.03;

    col *= 2.0;

    return col;
}

// --- Render ---

float3 render(float2 fragCoord) {
    float2 uv = (fragCoord / resolution - 0.5) *
                float2(resolution.x / resolution.y, 1.0);

    float t = time * 0.8 + 50.0;

    float3 ro = float3(4.84, 6.94, 2.64);
    float3x3 cam = get_cam(ro, ro + float3(-0.97, 3.7, 1.2));
    float3 rd = normalize(mul(cam, float3(uv, 1.0)));

    float3 col = float3(0.96, 0.95, 0.9) * 0.2;

    float3 sky_col = sky(rd);
    Hit hit = trace(ro, rd);
    if (hit.mat > 0) {
        float3 pos = ro + rd * hit.t;
        float3 normal = get_norm(pos, hit, t);

        float3 rfl = reflect(rd, normal);
        rfl.y = abs(rfl.y);
        float fres = clamp(pow(1.0 - max(0.0, dot(-normal, rd)), 5.0), 0.0, 1.0);
        col += sky(rfl) * fres * 0.9;

        float3 water_col = saturate(saturate(spc(0.46, 0.4)) * 0.05 * pow(min(pos.y + 0.5, 1.8), 4.0) *
                            length(sky_col) * (rd.z * 0.3 + 0.7));
        col += water_col * 0.35;

        col = lerp(col, sky_col, saturate(1.0 - exp(-hit.t / MDIST * 2.5)));
    } else {
        col = sky_col;
    }

    col = ReinhardExtLuma(col, 1.5);
    col = pow(col, (float3)1.1);
    return col;
}

// --- Entry point (no AA for performance) ---

float4 PSMain(PSInput input) : SV_Target {
    // Y-flip: ocean/sky scene has up/down orientation
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float3 color = render(fragCoord);

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float outA = max(color.r, max(color.g, color.b));
    return float4(color * outA, outA);
}

    )"
}

_Shader_Meta_DriftingWaves() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 30, timeOffsetMax: 90, timeAccumulate: true}
}

_Shader_HLSL_DuneSandworm() {
    return "
    (
// Dune (Sand Worm) — dean_the_coder
// https://www.shadertoy.com/view/7stGRj
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define R float3(resolution, 1.0)
#define NM normalize
#define Z0 min(time, 0.0)
#define sat(x) saturate(x)
#define S01(a) smoothstep(0.0, 1.0, a)
#define S(a, b, c) smoothstep(a, b, c)

float glsl_mod(float x, float y) { return x - y * floor(x / y); }

static float t;

struct Hit {
    float d;
    int id;
    float3 uv;
};

Hit makeHit(float d, int id, float3 uv) {
    Hit result; result.d = d; result.id = id; result.uv = uv;
    return result;
}

#define minH(a, b, c) { float h_ = a; if (h_ < h.d) h = makeHit(h_, b, c); }

float n31(float3 p) {
    const float3 s = float3(7, 157, 113);
    float3 ip = floor(p);
    p = frac(p);
    p = p * p * (3.0 - 2.0 * p);
    float4 h = float4(0, s.yz, s.y + s.z) + dot(ip, s);
    h = lerp(frac(sin(h) * 43758.545), frac(sin(h + s.x) * 43758.545), p.x);
    h.xy = lerp(h.xz, h.yw, p.y);
    return lerp(h.x, h.y, p.z);
}

float n21(float2 p) { return n31(float3(p, 1)); }

float smin(float a, float b, float k) {
    float h = sat(0.5 + 0.5 * (b - a) / k);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

float box(float3 p, float3 b) { return length(max(abs(p) - b, (float3)0)); }

float cap(float3 p, float2 h) {
    p.y -= clamp(p.y, 0.0, h.x);
    return length(p) - h.y;
}

Hit map(float3 p) {
    float d, e, g, lp, r, rz,
          f = S(0.0, 5.0, t),
          n = n31(p * 4.0);
    d = n21(p.xz * 0.1) * 3.0 + p.y + 2.5;
    g = smin(d, length(p - float3(0.2, -8.6, 12.6)) - 6.0 + 0.01 * (0.5 + 0.5 * sin(p.y * 22.0)), 1.0);
    p += float3(0.5 + sin(t * 0.6) * 0.2 + 0.6 * sin(p.z * 0.4 - 0.66),
                1.0 - cos(p.z * 0.3 - 0.3 - f * lerp(0.8, 1.0, S01(sin(t * 1.4) * 0.5 + 0.5))) * 1.8,
                S(28.0, 30.0, t) * 2.5 - lerp(6.0, 2.8, f));
    r = 0.8 + smin(p.z * 0.18, 2.0, 0.5) + abs(sin(p.z * 2.0) * S01(p.z) * 0.05);
    r *= S(-5.3 + 2.75 * cos(t * 0.8) * f, 1.4, p.z);
    lp = length(p.xy);
    f = abs(lp - r - 0.05) - 0.03;
    r *= S(2.5, 0.35 + sin(t) * 0.1, p.z);
    d = max(abs(lp - r) - 0.02, 0.4 - p.z);
    p.xy = float2(frac(atan2(p.y, p.x) * 0.477) - 0.5, lp);
    p.y -= r;
    Hit h = makeHit(min(d, box(p, float3(0.2 + p.z * 0.77, 0.02, 0.4))), 2, p);
    p.y += 0.13;
    float2 v2 = float2(0.1, sat(0.07 * p.y));
    p.z -= 0.4;
    rz = glsl_mod(p.z, 0.3) - 0.15;
    e = max(min(cap(float3(glsl_mod(p.x, 0.08333) - 0.04167, p.y, rz), v2),
                cap(float3(glsl_mod(p.x + 0.04167, 0.08333) - 0.04167, p.y, rz - 0.15), v2)),
            -0.05 - p.z * 0.2);
    d = abs(p.x) - p.z * 0.5 - 0.5;
    minH(max(e, d), 4, p);
    f = max(f, d - 0.05);
    minH(f, 3, p);
    g = smin(g, h.d, 0.4 + 0.4 * n * S(1.0, 0.0, abs(g - f)));
    minH(g, 1, p);
    return h;
}

float3 N(float3 p, float nt) {
    float h = nt * 0.4;
    float3 n = (float3)0;
    for (int i = 0; i < 4; i++) {
        float3 e = 0.005773 * (2.0 * float3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.0);
        n += e * map(p + e * h).d;
    }
    return NM(n);
}

float shadow(float3 p, float3 lp) {
    float d, s = 1.0, st = 0.1, mxt = length(p - lp);
    float3 ld = NM(lp - p);
    for (float i = Z0; i < 40.0; i++) {
        d = map(st * ld + p).d;
        s = min(s, 15.0 * d / st);
        st += max(0.1, d);
        if (mxt - st < 0.5 || s < 0.001) break;
    }
    return S01(s);
}

float ao(float3 p, float3 n, float h) { return map(h * n + p).d / h; }

float fog(float3 v) { return exp(dot(v, v) * -0.001); }

float3 lights(float3 p, float3 rd, float d, Hit h) {
    float3 ld = NM(float3(6, 3, -10) - p);
    float3 n = N(p, d);
    float3 c;
    float spe = 1.0;
    if (h.id == 3) {
        c = float3(0.4, 0.35, 0.3);
        n.y += n31(h.uv * 10.0);
        n = NM(n);
    }
    else if (h.id == 2) c = lerp(float3(0.16, 0.08, 0.07), (float3)0.6, pow(n31(h.uv * 10.0), 3.0));
    else if (h.id == 4) c = float3(0.6, 1, 4);
    else {
        spe = 0.1;
        c = (float3)0.6;
        n.x += sin((p.x + p.z * n.z) * 8.0) * 0.1;
        n = NM(n);
    }
    float ao_val = lerp(ao(p, n, 0.2), ao(p, n, 2.0), 0.7);
    float diff = sat(0.1 + 0.9 * dot(ld, n));
    float shad = 0.1 + 0.9 * shadow(p, float3(6, 3, -10));
    float ao_fac = 0.3 + 0.7 * ao_val;
    float rim = sat(0.1 + 0.9 * dot(ld * float3(-1, 0, -1), n)) * 0.3;
    float spec = pow(sat(dot(rd, reflect(ld, n))), 10.0) * spe;
    float3 lightCol = float3(1.85, 0.5, 0.08);
    float3 lit = (diff * shad * ao_fac + (rim + spec) * ao_val) * c * lightCol;
    return lerp(lit, lightCol, S(0.7, 1.0, 1.0 + dot(rd, n)) * 0.1);
}

float4 march(inout float3 p, float3 rd, float s, float mx) {
    float i, d = 0.01;
    Hit h;
    for (i = Z0; i < s; i++) {
        h = map(p);
        if (abs(h.d) < 0.0015) break;
        d += h.d;
        if (d > mx) return (float4)0;
        p += h.d * rd;
    }
    return float4(lights(p, rd, d, h), h.id);
}

float3 scene(float3 rd) {
    t = glsl_mod(time, 30.0);
    float3 c;
    float3 p = (float3)0;
    float4 col = march(p, rd, 180.0, 64.0);
    float f = 1.0, x = n31(rd + float3(-t * 2.0, -t * 0.4, t));
    if (col.w == 0.0) c = lerp(float3(0.5145, 0.147, 0.0315), float3(0.22, 0.06, 0.01), sat(rd.y * 3.0));
    else {
        c = col.rgb;
        f = fog(p * (0.7 + 0.3 * x));
    }
    f *= 1.0 - x * x * x * 0.4;
    return lerp(float3(0.49, 0.14, 0.03), c, sat(f));
}

float4 PSMain(PSInput input) : SV_Target {
    // Y-flip: scene has sky above, desert below
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 fc = fragCoord;
    float2 uv = (fc - 0.5 * R.xy) / R.y;
    float2 q = fc.xy / R.xy;
    float3 r = NM(cross(float3(0, 1, 0), float3(0, 0, 1)));
    float3 col = scene(NM(float3(0, 0, 1) + r * uv.x + cross(float3(0, 0, 1), r) * uv.y));
    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);

    // Gamma + fade-in/out (from rgba macro)
    float3 color = pow(max((float3)0, col), (float3)0.45) * sat(t) * sat(30.0 - t);

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_DuneSandworm() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 0, timeOffsetMax: 25, timeAccumulate: false}
}

_Shader_HLSL_EnterTheMatrix() {
    return "
    (
// Enter The Matrix — kishimisu (Shadertoy cl3XRX)
// CC BY-NC-SA 4.0
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 u = input.pos.xy;

    float M = 0.0;
    float A = 0.0;
    float T = time;
    float R = 0.0;

    float4 I = (float4)0;

    for (; R < 66.0; R += 1.0) {
        float4 X = float4(resolution.x, resolution.y, resolution.y, resolution.y);

        // Build rotation matrix from cos(A*sin(T*.1)*.3 + vec4(0,33,11,0))
        float4 angles = A * sin(T * 0.1) * 0.3 + float4(0.0, 33.0, 11.0, 0.0);
        float4 c = cos(angles);
        float2x2 rot = float2x2(c.x, c.y, c.z, c.w);

        float2 centered = u + u - X.xy;
        float2 rotated = mul(centered, rot);

        float4 p = A * normalize(float4(rotated, X.y, 0.0));
        p.z += T;
        p.y = abs(abs(p.y) - 1.0);

        // Random noise via ceil + sin + fract
        X = ceil(p * 4.0);
        X = frac(dot(X, sin(X)) + X);
        X.g += 4.0;

        // Texture lookup for character mask
        float2 texUV = (p.xz + ceil(T + X.x)) / 4.0;
        float texA = iChannel0.Sample(samp0, texUV).a;
        M = 4.0 * pow(smoothstep(1.0, 0.5, texA), 8.0) - 5.0;

        A += p.y * 0.6 - (M + A + A + 3.0) / 67.0;

        I += (X.a + 0.5) * (X + A) * (1.4 - p.y) / 2e2 / M / M / exp(A * 0.1);
    }

    float3 col = I.rgb;

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_EnterTheMatrix() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "enter_the_matrix_i0.png"}], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_ExitTheMatrix() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static float det = 0.001, t, boxhit;
static float3 adv, boxp;
static float2 gFragCoord;

float2 glsl_mod(float2 x, float2 y) { return x - y * floor(x / y); }
float glsl_mod(float x, float y) { return x - y * floor(x / y); }

float hash(float2 p) {
    float3 p3 = frac(float3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

float2x2 rot(float a) {
    float s = sin(a), c = cos(a);
    return float2x2(c, s, -s, c);
}

float3 path(float t) {
    float3 p = float3(float2(sin(t * 0.1), cos(t * 0.05)) * 10.0, t);
    p.x += smoothstep(0.0, 0.5, abs(0.5 - frac(t * 0.02))) * 10.0;
    return p;
}

float fractal(float2 p) {
    p = abs(5.0 - glsl_mod(p * 0.2, (float2)10.0)) - 5.0;
    float ot = 1000.0;
    for (int i = 0; i < 7; i++) {
        p = abs(p) / clamp(p.x * p.y, 0.25, 2.0) - 1.0;
        if (i > 0)
            ot = min(ot, abs(p.x) + 0.7 * frac(abs(p.y) * 0.05 + t * 0.05 + (float)i * 0.3));
    }
    ot = exp(-10.0 * ot);
    return ot;
}

float box(float3 p, float3 l) {
    float3 c = abs(p) - l;
    return length(max((float3)0, c)) + min(0.0, max(c.x, max(c.y, c.z)));
}

float de(float3 p) {
    boxhit = 0.0;
    float3 p2 = p - adv;
    p2.xz = mul(rot(t * 0.2), p2.xz);
    p2.xy = mul(rot(t * 0.1), p2.xy);
    p2.yz = mul(rot(t * 0.15), p2.yz);
    float b = box(p2, (float3)1.0);
    p.xy -= path(p.z).xy;
    float s = sign(p.y);
    p.y = -abs(p.y) - 3.0;
    p.z = glsl_mod(p.z, 20.0) - 10.0;
    for (int i = 0; i < 5; i++) {
        p = abs(p) - 1.0;
        p.xz = mul(rot(radians(s * -45.0)), p.xz);
        p.yz = mul(rot(radians(90.0)), p.yz);
    }
    float f = -box(p, float3(5.0, 5.0, 10.0));
    float d = min(f, b);
    if (d == b) {
        boxp = p2;
        boxhit = 1.0;
    }
    return d * 0.7;
}

float3 march(float3 from, float3 dir) {
    float3 p;
    float3 g = (float3)0;
    float d, td = 0.0;
    for (int i = 0; i < 80; i++) {
        p = from + td * dir;
        d = de(p) * (1.0 - hash(gFragCoord + t) * 0.3);
        if (d < det && boxhit < 0.5) break;
        td += max(det, abs(d));
        float f = fractal(p.xy) + fractal(p.xz) + fractal(p.yz);
        float b = fractal(boxp.xy) + fractal(boxp.xz) + fractal(boxp.yz);
        float3 colf = float3(f * f, f, f * f * f);
        float3 colb = float3(b + 0.1, b * b + 0.05, 0.0);
        g += colf / (3.0 + d * d * 2.0) * exp(-0.0015 * td * td) * step(5.0, td) / 2.0 * (1.0 - boxhit);
        g += colb / (10.0 + d * d * 20.0) * boxhit * 0.5;
    }
    return g;
}

float3x3 lookat(float3 d, float3 up) {
    d = normalize(d);
    float3 rt = normalize(cross(d, normalize(up)));
    return float3x3(rt, cross(rt, d), d);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    gFragCoord = fragCoord;
    float2 uv = (fragCoord - resolution * 0.5) / resolution.y;
    t = time * 7.0;
    float3 from = path(t);
    adv = path(t + 6.0 + sin(t * 0.1) * 3.0);
    float3 dir = normalize(float3(uv, 0.7));
    dir = mul(dir, lookat(adv - from, float3(0.0, 1.0, 0.0)));
    float3 col = march(from, dir);

    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_ExitTheMatrix() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 40, timeOffsetMax: 120, timeAccumulate: true}
}

_Shader_HLSL_ExplosiveTurbulentNoise() {
    return "
    (
// Explosive Turbulent Noise by OctopusX
// Ported from https://www.shadertoy.com/view/3lsSR7
// FBM with domain warping, billowed noise

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define UVScale 0.4
#define Speed 0.6

#define FBM_WarpPrimary  -0.24
#define FBM_WarpSecond    0.29
#define FBM_WarpPersist   0.78
#define FBM_EvalPersist   0.62
#define FBM_Persistence   0.5
#define FBM_Lacunarity    2.2
#define FBM_Octaves       5

// Fork from Dave Hoskins - https://www.shadertoy.com/view/4djSRW
float4 hash43(float3 p) {
    float4 p4 = frac(p.xyzx * float4(1031.0, 0.1030, 0.0973, 0.1099));
    p4 += dot(p4, p4.wzxy + 19.19);
    return -1.0 + 2.0 * frac(float4(
        (p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y,
        (p4.y + p4.z) * p4.w, (p4.z + p4.w) * p4.x));
}

// Offsets for noise
static const float3 nbs[8] = {
    float3(0, 0, 0), float3(0, 1, 0), float3(1, 0, 0), float3(1, 1, 0),
    float3(0, 0, 1), float3(0, 1, 1), float3(1, 0, 1), float3(1, 1, 1)
};

// Value simplex noise - forked from https://www.shadertoy.com/view/XltXRH
float4 AchNoise3D(float3 x) {
    float3 p = floor(x);
    float3 fr = smoothstep(0.0, 1.0, frac(x));
    float4 L1C1 = lerp(hash43(p + nbs[0]), hash43(p + nbs[2]), fr.x);
    float4 L1C2 = lerp(hash43(p + nbs[1]), hash43(p + nbs[3]), fr.x);
    float4 L1C3 = lerp(hash43(p + nbs[4]), hash43(p + nbs[6]), fr.x);
    float4 L1C4 = lerp(hash43(p + nbs[5]), hash43(p + nbs[7]), fr.x);
    float4 L2C1 = lerp(L1C1, L1C2, fr.y);
    float4 L2C2 = lerp(L1C3, L1C4, fr.y);
    return lerp(L2C1, L2C2, fr.z);
}

float4 ValueSimplex3D(float3 p) {
    float4 a = AchNoise3D(p);
    float4 b = AchNoise3D(p + 120.5);
    return (a + b) * 0.5;
}

float4 FBM(float3 p) {
    float4 f = (float4)0, s = (float4)0, n = (float4)0;
    float a = 1.0, w = 0.0;
    [loop]
    for (int i = 0; i < FBM_Octaves; i++) {
        n = ValueSimplex3D(p);
        f += abs(n) * a;
        s += n.zwxy * a;
        a *= FBM_Persistence;
        w *= FBM_WarpPersist;
        p *= FBM_Lacunarity;
        p += n.xyz * FBM_WarpPrimary * w;
        p += s.xyz * FBM_WarpSecond;
        p.z *= FBM_EvalPersist + (f.w * 0.5 + 0.5) * 0.015;
    }
    return f;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float aspect = resolution.x / resolution.y;
    float2 uv = fragCoord / (resolution / UVScale * 0.1);
    uv.x *= aspect;

    float4 fbm_val = FBM(float3(uv, time * Speed + 100.0));
    float explosionGrad = dot(fbm_val.xyzw, fbm_val.yxwx) * 0.5;
    explosionGrad = pow(explosionGrad, 1.3);
    explosionGrad = smoothstep(0.0, 1.0, explosionGrad);

    float3 color0 = float3(1.2, 0.0, 0.0);
    float3 color1 = float3(0.9, 0.7, 0.3);

    float3 color = explosionGrad * lerp(color0, color1, explosionGrad) * 1.2 + 0.05;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color *= 1.0 - darken;

    // Alpha from brightness, premultiply
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_ExplosiveTurbulentNoise() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_FakingGoldAndMurder() {
    return "
    (
// Faking Gold and Murder
//  Converted from Shadertoy: https://www.shadertoy.com/view/4tSGW3
//  Author: denzen
//  Simplex noise: Ashima Arts (MIT License)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

/* ~~~ Ashima Simplex Noise ~~~ */

float3 mod289_3(float3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float2 mod289_2(float2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float3 permute(float3 x) {
    return mod289_3(((x * 34.0) + 1.0) * x);
}

float snoise(float2 v) {
    const float4 C = float4(0.211324865405187,
                            0.366025403784439,
                           -0.577350269189626,
                            0.024390243902439);
    // First corner
    float2 i  = floor(v + dot(v, C.yy));
    float2 x0 = v -   i + dot(i, C.xx);

    // Other corners
    float2 i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;

    // Permutations
    i = mod289_2(i);
    float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0))
                                    + i.x + float3(0.0, i1.x, 1.0));

    float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
    m = m * m;
    m = m * m;

    // Gradients
    float3 x_ = 2.0 * frac(p * C.www) - 1.0;
    float3 h = abs(x_) - 0.5;
    float3 ox = floor(x_ + 0.5);
    float3 a0 = x_ - ox;

    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

    float3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

/* ~~~ End Simplex Noise ~~~ */

#define NB_OCTAVES 6
#define LACUNARITY 2.0
#define GAIN 0.5

float fbm(float2 p) {
    float total = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;

    for (int i = 0; i < NB_OCTAVES; i++) {
        total += snoise(p * frequency) * amplitude;
        frequency *= LACUNARITY;
        amplitude *= GAIN;
    }
    return total;
}

static float s_c1, s_c2;

float pattern(float2 p, out float c) {
    float t = time;
    float2 q = float2(fbm(p + float2(0.0, 0.0)),
                       fbm(p + float2(s_c2 * 0.1, t * 0.02)));

    c = fbm(p + 2.0 * q + float2(s_c1 + s_c2, -t * 0.01));
    return fbm(p + 2.0 * q);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord.xy / resolution.xy;
    float t = time;

    s_c1 = 0.1 + cos(t * 0.01) * 0.9;
    s_c2 = 0.4 + cos(t * 0.06) * 0.4;

    float2 p = float2(uv.x + s_c1 * 0.4 + s_c2 * 0.6, uv.y * 0.3);
    p.x *= 0.4 + s_c2 * 0.4;

    float c;
    float3 col = (float3)pattern(p, c);
    col.r = 0.6 + lerp(col.x, c, 0.2);
    col.b = 0.2 + lerp(col.x, c, 0.5) * 0.1;

    // Darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_FakingGoldAndMurder() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_FateBeckons() {
    return "
    (
// Fate Beckons — Fork by vivavolt
// Shadertoy: https://shadertoy.com/view/Dlj3Dm

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define TIME (time * 3.0)

static const float hf = 0.01;

#define hsv(h,s,v) (v) * (1.0 + (s) * clamp(abs(frac((h) + float3(3,2,1) / 3.0) * 6.0 - 3.0) - 2.0, -1.0, 0.0))

float3 aces_approx(float3 v) {
    v = max(v, (float3)0) * 0.6;
    return min((v * (2.51 * v + 0.03)) / (v * (2.43 * v + 0.59) + 0.14), (float3)1);
}

float pmin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

#define pabs(a,k) (-pmin(a, -(a), k))

float height(float2 p) {
    p *= 0.4;
    float tm = TIME,
          xm = 0.5 * 0.005123,
          ym = lerp(0.125, 0.25, 0.5 - 0.5 * sin(cos(6.28 * TIME / 6e2))),
           d = length(p),
           c = 1E6,
           x = pow(d, 0.1) * ym,
           y = (atan2(p.x, p.y) + 0.05 * tm - 3.0 * d) / 6.28;

    float v;
    for (float i = 0.0; i < 4.0; i += 1.0) {
        v = length(frac(float2(x - tm * i * xm,
                               frac(y + i * ym) / 8.0)
                        * 16.0 * (1.0 + abs(sin(0.01 * TIME + 10.0))))
                   * 2.0 - 1.0);
        c = pmin(c, v, 0.0125);
    }

    return hf * (pabs(tanh(5.5 * d - 40.0 * c * c * d * d * (0.55 - d)) - 0.25 * d, 0.25) - 1.0);
}

float3 get_normal(float2 p) {
    float2 e = float2(4.0 / resolution.y, 0.0);
    return normalize(float3(
        height(p + e.xy) - height(p - e.xy),
        -2.0 * e.x,
        height(p + e.yx) - height(p - e.yx)));
}

float3 get_color(float2 p) {
    float ss = 1.0, hh = 1.95, spe = 3.0;

    float3 lp1 = -float3(1, hh, -1) * float3(ss, 1, ss),
           lp2 = -float3(-1, hh, -1) * float3(ss, 1, ss),
         lcol1 = hsv(0.1, 0.75, abs(sin(TIME * 0.1)) * 2.0),
         lcol2 = hsv(0.57, sin(TIME * 0.1) * 0.7, 1.0),
          matc = hsv(0.55, 0.83, 0.55),
             n = get_normal(p),
            ro = float3(0, 8, 0),
            pp = float3(p.x, 0, p.y),
            po = pp,
            rd = normalize(ro - po),
           ld1 = normalize(lp1 - po),
           ld2 = normalize(lp2 - po),
           ref = reflect(rd, n);

    float diff1 = max(dot(n, ld1), 0.0),
          diff2 = max(dot(n, ld2), 0.0),
           ref1 = max(dot(ref, ld1), 0.0),
           ref2 = max(dot(ref, ld2), 0.0),
             rm = tanh(abs(height(p)) * 120.0);

    float3 lpow1 = rm * rm * matc * lcol1,
           lpow2 = rm * rm * matc * lcol2;

    return diff1 * diff1 * lpow1
         + diff2 * diff2 * lpow2
         + rm * pow(ref1, spe) * lcol1
         + rm * pow(ref2, spe) * lcol2;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 R = resolution;
    float2 p = (2.0 * fragCoord - R) / R.y;

    float3 col = get_color(p);
    col = aces_approx(col);
    float3 color = sqrt(max(col, (float3)0));

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_FateBeckons() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_FbmDomainWarping() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float hash21(float2 v) {
    return frac(sin(dot(v, float2(12.9898, 78.233))) * 43758.5453123);
}

float noise(float2 uv) {
    float2 f = frac(uv);
    float2 i = floor(uv);
    f = f * f * (3.0 - 2.0 * f);
    return lerp(
        lerp(hash21(i), hash21(i + float2(1, 0)), f.x),
        lerp(hash21(i + float2(0, 1)), hash21(i + float2(1, 1)), f.x), f.y);
}

float fbm(float2 uv) {
    float freq = 2.0;
    float amp = 0.5;
    float gain = 0.54;
    float v = 0.0;
    for (int i = 0; i < 6; ++i) {
        v += amp * noise(uv);
        amp *= gain;
        uv *= freq;
    }
    return v;
}

float fbmPattern(float2 p, out float2 q, out float2 r) {
    float qCoef = 2.0;
    float rCoef = 3.0;
    q.x = fbm(p              + 0.0  * time);
    q.y = fbm(p              - 0.02 * time + float2(10.0, 7.36));
    r.x = fbm(p + qCoef * q  + 0.1  * time + float2(5.0, 3.0));
    r.y = fbm(p + qCoef * q  - 0.07 * time + float2(10.0, 7.36));
    return fbm(p + rCoef * r  + 0.1  * time);
}

float3 basePalette(float t) {
    return 0.5 + 0.6 * cos(6.283185 * (-t + float3(0.0, 0.1, 0.2) - 0.2));
}

float3 smokePalette(float t) {
    return float3(0.6, 0.5, 0.5)
        + 0.5 * cos(6.283185 * (-float3(1.0, 1.0, 0.5) * t + float3(0.2, 0.15, -0.1) - 0.2));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution.yy;

    float scale = 5.0;
    float3 col = (float3)0.1;

    float2 q;
    float2 r;
    float n = fbmPattern(scale * uv, q, r);
    float3 baseCol = basePalette(r.x);
    float3 smokeCol = smokePalette(n);

    col = lerp(baseCol, smokeCol, pow(q.y, 1.3));

    // Apply darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_FbmDomainWarping() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_FbmNoise() {
    return "
    (
// fBM Noise - jorgemoag (Shadertoy WslcR2)
// Inspired by https://iquilezles.org/articles/warp
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float random(float2 p) {
    float x = dot(p, float2(4371.321, -9137.327));
    return 2.0 * frac(sin(x) * 17381.94472) - 1.0;
}

float noise(in float2 p) {
    float2 id = floor(p);
    float2 f = frac(p);

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(lerp(random(id + float2(0.0, 0.0)),
                     random(id + float2(1.0, 0.0)), u.x),
                lerp(random(id + float2(0.0, 1.0)),
                     random(id + float2(1.0, 1.0)), u.x),
                u.y);
}

float fbm(float2 p) {
    float f = 0.0;
    float gat = 0.0;

    for (float octave = 0.; octave < 5.; ++octave) {
        float la = pow(2.0, octave);
        float ga = pow(0.5, octave + 1.);
        f += ga * noise(la * p);
        gat += ga;
    }

    f = f / gat;

    return f;
}

float noise_fbm(float2 p) {
    float h = fbm(0.09 * time + p + fbm(0.065 * time + 2.0 * p - 5.0 * fbm(4.0 * p)));
    return h;
}

float outline(float2 p, float eps) {
    float f = noise_fbm(p - float2(0.0, 0.0));

    float ft = noise_fbm(p - float2(0.0, eps));
    float fl = noise_fbm(p - float2(eps, 0.0));
    float fb = noise_fbm(p + float2(0.0, eps));
    float fr = noise_fbm(p + float2(eps, 0.0));

    float gg = clamp(abs(4. * f - ft - fr - fl - fb), 0., 1.);

    return gg;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 p = (2.0 * fragCoord - resolution.xy) / resolution.y;

    float f = noise_fbm(p);

    float a2 = smoothstep(-0.5, 0.5, f);
    float a1 = smoothstep(-1.0, 1.0, fbm(p));

    float3 cc = lerp(lerp(float3(0.50, 0.00, 0.10),
                          float3(0.50, 0.75, 0.35), a1),
                          float3(0.00, 0.00, 0.02), a2);

    cc += float3(0.0, 0.2, 1.0) * outline(p, 0.0005);
    cc += float3(1.0, 1.0, 1.0) * outline(p, 0.0025);

    cc += 0.5 * float3(0.1, 0.0, 0.2) * noise_fbm(p);
    cc += 0.25 * float3(0.3, 0.4, 0.6) * noise_fbm(2.0 * p);

    // Darken/desaturate post-processing
    float lum = dot(cc, float3(0.299, 0.587, 0.114));
    cc = lerp(cc, float3(lum, lum, lum), desaturate);
    cc = cc * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(cc.r, max(cc.g, cc.b));
    return float4(cc * alpha, alpha);
}

    )"
}

_Shader_Meta_FbmNoise() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_Fire() {
    return "
    (
// Fire Shader — after @febucci

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float rand(float2 co) {
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

float hermite(float t) {
    return t * t * (3.0 - 2.0 * t);
}

float noise(float2 co, float frequency) {
    float2 v = float2(co.x * frequency, co.y * frequency);
    float ix1 = floor(v.x);
    float iy1 = floor(v.y);
    float ix2 = floor(v.x + 1.0);
    float iy2 = floor(v.y + 1.0);
    float fx = hermite(frac(v.x));
    float fy = hermite(frac(v.y));
    float fade1 = lerp(rand(float2(ix1, iy1)), rand(float2(ix2, iy1)), fx);
    float fade2 = lerp(rand(float2(ix1, iy2)), rand(float2(ix2, iy2)), fx);
    return lerp(fade1, fade2, fy);
}

float pnoise(float2 co, float freq, int steps, float persistence) {
    float value = 0.0;
    float ampl = 1.0;
    float sum = 0.0;
    for (int i = 0; i < steps; i++) {
        sum += ampl;
        value += noise(co, freq) * ampl;
        freq *= 2.0;
        ampl *= persistence;
    }
    return value / sum;
}

float4 PSMain(PSInput input) : SV_Target {
    // Y-flip: fire rises upward
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 uv = fragCoord.xy / resolution.xy;
    float gradient = 1.0 - uv.y;
    float gradientStep = 0.2;

    float2 pos = fragCoord.xy / resolution.x;
    pos.y -= time * 0.3125;

    float4 brighterColor = float4(1.0, 0.65, 0.1, 0.25);
    float4 darkerColor = float4(1.0, 0.0, 0.15, 0.0625);
    float4 middleColor = lerp(brighterColor, darkerColor, 0.5);

    float noiseTexel = pnoise(pos, 10.0, 5, 0.5);

    float firstStep = smoothstep(0.0, noiseTexel, gradient);
    float darkerColorStep = smoothstep(0.0, noiseTexel, gradient - gradientStep);
    float darkerColorPath = firstStep - darkerColorStep;
    float4 col = lerp(brighterColor, darkerColor, darkerColorPath);

    float middleColorStep = smoothstep(0.0, noiseTexel, gradient - 0.4);

    col = lerp(col, middleColor, darkerColorStep - middleColorStep);
    col = lerp((float4)0, col, firstStep);

    float3 color = col.rgb;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_Fire() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_FlowerOfFractal() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

// originals from gaz fractal 62
#define R(p,a,r) lerp(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)
#define H(h) (cos((h)*6.3+float3(25,20,21))*2.5+.5)

float3 glsl_mod(float3 x, float y) {
    return x - y * floor(x / y);
}

float happy_star(float2 uv, float anim) {
    uv = abs(uv);
    float2 pos = min(uv.xy / uv.yx, anim);
    float p = (2.0 - pos.x - pos.y);
    return (2.0 + p * (p * p - 1.5)) / (uv.x + uv.y);
}

float hash(int3 p) {
    int n = p.x * 3 + p.y * 113 + p.z * 311;
    n = (n << 13) ^ n;
    n = n * (n * n * 15731 + 789221) + 1376312589;
    return float(n & 0x0fffffff) / float(0x0fffffff);
}

float noise(float3 x) {
    int3 i = int3(floor(x));
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);

    return lerp(lerp(lerp(hash(i + int3(0, 0, 0)),
                          hash(i + int3(1, 0, 0)), f.x),
                     lerp(hash(i + int3(0, 1, 0)),
                          hash(i + int3(1, 1, 0)), f.x), f.y),
                lerp(lerp(hash(i + int3(0, 0, 1)),
                          hash(i + int3(1, 0, 1)), f.x),
                     lerp(hash(i + int3(0, 1, 1)),
                          hash(i + int3(1, 1, 1)), f.x), f.y), f.z);
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float4 O = (float4)0;
    float2 uv = (fragCoord - 0.5 * resolution) / resolution.y;
    float t2 = time * 0.1 + ((0.25 + 0.05 * sin(time * 0.1)) / (length(uv) + 0.51)) * 2.2;
    float si = sin(t2);
    float co = cos(t2);
    // GLSL mat2(co, si, -si, co) is column-major; transpose for HLSL row-major
    float2x2 ma = float2x2(co, -si, si, co);
    float3 r = float3(resolution, 1.0);
    float3 n1 = (float3)0;
    float3 d = normalize(float3((fragCoord * 2.0 - r.xy) / r.y, 1));

    float a, s, e, g = 0.;
    for (float i = 0.; ++i < 110.;
         O.xyz += lerp((float3)1, H(g * 0.1), sin(0.8)) * 1.0 / e / 8e3)
    {
        float c2 = noise(n1);
        n1 = g * d + c2;

        n1.xy = mul(n1.xy, -ma);
        float4 q = float4(n1, sin(time * 0.15) * 0.5);
        q.xy = mul(q.xy, ma);

        for (float j = 0.; j++ < 4.;) {
            for (float k = 0.; k++ < 3.;) {
                n1.x = cos(q.w * i + j);
                n1.y *= cos(q.x * i + j * q.z);
            }
        }

        a = 20.;
        n1 = glsl_mod(n1 - a, a * 2.) - a;
        s = 3. + c2;

        for (int ii = 0; ii++ < 8;) {
            n1 = 0.3 - abs(n1);

            if (n1.x < n1.z) n1 = n1.zyx;
            if (n1.z < n1.y) n1 = n1.xzy;
            if (n1.y < n1.x) n1 = n1.zyx;

            q = abs(q);
            q = q.x < q.y ? q.zwxy : q.zwyx;
            q = q.z < q.y ? q.xyzw : q.ywxz;

            s *= e = 1.4 + sin(time * 0.234) * 0.1;
            n1 = abs(n1) * e - float3(
                q.w + cos(time * 0.3 + 0.5 * cos(time * 0.3)) * 3.,
                120.,
                8. + cos(time * 0.5) * 5.);
        }

        g += e = length(n1.xy) / s;
    }

    uv *= 2.0 * (cos(time * 2.0) - 2.5);
    float anim = sin(time * 12.0) * 0.1 + 1.0;
    O += float4(happy_star(uv, anim) * float3(0.05, 1.2, 0.15) * 0.1, 0.0);

    // Alpha from brightness, darken/desaturate, premultiply
    float3 color = O.xyz;
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);
    float al = saturate(max(color.r, max(color.g, color.b)));
    color = saturate(color);
    return float4(color * al, al);
}

    )"
}

_Shader_Meta_FlowerOfFractal() {
    return {opacity: 0.45, iChannels: [], timeOffsetMin: 30, timeOffsetMax: 90, timeAccumulate: true}
}

_Shader_HLSL_ForkTheDrive() {
    return "
    (
// Fork The Drive — converted from Shadertoy McX3W7
// Original: The Drive Home by Martijn Steinrucken aka BigWings - 2017
// Fork by devesh1312
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define S(x, y, z) smoothstep(x, y, z)
#define B(a, b, edge, t) S(a-edge, a+edge, t)*S(b+edge, b-edge, t)
#define sat(x) saturate(x)

#define streetLightCol float3(1., .7, .3)
#define headLightCol float3(.8, .8, 1.)
#define tailLightCol float3(1., .1, .1)

#define HIGH_QUALITY
#define CAM_SHAKE 1.
#define LANE_BIAS .5
#define RAIN

static float3 ro, rd;

float N(float t) {
    return frac(sin(t * 10234.324) * 123423.23512);
}

float3 N31(float p) {
    float3 p3 = frac(p * float3(.1031, .11369, .13787));
    p3 += dot(p3, p3.yzx + 19.19);
    return frac(float3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));
}

float N2(float2 p) {
    float3 p3 = frac(p.xyx * float3(443.897, 441.423, 437.195));
    p3 += dot(p3, p3.yzx + 19.19);
    return frac((p3.x + p3.y) * p3.z);
}

float DistLine(float3 ro, float3 rd, float3 p) {
    return length(cross(p - ro, rd));
}

float3 ClosestPoint(float3 ro, float3 rd, float3 p) {
    return ro + max(0., dot(p - ro, rd)) * rd;
}

float Remap(float a, float b, float c, float d, float t) {
    return ((t - a) / (b - a)) * (d - c) + c;
}

float BokehMask(float3 ro, float3 rd, float3 p, float size, float blur) {
    float d = DistLine(ro, rd, p);
    float m = S(size, size * (1. - blur), d);

    #ifdef HIGH_QUALITY
    m *= lerp(.7, 1., S(.8 * size, size, d));
    #endif

    return m;
}

float SawTooth(float t) {
    return cos(t + cos(t)) + sin(2. * t) * .2 + sin(4. * t) * .02;
}

float DeltaSawTooth(float t) {
    return 0.4 * cos(2. * t) + 0.08 * cos(4. * t) - (1. - sin(t)) * sin(t + cos(t));
}

float2 GetDrops(float2 uv, float seed, float m) {
    float t = time + m * 30.;
    float2 o = (float2)0;

    uv.y += t * .05;

    uv *= float2(10., 2.5) * 2.;
    float2 id = floor(uv);
    float3 n = N31(id.x + (id.y + seed) * 546.3524);
    float2 bd = frac(uv);

    bd -= .5;
    bd.y *= 4.;
    bd.x += (n.x - .5) * .6;

    t += n.z * 6.28;
    float slide = SawTooth(t);

    float ts = 1.5;
    float2 trailPos = float2(bd.x * ts, (frac(bd.y * ts * 2. - t * 2.) - .5) * .5);

    bd.y += slide * 2.;

    #ifdef HIGH_QUALITY
    float dropShape = bd.x * bd.x;
    dropShape *= DeltaSawTooth(t);
    bd.y += dropShape;
    #endif

    float d = length(bd);

    float trailMask = S(-.2, .2, bd.y);
    trailMask *= bd.y;
    float td = length(trailPos * max(.5, trailMask));

    float mainDrop = S(.2, .1, d);
    float dropTrail = S(.1, .02, td);

    dropTrail *= trailMask;
    o = lerp(bd * mainDrop, trailPos, dropTrail);

    return o;
}

void CameraSetup(float2 uv, float3 pos, float3 lookat, float zoom, float m) {
    ro = pos;
    float3 f = normalize(lookat - ro);
    float3 r = cross(float3(0., 1., 0.), f);
    float3 u = cross(f, r);
    float t = time;

    float2 offs = (float2)0;
    #ifdef RAIN
    float2 dropUv = uv;

    #ifdef HIGH_QUALITY
    float x = (sin(t * .1) * .5 + .5) * .5;
    x = -x * x;
    float s = sin(x);
    float c = cos(x);

    // GLSL mat2(c,-s,s,c) is column-major; HLSL float2x2 is row-major
    float2x2 rot = float2x2(c, s, -s, c);

    dropUv = mul(uv, rot);
    dropUv.x += -sin(t * .1) * .5;
    #endif

    offs = GetDrops(dropUv, 1., m);

    offs += GetDrops(dropUv * 1.4, 10., m);
    #ifdef HIGH_QUALITY
    offs += GetDrops(dropUv * 2.4, 25., m);
    #endif

    float ripple = sin(t + uv.y * 3.1415 * 30. + uv.x * 124.) * .5 + .5;
    ripple *= .005;
    offs += float2(ripple * ripple, ripple);
    #endif

    float3 center = ro + f * zoom;
    float3 i = center + (uv.x - offs.x) * r + (uv.y - offs.y) * u;

    rd = normalize(i - ro);
}

float3 HeadLights(float i, float t) {
    float z = frac(-t * 2. + i);
    float3 p = float3(-.3, .1, z * 40.);
    float d = length(p - ro);

    float size = lerp(.03, .05, S(.02, .07, z)) * d;
    float m = 0.;
    float blur = .1;
    m += BokehMask(ro, rd, p - float3(.08, 0., 0.), size, blur);
    m += BokehMask(ro, rd, p + float3(.08, 0., 0.), size, blur);

    #ifdef HIGH_QUALITY
    m += BokehMask(ro, rd, p + float3(.1, 0., 0.), size, blur);
    m += BokehMask(ro, rd, p - float3(.1, 0., 0.), size, blur);
    #endif

    float distFade = max(.01, pow(1. - z, 9.));

    blur = .8;
    size *= 2.5;
    float r = 0.;
    r += BokehMask(ro, rd, p + float3(-.09, -.2, 0.), size, blur);
    r += BokehMask(ro, rd, p + float3(.09, -.2, 0.), size, blur);
    r *= distFade * distFade;

    return headLightCol * (m + r) * distFade;
}

float3 TailLights(float i, float t) {
    t = t * 1.5 + i;

    float id = floor(t) + i;
    float3 n = N31(id);

    float laneId = S(LANE_BIAS, LANE_BIAS + .01, n.y);

    float ft = frac(t);

    float z = 3. - ft * 3.;

    laneId *= S(.2, 1.5, z);
    float lane = lerp(.6, .3, laneId);
    float3 p = float3(lane, .1, z);
    float d = length(p - ro);

    float size = .05 * d;
    float blur = .1;
    float m = BokehMask(ro, rd, p - float3(.08, 0., 0.), size, blur) +
              BokehMask(ro, rd, p + float3(.08, 0., 0.), size, blur);

    #ifdef HIGH_QUALITY
    float bs = n.z * 3.;
    float brake = S(bs, bs + .01, z);
    brake *= S(bs + .01, bs, z - .5 * n.y);

    m += (BokehMask(ro, rd, p + float3(.1, 0., 0.), size, blur) +
          BokehMask(ro, rd, p - float3(.1, 0., 0.), size, blur)) * brake;
    #endif

    float refSize = size * 2.5;
    m += BokehMask(ro, rd, p + float3(-.09, -.2, 0.), refSize, .8);
    m += BokehMask(ro, rd, p + float3(.09, -.2, 0.), refSize, .8);
    float3 col = tailLightCol * m * ft;

    float b = BokehMask(ro, rd, p + float3(.12, 0., 0.), size, blur);
    b += BokehMask(ro, rd, p + float3(.12, -.2, 0.), refSize, .8) * .2;

    float3 blinker = float3(1., .7, .2);
    blinker *= S(1.5, 1.4, z) * S(.2, .3, z);
    blinker *= sat(sin(t * 200.) * 100.);
    blinker *= laneId;
    col += blinker * b;

    return col;
}

float3 StreetLights(float i, float t) {
    float side = sign(rd.x);
    float offset = max(side, 0.) * (1. / 16.);
    float z = frac(i - t + offset);
    float3 p = float3(2. * side, 2., z * 60.);
    float d = length(p - ro);
    float blur = .1;
    float3 rp = ClosestPoint(ro, rd, p);
    float distFade = Remap(1., .7, .1, 1.5, 1. - pow(1. - z, 6.));
    distFade *= (1. - z);
    float m = BokehMask(ro, rd, p, .05 * d, blur) * distFade;

    return m * streetLightCol;
}

float3 EnvironmentLights(float i, float t) {
    float n = N(i + floor(t));

    float side = sign(rd.x);
    float offset = max(side, 0.) * (1. / 16.);
    float z = frac(i - t + offset + frac(n * 234.));
    float n2 = frac(n * 100.);
    float3 p = float3((3. + n) * side, n2 * n2 * n2 * 1., z * 60.);
    float d = length(p - ro);
    float blur = .1;
    float3 rp = ClosestPoint(ro, rd, p);
    float distFade = Remap(1., .7, .1, 1.5, 1. - pow(1. - z, 6.));
    float m = BokehMask(ro, rd, p, .05 * d, blur);
    m *= distFade * distFade * .5;

    m *= 1. - pow(sin(z * 6.28 * 20. * n) * .5 + .5, 20.);
    float3 randomCol = float3(frac(n * -34.5), frac(n * 4572.), frac(n * 1264.));
    float3 col = lerp(tailLightCol, streetLightCol, frac(n * -65.42));
    col = lerp(col, randomCol, n);
    return m * col * .2;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float t = time * 0.2;
    float3 col = (float3)0;
    float2 uv = fragCoord.xy / resolution.xy;

    uv -= .5;
    uv.x *= resolution.x / resolution.y;

    // iMouse zeroed — shader animates via time, mouse was just a time scrub offset
    float3 pos = float3(.3, .15, 0.);

    float bt = t * 5.;
    float h1 = N(floor(bt));
    float h2 = N(floor(bt + 1.));
    float bumps = lerp(h1, h2, frac(bt)) * .1;
    bumps = bumps * bumps * bumps * CAM_SHAKE;

    pos.y += bumps;
    float lookatY = pos.y + bumps;
    float3 lookat = float3(0.3, lookatY, 1.);
    float3 lookat2 = float3(0., lookatY, .7);
    lookat = lerp(lookat, lookat2, sin(t * .1) * .5 + .5);

    uv.y += bumps * 4.;
    CameraSetup(uv, pos, lookat, 2., 0.);

    t *= .03;

    [unroll] for (int si = 0; si < 8; si++) {
        col += StreetLights(si * 0.125, t);
    }

    [unroll] for (int hi = 0; hi < 8; hi++) {
        float hf = hi * 0.125;
        float n = N(hf + floor(t));
        col += HeadLights(hf + n * 0.125 * .7, t);
    }

    #ifdef HIGH_QUALITY
    [unroll] for (int ei = 0; ei < 32; ei++) {
        col += EnvironmentLights(ei * 0.03125, t);
    }
    #else
    [unroll] for (int ei = 0; ei < 16; ei++) {
        col += EnvironmentLights(ei * 0.0625, t);
    }
    #endif

    col += TailLights(0., t);
    col += TailLights(.5, t);

    col += sat(rd.y) * float3(.6, .5, .9);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_ForkTheDrive() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_FractalGalaxyParallax() {
    return "
    (
// Fractal Galaxy Parallax — converted from Shadertoy Dl2XWD
// Original by Birdmachine (CC BY-NC-SA 3.0)
// Parallax scrolling fractal galaxy with stars

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// Synthetic beat replacement for audio channels
float getFreq(float band) {
    return 0.4 + 0.15 * sin(time * (0.8 + band * 0.3))
               + 0.1 * sin(time * (1.3 + band * 0.7));
}

float field(float3 p, float s) {
    float strength = 7.0 + 0.03 * log(1.e-6 + frac(sin(time) * 4373.11));
    float accum = s / 4.0;
    float prev = 0.0;
    float tw = 0.0;
    for (int i = 0; i < 26; ++i) {
        float mag = dot(p, p);
        p = abs(p) / mag + float3(-0.5, -0.4, -1.5);
        float w = exp(-(float)i / 7.0);
        accum += w * exp(-strength * pow(abs(mag - prev), 2.2));
        tw += w;
        prev = mag;
    }
    return max(0.0, 5.0 * accum / tw - 0.7);
}

// Less iterations for second layer
float field2(float3 p, float s) {
    float strength = 7.0 + 0.03 * log(1.e-6 + frac(sin(time) * 4373.11));
    float accum = s / 4.0;
    float prev = 0.0;
    float tw = 0.0;
    for (int i = 0; i < 18; ++i) {
        float mag = dot(p, p);
        p = abs(p) / mag + float3(-0.5, -0.4, -1.5);
        float w = exp(-(float)i / 7.0);
        accum += w * exp(-strength * pow(abs(mag - prev), 2.2));
        tw += w;
        prev = mag;
    }
    return max(0.0, 5.0 * accum / tw - 0.7);
}

float3 nrand3(float2 co) {
    float3 a = frac(cos(co.x * 8.3e-3 + co.y) * float3(1.3e5, 4.7e5, 2.9e5));
    float3 b = frac(sin(co.x * 0.3e-3 + co.y) * float3(8.1e5, 1.0e5, 0.1e5));
    float3 c = lerp(a, b, 0.5);
    return c;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = 2.0 * fragCoord.xy / resolution.xy - 1.0;
    float2 uvs = uv * resolution.xy / max(resolution.x, resolution.y);
    float3 p = float3(uvs / 4.0, 0.0) + float3(1.0, -1.3, 0.0);
    p += 0.2 * float3(sin(time / 16.0), sin(time / 12.0), sin(time / 128.0));

    // Synthetic frequency bands (replaces audio input)
    float freqs0 = getFreq(0.0);
    float freqs1 = getFreq(1.0);
    float freqs2 = getFreq(2.0);
    float freqs3 = getFreq(3.0);

    float t = field(p, freqs2);
    float v = (1.0 - exp((abs(uv.x) - 1.0) * 6.0)) * (1.0 - exp((abs(uv.y) - 1.0) * 6.0));

    // Second Layer
    float3 p2 = float3(uvs / (4.0 + sin(time * 0.11) * 0.2 + 0.2 + sin(time * 0.15) * 0.3 + 0.4), 1.5) + float3(2.0, -1.3, -1.0);
    p2 += 0.25 * float3(sin(time / 16.0), sin(time / 12.0), sin(time / 128.0));
    float t2 = field2(p2, freqs3);
    float4 c2 = lerp(0.4, 1.0, v) * float4(1.3 * t2 * t2 * t2, 1.8 * t2 * t2, t2 * freqs0, t2);

    // Stars
    float2 seed = p.xy * 2.0;
    seed = floor(seed * resolution.x);
    float3 rnd = nrand3(seed);
    float4 starcolor = (float4)pow(rnd.y, 40.0);

    // Second layer stars
    float2 seed2 = p2.xy * 2.0;
    seed2 = floor(seed2 * resolution.x);
    float3 rnd2 = nrand3(seed2);
    starcolor += (float4)pow(rnd2.y, 40.0);

    float4 col = lerp(freqs3 - 0.3, 1.0, v) * float4(1.5 * freqs2 * t * t * t, 1.2 * freqs1 * t * t, freqs3 * t, 1.0) + c2 + starcolor;

    float3 color = col.rgb;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_FractalGalaxyParallax() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60}
}

_Shader_HLSL_Galvanize() {
    return "
    (
// Galvanize / Alcatraz
// Jochen 'Virgill' Feldkoetter
// Intro for Nordlicht demoparty 2014 - Shadertoy version
// https://www.shadertoy.com/view/4tc3zf

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// globals
static int efx = 0;
static int refleco = 0;
static int snowo = 0;
static float4 orbitTrap = float4(0.0, 0.0, 0.0, 0.0);
static float blend_g = 0.0;
static float d_g = 0.0;
static float m_g = 0.0;
static float kalitime = 0.0;
static float depth_g = 0.0;
static float prec = 0.0;
static const float scene = 35.0;
static float2 g_fragCoord;

// Rotate
float3 rotXaxis(float3 p, float rad)
{
    float z2 = cos(rad) * p.z - sin(rad) * p.y;
    float y2 = sin(rad) * p.z + cos(rad) * p.y;
    p.z = z2;
    p.y = y2;
    return p;
}

float3 rotYaxis(float3 p, float rad)
{
    float x2 = cos(rad) * p.x - sin(rad) * p.z;
    float z2 = sin(rad) * p.x + cos(rad) * p.z;
    p.x = x2;
    p.z = z2;
    return p;
}

float3 rotZaxis(float3 p, float rad)
{
    float x2 = cos(rad) * p.x - sin(rad) * p.y;
    float y2 = sin(rad) * p.x + cos(rad) * p.y;
    p.x = x2;
    p.y = y2;
    return p;
}

// noise functions
float rand1(float2 co)
{
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

float rand2(float2 co)
{
    return frac(cos(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

// polynomial smooth min (IQ)
float sminPoly(float a, float b, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

// exponential smooth min (IQ)
float smin_f(float a, float b, float k)
{
    float res = exp(-k * a) + exp(-k * b);
    return -log(res) / k;
}

// length squared
float length2(float2 p)
{
    return dot(p, p);
}

// worley effect
float worley(float2 p)
{
    float d = 1.0;
    for (int xo = -1; xo <= 1; ++xo)
    for (int yo = -1; yo <= 1; ++yo)
    {
        float2 tp = floor(p) + float2(xo, yo);
        d = min(d, length2(p - tp - float2(rand1(tp), rand1(tp))));
    }
    return 3.0 * exp(-4.0 * abs(2.0 * d - 1.0));
}

float fworley(float2 p)
{
    return sqrt(sqrt(sqrt(worley(p * 32.0 + 4.3 + time * 0.250) * sqrt(worley(p * 64.0 + 5.3 + time * -0.125)) * sqrt(sqrt(worley(p * -128.0 + 7.3))))));
}

// menger
float NewMenger(float3 z)
{
    float Scale = 3.0;
    float3 Offset = float3(1.0, 1.0, 1.0);
    int Iterations = 6;
    int ColorIterations = 3;

    for (int n = 0; n < 6; n++)
    {
        z.z *= 1.0 + 0.2 * sin(time / 4.0) + 0.1;
        z = abs(z);
        if (z.x < z.y) { float tmp = z.x; z.x = z.y; z.y = tmp; }
        if (z.x < z.z) { float tmp = z.x; z.x = z.z; z.z = tmp; }
        if (z.y < z.z) { float tmp = z.y; z.y = z.z; z.z = tmp; }
        z = Scale * z - Offset * (Scale - 1.0);
        if (z.z < -0.5 * Offset.z * (Scale - 1.0)) z.z += Offset.z * (Scale - 1.0);

        if (n < ColorIterations) orbitTrap = min(orbitTrap, float4(abs(z), dot(z, z)));
    }
    return abs(length(z)) * pow(Scale, (float)(-Iterations - 1));
}

// mandelbulb (Fractalforums.com)
float Mandelbulb(float3 p)
{
    float Scale = 3.0;
    int Iterations = 6;
    int ColorIterations = 1;
    float parachute = (1.0 - min(1.8 * abs(sin((time - 5.0) * 3.1415 / scene)), 1.0));
    parachute = smoothstep(0.0, 1.0, parachute) * 35.0;
    float3 w = p;
    float dr = 1.0 + parachute;
    float r = 0.0;
    for (int i = 0; i < 6; ++i)
    {
        r = length(w);
        if (r > 4.0) break;
        dr *= pow(r, 7.0) * 8.0 + 1.0;
        float x = w.x; float x2 = x * x; float x4 = x2 * x2;
        float y = w.y; float y2 = y * y; float y4 = y2 * y2;
        float z = w.z; float z2 = z * z; float z4 = z2 * z2;
        float k3 = x2 + z2;
        float k2 = rsqrt(pow(k3, 7.0));
        float k1 = x4 + y4 + z4 - 6.0 * y2 * z2 - 6.0 * x2 * y2 + 2.0 * z2 * x2;
        float k4 = x2 - y2 + z2;
        w = float3(64.0 * x * y * z * (x2 - z2) * k4 * (x4 - 6.0 * x2 * z2 + z4) * k1 * k2, -16.0 * y2 * k3 * k4 * k4 + k1 * k1, -8.0 * y * k4 * (x4 * x4 - 28.0 * x4 * x2 * z2 + 70.0 * x4 * z4 - 28.0 * x2 * z2 * z4 + z4 * z4) * k1 * k2);
        w -= p;
        w = rotYaxis(w, sin(time * 0.14));
        w = rotZaxis(w, cos(time * 0.2));
        orbitTrap = min(orbitTrap, abs(float4(p.x * w.z, p.y * w.x, 0.0, 0.0)));
        if (i >= ColorIterations + 2) orbitTrap = float4(0.0, 0.0, 0.0, 0.0);
    }
    return 0.5 * log(r) * r / dr;
}

// kalibox (Kali / Fractalforums.com)
float Kalibox(float3 pos)
{
    float Scale = 1.84;
    int Iterations = 14;
    int ColorIterations = 3;
    float MinRad2 = 0.34;
    float3 Trans = float3(0.076, -1.86, 0.036);
    float3 Julia = float3(-0.66, -1.2 + (kalitime / 80.0), -0.66);
    float4 scale = float4(Scale, Scale, Scale, abs(Scale)) / MinRad2;
    float absScalem1 = abs(Scale - 1.0);
    float AbsScaleRaisedTo1mIters = pow(abs(Scale), (float)(1 - Iterations));
    float4 p = float4(pos, 1), p0 = float4(Julia, 1);
    for (int i = 0; i < 14; i++)
    {
        p.xyz = abs(p.xyz) + Trans;
        float r2 = dot(p.xyz, p.xyz);
        p *= clamp(max(MinRad2 / r2, MinRad2), 0.0, 1.0);
        p = p * scale + p0;
        if (i < ColorIterations) orbitTrap = min(orbitTrap, abs(float4(p.xyz, r2)));
    }
    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
}

// balls and cube
float Balls(float3 pos)
{
    m_g = length(max(abs(rotYaxis(rotXaxis(pos + float3(0.0, -0.3, 0.0), time), time * 0.3)) - float3(0.35, 0.35, 0.35), 0.0)) - 0.02;
    m_g = smin_f(m_g, length(pos + float3(0.0, -0.40, 1.2 + 0.5 * sin(0.8 * time + 0.0))) - 0.4, 7.4);
    m_g = smin_f(m_g, length(pos + float3(0.0, -0.40, -1.2 - 0.5 * sin(0.8 * time + 0.4))) - 0.4, 7.4);
    m_g = smin_f(m_g, length(pos + float3(-1.2 - 0.5 * sin(0.8 * time + 0.8), -0.40, 0.0)) - 0.4, 7.4);
    m_g = smin_f(m_g, length(pos + float3(1.2 + 0.5 * sin(0.8 * time + 1.2), -0.40, 0.0)) - 0.4, 7.4);
    m_g = smin_f(m_g, length(pos + float3(0.0, -1.6 + 0.5 * -sin(0.8 * time + 1.6), 0.0)) - 0.4, 7.4);
    orbitTrap = float4(length(pos) - 0.8 * pos.z, length(pos) - 0.8 * pos.y, length(pos) - 0.8 * pos.x, 0.0) * 1.0;
    return m_g;
}

// plane
float sdPlane(float3 p)
{
    return p.y + (0.025 * sin(p.x * 10.0 + 1.4 * time)) + (0.025 * sin(p.z * 12.3 * cos(0.4 - p.x) + 1.6 * time)) - 0.05;
}

// cylinder
float sdCylinder(float3 p, float3 c)
{
    return length(p.xz - c.xy) - c.z;
}

// scene
float map(float3 p)
{
    orbitTrap = float4(10.0, 10.0, 10.0, 10.0);
    d_g = sdPlane(p);

    if (efx == 0) {
        m_g = Balls(p);
    }
    if (efx == 1) {
        m_g = NewMenger(rotYaxis(rotXaxis(p - float3(0.0, sin(time / 0.63) + 0.2, 0.0), 0.15 * time), 0.24 * time));
    }
    if (efx == 2) {
        m_g = Mandelbulb(rotYaxis(rotXaxis(p, time * 0.1), 0.21 * time));
    }
    if (efx == 3) {
        m_g = Kalibox(rotYaxis(rotXaxis(p, 1.50), 0.1 * time));
    }
    if (efx == 4 || efx == 5) {
        float3 c = float3(2.0, 8.0, 2.0);
        // GLSL mod: x - y*floor(x/y), always positive for positive y
        float3 poff = p - float3(1.0, 0.1 * time, 1.0);
        float3 q = poff - c * floor(poff / c) - 0.5 * c;
        float kali = Kalibox(rotYaxis(q, 0.04 * time));
        m_g = max(kali, -sdCylinder(p, float3(0.0, 0.0, 0.30 + 0.1 * sin(time * 0.2))));
    }
    d_g = sminPoly(m_g, d_g, 0.04);
    return d_g;
}

// normal calculation
float3 calcNormal(float3 p)
{
    float3 e = float3(0.001, 0.0, 0.0);
    float3 nor = float3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx));
    return normalize(nor);
}

// cast
float castRay(float3 ro, float3 rd, float maxt)
{
    float precis = prec;
    float h = precis * 2.0;
    float t = depth_g;

    for (int i = 0; i < 122; i++)
    {
        if (abs(h) < precis || t > maxt) break;
        orbitTrap = float4(10.0, 10.0, 10.0, 10.0);
        h = map(ro + rd * t);
        t += h;
    }
    return t;
}

// softshadow (IQ)
float softshadow(float3 ro, float3 rd, float mint, float maxt, float k)
{
    float sh = 1.0;
    float t = mint;
    float h = 0.0;
    for (int i = 0; i < 19; i++)
    {
        if (t > maxt) continue;
        orbitTrap = float4(10.0, 10.0, 10.0, 10.0);
        h = map(ro + rd * t);
        sh = min(sh, k * h / t);
        t += h;
    }
    return sh;
}

// orbit color
static const float3 BaseColor = float3(0.2, 0.2, 0.2);
static const float3 OrbitStrength = float3(0.8, 0.8, 0.8);
static const float4 X_c = float4(0.5, 0.6, 0.6, 0.2);
static const float4 Y_c = float4(1.0, 0.5, 0.1, 0.7);
static const float4 Z_c = float4(0.8, 0.7, 1.0, 0.3);
static const float4 R_c = float4(0.7, 0.7, 0.5, 0.1);

float3 getColor()
{
    orbitTrap.w = sqrt(orbitTrap.w);
    float3 orbitColor = X_c.xyz * X_c.w * orbitTrap.x + Y_c.xyz * Y_c.w * orbitTrap.y + Z_c.xyz * Z_c.w * orbitTrap.z + R_c.xyz * R_c.w * orbitTrap.w;
    float3 color = lerp(BaseColor, 3.0 * orbitColor, OrbitStrength);
    return color;
}

// particles (Andrew Baldwin)
float snow(float3 direction)
{
    float help = 0.0;
    // mat3 p in GLSL is column-major; mul() in HLSL with float3x3 is row-major
    // GLSL mat3(a,b,c, d,e,f, g,h,i) fills columns: col0=(a,b,c), col1=(d,e,f), col2=(g,h,i)
    // HLSL float3x3(a,b,c, d,e,f, g,h,i) fills rows: row0=(a,b,c), row1=(d,e,f), row2=(g,h,i)
    // Since we use p*m (GLSL) = mul(m, p) with transposed matrix, we transpose:
    static const float3x3 pm = float3x3(
        13.323122, 21.1212, 21.8112,
        23.5112,   28.7312, 14.7212,
        21.71123,  11.9312, 61.3934);
    float2 uvx = float2(direction.x, direction.z) + float2(1.0, resolution.y / resolution.x) * g_fragCoord.xy / resolution.xy;
    float acc = 0.0;
    float DEPTH = direction.y * direction.y - 0.3;
    float WIDTH = 0.1;
    float SPEED = 0.1;
    for (int i = 0; i < 10; i++)
    {
        float fi = (float)i;
        float2 q = uvx * (1.0 + fi * DEPTH);
        q += float2(q.y * (WIDTH * frac(fi * 7.238917) - WIDTH * 0.5), SPEED * time / (1.0 + fi * DEPTH * 0.03));
        float3 n = float3(floor(q), 31.189 + fi);
        float3 fm = floor(n) * 0.00001 + frac(n);
        float3 mp = (31415.9 + fm) / frac(mul(pm, fm));
        float3 r = frac(mp);
        float2 qmod = q - floor(q); // GLSL mod(q, 1.0)
        float2 s = abs(qmod - 0.5 + 0.9 * r.xy - 0.45);
        float dd = 0.7 * max(s.x - s.y, s.x + s.y) + max(s.x, s.y) - 0.01;
        float edge = 0.04;
        acc += smoothstep(edge, -edge, dd) * (r.x / 1.0);
        help = acc;
    }
    return help;
}

// GLSL mod equivalent (always positive)
float glmod(float x, float y) { return x - y * floor(x / y); }

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    g_fragCoord = fragCoord;

    if (time >= 0.0  && time <= 35.0)  { efx = 4; refleco = 0; snowo = 0; }
    if (time > 35.0  && time <= 70.0)  { efx = 0; refleco = 1; snowo = 1; }
    if (time > 70.0  && time <= 105.0) { efx = 1; refleco = 0; snowo = 1; }
    if (time > 105.0 && time <= 140.0) { efx = 3; refleco = 0; snowo = 1; }
    if (time > 140.0 && time <= 175.0) { efx = 2; refleco = 0; snowo = 1; }
    if (time > 175.0 && time <= 210.0) { efx = 4; refleco = 0; snowo = 0; }
    if (time > 210.0 && time <= 245.0) { efx = 5; refleco = 0; snowo = 0; }

    blend_g = max(min(2.0 * abs(sin((time + 0.0) * 3.1415 / scene)), 1.0), 0.3);
    float2 uv = fragCoord.xy / resolution.xy;
    float2 p = uv * 2.0 - 1.0;
    p.x *= resolution.x / resolution.y;
    float theta = sin(time * 0.03) * 3.14 * 2.0;
    float x = 3.0 * cos(theta) + 0.007 * rand1(fragCoord.xy);
    float z = 3.0 * sin(theta) + 0.007 * rand2(fragCoord.xy);
    float3 ro = (float3)0;

    if (efx == 0) {
        prec = 0.001;
        ro = float3(x * 0.2 + 1.0, 5.0, z * 2.0 - 3.0);
    }
    if (efx == 1) {
        prec = 0.002;
        ro = float3(x * 1.2, 7.0, z * 2.0);
    }
    if (efx == 2) {
        prec = 0.002;
        ro = float3(x * 1.0, 6.2, z * 2.8);
        depth_g = 4.0;
    }
    if (efx == 3) {
        kalitime = 40.0;
        prec = 0.002;
        ro = float3(x * 1.7, 2.6, 2.0);
    }
    if (efx == 4) {
        prec = 0.002;
        kalitime = time - 15.0;
        ro = float3(0.0, 8.0, 0.0001);
    }
    if (efx == 5) {
        prec = 0.004;
        kalitime = 210.0 + 175.0;
        ro = float3(0, 3.8, 0.0001);
    }

    float3 ta = float3(0.0, 0.25, 0.0);
    float3 cw = normalize(ta - ro);
    float3 cp = float3(0.0, 1.0, 0.0);
    float3 cu = normalize(cross(cw, cp));
    float3 cv = normalize(cross(cu, cw));
    float3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);

    // render
    float3 col = float3(0.0, 0.0, 0.0);
    float t = castRay(ro, rd, 12.0);
    float3 pos = ro + rd * t;
    float3 nor = calcNormal(pos);
    float3 lig;
    if (efx == 4 || efx == 5)   lig = normalize(float3(-0.4 * sin(time * 0.15), 1.0, 0.5));
    else if (efx == 3)          lig = normalize(float3(-0.1 * sin(time * 0.2), 0.2, 0.4 * sin(time * 0.1)));
    else                        lig = normalize(float3(-0.4, 0.7, 0.5));
    float dif = clamp(dot(lig, nor), 0.0, 1.0);
    float spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);
    float sh = 1.0;
    if (efx == 1 || efx == 5) sh = softshadow(pos, lig, 0.02, 20.0, 7.0);
    float3 color = getColor();
    col = ((0.8 * dif + spec) + 0.35 * color);
    if (efx != 1 && efx != 5) sh = softshadow(pos, lig, 0.02, 20.0, 7.0);
    col = col * clamp(sh, 0.0, 1.0);

    // reflections
    if (refleco == 1) {
        float3 col2 = float3(0.0, 0.0, 0.0);
        float3 ro2 = pos - rd / t;
        float3 rd2 = reflect(rd, nor);
        float t2 = castRay(ro2, rd2, 7.0);
        float3 pos2 = float3(0.0, 0.0, 0.0);
        if (t2 < 7.0) {
            pos2 = ro2 + rd2 * t2;
        }
        float3 nor2 = calcNormal(pos2);
        float dif2 = clamp(dot(lig, nor2), 0.0, 1.0);
        float spec2 = pow(clamp(dot(reflect(rd2, nor2), lig), 0.0, 1.0), 16.0);
        col += 0.22 * float3(dif2 * color + (float3)spec2);
    }

    // postprocessing
    float klang1 = 0.75;
    float2 uv2 = -0.3 + 2.0 * fragCoord.xy / resolution.xy;
    col -= 0.20 * (1.0 - klang1) * rand1(uv2.xy * time);
    col *= 0.9 + 0.20 * (1.0 - klang1) * sin(10.0 * time + uv2.x * resolution.x);
    col *= 0.9 + 0.20 * (1.0 - klang1) * sin(10.0 * time + uv2.y * resolution.y);
    float Scr = 1.0 - dot(uv2, uv2) * 0.15;
    float2 uv3 = fragCoord.xy / resolution.xy;
    float worl = fworley(uv3 * resolution.xy / 2100.0);
    worl *= exp(-length2(abs(2.0 * uv3 - 1.0)));
    worl *= abs(1.0 - 0.6 * dot(2.0 * uv3 - 1.0, 2.0 * uv3 - 1.0));
    if (efx == 4) col += float3(0.4 * worl, 0.35 * worl, 0.25 * worl);
    if (efx == 5) col += float3(0.2 * worl, 0.2 * worl, 0.2 * worl);
    float g2 = (blend_g / 2.0) + 0.39;
    float g1 = ((1.0 - blend_g) / 2.0);
    if (uv3.y >= g2 + 0.11) col *= 0.0;
    if (uv3.y >= g2 + 0.09) col *= 0.4;
    if (uv3.y >= g2 + 0.07) { if (glmod(uv3.x - 0.06 * time, 0.18) <= 0.16) col *= 0.5; }
    if (uv3.y >= g2 + 0.05) { if (glmod(uv3.x - 0.04 * time, 0.12) <= 0.10) col *= 0.6; }
    if (uv3.y >= g2 + 0.03) { if (glmod(uv3.x - 0.02 * time, 0.08) <= 0.06) col *= 0.7; }
    if (uv3.y >= g2 + 0.01) { if (glmod(uv3.x - 0.01 * time, 0.04) <= 0.02) col *= 0.8; }
    if (uv3.y <= g1 + 0.10) { if (glmod(uv3.x + 0.01 * time, 0.04) <= 0.02) col *= 0.8; }
    if (uv3.y <= g1 + 0.08) { if (glmod(uv3.x + 0.02 * time, 0.08) <= 0.06) col *= 0.7; }
    if (uv3.y <= g1 + 0.06) { if (glmod(uv3.x + 0.04 * time, 0.12) <= 0.10) col *= 0.6; }
    if (uv3.y <= g1 + 0.04) { if (glmod(uv3.x + 0.06 * time, 0.18) <= 0.16) col *= 0.5; }
    if (uv3.y <= g1 + 0.02) col *= 0.4;
    if (uv3.y <= g1 + 0.00) col *= 0.0;

    float4 fragColor;
    if (snowo == 1) fragColor = (float4(col * 1.0 * Scr - 1.6 * snow(cv), 1.0) * blend_g) * float4(1.0, 0.93, 1.0, 1.0);
    else fragColor = float4(col * 1.0 * Scr, 1.0) * blend_g;

    float3 finalCol = fragColor.rgb;

    // darken/desaturate
    float lum = dot(finalCol, float3(0.299, 0.587, 0.114));
    finalCol = lerp(finalCol, float3(lum, lum, lum), desaturate);
    finalCol = finalCol * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(finalCol.r, max(finalCol.g, finalCol.b));
    return float4(finalCol * a, a);
}

    )"
}

_Shader_Meta_Galvanize() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 0, timeOffsetMax: 245, timeAccumulate: true}
}

_Shader_HLSL_GalvanizeTunnel() {
    return "
    (
// Galvanize Tunnel
// From Alcatraz 8K intro Galvanize
// Jochen 'Virgill' Feldkoetter
// https://www.shadertoy.com/view/MlX3Wr

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// GLSL-compatible mod (handles negatives correctly)
float glsl_mod(float x, float y) { return x - y * floor(x / y); }
float2 glsl_mod(float2 x, float2 y) { return x - y * floor(x / y); }
float3 glsl_mod(float3 x, float3 y) { return x - y * floor(x / y); }

// Mutable globals (per-pixel in HLSL via static)
static float blend_g = 0.0;
static float scene = 35.0;
static float d_g = 0.0;
static float m_g = 0.0;
static float kalitime;
static float depth_g = 0.0;
static float prec_g = 0.002;
static float4 orbitTrap = (float4)0.0;

// Rotate
float3 rotXaxis(float3 p, float rad) {
    float z2 = cos(rad) * p.z - sin(rad) * p.y;
    float y2 = sin(rad) * p.z + cos(rad) * p.y;
    p.z = z2; p.y = y2;
    return p;
}

float3 rotYaxis(float3 p, float rad) {
    float x2 = cos(rad) * p.x - sin(rad) * p.z;
    float z2 = sin(rad) * p.x + cos(rad) * p.z;
    p.x = x2; p.z = z2;
    return p;
}

float3 rotZaxis(float3 p, float rad) {
    float x2 = cos(rad) * p.x - sin(rad) * p.y;
    float y2 = sin(rad) * p.x + cos(rad) * p.y;
    p.x = x2; p.y = y2;
    return p;
}

// Rand
float rand1(float2 co) {
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

// Polynomial smooth min (IQ)
float sminPoly(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

// Length squared
float length2(float2 p) {
    return dot(p, p);
}

// Worley effect
float worley(float2 p) {
    float dw = 1.0;
    for (int xo = -1; xo <= 1; ++xo)
    for (int yo = -1; yo <= 1; ++yo) {
        float2 tp = floor(p) + float2((float)xo, (float)yo);
        dw = min(dw, length2(p - tp - float2(rand1(tp), rand1(tp))));
    }
    return 3.0 * exp(-4.0 * abs(2.0 * dw - 1.0));
}

float fworley(float2 p) {
    return sqrt(sqrt(sqrt(
        worley(p * 32.0 + 4.3 + time * 0.250) *
        sqrt(worley(p * 64.0 + 5.3 + time * -0.125)) *
        sqrt(sqrt(worley(p * -128.0 + 7.3))))));
}

// Kalibox (Kali / Fractalforums.com)
float Kalibox(float3 pos) {
    float Scale = 1.84;
    int ColorIterations = 3;
    float MinRad2 = 0.34;
    float3 Trans = float3(0.076, -1.86, 0.036);
    float3 Julia = float3(-0.66, -1.2 + (kalitime / 80.0), -0.66);
    float4 scale = float4(Scale, Scale, Scale, abs(Scale)) / MinRad2;
    float absScalem1 = abs(Scale - 1.0);
    float AbsScaleRaisedTo1mIters = pow(abs(Scale), (float)(1 - 14));
    float4 p = float4(pos, 1.0), p0 = float4(Julia, 1.0);
    for (int i = 0; i < 14; i++) {
        p.xyz = abs(p.xyz) + Trans;
        float r2 = dot(p.xyz, p.xyz);
        p *= clamp(max(MinRad2 / r2, MinRad2), 0.0, 1.0);
        p = p * scale + p0;
        if (i < ColorIterations) orbitTrap = min(orbitTrap, abs(float4(p.xyz, r2)));
    }
    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
}

// Plane
float sdPlane(float3 p) {
    return p.y + (0.025 * sin(p.x * 10.0 + 1.4 * time)) + (0.025 * sin(p.z * 12.3 * cos(0.4 - p.x) + 1.6 * time)) - 0.05;
}

// Cylinder
float sdCylinder(float3 p, float3 c) {
    return length(p.xz - c.xy) - c.z;
}

// Map
float map(float3 p) {
    orbitTrap = (float4)10.0;
    d_g = sdPlane(p);

    float3 c = float3(2.0, 8.0, 2.0);
    float3 q = glsl_mod(p - float3(1.0, 0.1 * time, 1.0), c) - 0.5 * c;
    float kali = Kalibox(rotYaxis(q, 0.04 * time));
    m_g = max(kali, -sdCylinder(p, float3(0.0, 0.0, 0.30 + 0.1 * sin(time * 0.2))));

    d_g = sminPoly(m_g, d_g, 0.04);
    return d_g;
}

// Normal Calculation
float3 calcNormal(float3 p) {
    float3 e = float3(0.001, 0.0, 0.0);
    float3 nor = float3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx));
    return normalize(nor);
}

// Cast
float castRay(float3 ro, float3 rd, float maxt) {
    float precis = prec_g;
    float h = precis * 2.0;
    float t = depth_g;

    for (int i = 0; i < 122; i++) {
        if (abs(h) < precis || t > maxt) break;
        orbitTrap = (float4)10.0;
        h = map(ro + rd * t);
        t += h;
    }
    return t;
}

// Softshadow (IQ)
float softshadow(float3 ro, float3 rd, float mint, float maxt, float k) {
    float sh = 1.0;
    float t = mint;
    float h = 0.0;
    for (int i = 0; i < 19; i++) {
        if (t > maxt) continue;
        orbitTrap = (float4)10.0;
        h = map(ro + rd * t);
        sh = min(sh, k * h / t);
        t += h;
    }
    return sh;
}

// Orbit color
float3 getColor() {
    float3 BaseColor = float3(0.2, 0.2, 0.2);
    float3 OrbitStrength = float3(0.8, 0.8, 0.8);
    float4 X = float4(0.5, 0.6, 0.6, 0.2);
    float4 Y = float4(1.0, 0.5, 0.1, 0.7);
    float4 Z = float4(0.8, 0.7, 1.0, 0.3);
    float4 R = float4(0.7, 0.7, 0.5, 0.1);
    orbitTrap.w = sqrt(orbitTrap.w);
    float3 orbitColor = X.xyz * X.w * orbitTrap.x + Y.xyz * Y.w * orbitTrap.y + Z.xyz * Z.w * orbitTrap.z + R.xyz * R.w * orbitTrap.w;
    float3 color = lerp(BaseColor, 3.0 * orbitColor, OrbitStrength);
    return color;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    kalitime = time - 15.0;
    blend_g = min(2.0 * abs(sin((time + 0.0) * 3.1415 / scene)), 1.0);
    float2 uv = fragCoord.xy / resolution.xy;
    float2 p = uv * 2.0 - 1.0;
    p.x *= resolution.x / resolution.y;
    float theta = sin(time * 0.03) * 3.14 * 2.0;
    float x = 3.0 * cos(theta);
    float z = 3.0 * sin(theta);
    float3 ro;

    ro = float3(0.0, 8.0, 0.0001);

    float3 ta = float3(0.0, 0.25, 0.0);
    float3 cw = normalize(ta - ro);
    float3 cp = float3(0.0, 1.0, 0.0);
    float3 cu = normalize(cross(cw, cp));
    float3 cv = normalize(cross(cu, cw));
    float3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);

    // Render
    float3 col = (float3)0.0;
    float t = castRay(ro, rd, 12.0);
    float3 pos = ro + rd * t;
    float3 nor = calcNormal(pos);
    float3 lig;
    lig = normalize(float3(-0.4 * sin(time * 0.15), 1.0, 0.5));

    float dif = clamp(dot(lig, nor), 0.0, 1.0);
    float spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);
    float sh = softshadow(pos, lig, 0.02, 20.0, 7.0);
    float3 color = getColor();
    col = ((0.8 * dif + spec) + 0.35 * color);
    col = col * clamp(sh, 0.0, 1.0);

    // Postprocessing
    float klang1 = 0.4;
    float2 uv2 = -0.3 + 2.0 * fragCoord.xy / resolution.xy;
    col -= 0.20 * (1.0 - klang1) * rand1(uv2.xy * time);
    col *= 0.9 + 0.20 * (1.0 - klang1) * sin(10.0 * time + uv2.x * resolution.x);
    col *= 0.9 + 0.20 * (1.0 - klang1) * sin(10.0 * time + uv2.y * resolution.y);
    float Scr = 1.0 - dot(uv2, uv2) * 0.15;
    float2 uv3 = fragCoord.xy / resolution.xy;
    float worl = fworley(uv3 * resolution.xy / 2100.0);
    worl *= exp(-length2(abs(2.0 * uv3 - 1.0)));
    worl *= abs(1.0 - 0.6 * dot(2.0 * uv3 - 1.0, 2.0 * uv3 - 1.0));
    col += float3(0.40 * worl, 0.35 * worl, 0.25 * worl);

    // Border
    float g2 = (blend_g / 2.0) + 0.39;
    float g1 = ((1.0 - blend_g) / 2.0);
    if (uv3.y >= g2 + 0.11) col *= 0.0;
    if (uv3.y >= g2 + 0.09) col *= 0.4;
    if (uv3.y >= g2 + 0.07) { if (glsl_mod(uv3.x - 0.06 * time, 0.18) <= 0.16) col *= 0.5; }
    if (uv3.y >= g2 + 0.05) { if (glsl_mod(uv3.x - 0.04 * time, 0.12) <= 0.10) col *= 0.6; }
    if (uv3.y >= g2 + 0.03) { if (glsl_mod(uv3.x - 0.02 * time, 0.08) <= 0.06) col *= 0.7; }
    if (uv3.y >= g2 + 0.01) { if (glsl_mod(uv3.x - 0.01 * time, 0.04) <= 0.02) col *= 0.8; }
    if (uv3.y <= g1 + 0.10) { if (glsl_mod(uv3.x + 0.01 * time, 0.04) <= 0.02) col *= 0.8; }
    if (uv3.y <= g1 + 0.08) { if (glsl_mod(uv3.x + 0.02 * time, 0.08) <= 0.06) col *= 0.7; }
    if (uv3.y <= g1 + 0.06) { if (glsl_mod(uv3.x + 0.04 * time, 0.12) <= 0.10) col *= 0.6; }
    if (uv3.y <= g1 + 0.04) { if (glsl_mod(uv3.x + 0.06 * time, 0.18) <= 0.16) col *= 0.5; }
    if (uv3.y <= g1 + 0.02) col *= 0.4;
    if (uv3.y <= g1 + 0.00) col *= 0.0;

    col = col * Scr * blend_g;

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_GalvanizeTunnel() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 20, timeOffsetMax: 80, timeAccumulate: true}
}

_Shader_HLSL_GargantuaRender() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);
Texture2D iChannel1 : register(t1);
SamplerState samp1 : register(s1);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// Constants
#define PI          3.1415926
#define TWO_PI      6.2831852
#define HALF_PI     1.5707963
#define EPSILON_C   0.00001
#define IN_RANGE(x,a,b)     (((x) > (a)) && ((x) < (b)))

// Reduced SPP for real-time performance
#define SPP 2
#define GRAVITATIONAL_LENSING

struct Ray {
    float3 origin;
    float3 dir;
};

struct Camera {
    float3x3 rotate;
    float3 pos;
    float3 target;
    float fovV;
};

struct BlackHole {
    float3 position_;
    float radius_;
    float ring_radius_inner_;
    float ring_radius_outer_;
    float ring_thickness_;
    float mass_;
};

static float seed;
static BlackHole gargantua;
static Camera camera;

float rnd() { return frac(sin(seed++)*43758.5453123); }

void initScene() {
    gargantua.position_ = float3(0.0, 0.0, -8.0);
    gargantua.radius_ = 0.1;
    gargantua.ring_radius_inner_ = gargantua.radius_ + 0.8;
    gargantua.ring_radius_outer_ = 6.0;
    gargantua.ring_thickness_ = 0.15;
    gargantua.mass_ = 1000.0;
}

void initCamera(float3 pos, float3 target, float3 upDir, float fovV) {
    float3 back = normalize(pos - target);
    float3 right = normalize(cross(upDir, back));
    float3 up = cross(back, right);
    camera.rotate[0] = right;
    camera.rotate[1] = up;
    camera.rotate[2] = back;
    camera.fovV = fovV;
    camera.pos = pos;
}

float3 sphericalToCartesian(float rho, float phi, float theta) {
    float sinTheta = sin(theta);
    return float3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) * rho;
}

void cartesianToSpherical(float3 xyz, out float rho, out float phi, out float theta) {
    rho = sqrt(xyz.x * xyz.x + xyz.y * xyz.y + xyz.z * xyz.z);
    phi = asin(xyz.y / rho);
    theta = atan2(xyz.z, xyz.x);
}

Ray genRay(float2 pixel) {
    Ray ray;
    float2 iPlaneSize = 2.0 * tan(0.5 * camera.fovV) * float2(resolution.x / resolution.y, 1.0);
    float2 ixy = (pixel / resolution.xy - 0.5) * iPlaneSize;
    ray.origin = camera.pos;
    ray.dir = mul(normalize(float3(ixy.x, ixy.y, -1.0)), camera.rotate);
    return ray;
}

float noise(float3 x) {
    float3 p = floor(x);
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    float2 uv = (p.xy + float2(37.0, 17.0) * p.z) + f.xy;
    float2 rg = iChannel0.SampleLevel(samp0, (uv + 0.5) / 256.0, 0.0).yx;
    return -1.0 + 2.0 * lerp(rg.x, rg.y, f.z);
}

float map5(float3 p) {
    float3 q = p;
    float f;
    f  = 0.50000 * noise(q); q = q * 2.02;
    f += 0.25000 * noise(q); q = q * 2.03;
    f += 0.12500 * noise(q); q = q * 2.01;
    f += 0.06250 * noise(q); q = q * 2.02;
    f += 0.03125 * noise(q);
    return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
}

// Stars from nimitz - https://www.shadertoy.com/view/ltfGDs
float tri(float x) { return abs(frac(x) - 0.5); }

float3 hash33(float3 p) {
    p = frac(p * float3(5.3983, 5.4427, 6.9371));
    p += dot(p.yzx, p.xyz + float3(21.5351, 14.3137, 15.3219));
    return frac(float3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));
}

float3 stars(float3 p) {
    float fov = radians(50.0);
    float3 c = (float3)0;
    float res = resolution.x * 0.85 * fov;

    p.x += (tri(p.z * 50.0) + tri(p.y * 50.0)) * 0.006;
    p.y += (tri(p.z * 50.0) + tri(p.x * 50.0)) * 0.006;
    p.z += (tri(p.x * 50.0) + tri(p.y * 50.0)) * 0.006;

    for (float i = 0.0; i < 3.0; i++) {
        float3 q = frac(p * (0.15 * res)) - 0.5;
        float3 id = floor(p * (0.15 * res));
        float rn = hash33(id).z;
        float c2 = 1.0 - smoothstep(-0.2, 0.4, length(q));
        c2 *= step(rn, 0.005 + i * 0.014);
        c += c2 * (lerp(float3(1.0, 0.75, 0.5), float3(0.85, 0.9, 1.0), rn * 30.0) * 0.5 + 0.5);
        p *= 1.15;
    }
    return c * c * 1.5;
}

float3 getBgColor(float3 dir) {
    float rho, phi, theta;
    cartesianToSpherical(dir, rho, phi, theta);
    float2 uv = float2(phi / PI, theta / TWO_PI);
    float3 c0 = iChannel1.Sample(samp1, uv).xyz * 0.3;
    float3 c1 = stars(dir);
    return c0.bgr * 0.4 + c1 * 2.0;
}

void getCloudColorAndDensity(float3 p, float t, out float4 color, out float density) {
    float d2 = dot(p, p);
    color = (float4)0;

    if (sqrt(d2) < gargantua.radius_) {
        density = 0.0;
    } else {
        float rho, phi, theta;
        cartesianToSpherical(p, rho, phi, theta);
        rho = (rho - gargantua.ring_radius_inner_) / (gargantua.ring_radius_outer_ - gargantua.ring_radius_inner_);

        if (!IN_RANGE(p.y, -gargantua.ring_thickness_, gargantua.ring_thickness_) ||
            !IN_RANGE(rho, 0.0, 1.0)) {
            density = 0.0;
        } else {
            float cloudX = sqrt(rho);
            float cloudY = ((p.y - gargantua.position_.y) + gargantua.ring_thickness_) / (2.0 * gargantua.ring_thickness_);
            float cloudZ = theta / TWO_PI;

            float blending = 1.0;
            blending *= lerp(rho * 5.0, 1.0 - (rho - 0.2) / (0.8 * rho), rho > 0.2 ? 1.0 : 0.0);
            blending *= lerp(cloudY * 2.0, 1.0 - (cloudY - 0.5) * 2.0, cloudY > 0.5 ? 1.0 : 0.0);

            float3 moving = float3(t * 0.5, 0.0, t * rho * 0.1);
            float3 localCoord = float3(cloudX * (rho * rho), -0.02 * cloudY, cloudZ);

            density = blending * map5((localCoord + moving) * 100.0);
            color = 5.0 * lerp(float4(1.0, 0.9, 0.4, rho * density), float4(1.0, 0.3, 0.1, rho * density), rho);
        }
    }
}

float4 Radiance(Ray ray) {
    float4 sum = (float4)0;
    float marchingStep = lerp(0.27, 0.3, rnd());
    float marchingStart = 2.5;

    Ray currentRay;
    currentRay.origin = ray.origin + ray.dir * marchingStart;
    currentRay.dir = ray.dir;

    float transmittance = 1.0;

    for (int i = 0; i < 64 && transmittance > 1e-3; i++) {
        float3 p = currentRay.origin - gargantua.position_;

        float density;
        float4 ringColor;
        getCloudColorAndDensity(p, time * 0.1, ringColor, density);

        ringColor *= marchingStep;

        float tau = density * (1.0 - ringColor.w) * marchingStep;
        transmittance *= exp(-tau);

        sum += transmittance * density * ringColor;

#ifdef GRAVITATIONAL_LENSING
        float G_M1_M2 = 0.50;
        float d2 = dot(p, p);
        float3 gravityVec = normalize(-p) * (G_M1_M2 / d2);
        currentRay.dir = normalize(currentRay.dir + marchingStep * gravityVec);
#endif
        currentRay.origin = currentRay.origin + currentRay.dir * marchingStep;
    }

    float3 bgColor = getBgColor(currentRay.dir);
    sum = float4(bgColor * transmittance + sum.xyz, 1.0);

    return clamp(sum, 0.0, 1.0);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    seed = resolution.y * fragCoord.x / resolution.x + fragCoord.y / resolution.y;

    initScene();

    // No mouse — use default camera angle
    float2 screen_uv = float2(0.8, 0.4);

    // Gentle time-based camera drift
    float2 drift = float2(sin(time * 0.02) * 0.05, cos(time * 0.015) * 0.03);
    screen_uv += drift;

    float mouseSensitivity = 0.4;
    float3 cameraDir = sphericalToCartesian(1.0, -((HALF_PI - screen_uv.y * PI) * mouseSensitivity), (-screen_uv.x * TWO_PI) * mouseSensitivity);

    initCamera(gargantua.position_ + cameraDir * 8.0, gargantua.position_, float3(0.2, 1.0, 0.0), radians(50.0));

    float4 color = float4(0.0, 0.0, 0.0, 1.0);
    for (int i = 0; i < SPP; i++) {
        float2 screenCoord = fragCoord.xy + float2(rnd(), rnd());
        Ray ray = genRay(screenCoord);
        color += Radiance(ray);
    }

    float3 col = ((1.0 / (float)SPP) * color).rgb;

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_GargantuaRender() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "gargantua_render_i0.png"}, {index: 1, file: "gargantua_render_i1.jpg"}], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_Glasswall() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// GLSL mod: always returns positive remainder for positive divisor
float glsl_mod(float x, float y) { return x - y * floor(x / y); }

float random(in float2 _st) {
    return frac(sin(dot(_st.xy, float2(0.89, -0.90))) * 757.153);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise(in float2 _st) {
    float2 i = floor(_st);
    float2 f = frac(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float fbm(in float2 _st) {
    float v = sin(time * 0.2) * 0.15;
    float a = 0.8;
    float2 shift = (float2)100.0;
    // Rotate to reduce axial bias
    // GLSL mat2 is column-major; HLSL float2x2 is row-major — transpose constructor args
    float2x2 rot = float2x2(cos(0.5), -sin(0.5),
                             sin(1.0),  acos(0.5));
    for (int i = 0; i < 5; ++i) {
        v += a * noise(_st);
        _st = mul(rot, _st) * 2.0 + shift;
        a *= 0.01;
    }
    return v;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 st = (2.0 * fragCoord - resolution) / min(resolution.x, resolution.y) * 1.7;

    float2 co = st;
    float len;
    for (int i = 0; i < 3; i++) {
        len = length(co);
        co.x += sin(co.y + time * 0.620) * 0.1;
        co.y += cos(co.x + time * 0.164) * 0.1;
    }
    len -= 3.0;

    float3 col = (float3)0.0;

    float2 q = (float2)0.0;
    q.x = fbm(st + 1.0);
    q.y = fbm(st + float2(-0.45, 0.65));

    float2 r = (float2)0.0;
    r.x = fbm(st + q + float2(0.57, 0.52) + 0.5 * time);
    r.y = fbm(st + q + float2(0.34, -0.57) + 0.4 * time);

    for (float j = 0.0; j < 3.0; j++) {
        r += 1.0 / abs(glsl_mod(st.y, 1.2 * j) * 500.0) * 1.0;       // Vertical line
        r += 1.0 / abs(glsl_mod(st.x, 0.3 * j) * 500.0) * 1.0;       // Horizontal line
        r += 1.0 / abs(glsl_mod(st.y + st.x, 0.6 * j) * 500.0) * 1.0; // Diagonal line
        r += 1.0 / abs(glsl_mod(st.y - st.x, 0.6 * j) * 500.0) * 1.0; // Diagonal line
    }
    float f = fbm(st + r);

    col = lerp(col, cos(len + float3(0.2, 0.0, -0.5)), 1.0);
    col = lerp(float3(0.730, 0.386, 0.372), float3(0.397, 0.576, 0.667), col);

    float3 color = 2.0 * (f * f * f + 0.6 * f * f + 0.5 * f) * col;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness — premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_Glasswall() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_GlassyWithOddRotation() {
    return "
    (
// Glassy with odd rotation by etrujillo — https://www.shadertoy.com/view/3XdXWX
// A shiny reflective variation of a raymarched fractal accident (CC0)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// tanh not available in SM 5.0
float3 tanhSafe(float3 x) {
    float3 e2x = exp(2.0 * clamp(x, -10.0, 10.0));
    return (e2x - 1.0) / (e2x + 1.0);
}

float sdfMap(float3 p) {
    // Domain repetition
    p = abs(frac(p) - 0.5);
    // Cylinder + planes SDF
    return abs(min(length(p.xy) - 0.175, min(p.x, p.y) + 1e-3)) + 1e-3;
}

float3 estimateNormal(float3 p) {
    float eps = 0.001;
    return normalize(float3(
        sdfMap(p + float3(eps, 0.0, 0.0)) - sdfMap(p - float3(eps, 0.0, 0.0)),
        sdfMap(p + float3(0.0, eps, 0.0)) - sdfMap(p - float3(0.0, eps, 0.0)),
        sdfMap(p + float3(0.0, 0.0, eps)) - sdfMap(p - float3(0.0, 0.0, eps))));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 r = resolution;
    float2 uv = (fragCoord - 0.5 * r) / r.y;

    float t = time;
    float z = frac(dot(fragCoord, sin(fragCoord))) - 0.5;
    float3 col = (float3)0;
    float4 p;

    [loop]
    for (float i = 0.0; i < 77.0; i++) {
        // Ray direction
        p = float4(z * normalize(float3(fragCoord - 0.7 * r, r.y)), 0.1 * t);
        p.z += t;

        float4 q = p;

        // Apply rotation matrices for glitchy fractal distortion
        // GLSL: p.xy *= mat2(cos(vec4)) → HLSL: p.xy = mul(float2x2(cos(float4)), p.xy)
        float4 cosVal1 = cos(2.0 + q.z + float4(0, 11, 33, 0));
        p.xy = mul(float2x2(cosVal1.x, cosVal1.y, cosVal1.z, cosVal1.w), p.xy);
        float4 cosVal2 = cos(q + float4(0, 11, 33, 0));
        p.xy = mul(float2x2(cosVal2.x, cosVal2.y, cosVal2.z, cosVal2.w), p.xy);

        // Distance estimation
        float d = sdfMap(p.xyz);

        // Estimate lighting
        float3 pos = p.xyz;
        float3 lightDir = normalize(float3(0.3, 0.5, 1.0));
        float3 viewDir = normalize(float3(uv, 1.0));
        float3 n = estimateNormal(pos);
        float3 reflectDir = reflect(viewDir, n);

        // Fake environment reflection
        float3 envColor = lerp(float3(0.8, 0.4, 0.8), (float3)1.0, 0.5 + 0.5 * reflectDir.y);

        // Specular highlight
        float spec = pow(max(dot(reflectDir, lightDir), 0.0), 32.0);

        // Funky palette color
        float4 baseColor = (1.0 + sin(0.5 * q.z + length(p.xyz - q.xyz) + float4(0, 4, 3, 6)))
                         / (0.5 + 2.0 * dot(q.xy, q.xy));

        // Combine base color + environment reflection + specular
        float3 finalColor = baseColor.rgb * 0.1 + envColor * 0.9 + (float3)spec * 1.2;

        // Brightness weighted accumulation
        col += finalColor / d;

        z += 0.6 * d;
    }

    // Compress brightness range
    float3 color = tanhSafe(col / 2e4);

    // Apply darken/desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_GlassyWithOddRotation() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60}
}

_Shader_HLSL_Glittery() {
    return "
    (
// Glittery
// Based on https://www.shadertoy.com/view/lslyRn
//          https://www.shadertoy.com/view/lscczl
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define iterations 17
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom   0.800
#define tile   0.850

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation 0.850
#define S(a, b, val) smoothstep(a, b, val)

static const float pi = 3.14159265359;
static const float triangleScale = 0.816497161855865;
static const float3 orange = float3(0.937, 0.435, 0.0);

float3 glsl_mod(float3 x, float3 y) { return x - y * floor(x / y); }

float rand(float2 co) {
    return frac(sin(dot(co, float2(12.9898, 78.233))) * 43758.5453);
}

// --- Triangle grid functions ---

float4 getTriangleCoords(float2 uv) {
    uv.y /= triangleScale;
    uv.x -= uv.y / 2.0;
    float2 center = floor(uv);
    float2 local = frac(uv);

    center.x += center.y / 2.0;
    center.y *= triangleScale;

    if (local.x + local.y > 1.0) {
        local.x -= 1.0 - local.y;
        local.y = 1.0 - local.y;
        center.y += 0.586;
        center.x += 1.0;
    } else {
        center.y += 0.287;
        center.x += 0.5;
    }

    return float4(center, local);
}

float4 getLoader(float4 tri) {
    if (length(tri.xy) > 1.6) {
        return (float4)0;
    }

    float angle = atan2(tri.x, tri.y);
    float seed = rand(tri.xy);
    float dst = min(tri.z, min(tri.w, 1.0 - tri.z - tri.w)) * 15.0;
    float glow = dst < pi ? pow(sin(dst), 1.5) : 0.0;

    return float4(lerp(orange, (float3)1.0, glow * 0.07), pow(0.5 + 0.5 * sin(angle - time * 6.0 + seed), 2.0));
}

float getBackground(float4 tri) {
    float dst = min(tri.z, min(tri.w, 1.0 - tri.z - tri.w)) - 0.05;

    if (tri.y > 1.9 || tri.y < -2.4 || dst < 0.0) {
        return 0.0;
    }

    float value = pow(0.5 + 0.5 * cos(-abs(tri.x) * 0.4 + rand(tri.xy) * 2.0 + time * 4.0), 2.0) * 0.08;
    return value * (dst > 0.05 ? 0.65 : 1.0);
}

float3 getColor(float2 uv) {
    uv *= 2.0 / resolution.y;

    float3 background = (float3)getBackground(getTriangleCoords(uv * 6.0 - float2(0.5, 0.3)));
    float4 loader = getLoader(getTriangleCoords(uv * 11.0));

    float3 color = lerp(background, loader.rgb, loader.a);
    return color;
}

// --- Line/triangle synapse network ---
// Note: GLSL 'line' and 'triangle' renamed to avoid HLSL reserved keywords

float N21(float2 p) {
    p = frac(p * float2(233.34, 851.73));
    p += dot(p, p + 23.45);
    return frac(p.x * p.y);
}

float2 N22(float2 p) {
    float n = N21(p);
    return float2(n, N21(p + n));
}

float2 getPos(float2 id, float2 offset) {
    float2 n = N22(id + offset) * time;
    return offset + sin(n) * 0.4;
}

float distLine(float2 p, float2 a, float2 b) {
    float2 pa = p - a;
    float2 ba = b - a;
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * t);
}

float lineSeg(float2 p, float2 a, float2 b) {
    float d = distLine(p, a, b);
    float m = S(0.03, 0.01, d);
    float d2 = length(a - b);
    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));
    return m;
}

float distTriangle(float2 p, float2 p0, float2 p1, float2 p2) {
    float2 e0 = p1 - p0;
    float2 e1 = p2 - p1;
    float2 e2 = p0 - p2;

    float2 v0 = p - p0;
    float2 v1 = p - p1;
    float2 v2 = p - p2;

    float2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);
    float2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);
    float2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);

    float s = sign(e0.x * e2.y - e0.y * e2.x);
    float2 d = min(min(float2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),
                       float2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),
                   float2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));

    return -sqrt(d.x) * sign(d.y);
}

float triSeg(float2 p, float2 a, float2 b, float2 c) {
    float d = distTriangle(p, a, b, c);
    float m = S(0.03, 0.01, d);
    float d2 = length(a - b);
    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));
    return m;
}

float layer(float2 uv) {
    float2 gv = frac(uv) - 0.5;
    float2 id = floor(uv);

    float2 p[9];
    int idx = 0;
    for (float y = -1.0; y <= 1.0; y++) {
        for (float x = -1.0; x <= 1.0; x++) {
            p[idx++] = getPos(id, float2(x, y));
        }
    }

    float t = time * 10.0;
    float m = 0.0;
    for (int i = 0; i < 9; i++) {
        m += lineSeg(gv, p[4], p[i]);

        float2 j = (p[i] - gv) * 20.0;
        float sparkle = 1.0 / dot(j, j);
        m += sparkle * (sin(t + frac(p[i].x) * 10.0) * 0.5 + 0.5);

        for (int yi = i + 1; yi < 9; yi++) {
            for (int zi = yi + 1; zi < 9; zi++) {
                float len1 = abs(length(p[i] - p[yi]));
                float len2 = abs(length(p[yi] - p[zi]));
                float len3 = abs(length(p[i] - p[zi]));
                if ((len1 + len2 + len3) < 2.8) {
                    m += triSeg(gv, p[i], p[yi], p[zi]) * 0.8;
                }
            }
        }
    }

    m += lineSeg(gv, p[1], p[3]);
    m += lineSeg(gv, p[1], p[5]);
    m += lineSeg(gv, p[7], p[3]);
    m += lineSeg(gv, p[7], p[5]);

    return m;
}

// --- Volumetric star field ---

float4 volumetric(float3 ro, float3 rd) {
    float s = 0.1, fade = 1.0;
    float3 v = (float3)0;
    for (int r = 0; r < volsteps; r++) {
        float3 p = ro + s * rd * 0.5;
        p = abs((float3)tile - glsl_mod(p, (float3)(tile * 2.0)));
        float pa = 0.0, a = 0.0;
        for (int i = 0; i < iterations; i++) {
            p = abs(p) / dot(p, p) - formuparam;
            a += abs(length(p) - pa);
            pa = length(p);
        }
        float dm = max(0.0, darkmatter - a * a * 0.001);
        a *= a * a;
        if (r > 6) fade *= 1.1;
        v += fade;
        v += float3(s, s * s, s * s * s * s) * a * brightness * fade;
        fade *= distfading;
        s += stepsize;
    }
    v = lerp((float3)length(v), v, saturation);
    return float4(v * 0.03, 1.0);
}

// --- Entry point ---

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution.xy - 0.5;
    uv.y *= resolution.y / resolution.x;
    float3 dir = float3(uv * zoom, time * 0.002);

    // Line/triangle synapse network
    float m = 0.0;
    float t = time * 0.1;
    float gradient = uv.y;

    float sn = sin(t);
    float cs = cos(t);
    // GLSL column-major mat2(c,-s,s,c) -> HLSL row-major (transposed)
    float2x2 rot = float2x2(cs, sn, -sn, cs);
    uv = mul(uv, rot);

    for (float i = 0.0; i < 1.0; i += 1.0 / 4.0) {
        float z = frac(i + t);
        float sz = lerp(10.0, 0.5, z);
        float fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);
        m += layer(uv * sz + i * 20.0) * fade;
    }

    float3 base = sin(t * 5.0 * float3(0.345, 0.456, 0.567)) * 0.4 + 0.6;
    float3 col = m * base;
    col -= gradient * base;

    // Triangle grid (supersampled, modulates star field camera)
    float2 fc = fragCoord - 0.5 * resolution;
    float3 triColor = 0.25 * (getColor(fc)
                              + getColor(fc + float2(0.5, 0.0))
                              + getColor(fc + float2(0.5, 0.5))
                              + getColor(fc + float2(0.0, 0.5)));

    // Volumetric star field (camera origin influenced by triangle grid)
    // speed=0.0 in original -> localTime=0.25 (constant)
    float3 from = float3(1.0, 0.5, 0.5) + triColor + float3(0.5, 0.25, -2.0);
    float4 vr = volumetric(from, dir);
    float3 color = vr.rgb * col;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_Glittery() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_GlowingMarblingBlack() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (2.0 * fragCoord - resolution) / min(resolution.x, resolution.y);

    for (float i = 1.0; i < 10.0; i++) {
        uv.x += 0.6 / i * cos(i * 2.5 * uv.y + time);
        uv.y += 0.6 / i * cos(i * 1.5 * uv.x + time);
    }

    float3 color = (float3)(0.1) / abs(sin(time - uv.y - uv.x));

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float al = saturate(max(color.r, max(color.g, color.b)));
    color = saturate(color);
    return float4(color * al, al);
}

    )"
}

_Shader_Meta_GlowingMarblingBlack() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_GoldAgate() {
    return "
    (
// Gold Agate - JuliaPoo (Shadertoy XtcfRn)
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2x2 rot(float a) { return float2x2(sin(a), cos(a), -cos(a), sin(a)); }

float noise(in float2 x) { return smoothstep(0., 1., sin(1.5 * x.x) * sin(1.5 * x.y)); }

float fbm(float2 p) {

    float2x2 m = rot(.4);
    float f = 0.0;
    f += 0.500000 * (0.5 + 0.5 * noise(p)); p = mul(p, m) * 2.02;
    f += 0.250000 * (0.5 + 0.5 * noise(p)); p = mul(p, m) * 2.03;
    f += 0.125000 * (0.5 + 0.5 * noise(p)); p = mul(p, m) * 2.01;
    f += 0.015625 * (0.5 + 0.5 * noise(p));
    return f / 0.96875;
}

float pattern(in float2 p, out float2 q, out float2 r, float t) {

    q.x = fbm(2.0 * p + float2(0.0, 0.0) + 2. * t);
    q.y = fbm(1.5 * p + float2(5.2, 1.3) + 1. * t);

    r.x = fbm(p + 4. * q + float2(1.7, 9.2) + sin(t) + .9 * sin(30. * length(q)));
    r.y = fbm(p + 8. * q + float2(8.3, 2.8) + cos(t) + .9 * sin(20. * length(q)));

    return fbm(p + mul(rot(t), 7. * r));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // iMouse zeroed — shader looks great without mouse interaction
    float2 uv = fragCoord.xy / resolution.xy * 2.;
    uv.x *= resolution.x / resolution.y;

    float2 q, r;
    float3 col1 = float3(.9, .7, .5);
    float3 col2 = float3(.3, .5, .4);
    float3 c;

    float f = pattern(uv, q, r, 0.1 * time);

    // mix colours
    c = lerp(col1, (float3)0, pow(smoothstep(.0, .9, f), 2.));
    c += col2 * pow(smoothstep(0., .8, dot(q, r) * .6), 3.) * 1.5;
    // add contrast
    c *= pow(dot(q, r) + .3, 3.);
    // soften the bright parts
    c *= f * 1.5;

    // Darken/desaturate post-processing
    float lum = dot(c, float3(0.299, 0.587, 0.114));
    c = lerp(c, float3(lum, lum, lum), desaturate);
    c = c * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(c.r, max(c.g, c.b));
    return float4(c * a, a);
}

    )"
}

_Shader_Meta_GoldAgate() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_GreyLiquid() {
    return "
    (
// Grey Liquid - Converted from Shadertoy (fsdyzf)
// Licence CC0: Liquid Metal
// Some experimenting with warped FBM and very very fake lighting
// Author: fractalfantasy — Forked from Warped Liquid two (7tyXDw)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI  3.141592654
#define TAU (2.0*PI)

void rot(inout float2 p, float a) {
    float c = cos(a);
    float s = sin(a);
    p = float2(c*p.x + s*p.y, -s*p.x + c*p.y);
}

float hash(in float2 co) {
    return frac(sin(dot(co.xy, float2(12.9898, 58.233))) * 13758.5453);
}

float psin(float a) {
    return 0.5 + 0.5*sin(a);
}

float tanh_approx(float x) {
    float x2 = x*x;
    return clamp(x*(27.0 + x2)/(27.0 + 9.0*x2), -1.0, 1.0);
}

float onoise(float2 x) {
    x *= 0.5;
    float a = sin(x.x);
    float b = sin(x.y);
    float c = lerp(a, b, psin(TAU*tanh_approx(a*b + a + b)));
    return c;
}

float vnoise(float2 x) {
    float2 i = floor(x);
    float2 w = frac(x);

    // quintic interpolation
    float2 u = w*w*w*(w*(w*6.0 - 15.0) + 10.0);

    float a = hash(i + float2(0.0, 0.0));
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));

    float k0 = a;
    float k1 = b - a;
    float k2 = c - a;
    float k3 = d - c + a - b;

    return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;
}

float fbm1(float2 p) {
    float2 op = p;
    const float aa = 0.45;
    const float pp = 2.03;
    const float2 oo = -float2(1.23, 1.5);
    const float rr = 1.2;

    float h = 0.0;
    float d = 0.0;
    float a = 1.0;

    [loop]
    for (int i = 0; i < 5; ++i) {
        h += a*onoise(p);
        d += a;
        a *= aa;
        p += oo;
        p *= pp;
        rot(p, rr);
    }

    return lerp(h/d, -0.5*(h/d), pow(vnoise(0.9*op), 0.25));
}

float fbm2(float2 p) {
    float2 op = p;
    const float aa = 0.45;
    const float pp = 2.03;
    const float2 oo = -float2(1.23, 1.5);
    const float rr = 1.2;

    float h = 0.0;
    float d = 0.0;
    float a = 1.0;

    [loop]
    for (int i = 0; i < 7; ++i) {
        h += a*onoise(p);
        d += a;
        a *= aa;
        p += oo;
        p *= pp;
        rot(p, rr);
    }

    return lerp(h/d, -0.5*(h/d), pow(vnoise(0.9*op), 0.25));
}

float fbm3(float2 p) {
    float2 op = p;
    const float aa = 0.45;
    const float pp = 2.03;
    const float2 oo = -float2(1.23, 1.5);
    const float rr = 1.2;

    float h = 0.0;
    float d = 0.0;
    float a = 1.0;

    [loop]
    for (int i = 0; i < 3; ++i) {
        h += a*onoise(p);
        d += a;
        a *= aa;
        p += oo;
        p *= pp;
        rot(p, rr);
    }

    return lerp(h/d, -0.5*(h/d), pow(vnoise(0.9*op), 0.25));
}

float warp(float2 p) {
    float2 v = float2(fbm1(p), fbm1(p + 0.7*float2(1.0, 1.0)));

    rot(v, 1.0 + time*1.8);

    float2 vv = float2(fbm2(p + 3.7*v), fbm2(p + -2.7*v.yx + 0.7*float2(1.0, 1.0)));

    rot(vv, -1.0 + time*0.8);

    return fbm3(p + 9.0*vv);
}

float height(float2 p) {
    float a = 0.045*time;
    p += 9.0*float2(cos(a), sin(a));
    p *= 2.0;
    p += 13.0;
    float h = warp(p);
    float rs = 3.0;
    return 0.35*tanh_approx(rs*h)/rs;
}

float3 computeNormal(float2 p) {
    float2 eps = -float2(2.0/resolution.y, 0.0);

    float3 n;
    n.x = height(p + eps.xy) - height(p - eps.xy);
    n.y = 2.0*eps.x;
    n.z = height(p + eps.yx) - height(p - eps.yx);

    return normalize(n);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 q = fragCoord / resolution.xy;
    float2 p = -1. + 2. * q;
    p.x *= resolution.x / resolution.y;

    // lights positions
    const float3 lp1 = float3(2.1, -0.5, -0.1);
    const float3 lp2 = float3(-2.1, -0.5, -0.1);

    float h = height(p);
    float3 pp = float3(p.x, h, p.y);
    float ll1 = length(lp1.xz - pp.xz);
    float3 ld1 = normalize(lp1 - pp);
    float3 ld2 = normalize(lp2 - pp);

    float3 n = computeNormal(p);
    float diff1 = max(dot(ld1, n), 0.0);
    float diff2 = max(dot(ld2, n), 0.0);

    // lights colors
    float3 baseCol1 = float3(0.5, 0.4, 0.4);
    float3 baseCol2 = float3(0.1, 0.1, 0.1);

    float oh = height(p + ll1*0.05*normalize(ld1.xz));
    const float level0 = 0.0;
    const float level1 = 0.125;

    // VERY VERY fake shadows + hilight
    float3 scol1 = baseCol1*(smoothstep(level0, level1, h) - smoothstep(level0, level1, oh));
    float3 scol2 = baseCol2*(smoothstep(level0, level1, h) - smoothstep(level0, level1, oh));

    // specular and diffuse
    float3 color = float3(0.0, 0.0, 0.0);
    color += 0.55*baseCol1.zyx*pow(diff1, 1.0);
    color += 0.55*baseCol1.zyx*pow(diff1, 1.0);
    color += 0.55*baseCol2.zyx*pow(diff2, 1.0);
    color += 0.55*baseCol2.zyx*pow(diff2, 1.0);
    color += scol1*0.5;
    color += scol2*0.5;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_GreyLiquid() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 20, timeOffsetMax: 80, timeAccumulate: true}
}

_Shader_HLSL_HappyLittleWindowsTerminal() {
    return "
    (
// CC0: Happy little windows terminal
//  Based on: https://www.shadertoy.com/view/7tVfDV
//  Converted from: https://www.shadertoy.com/view/7tGfW3

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define TIME        time
#define RESOLUTION  float3(resolution, 1.0)
#define PI          3.141592654
#define TAU         (2.0*PI)
#define ROT(a)      float2x2(cos(a), -sin(a), sin(a), cos(a))

#define TOLERANCE       0.0005
#define MAX_RAY_LENGTH  10.0
#define MAX_RAY_MARCHES 60
#define NORM_OFF        0.005

static float g_mod = 2.5;

// License: WTFPL, author: sam hocevar
static const float4 hsv2rgb_K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
float3 hsv2rgb(float3 c) {
  float3 p = abs(frac(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
  return c.z * lerp(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
}
#define HSV2RGB(c)  (c.z * lerp(hsv2rgb_K.xxx, clamp(abs(frac(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

static const float hoff = 0.;

static const float3 skyCol     = HSV2RGB(float3(hoff+0.50, 0.90, 0.25));
static const float3 skylineCol = HSV2RGB(float3(hoff+0.70, 0.95, 0.5));
static const float3 sunCol     = HSV2RGB(float3(hoff+0.80, 0.90, 0.5));
static const float3 diffCol1   = HSV2RGB(float3(hoff+0.75, 0.90, 0.5));
static const float3 diffCol2   = HSV2RGB(float3(hoff+0.95, 0.90, 0.5));

static const float3 sunDir1    = normalize(float3(0., 0.05, -1.0));

static const float lpf = 5.0;
static const float3 lightPos1  = lpf*float3(+1.0, 2.0, 3.0);
static const float3 lightPos2  = lpf*float3(-1.0, 2.0, 3.0);

// License: Unknown, author: nmz (twitter: @stormoid)
float3 sRGB(float3 t) {
  return lerp(1.055*pow(t, (float3)(1./2.4)) - 0.055, 12.92*t, step(t, (float3)0.0031308));
}

// License: Unknown, author: Matt Taylor
float3 aces_approx(float3 v) {
  v = max(v, 0.0);
  v *= 0.6f;
  float a = 2.51f;
  float b = 0.03f;
  float c = 2.43f;
  float d = 0.59f;
  float e = 0.14f;
  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
}

float tanh_approx(float x) {
  float x2 = x*x;
  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
}

// License: MIT, author: Inigo Quilez
float rayPlane(float3 ro, float3 rd, float4 p) {
  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
}

// License: MIT, author: Inigo Quilez
float box(float2 p, float2 b) {
  float2 d = abs(p)-b;
  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

float3 render0(float3 ro, float3 rd) {
  float3 col = (float3)0;
  float sf = 1.0001-max(dot(sunDir1, rd), 0.0);
  col += skyCol*pow((1.0-abs(rd.y)), 8.0);
  col += (lerp(0.0025, 0.125, tanh_approx(.005/sf))/abs(rd.y))*skylineCol;
  sf *= sf;
  col += sunCol*0.00005/sf;

  float tp1  = rayPlane(ro, rd, float4(float3(0.0, -1.0, 0.0), 6.0));

  if (tp1 > 0.0) {
    float3 pos  = ro + tp1*rd;
    float2 pp = pos.xz;
    float db = box(pp, float2(5.0, 9.0))-3.0;

    col += (float3)4.0*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);
    col += (float3)0.8*skyCol*exp(-0.5*max(db, 0.0));
  }

  return clamp(col, 0.0, 10.0);
}

float df(float3 p) {
  float3 p0 = p;
  p0.xy = mul(ROT(0.2*p0.z-0.1*TIME), p0.xy);
  float d = -box(p0.xy, float2(g_mod, 1.25));
  return d;
}

float3 calcNormal(float3 pos) {
  float2 eps = float2(NORM_OFF, 0.0);
  float3 nor;
  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
  return normalize(nor);
}

float rayMarch(float3 ro, float3 rd, float initt) {
  float t = initt;
  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {
    if (t > MAX_RAY_LENGTH) {
      t = MAX_RAY_LENGTH;
      break;
    }
    float d = df(ro + rd*t);
    if (d < TOLERANCE) {
      break;
    }
    t += d;
  }
  return t;
}

float3 boxCol(float3 col, float3 nsp, float3 ro, float3 rd, float3 nnor, float3 nrcol) {
  float nfre  = 1.0+dot(rd, nnor);
  nfre        *= nfre;

  float3 nld1   = normalize(lightPos1-nsp);
  float3 nld2   = normalize(lightPos2-nsp);

  float ndif1 = max(dot(nld1, nnor), 0.0);
  ndif1       *= ndif1;

  float ndif2 = max(dot(nld2, nnor), 0.0);
  ndif2       *= ndif2;

  float3 scol = (float3)0;
  scol += diffCol1*ndif1;
  scol += diffCol2*ndif2;
  scol += 0.1*(skyCol+skylineCol);
  scol += nrcol*0.75*lerp((float3)0.25, float3(0.5, 0.5, 1.0), nfre);

  float3 pp = nsp-ro;

  col = lerp(col, scol, smoothstep(100.0, 20.0, dot(pp, pp)));

  return col;
}

float3 render1(float3 ro, float3 rd) {
  float3 col = 0.1*sunCol;

  float nt    = rayMarch(ro, rd, 0.0);
  if (nt < MAX_RAY_LENGTH) {
    float3 nsp    = ro + rd*nt;
    float3 nnor   = calcNormal(nsp);

    float3 nref   = reflect(rd, nnor);
    float nrt   = rayMarch(nsp, nref, 0.2);
    float3 nrcol  = render0(nsp, nref);

    if (nrt < MAX_RAY_LENGTH) {
      float3 nrsp   = nsp + nref*nrt;
      float3 nrnor  = calcNormal(nrsp);
      float3 nrref  = reflect(nref, nrnor);
      nrcol = boxCol(nrcol, nrsp, ro, nref, nrnor, render0(nrsp, nrref));
    }

    col = boxCol(col, nsp, ro, rd, nnor, nrcol);
  }

  return col;
}

float3 effect(float2 p) {
  const float fov = tan(TAU/(6.-0.6));
  const float3 up = float3(0.0, 1.0, 0.0);
  const float3 ro = float3(0.0, 0.0, 5.0);
  const float3 la = float3(0.0, 0.0, 0.);

  float3 ww = normalize(la - ro);
  float3 uu = normalize(cross(up, ww));
  float3 vv = cross(ww,uu);
  float3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);

  float3 col = render1(ro, rd);

  return col;
}

float4 PSMain(PSInput input) : SV_Target {
  float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
  float2 q = fragCoord/RESOLUTION.xy;
  float2 p = -1. + 2. * q;
  p.x *= RESOLUTION.x/RESOLUTION.y;
  g_mod = lerp(1.25, 2.5, 0.5+0.5*sin(TAU*TIME/66.0));
  float3 col = effect(p);
  // Saturate colors
  col -= 0.0333*float3(1.0, 2.0, 2.0);
  col = aces_approx(col);
  col = sRGB(col);

  // Darken/desaturate post-processing
  float lum = dot(col, float3(0.299, 0.587, 0.114));
  col = lerp(col, (float3)lum, desaturate);
  col = col * (1.0 - darken);

  // Alpha from brightness, premultiply
  float a = max(col.r, max(col.g, col.b));
  return float4(col * a, a);
}

    )"
}

_Shader_Meta_HappyLittleWindowsTerminal() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 0, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_Hell() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

float noise(float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);

    float2 uv = (p.xy + float2(37.0, 17.0) * p.z) + f.xy;
    float2 rg = iChannel0.SampleLevel(samp0, (uv + 0.5) / 256.0, 0.0).yx;
    return lerp(rg.x, rg.y, f.z);
}

float4 map(float3 p)
{
    float den = 0.2 - p.y;

    // invert space
    p = -7.0 * p / dot(p, p);

    // twist space
    float co = cos(den - 0.25 * time);
    float si = sin(den - 0.25 * time);
    p.xz = float2(co * p.x - si * p.z, si * p.x + co * p.z);

    // smoke
    float f;
    float3 q = p                            - float3(0.0, 1.0, 0.0) * time;
    f  = 0.50000 * noise(q); q = q * 2.02 - float3(0.0, 1.0, 0.0) * time;
    f += 0.25000 * noise(q); q = q * 2.03 - float3(0.0, 1.0, 0.0) * time;
    f += 0.12500 * noise(q); q = q * 2.01 - float3(0.0, 1.0, 0.0) * time;
    f += 0.06250 * noise(q); q = q * 2.02 - float3(0.0, 1.0, 0.0) * time;
    f += 0.03125 * noise(q);

    den = den + 4.0 * f;

    float3 col = lerp(float3(1.0, 0.9, 0.8), float3(0.4, 0.15, 0.1), den) + 0.05 * sin(p);

    return float4(col, den);
}

float3 raymarch(float3 ro, float3 rd, float2 pixel)
{
    float4 sum = (float4)0;

    // dithering
    float t = 0.05 * frac(10.5421 * dot(float2(0.0149451, 0.038921), pixel));

    for (int i = 0; i < 150; i++)
    {
        float3 pos = ro + t * rd;
        float4 col = map(pos);
        if (col.w > 0.0)
        {
            col.w = min(col.w, 1.0);

            col.xyz *= lerp(3.1 * float3(1.0, 0.5, 0.05), float3(0.48, 0.53, 0.5), clamp((pos.y - 0.2) / 1.9, 0.0, 1.0));

            col.a *= 0.6;
            col.rgb *= col.a;

            sum = sum + col * (1.0 - sum.a);
            if (sum.a > 0.99) break;
        }
        t += 0.05;
    }

    return clamp(sum.xyz, 0.0, 1.0);
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float2 p = (2.0 * fragCoord - resolution.xy) / resolution.y;

    // camera
    float3 ro = 4.0 * normalize(float3(1.0, 1.5, 0.0));
    float3 ta = float3(0.0, 1.0, 0.0) + 0.05 * (-1.0 + 2.0 * iChannel0.SampleLevel(samp0, time * float2(0.013, 0.008), 0.0).xyz);
    float cr = 0.5 * cos(0.7 * time);

    // build ray
    float3 ww = normalize(ta - ro);
    float3 uu = normalize(cross(float3(sin(cr), cos(cr), 0.0), ww));
    float3 vv = normalize(cross(ww, uu));
    float3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);

    // raymarch
    float3 col = raymarch(ro, rd, fragCoord);

    // color grade
    col = col * 0.5 + 0.5 * col * col * (3.0 - 2.0 * col);

    // vignetting
    float2 q = fragCoord.xy / resolution.xy;
    col *= 0.2 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1);

    // alpha from brightness, darken/desaturate, premultiply
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_Hell() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "hell_i0.png"}], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_HolographicLiquid() {
    return "
    (
// Holographic liquid — dennizor (Shadertoy 4fs3Rl)
// CC BY-NC-SA 3.0
// Converted from GLSL to HLSL for Alt-Tabby
// Domain warping based on https://iquilezles.org/articles/warp/warp.htm

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float noise(float2 x) {
    float2 p = floor(x);
    float2 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    float a = iChannel0.SampleLevel(samp0, (p + float2(0.5, 0.5)) / 256.0, 0.0).x;
    float b = iChannel0.SampleLevel(samp0, (p + float2(1.5, 0.5)) / 256.0, 0.0).x;
    float c = iChannel0.SampleLevel(samp0, (p + float2(0.5, 1.5)) / 256.0, 0.0).x;
    float d = iChannel0.SampleLevel(samp0, (p + float2(1.5, 1.5)) / 256.0, 0.0).x;
    return lerp(lerp(a, b, f.x), lerp(c, d, f.x), f.y);
}

static const float2x2 mtx = float2x2(0.80, 0.60, -0.60, 0.80);

float fbm(float2 p) {
    float f = 0.0;

    f += 0.500000 * noise(p); p = mul(p, mtx) * 2.02;
    f += 0.250000 * noise(p); p = mul(p, mtx) * 2.03;
    f += 0.125000 * noise(p); p = mul(p, mtx) * 2.01;
    f += 0.062500 * noise(p); p = mul(p, mtx) * 2.04;
    f += 0.031250 * noise(p); p = mul(p, mtx) * 2.01;
    f += 0.015625 * noise(p);

    return f / 0.96875;
}

struct PatternResult {
    float value;
    float2 q;
    float2 r;
    float2 g;
};

PatternResult pattern(float2 p, float t, float2 uv) {
    PatternResult res;
    res.q = float2(fbm(p), fbm(p + float2(10, 1.3)));

    res.r = float2(fbm(p + 4.0 * res.q + (float2)t + float2(1.7, 9.2)),
                   fbm(p + 4.0 * res.q + (float2)t + float2(8.3, 2.8)));
    res.g = float2(fbm(p + 2.0 * res.r + float2(t * 20.0, t * 20.0) + float2(2, 6)),
                   fbm(p + 2.0 * res.r + float2(t * 10.0, t * 10.0) + float2(5, 3)));
    res.value = fbm(p + 5.5 * res.g + float2(-t * 7.0, -t * 7.0));
    return res;
}

float3 getGradientColor(float t) {
    float3 color1 = float3(255.0, 199.0, 51.0) / 255.0;
    float3 color2 = float3(245.0, 42.0, 116.0) / 255.0;
    float3 color3 = float3(7.0, 49.0, 143.0) / 255.0;
    float3 color4 = float3(71.0, 205.0, 255.0) / 255.0;
    float3 color5 = float3(185.0, 73.0, 255.0) / 255.0;
    float3 color6 = float3(255.0, 180.0, 204.0) / 255.0;

    float ratio1 = 0.1;
    float ratio2 = 0.3;
    float ratio3 = 0.6;
    float ratio4 = 0.8;

    if (t < ratio1)
        return lerp(color1, color2, t / ratio1);
    else if (t < ratio2)
        return lerp(color2, color3, (t - ratio1) / (ratio2 - ratio1));
    else if (t < ratio3)
        return lerp(color3, color4, (t - ratio2) / (ratio3 - ratio2));
    else if (t < ratio4)
        return lerp(color4, color5, (t - ratio3) / (ratio4 - ratio3));
    else
        return lerp(color5, color6, (t - ratio4) / (1.0 - ratio4));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float zoom = 0.05;
    float speed = 0.2;
    float2 zoomedCoord = fragCoord * zoom;
    float adjustedTime = time * speed;
    float2 uv = zoomedCoord / resolution.xy;

    PatternResult pat = pattern(zoomedCoord * (float2)0.004, adjustedTime * 0.007, uv);

    float t = frac(pat.value * 2.6 - 1.0);
    float3 col = getGradientColor(t);

    col *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.1);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_HolographicLiquid() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "holographic_liquid_i0.png"}], timeOffsetMin: 30, timeOffsetMax: 90, timeAccumulate: true}
}

_Shader_HLSL_HorizonZeroDawnClouds2d() {
    return "
    (
// Horizon Zero Dawn Clouds 2D — perlin-worley 2D cloudscapes
// https://www.shadertoy.com/view/WddSDr
// Author: piyushslayer | License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define SAT(x) clamp(x, 0., 1.)

#define CLOUD_COVERAGE 0.64
#define CLOUD_DETAIL_COVERAGE .16
#define CLOUD_SPEED 1.6
#define CLOUD_DETAIL_SPEED 4.8
#define CLOUD_AMBIENT .01

// Hash functions by Dave_Hoskins
float hash12(float2 p)
{
    uint2 q = uint2(int2(p)) * uint2(1597334673u, 3812015801u);
    uint n = (q.x ^ q.y) * 1597334673u;
    return float(n) * (1.0 / float(0xffffffffu));
}

float2 hash22(float2 p)
{
    uint2 q = uint2(int2(p)) * uint2(1597334673u, 3812015801u);
    q = (q.x ^ q.y) * uint2(1597334673u, 3812015801u);
    return float2(q) * (1.0 / float(0xffffffffu));
}

float remap(float x, float a, float b, float c, float d)
{
    return (((x - a) / (b - a)) * (d - c)) + c;
}

// Noise function by morgan3d
float perlinNoise(float2 x) {
    float2 i = floor(x);
    float2 f = frac(x);

    float a = hash12(i);
    float b = hash12(i + float2(1.0, 0.0));
    float c = hash12(i + float2(0.0, 1.0));
    float d = hash12(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float2 curlNoise(float2 uv)
{
    float2 eps = float2(0., 1.);

    float n1, n2, a, b;
    n1 = perlinNoise(uv + eps);
    n2 = perlinNoise(uv - eps);
    a = (n1 - n2) / (2. * eps.y);

    n1 = perlinNoise(uv + eps.yx);
    n2 = perlinNoise(uv - eps.yx);
    b = (n1 - n2) / (2. * eps.y);

    return float2(a, -b);
}

float worleyNoise(float2 uv, float freq, float t, bool useCurl)
{
    uv *= freq;
    uv += t + (useCurl ? curlNoise(uv * 2.) : float2(0., 0.));

    float2 id = floor(uv);
    float2 gv = frac(uv);

    float minDist = 100.;
    for (float y = -1.; y <= 1.; y += 1.)
    {
        for (float x = -1.; x <= 1.; x += 1.)
        {
            float2 offset = float2(x, y);
            float2 h = hash22(id + offset) * .8 + .1;
            h += offset;
            float2 d = gv - h;
            minDist = min(minDist, dot(d, d));
        }
    }

    return minDist;
}

float perlinFbm(float2 uv, float freq, float t)
{
    uv *= freq;
    uv += t;
    float amp = .5;
    float n = 0.;
    for (int i = 0; i < 8; ++i)
    {
        n += amp * perlinNoise(uv);
        uv *= 1.9;
        amp *= .55;
    }
    return n;
}

float4 worleyFbm(float2 uv, float freq, float t, bool useCurl)
{
    float worley0 = 0.;
    if (freq < 4.)
        worley0 = 1. - worleyNoise(uv, freq * 1., t * 1., false);
    float worley1 = 1. - worleyNoise(uv, freq * 2., t * 2., useCurl);
    float worley2 = 1. - worleyNoise(uv, freq * 4., t * 4., useCurl);
    float worley3 = 1. - worleyNoise(uv, freq * 8., t * 8., useCurl);
    float worley4 = 1. - worleyNoise(uv, freq * 16., t * 16., useCurl);

    float fbm0 = (freq > 4. ? 0. : worley0 * .625 + worley1 * .25 + worley2 * .125);
    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;
    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;
    float fbm3 = worley3 * .75 + worley4 * .25;
    return float4(fbm0, fbm1, fbm2, fbm3);
}

float clouds(float2 uv, float t)
{
    float coverage = hash12(float2(uv.x * resolution.y / resolution.x, uv.y)) *
        .1 + ((SAT(CLOUD_COVERAGE) * 1.6) * .5 + .5);
    float pfbm = perlinFbm(uv, 2., t);
    float4 wfbmLowFreq = worleyFbm(uv, 1.6, t * CLOUD_SPEED, false);
    float4 wfbmHighFreq = worleyFbm(uv, 8., t * CLOUD_DETAIL_SPEED, true);
    float perlinWorley = remap(abs(pfbm * 2. - 1.),
                               1. - wfbmLowFreq.r, 1., 0., 1.);
    perlinWorley = remap(perlinWorley, 1. - coverage, 1., 0., 1.) * coverage;
    float worleyLowFreq = wfbmLowFreq.g * .625 + wfbmLowFreq.b * .25
        + wfbmLowFreq.a * .125;
    float worleyHighFreq = wfbmHighFreq.g * .625 + wfbmHighFreq.b * .25
        + wfbmHighFreq.a * .125;
    float c = remap(perlinWorley, (worleyLowFreq - 1.) * .64, 1., 0., 1.);
    c = remap(c, worleyHighFreq * CLOUD_DETAIL_COVERAGE, 1., 0., 1.);
    return max(0., c);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 uv = fragCoord / resolution.y;

    // Sun position: slow orbit in upper portion of screen
    float aspect = resolution.x / resolution.y;
    float2 m = float2(
        aspect * 0.5 + sin(time * 0.05) * aspect * 0.35,
        0.6 + cos(time * 0.07) * 0.15);

    float t = fmod(time + 600., 7200.) * .03;

    // 2D ray march variables
    float2 marchDist = float2(.35 * max(resolution.x, resolution.y), .35 * max(resolution.x, resolution.y)) / resolution;
    float steps = 10.;
    float stepsInv = 1. / steps;
    float2 sunDir = normalize(m - uv) * marchDist * stepsInv;
    float2 marchUv = uv;
    float cloudColor = 1.;
    float cloudShape = clouds(uv, t);

    // 2D ray march lighting loop
    for (float i = 0.; i < marchDist.x; i += marchDist.x * stepsInv)
    {
        marchUv += sunDir * i;
        float c = clouds(marchUv, t);
        cloudColor *= clamp(1. - c, 0., 1.);
    }

    cloudColor += CLOUD_AMBIENT;
    // beer's law + powder sugar
    cloudColor = exp(-cloudColor) * (1. - exp(-cloudColor * 2.)) * 2.;
    cloudColor *= cloudShape;

    float3 skyCol = lerp(float3(.1, .5, .9), float3(.1, .1, .9), uv.y);
    float3 col = float3(0., 0., 0.);
    col = skyCol + cloudShape;
    col = lerp(float3(cloudColor, cloudColor, cloudColor) * 25., col, 1. - cloudShape);
    float sun = .002 / pow(length(uv - m), 1.7);
    col += (1. - smoothstep(.0, .4, cloudShape)) * sun;
    col = sqrt(col);

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_HorizonZeroDawnClouds2d() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 40, timeOffsetMax: 120}
}

_Shader_HLSL_HudMatrix() {
    return "
    (
// HUD Matrix
// https://www.shadertoy.com/view/Nff3Rn
// by proas61

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI 3.14159265359

float hash(float n) { return frac(sin(n) * 43758.5453123); }
float hash21(float2 p) { return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453); }

float bandMaskHard(float y, float y0, float thick) {
    return step(abs(y - y0), thick);
}

float glyph(float2 uv, float id) {
    uv *= float2(5.0, 7.0);
    float2 gv = floor(uv);
    float2 lv = frac(uv);

    float h = hash21(gv + id * 13.1);
    float on = step(0.55, h);

    float edge = smoothstep(0.1, 0.0, min(min(lv.x, 1.0 - lv.x), min(lv.y, 1.0 - lv.y)));
    return on * edge;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float2 uv0 = fragCoord.xy / resolution.xy;
    float2 uv = uv0 * 0.64;

    uv.x *= resolution.x / resolution.y;

    // ---------------- SCROLL ----------------
    float scrollSpeed = 0.128;
    uv.y += time * scrollSpeed;

    float row = floor(uv.y * 20.0);
    float col = floor(uv.x * 30.0);

    float2 cell = float2(col, row);
    float id = hash21(cell);

    float2 localUV = frac(float2(uv.x * 30.0, uv.y * 20.0));

    // ---------------- GLITCH ----------------
    float t = floor(time * 14.0);

    float glitchCount = 3.0;
    float glitchThickness = 0.02;
    float glitchOffset = 0.25;

    float globalGate = step(3.45, hash(t * 2.1));

    float2 uvGlitch = uv;

    for (float i = 0.0; i < glitchCount; i++) {
        float gid = i + t * 17.13;

        float y0 = hash(gid) * 2.0 - 1.0;
        float dir = (hash(gid * 3.7) < 0.5) ? -1.0 : 1.0;
        float power = lerp(0.3, 1.0, hash(gid * 9.1));

        float m = bandMaskHard(uv.y * 2.0 - 1.0, y0, glitchThickness);

        uvGlitch.x += globalGate * m * dir * glitchOffset * power;
    }

    float2 localGlitch = frac(float2(uvGlitch.x * 36.0, uvGlitch.y * 24.0));

    float gR = glyph(localGlitch + float2(0.01, 0.0), id);
    float gG = glyph(localGlitch, id);
    float gB = glyph(localGlitch - float2(0.01, 0.0), id);

    // depth fade
    float fade = exp(-uv.x * 0.8);

    // flicker
    float flick = 0.85 + 0.25 * sin(time * 8.0 + row);

    float3 colOut = float3(gR * 0.3, gG * 0.8, gB * 0.7) * fade * flick;

    // random flash burst
    colOut *= 1.0 + 0.5 * step(0.94, hash(t * 5.7));

    // Darken/desaturate post-processing
    float lum = dot(colOut, float3(0.299, 0.587, 0.114));
    colOut = lerp(colOut, float3(lum, lum, lum), desaturate);
    colOut = colOut * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(colOut.r, max(colOut.g, colOut.b));
    return float4(colOut * a, a);
}

    )"
}

_Shader_Meta_HudMatrix() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_InSpace() {
    return "
    (
// In Space - by morimea (Danil)
// https://www.shadertoy.com/view/sldGDf
// License: CC0
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define SS(x, y, z) smoothstep(x, y, z)
#define MD(a) float2x2(cos(a), sin(a), -sin(a), cos(a))

static const float divx = 35.0;
#define polar_line_scale (2.0/divx)
static const float zoom_nise = 9.0;

// Rotation matrices
float3x3 rotx(float a) {
    float s = sin(a); float c = cos(a);
    return float3x3(1, 0, 0,  0, c, -s,  0, s, c);
}

float3x3 roty(float a) {
    float s = sin(a); float c = cos(a);
    return float3x3(c, 0, -s,  0, 1, 0,  s, 0, c);
}

float3x3 rotz(float a) {
    float s = sin(a); float c = cos(a);
    return float3x3(c, -s, 0,  s, c, 0,  0, 0, 1);
}

float linearstep(float begin, float end, float t) {
    return clamp((t - begin) / (end - begin), 0.0, 1.0);
}

float hash(float2 p) {
    float3 p3 = frac(float3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return -1.0 + 2.0 * frac((p3.x + p3.y) * p3.z);
}

float noise(float2 p) {
    float2 i = floor(p);
    float2 f = frac(p);
    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(lerp(hash(i + float2(0.0, 0.0)),
                     hash(i + float2(1.0, 0.0)), u.x),
                lerp(hash(i + float2(0.0, 1.0)),
                     hash(i + float2(1.0, 1.0)), u.x), u.y);
}

float fbm(float2 p) {
    p *= 0.25;
    float s = 0.5;
    float f = 0.0;
    for (int i = 0; i < 4; i++) {
        f += s * noise(p);
        s *= 0.8;
        p = 2.01 * mul(float2x2(0.8, -0.6, 0.6, 0.8), p);
    }
    return 0.5 + 0.5 * f;
}

float2 ToPolar(float2 v) {
    return float2(atan2(v.y, v.x) / 3.1415926, length(v));
}

float3 fcos(float3 x) {
    float3 w = fwidth(x);
    return cos(x) * smoothstep(3.14 * 2.0, 0.0, w);
}

float3 getColor(float t) {
    float3 col = float3(0.3, 0.4, 0.5);
    col += 0.12 * fcos(6.28318 * t *   1.0 + float3(0.0, 0.8, 1.1));
    col += 0.11 * fcos(6.28318 * t *   3.1 + float3(0.3, 0.4, 0.1));
    col += 0.10 * fcos(6.28318 * t *   5.1 + float3(0.1, 0.7, 1.1));
    col += 0.10 * fcos(6.28318 * t *  17.1 + float3(0.2, 0.6, 0.7));
    col += 0.10 * fcos(6.28318 * t *  31.1 + float3(0.1, 0.6, 0.7));
    col += 0.10 * fcos(6.28318 * t *  65.1 + float3(0.0, 0.5, 0.8));
    col += 0.10 * fcos(6.28318 * t * 115.1 + float3(0.1, 0.4, 0.7));
    col += 0.10 * fcos(6.28318 * t * 265.1 + float3(1.1, 1.4, 2.7));
    return col;
}

float3 pal(float t, float3 a, float3 b, float3 c, float3 d) {
    return a + b * cos(6.28318 * (c * t + d));
}

float3 get_noise(float2 p, float timer) {
    float2 res = resolution / resolution.y;
    float2 shiftx = res * 0.5 * 1.25 + 0.5 * (0.5 + 0.5 * float2(sin(timer * 0.0851), cos(timer * 0.0851)));
    float2 shiftx2 = res * 0.5 * 2.0 + 0.5 * (0.5 + 0.5 * float2(sin(timer * 0.0851), cos(timer * 0.0851)));
    float2 tp = p + shiftx;
    float atx = (atan2(tp.x + 0.0001 * (1.0 - abs(sign(tp.x))), tp.y) / 3.141592653) * 0.5 + frac(timer * 0.025);
    float2 puv = ToPolar(tp);
    puv.y += atx;
    puv.x *= 0.5;
    float2 tuv = puv * divx;
    float idx = fmod(floor(tuv.y), divx) + 200.0;
    puv.y = frac(puv.y);
    puv.x = abs(frac(puv.x / divx) - 0.5) * divx;
    puv.x += -0.5 * timer * (0.075 - 0.0025 * max((min(idx, 16.0) + 2.0 * sin(idx / 5.0)), 0.0));
    float2 idxVec = (float2)(4.0 + 2.0 * idx);
    return float3(
        SS(0.43, 0.73, fbm(mul((p * 0.5 + shiftx2), MD(-timer * 0.013951 * 10.0 / zoom_nise)) * zoom_nise * 2.0 + idxVec)),
        SS(0.543, 0.73, fbm(mul((p * 0.5 + shiftx2), MD(timer * 0.02751 * 10.0 / zoom_nise)) * zoom_nise * 1.4 + idxVec)),
        fbm(idxVec * puv * zoom_nise / 100.0));
}

float4 get_lines_color(float2 p, float3 n, float timer) {
    float2 res = resolution / resolution.y;

    float3 col = (float3)0;
    float a = 1.0;

    float2 shiftx = res * 0.5 * 1.25 + 0.5 * (0.5 + 0.5 * float2(sin(timer * 0.0851), cos(timer * 0.0851)));
    float2 tp = p + shiftx;
    float atx = (atan2(tp.x + 0.0001 * (1.0 - abs(sign(tp.x))), tp.y) / 3.141592653) * 0.5 + frac(timer * 0.025);
    float2 puv = ToPolar(tp);
    puv.y += atx;
    puv.x *= 0.5;
    float2 tuv = puv * divx;
    float idx = fmod(floor(tuv.y), divx) + 1.0;

    // thin lines
    float d = length(tp);
    d += atx;
    float v = sin(3.141592653 * 2.0 * divx * 0.5 * d + 0.5 * 3.141592653);
    float fv = fwidth(v);
    fv += 0.0001 * (1.0 - abs(sign(fv)));
    d = 1.0 - SS(-1.0, 1.0, 0.3 * abs(v) / fv);

    float d2 = 1.0 - SS(0.0, 0.473, abs(frac(tuv.y) - 0.5));
    tuv.x += 3.5 * timer * (0.01 + divx / 200.0) - 0.435 * idx;

    // lines
    tuv.x = abs(frac(tuv.x / divx) - 0.5) * divx;
    float ld = SS(0.1, 0.9, (frac(polar_line_scale * tuv.x * max(idx, 1.0) / 10.0 + idx / 3.0))) *
               (1.0 - SS(0.98, 1.0, (frac(polar_line_scale * tuv.x * max(idx, 1.0) / 10.0 + idx / 3.0))));

    tuv.x += 1.0 * timer * (0.01 + divx / 200.0) - 1.135 * idx;
    ld *= 1.0 - SS(0.1, 0.9, (frac(polar_line_scale * tuv.x * max(idx, 1.0) / 10.0 + idx / 6.5))) *
                (1.0 - SS(0.98, 1.0, (frac(polar_line_scale * tuv.x * max(idx, 1.0) / 10.0 + idx / 6.5))));

    float ld2 = 0.1 / (max(abs(frac(tuv.y) - 0.5) * 1.46, 0.0001) + ld);
    ld = 0.1 / ((max(abs(frac(tuv.y) - 0.5) * 1.46, 0.0001) + ld) * (2.5 - (n.y + 1.0 * max(n.y, n.z))));

    ld = min(ld, 13.0);
    ld *= SS(0.0, 0.15, 0.5 - abs(frac(tuv.y) - 0.5));

    // noise
    d *= n.z * n.z * 2.0;
    float d3 = (d * n.x * n.y + d * n.y * n.y + (d2 * ld2 + d2 * ld * n.z * n.z));
    d = (d * n.x * n.y + d * n.y * n.y + (d2 * ld + d2 * ld * n.z * n.z));

    a = clamp(d, 0.0, 1.0);

    puv.y = lerp(frac(puv.y), frac(puv.y + 0.5), SS(0.0, 0.1, abs(frac(puv.y) - 0.5)));
    col = getColor(0.54 * length(puv.y));

    col = 3.5 * a * col * col + 2.0 * (lerp(col.bgr, col.grb, 0.5 + 0.5 * sin(timer * 0.1)) - col * 0.5) * col;

    d3 = min(d3, 4.0);
    d3 *= (d3 * n.y - (n.y * n.x * n.z));
    d3 *= n.y / max(n.z + n.x, 0.001);
    d3 = max(d3, 0.0);
    float3 col2 = 0.5 * d3 * float3(0.3, 0.7, 0.98);
    col2 = clamp(col2, 0.0, 2.0);

    col = col2 * 0.5 * (0.5 - 0.5 * cos((timer * 0.48 * 2.0))) + lerp(col, col2, 0.45 + 0.45 * cos((timer * 0.48 * 2.0)));

    col = clamp(col, 0.0, 1.0);

    return float4(col, a);
}

float4 planet(float3 ro, float3 rd, float timer) {
    float3 lgt = float3(-0.523, 0.41, -0.747);
    float sd = clamp(dot(lgt, rd) * 0.5 + 0.5, 0.0, 1.0);
    float far_dist = 400.0;
    float dtp = 13.0 - (ro + rd * far_dist).y * 3.5;
    float hori = (linearstep(-1900.0, 0.0, dtp) - linearstep(11.0, 700.0, dtp)) * 1.0;
    hori *= pow(abs(sd), 0.04);
    hori = abs(hori);

    float3 col = (float3)0;
    col += pow(hori, 200.0) * float3(0.3, 0.7, 1.0) * 3.0;
    col += pow(hori, 25.0) * float3(0.5, 0.5, 1.0) * 0.5;
    col += pow(hori, 7.0) * pal(timer * 0.48 * 0.1, float3(0.8, 0.5, 0.04), float3(0.3, 0.04, 0.82), float3(2.0, 1.0, 1.0), float3(0.0, 0.25, 0.25)) * 1.0;
    col = clamp(col, 0.0, 1.0);

    float t = fmod(timer, 15.0);
    float t2 = fmod(timer + 7.5, 15.0);
    float td = 0.071 * dtp / far_dist + 5.1;
    float td2 = 0.1051 * dtp / far_dist + t * 0.00715 + 0.025;
    float td3 = 0.1051 * dtp / far_dist + t2 * 0.00715 + 0.025;
    float3 c1 = getColor(td);
    float3 c2 = getColor(td2);
    float3 c3 = getColor(td3);
    c2 = lerp(c2, c3.bbr, abs(t - 7.5) / 7.5);

    c2 = clamp(c2, 0.0001, 1.0);

    col += sd * hori * clamp((c1 / (2.0 * c2)), 0.0, 3.0) * SS(0.0, 50.0, dtp);
    col = clamp(col, 0.0, 1.0);

    float a = 1.0;
    a = (0.15 + 0.95 * (1.0 - sd)) * hori * (1.0 - SS(0.0, 25.0, dtp));
    a = clamp(a, 0.0, 1.0);

    return float4(col, a);
}

float3 cam(float2 uv, float timer) {
    timer *= 0.48;
    float2 im = float2(cos(fmod(timer, 3.1415926)), -0.02 + 0.06 * cos(timer * 0.17));
    im *= 3.14159263;
    im.y = -im.y;

    float fov = 90.0;
    float aspect = 1.0;
    float screenSize = (1.0 / (tan(((180.0 - fov) * (3.14159263 / 180.0)) / 2.0)));
    float3 rd = normalize(float3(uv * screenSize, 1.0 / aspect));
    rd = mul(mul(mul(roty(-im.x), rotx(im.y)), rotz(0.32 * sin(timer * 0.07))), rd);
    return rd;
}

static const float3x3 ACESInputMat = float3x3(
    0.59719, 0.07600, 0.02840,
    0.35458, 0.90834, 0.13383,
    0.04823, 0.01566, 0.83777);

static const float3x3 ACESOutputMat = float3x3(
     1.60475, -0.10208, -0.00327,
    -0.53108,  1.10813, -0.07276,
    -0.07367, -0.00605,  1.07602);

float3 RRTAndODTFit(float3 v) {
    float3 a = v * (v + 0.0245786) - 0.000090537;
    float3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
    return a / b;
}

float3 ACESFitted(float3 color) {
    color = mul(color, ACESInputMat);
    color = RRTAndODTFit(color);
    color = mul(color, ACESOutputMat);
    color = clamp(color, 0.0, 1.0);
    return color;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float timer = 0.65 * time + 220.0;
    float2 res = resolution / resolution.y;
    float2 uv = fragCoord.xy / resolution.y - 0.5 * res;

    float3 noisev = get_noise(uv, timer);
    float4 lcol = get_lines_color(uv, noisev, timer);

    float3 ro = float3(1.0, 40.0, 1.0);
    float3 rd = cam(uv, timer);
    float4 planetc = planet(ro, rd, timer);

    float3 col = lcol.rgb * planetc.a * 0.75 + 0.5 * lcol.rgb * min(12.0 * planetc.a, 1.0) + planetc.rgb;
    col = clamp(col, 0.0, 1.0);

    col = col * 0.85 + 0.15 * col * col;

    // Extra color correction
    col = col * 0.15 + col * col * 0.65 + (col * 0.7 + 0.3) * ACESFitted(col);

    // Darken/desaturate for Alt-Tabby compositing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Brightness-based alpha with premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_InSpace() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 0, timeOffsetMax: 10, timeAccumulate: true}
}

_Shader_HLSL_InsideTheMatrix() {
    return "
    (
// Inside the Matrix - Converted from Shadertoy (4t3BWl) by And390
// License: CC BY-NC-SA 3.0
// Uses runes code by FabriceNeyret2 / otaviogood

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const int ITERATIONS = 40;
static const float SPEED = 1.0;

static const float STRIP_CHARS_MIN =  7.0;
static const float STRIP_CHARS_MAX = 40.0;
static const float STRIP_CHAR_HEIGHT = 0.15;
static const float STRIP_CHAR_WIDTH = 0.10;
static const float ZCELL_SIZE = 1.0 * (STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX);
static const float XYCELL_SIZE = 12.0 * STRIP_CHAR_WIDTH;

static const int BLOCK_SIZE = 10;
static const int BLOCK_GAP = 2;

static const float WALK_SPEED = 1.0 * XYCELL_SIZE;
static const float BLOCKS_BEFORE_TURN = 3.0;

static const float PI = 3.14159265359;


//        ----  random  ----

float hash(float v) {
    return frac(sin(v) * 43758.5453123);
}

float hash_v2(float2 v) {
    return hash(dot(v, float2(5.3983, 5.4427)));
}

float2 hash2(float2 v)
{
    // GLSL: v = vec2(v * mat2(127.1, 311.7, 269.5, 183.3))
    // mat2 in GLSL is column-major: col0=(127.1, 311.7), col1=(269.5, 183.3)
    // v * M in GLSL = mul(v, transpose(M)) in HLSL = mul(v, float2x2(127.1, 269.5, 311.7, 183.3))
    float2x2 m = float2x2(127.1, 269.5, 311.7, 183.3);
    v = mul(v, m);
    return frac(sin(v) * 43758.5453123);
}

float4 hash4_v2(float2 v)
{
    // GLSL: vec4(v * mat4x2(...)) where mat4x2 is 4 columns, 2 rows
    // v * mat4x2 in GLSL: v(1x2) * mat(2x4) -> 1x4
    // In HLSL: mul(v, float2x4(...))
    // GLSL mat4x2 column-major: col0=(127.1,311.7), col1=(269.5,183.3), col2=(113.5,271.9), col3=(246.1,124.6)
    // For v*M in GLSL -> mul(v, transpose(M_hlsl)) but we need to set up correctly
    // GLSL v*mat4x2: result[j] = sum_i(v[i] * mat[j][i]) = v.x*mat[j][0] + v.y*mat[j][1]
    // So result = float4(dot(v, col0), dot(v, col1), dot(v, col2), dot(v, col3))
    float4 p = float4(
        dot(v, float2(127.1, 311.7)),
        dot(v, float2(269.5, 183.3)),
        dot(v, float2(113.5, 271.9)),
        dot(v, float2(246.1, 124.6)));

    return frac(sin(p) * 43758.5453123);
}

float4 hash4_v3(float3 v)
{
    // GLSL: vec4(v * mat4x3(...)) where mat4x3 is 4 columns, 3 rows
    // v*mat4x3: result[j] = v.x*mat[j][0] + v.y*mat[j][1] + v.z*mat[j][2]
    // col0=(127.1,311.7,74.7), col1=(269.5,183.3,246.1), col2=(113.5,271.9,124.6), col3=(271.9,269.5,311.7)
    float4 p = float4(
        dot(v, float3(127.1, 311.7, 74.7)),
        dot(v, float3(269.5, 183.3, 246.1)),
        dot(v, float3(113.5, 271.9, 124.6)),
        dot(v, float3(271.9, 269.5, 311.7)));

    return frac(sin(p) * 43758.5453123);
}


//        ----  symbols  ----

float rune_line(float2 p, float2 a, float2 b) {
    p -= a; b -= a;
    float h = clamp(dot(p, b) / dot(b, b), 0.0, 1.0);
    return length(p - b * h);
}

float rune(float2 U, float2 seed, float highlight)
{
    float d = 1e5;
    for (int i = 0; i < 4; i++)
    {
        float4 pos = hash4_v2(seed);
        seed += 1.0;

        if (i == 0) pos.y = 0.0;
        if (i == 1) pos.x = 0.999;
        if (i == 2) pos.x = 0.0;
        if (i == 3) pos.y = 0.999;

        float4 snaps = float4(2, 3, 2, 3);
        pos = (floor(pos * snaps) + 0.5) / snaps;

        if (any(pos.xy != pos.zw))
            d = min(d, rune_line(U, pos.xy, pos.zw + 0.001));
    }
    return smoothstep(0.1, 0.0, d) + highlight * smoothstep(0.4, 0.0, d);
}

float random_char(float2 outer, float2 inner, float highlight) {
    float2 seed = float2(dot(outer, float2(269.5, 183.3)), dot(outer, float2(113.5, 271.9)));
    return rune(inner, seed, highlight);
}


//        ----  digital rain  ----

float3 rain(float3 ro3, float3 rd3, float t_time) {
    float4 result = (float4)0;

    float2 ro2 = ro3.xy;
    float2 rd2 = normalize(rd3.xy);

    bool prefer_dx = abs(rd2.x) > abs(rd2.y);
    float t3_to_t2 = prefer_dx ? rd3.x / rd2.x : rd3.y / rd2.y;

    int3 cell_side = int3(step(0.0, rd3));
    int3 cell_shift = int3(sign(rd3));

    float t2 = 0.0;
    int2 next_cell = int2(floor(ro2 / XYCELL_SIZE));

    for (int i = 0; i < ITERATIONS; i++) {
        int2 cell = next_cell;
        float t2s = t2;

        float2 side = float2(next_cell + cell_side.xy) * XYCELL_SIZE;
        float2 t2_side = (side - ro2) / rd2;
        if (t2_side.x < t2_side.y) {
            t2 = t2_side.x;
            next_cell.x += cell_shift.x;
        } else {
            t2 = t2_side.y;
            next_cell.y += cell_shift.y;
        }

        float2 cell_in_block = frac(float2(cell) / (float)BLOCK_SIZE);
        float gap = (float)BLOCK_GAP / (float)BLOCK_SIZE;
        if (cell_in_block.x < gap || cell_in_block.y < gap || (cell_in_block.x < (gap + 0.1) && cell_in_block.y < (gap + 0.1))) {
            continue;
        }

        float t3s = t2s / t3_to_t2;

        float pos_z = ro3.z + rd3.z * t3s;
        float xycell_hash = hash_v2(float2(cell));
        float z_shift = xycell_hash * 11.0 - t_time * (0.5 + xycell_hash * 1.0 + xycell_hash * xycell_hash * 1.0 + pow(xycell_hash, 16.0) * 3.0);
        float char_z_shift = floor(z_shift / STRIP_CHAR_HEIGHT);
        z_shift = char_z_shift * STRIP_CHAR_HEIGHT;
        int zcell = int(floor((pos_z - z_shift) / ZCELL_SIZE));

        for (int j = 0; j < 2; j++) {
            float4 cell_hash = hash4_v3(float3(int3(cell, zcell)));
            float4 cell_hash2 = frac(cell_hash * float4(127.1, 311.7, 271.9, 124.6));

            float chars_count = cell_hash.w * (STRIP_CHARS_MAX - STRIP_CHARS_MIN) + STRIP_CHARS_MIN;
            float target_length = chars_count * STRIP_CHAR_HEIGHT;
            float target_rad = STRIP_CHAR_WIDTH / 2.0;
            float target_z = ((float)zcell * ZCELL_SIZE + z_shift) + cell_hash.z * (ZCELL_SIZE - target_length);
            float2 target = float2(cell) * XYCELL_SIZE + target_rad + cell_hash.xy * (XYCELL_SIZE - target_rad * 2.0);

            float2 s = target - ro2;
            float tmin = dot(s, rd2);
            if (tmin >= t2s && tmin <= t2) {
                float u = s.x * rd2.y - s.y * rd2.x;
                if (abs(u) < target_rad) {
                    u = (u / target_rad + 1.0) / 2.0;
                    float z = ro3.z + rd3.z * tmin / t3_to_t2;
                    float v = (z - target_z) / target_length;
                    if (v >= 0.0 && v < 1.0) {
                        float c = floor(v * chars_count);
                        float q = frac(v * chars_count);
                        float2 char_hash = hash2(float2(c + char_z_shift, cell_hash2.x));
                        if (char_hash.x >= 0.1 || c == 0.0) {
                            float time_factor = floor(c == 0.0 ? t_time * 5.0 :
                                    t_time * (1.0 * cell_hash2.z +
                                            cell_hash2.w * cell_hash2.w * 4.0 * pow(char_hash.y, 4.0)));
                            float a = random_char(float2(char_hash.x, time_factor), float2(u, q), max(1.0, 3.0 - c / 2.0) * 0.2);
                            a *= clamp((chars_count - 0.5 - c) / 2.0, 0.0, 1.0);
                            if (a > 0.0) {
                                float attenuation = 1.0 + pow(0.06 * tmin / t3_to_t2, 2.0);
                                float3 col = (c == 0.0 ? float3(0.67, 1.0, 0.82) : float3(0.25, 0.80, 0.40)) / attenuation;
                                float a1 = result.a;
                                result.a = a1 + (1.0 - a1) * a;
                                result.xyz = (result.xyz * a1 + col * (1.0 - a1) * a) / result.a;
                                if (result.a > 0.98) return result.xyz;
                            }
                        }
                    }
                }
            }
            zcell += cell_shift.z;
        }
    }

    return result.xyz * result.a;
}


//        ----  main, camera  ----

float2 rotate2d(float2 v, float a) {
    float s = sin(a);
    float c = cos(a);
    // GLSL mat2(c,-s,s,c) is column-major: col0=(c,s), col1=(-s,c)
    // v * M in GLSL -> mul(v, transpose(M))
    // transpose: row0=(c,s), row1=(-s,c) -> float2x2(c,-s,s,c) in HLSL row-major
    // But mul(v, M) in HLSL does v*M with M as row-major
    // We need: result.x = v.x*c + v.y*s, result.y = v.x*(-s) + v.y*c
    float2x2 m = float2x2(c, -s, s, c);
    return mul(v, m);
}

float3 rotateX(float3 v, float a) {
    float s = sin(a);
    float c = cos(a);
    // GLSL: mat3(1,0,0, 0,c,-s, 0,s,c) column-major
    // col0=(1,0,0), col1=(0,c,s), col2=(0,-s,c)
    // v * M -> mul(v, transpose(M))
    // transpose: row0=(1,0,0), row1=(0,c,s), row2=(0,-s,c)
    float3x3 m = float3x3(1.0, 0.0, 0.0,
                           0.0, c, s,
                           0.0, -s, c);
    return mul(v, m);
}

float3 rotateY(float3 v, float a) {
    float s = sin(a);
    float c = cos(a);
    // GLSL: mat3(c,0,-s, 0,1,0, s,0,c) column-major
    // col0=(c,0,s), col1=(0,1,0), col2=(-s,0,c)
    // transpose: row0=(c,0,s), row1=(0,1,0), row2=(-s,0,c)
    float3x3 m = float3x3(c, 0.0, s,
                           0.0, 1.0, 0.0,
                           -s, 0.0, c);
    return mul(v, m);
}

float3 rotateZ(float3 v, float a) {
    float s = sin(a);
    float c = cos(a);
    // GLSL: mat3(c,-s,0, s,c,0, 0,0,1) column-major
    // col0=(c,s,0), col1=(-s,c,0), col2=(0,0,1)
    // transpose: row0=(c,s,0), row1=(-s,c,0), row2=(0,0,1)
    float3x3 m = float3x3(c, s, 0.0,
                           -s, c, 0.0,
                           0.0, 0.0, 1.0);
    return mul(v, m);
}

float smoothstep1(float x) {
    return smoothstep(0.0, 1.0, x);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    if (STRIP_CHAR_WIDTH > XYCELL_SIZE || STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX > ZCELL_SIZE) {
        return float4(1.0, 0.0, 0.0, 1.0);
    }

    float2 uv = (fragCoord.xy * 2.0 - resolution.xy) / resolution.y;

    float t_time = time * SPEED;

    const float turn_rad = 0.25 / BLOCKS_BEFORE_TURN;
    const float turn_abs_time = (PI / 2.0 * turn_rad) * 1.5;
    const float turn_time = turn_abs_time / (1.0 - 2.0 * turn_rad + turn_abs_time);

    float level1_size = (float)BLOCK_SIZE * BLOCKS_BEFORE_TURN * XYCELL_SIZE;
    float level2_size = 4.0 * level1_size;
    float gap_size = (float)BLOCK_GAP * XYCELL_SIZE;

    float3 ro = float3(gap_size / 2.0, gap_size / 2.0, 0.0);
    float3 rd = float3(uv.x, 2.0, uv.y);

    float tq = frac(t_time / (level2_size * 4.0) * WALK_SPEED);
    float t8 = frac(tq * 4.0);
    float t1 = frac(t8 * 8.0);

    float2 prev;
    float2 dir;
    if (tq < 0.25) {
        prev = float2(0.0, 0.0);
        dir = float2(0.0, 1.0);
    } else if (tq < 0.5) {
        prev = float2(0.0, 1.0);
        dir = float2(1.0, 0.0);
    } else if (tq < 0.75) {
        prev = float2(1.0, 1.0);
        dir = float2(0.0, -1.0);
    } else {
        prev = float2(1.0, 0.0);
        dir = float2(-1.0, 0.0);
    }
    float angle = floor(tq * 4.0);

    prev *= 4.0;

    const float first_turn_look_angle = 0.4;
    const float second_turn_drift_angle = 0.5;
    const float fifth_turn_drift_angle = 0.25;

    float2 turn;
    float turn_sign = 0.0;
    float2 dirL = rotate2d(dir, -PI / 2.0);
    float2 dirR = -dirL;
    float up_down = 0.0;
    float rotate_on_turns = 1.0;
    float roll_on_turns = 1.0;
    float add_angel = 0.0;

    if (t8 < 0.125) {
        turn = dirL;
        turn_sign = -1.0;
        angle -= first_turn_look_angle * (max(0.0, t1 - (1.0 - turn_time * 2.0)) / turn_time - max(0.0, t1 - (1.0 - turn_time)) / turn_time * 2.5);
        roll_on_turns = 0.0;
    } else if (t8 < 0.250) {
        prev += dir;
        turn = dir;
        dir = dirL;
        angle -= 1.0;
        turn_sign = 1.0;
        add_angel += first_turn_look_angle * 0.5 + (-first_turn_look_angle * 0.5 + 1.0 + second_turn_drift_angle) * t1;
        rotate_on_turns = 0.0;
        roll_on_turns = 0.0;
    } else if (t8 < 0.375) {
        prev += dir + dirL;
        turn = dirR;
        turn_sign = 1.0;
        add_angel += second_turn_drift_angle * sqrt(1.0 - t1);
    } else if (t8 < 0.5) {
        prev += dir + dir + dirL;
        turn = dirR;
        dir = dirR;
        angle += 1.0;
        turn_sign = 0.0;
        up_down = sin(t1 * PI) * 0.37;
    } else if (t8 < 0.625) {
        prev += dir + dir;
        turn = dir;
        dir = dirR;
        angle += 1.0;
        turn_sign = -1.0;
        up_down = sin(-min(1.0, t1 / (1.0 - turn_time)) * PI) * 0.37;
    } else if (t8 < 0.750) {
        prev += dir + dir + dirR;
        turn = dirL;
        turn_sign = -1.0;
        add_angel -= (fifth_turn_drift_angle + 1.0) * smoothstep1(t1);
        rotate_on_turns = 0.0;
        roll_on_turns = 0.0;
    } else if (t8 < 0.875) {
        prev += dir + dir + dir + dirR;
        turn = dir;
        dir = dirL;
        angle -= 1.0;
        turn_sign = 1.0;
        add_angel -= fifth_turn_drift_angle - smoothstep1(t1) * (fifth_turn_drift_angle * 2.0 + 1.0);
        rotate_on_turns = 0.0;
        roll_on_turns = 0.0;
    } else {
        prev += dir + dir + dir;
        turn = dirR;
        turn_sign = 1.0;
        angle += fifth_turn_drift_angle * (1.5 * min(1.0, (1.0 - t1) / turn_time) - 0.5 * smoothstep1(1.0 - min(1.0, t1 / (1.0 - turn_time))));
    }

    // No mouse in Alt-Tabby — always use auto-demo mode
    angle += add_angel;

    rd = rotateX(rd, up_down);

    float2 p;
    if (turn_sign == 0.0) {
        p = prev + dir * (turn_rad + 1.0 * t1);
    }
    else if (t1 > (1.0 - turn_time)) {
        float tr = (t1 - (1.0 - turn_time)) / turn_time;
        float2 c = prev + dir * (1.0 - turn_rad) + turn * turn_rad;
        p = c + turn_rad * rotate2d(dir, (tr - 1.0) * turn_sign * PI / 2.0);
        angle += tr * turn_sign * rotate_on_turns;
        rd = rotateY(rd, sin(tr * turn_sign * PI) * 0.2 * roll_on_turns);
    } else {
        t1 /= (1.0 - turn_time);
        p = prev + dir * (turn_rad + (1.0 - turn_rad * 2.0) * t1);
    }

    rd = rotateZ(rd, angle * PI / 2.0);

    ro.xy += level1_size * p;

    ro += rd * 0.2;
    rd = normalize(rd);

    float3 col = rain(ro, rd, t_time);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_InsideTheMatrix() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 0, timeOffsetMax: 10, timeAccumulate: true}
}

_Shader_HLSL_Interstellar() {
    return "
    (
// Interstellar
// Hazel Quantock (TekF)
// https://www.shadertoy.com/view/Xdl3D2
// Converted from Shadertoy GLSL to HLSL for Alt-Tabby
// License: CC0 1.0 (public domain)
// Y-axis: no flip (symmetric radial starfield)

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define GAMMA (2.2)

float3 ToGamma(in float3 col)
{
    return pow(col, (float3)(1.0 / GAMMA));
}

float4 Noise(in int2 x)
{
    return iChannel0.SampleLevel(samp0, ((float2)x + 0.5) / 256.0, 0);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;

    float3 ray;
    ray.xy = 2.0 * (fragCoord.xy - resolution.xy * 0.5) / resolution.x;
    ray.z = 1.0;

    float offset = time * 0.5;
    float speed2 = (cos(offset) + 1.0) * 2.0;
    float speed = speed2 + 0.1;
    offset += sin(offset) * 0.96;
    offset *= 2.0;

    float3 col = (float3)0;

    float3 stp = ray / max(abs(ray.x), abs(ray.y));

    float3 pos = 2.0 * stp + 0.5;
    for (int i = 0; i < 20; i++)
    {
        float z = Noise((int2)pos.xy).x;
        z = frac(z - offset);
        float d = 50.0 * z - pos.z;
        float w = pow(max(0.0, 1.0 - 8.0 * length(frac(pos.xy) - 0.5)), 2.0);
        float3 c = max((float3)0, float3(1.0 - abs(d + speed2 * 0.5) / speed, 1.0 - abs(d) / speed, 1.0 - abs(d - speed2 * 0.5) / speed));
        col += 1.5 * (1.0 - z) * c * w;
        pos += stp;
    }

    float3 color = ToGamma(col);

    // Desaturate / darken
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_Interstellar() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "interstellar_i0.png"}]}
}

_Shader_HLSL_IsItStillRaymarching() {
    return "
    (
// Inspired by https://www.shadertoy.com/view/MtX3Ws

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float2 r = resolution.xy;
    float mr = 1. / min(r.x, r.y);
    float x = 0, y = 0, i, j, c, f, t = time;
    float3 n, k = (float3)0, p;
    float3 l = float3(sin(t * .035), sin(t * .089) * cos(t * .073), cos(t * .1)) * .3 + (float3).3;

    // 2x2 AA loop
    for (x = 0; x++ < 2.; y = 0.) { for (y = 0; y++ < 2.;) {
        n = float3((fragCoord * 2. - r + float2(x, y)) * mr * 4., 1.);
        float3 g = (float3)0;
        float u = .2, d = 0.;
        for (i = 0.; i++ < 3.;) {
            d += u; p = n * d - l; c = 0.;
            for (j = 0.; j++ < 7.;) {
                p = (sin(t * .05) * .1 + .9) * abs(p) / dot(p, p) - (cos(t * .09) * .02 + .8);
                p.xy = float2(p.x * p.x - p.y * p.y, (smoothstep(0., 4., time) * 3. + .8 * cos(t * .07)) * p.x * p.y);
                p = p.yxz;
                c += exp(-9. * abs(dot(p, p.zxy)));
            }
            u *= exp(-c * .6);
            f = c * c * .09;
            g = g * 1.5 + .5 * float3(c * f * .3, f, f);
        }
        g *= g;
        k += g * .4;
    }}

    float3 col = k / (1. + k);

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_IsItStillRaymarching() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_IsoScreensaver() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float3 pal(float t, float3 a, float3 b, float3 c, float3 d)
{
    return a + b * cos(6.28318 * (c * t + d));
}

float hash(float2 p) {
    p += 0.4;
    float3 p3 = frac(float3(p.x, p.y, p.x) * 0.13);
    p3 += dot(p3, p3.yzx + 3.333);
    return frac((p3.x + p3.y) * p3.z);
}

float noise(float2 x) {
    float2 i = floor(x);
    float2 f = frac(x);

    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float fbm(float2 x) {
    float v = 0.0;
    float a = 0.5;
    float2 shift = (float2)100;

    // GLSL mat2 is column-major; HLSL float2x2 is row-major — transposed
    float2x2 rot = float2x2(cos(0.5), -sin(0.5), sin(0.5), cos(0.5));
    for (int i = 0; i < 7; ++i) {
        v += a * noise(x);
        x = mul(rot, x) * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float3 getColor(float2 p) {
    float f = fbm(p) - 0.1 * time;
    float n = floor(f * 10.0) / 10.0;

    float t = 2.0 * abs(frac(f * 10.0) - 0.5);

    float3 a = float3(0.5, 0.5, 0.5);
    float3 b = float3(0.5, 0.5, 0.5);
    float3 c = float3(1.0, 1.0, 1.0);
    float3 d = float3(0.3, 0.5, 0.7);

    float3 c1 = pal(9.19232 * n, a, b, c, d);
    float3 c2 = pal(9.19232 * (n - 1.0 / 10.0), a, b, c, d);

    return lerp(c1, c2, pow(t, 15.0));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 p = 5.0 * (fragCoord - 0.5 * resolution) / resolution.y;

    float3 col = getColor(p) - 0.3 * getColor(p + 0.02) - 0.3 * getColor(p + 0.01);
    col *= 2.0;

    col = pow(max(col, (float3)0), (float3)(1.0 / 2.2));

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float al = max(col.r, max(col.g, col.b));
    return float4(col * al, al);
}

    )"
}

_Shader_Meta_IsoScreensaver() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_IteratingCaustics() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define sepsize 1.2
#define seplight 1.9
#define sepanim 0.1
#define caustic_strength 0.008
#define caustic_roughness 1.3
#define caustic_chormatic_aberation 0.001

float4 mod289(float4 x)
{
    return x - floor(x / 289.0) * 289.0;
}

float4 permute(float4 x)
{
    return mod289((x * 34.0 + 1.0) * x);
}

float4 snoise(float3 v)
{
    const float2 C = float2(1.0 / 6.0, 1.0 / 3.0);

    // First corner
    float3 i  = floor(v + dot(v, (float3)C.y));
    float3 x0 = v   - i + dot(i, (float3)C.x);

    // Other corners
    float3 g = step(x0.yzx, x0.xyz);
    float3 l = 1.0 - g;
    float3 i1 = min(g.xyz, l.zxy);
    float3 i2 = max(g.xyz, l.zxy);

    float3 x1 = x0 - i1 + C.x;
    float3 x2 = x0 - i2 + C.y;
    float3 x3 = x0 - 0.5;

    // Permutations
    float4 p =
      permute(permute(permute(i.z + float4(0.0, i1.z, i2.z, 1.0))
                            + i.y + float4(0.0, i1.y, i2.y, 1.0))
                            + i.x + float4(0.0, i1.x, i2.x, 1.0));

    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    float4 j = p - 49.0 * floor(p / 49.0);

    float4 x_ = floor(j / 7.0);
    float4 y_ = floor(j - 7.0 * x_);

    float4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;
    float4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;

    float4 h = 1.0 - abs(x) - abs(y);

    float4 b0 = float4(x.xy, y.xy);
    float4 b1 = float4(x.zw, y.zw);

    float4 s0 = floor(b0) * 2.0 + 1.0;
    float4 s1 = floor(b1) * 2.0 + 1.0;
    float4 sh = -step(h, (float4)0.0);

    float4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    float4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    float3 g0 = float3(a0.xy, h.x);
    float3 g1 = float3(a0.zw, h.y);
    float3 g2 = float3(a1.xy, h.z);
    float3 g3 = float3(a1.zw, h.w);

    // Compute noise and gradient at P
    float4 m = max(0.6 - float4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    float4 m2 = m * m;
    float4 m3 = m2 * m;
    float4 m4 = m2 * m2;
    float3 grad =
      -6.0 * m3.x * x0 * dot(x0, g0) + m4.x * g0 +
      -6.0 * m3.y * x1 * dot(x1, g1) + m4.y * g1 +
      -6.0 * m3.z * x2 * dot(x2, g2) + m4.z * g2 +
      -6.0 * m3.w * x3 * dot(x3, g3) + m4.w * g3;
    float4 px = float4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));
    return 42.0 * float4(grad, dot(m4, px));
}

float4 cloud(float3 v, int oct)
{
    float4 outp = (float4)0.0;
    for (int i = 1; i < 64; i++)
    {
        if(i >= oct+1) { break; }
        outp += snoise(float3(-143*i,842*i,0)+v*float3(1.,1.,pow((float)i,sepanim))*pow((float)i,sepsize))*(1.0/pow((float)i,seplight));
    }
    return outp;
}

float caustic(float2 uv, int octaves, float st)
{
    float4 val = (float4)0.0;
    for(int i = 0; i < 10; i++)
    {
        val = cloud(float3(uv.xy, time), octaves);
        uv -= val.xy * st;
    }
    return exp(cloud(float3(uv.xy, time), octaves).w * caustic_roughness - caustic_roughness / 2.0);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (3.0 * fragCoord.xy - resolution.xy) / resolution.y;

    float3 color = float3(
        caustic(uv, 24, caustic_strength + caustic_chormatic_aberation),
        caustic(uv, 24, caustic_strength),
        caustic(uv, 24, caustic_strength - caustic_chormatic_aberation));

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_IteratingCaustics() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_JaszUniverse() {
    return "
    (
// Jasz Universe - Volumetric nebula fog with camera movement
// Original: Shadertoy by Jan Mroz (jaszunio15)
// License: CC BY 3.0
// Audio reactivity stripped; replaced with time-based pulse.

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// --- Constants (from Shadertoy Common tab, non-HQ branch) ---
static const float NOISE_ALPHA_MULTIPLIER = 0.5;
static const float NOISE_SIZE_MULTIPLIER  = 1.8;
static const int   RAYS_COUNT             = 54;
static const float STEP_MODIFIER          = 1.0175;
static const float SHARPNESS              = 0.02;
static const float NOISE_LAYERS_COUNT     = 4.0;
static const float JITTERING              = 0.08;
static const float DITHER                 = 0.3;
static const float NEAR_PLANE             = 0.6;
static const float RENDER_DISTANCE        = 2.0;
static const float BRIGHTNESS             = 5.0;
static const float3 COLOR1                = float3(0.0, 1.0, 1.0);
static const float3 COLOR2                = float3(1.0, 0.0, 0.9);
static const float CAMERA_SPEED           = 0.04;
static const float CAMERA_ROTATION_SPEED  = 0.06;

// --- Helper functions ---

float hash(float3 v) {
    return frac(sin(dot(v, float3(11.51721, 67.12511, 9.7561))) * 1551.4172);
}

float getNoiseFromVec3(float3 v) {
    float3 rootV = floor(v);
    float3 f = smoothstep(0.0, 1.0, frac(v));

    float n000 = hash(rootV);
    float n001 = hash(rootV + float3(0, 0, 1));
    float n010 = hash(rootV + float3(0, 1, 0));
    float n011 = hash(rootV + float3(0, 1, 1));
    float n100 = hash(rootV + float3(1, 0, 0));
    float n101 = hash(rootV + float3(1, 0, 1));
    float n110 = hash(rootV + float3(1, 1, 0));
    float n111 = hash(rootV + float3(1, 1, 1));

    float4 n = lerp(float4(n000, n010, n100, n110), float4(n001, n011, n101, n111), f.z);
    n.xy = lerp(float2(n.x, n.z), float2(n.y, n.w), f.y);
    return lerp(n.x, n.y, f.x);
}

float volumetricFog(float3 v, float noiseMod) {
    float noise = 0.0;
    float alpha = 1.0;
    float3 pt = v;
    for (float i = 0.0; i < NOISE_LAYERS_COUNT; i++) {
        noise += getNoiseFromVec3(pt) * alpha;
        pt *= NOISE_SIZE_MULTIPLIER;
        alpha *= NOISE_ALPHA_MULTIPLIER;
    }

    noise *= 0.575;

    // MUTATE_SHAPE enabled: animate fog edge over time
    float edge = 0.1 + getNoiseFromVec3(v * 0.5 + float3(time * 0.03, time * 0.03, time * 0.03)) * 0.8;

    noise = (0.5 - abs(edge * (1.0 + noiseMod * 0.05) - noise)) * 2.0;
    return (smoothstep(1.0 - SHARPNESS * 2.0, 1.0 - SHARPNESS, noise * noise)
          + (1.0 - smoothstep(1.3, 0.6, noise))) * 0.2;
}

float3 nearPlanePoint(float2 v, float t) {
    return float3(v.x, NEAR_PLANE * (1.0 + sin(t * 0.2) * 0.4), v.y);
}

float3 fogMarch(float3 rayStart, float3 rayDirection, float t, float disMod) {
    float stepLen = RENDER_DISTANCE / (float)RAYS_COUNT;
    float3 fog = float3(0.0, 0.0, 0.0);
    float3 pt = rayStart;

    for (int i = 0; i < RAYS_COUNT; i++) {
        pt += rayDirection * stepLen;
        fog += volumetricFog(pt, disMod)
             * lerp(COLOR1, COLOR2 * (1.0 + disMod * 0.5),
                    getNoiseFromVec3((pt + float3(12.51, 52.167, 1.146)) * 0.5))
             * lerp(1.0, getNoiseFromVec3(pt * 40.0) * 2.0, DITHER)
             * getNoiseFromVec3(pt * 0.2 + 20.0) * 2.0;

        stepLen *= STEP_MODIFIER;
    }

    fog = (fog / (float)RAYS_COUNT)
        * (pow(getNoiseFromVec3(rayStart + rayDirection * RENDER_DISTANCE), 2.0) * 3.0
           + disMod * 0.5);

    return fog;
}

// Audio stripped - gentle time-based pulse as substitute
float getBeat() {
    return smoothstep(0.6, 0.9, pow(sin(time * 1.5) * 0.5 + 0.5, 4.0)) * 0.3;
}

// --- Entry point ---

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float musicVolume = getBeat();
    float2 res = resolution;
    float2 uv = (2.0 * fragCoord - res) / res.x;

    // Camera movement
    float3 cameraCenter = float3(
        sin(time * CAMERA_SPEED) * 10.0,
        time * CAMERA_SPEED * 10.0,
        cos(time * 0.78 * CAMERA_SPEED + 2.14) * 10.0);

    // Rotation matrix (GLSL column-major -> HLSL row-major transposed)
    float angleY = sin(time * CAMERA_ROTATION_SPEED * 2.0);
    float angleX = cos(time * 0.712 * CAMERA_ROTATION_SPEED);
    float angleZ = sin(time * 1.779 * CAMERA_ROTATION_SPEED);

    float3x3 rotX = float3x3(
        1, 0,            0,
        0, sin(angleX), -cos(angleX),
        0, cos(angleX),  sin(angleX));

    float3x3 rotZ = float3x3(
        sin(angleZ), -cos(angleZ), 0,
        cos(angleZ),  sin(angleZ), 0,
        0,            0,           1);

    float3x3 rotY = float3x3(
        sin(angleY),  0, -cos(angleY),
        0,            1,  0,
        cos(angleY),  0,  sin(angleY));

    float3x3 rotation = mul(rotX, mul(rotZ, rotY));

    float3 rayDirection = mul(rotation, normalize(nearPlanePoint(uv, time)));
    float3 rayStart = rayDirection * 0.2 + cameraCenter;

    // Jittering
    rayStart += rayDirection * (hash(float3(uv + 4.0, frac(time) + 2.0)) - 0.5) * JITTERING;

    float3 fog = fogMarch(rayStart, rayDirection, time, musicVolume);

    // Postprocess
    fog *= 2.5 * BRIGHTNESS;
    fog += 0.07 * lerp(COLOR1, COLOR2, 0.5);
    fog = sqrt(smoothstep(0.0, 1.5, fog));

    float3 color = fog * smoothstep(0.0, 10.0, time);

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_JaszUniverse() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 40, timeOffsetMax: 120}
}

_Shader_HLSL_KaleidoscopeCrystal() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define DTR 0.01745329

// GLSL mat2 is column-major, HLSL float2x2 is row-major — transpose elements
float2x2 rot(float a) {
    float c = cos(a), s = sin(a);
    return float2x2(c, -s, s, c);
}

static float2 g_uv;
static float3 cp, cn, cr, ro, rd, ss, oc, cc, gl, vb;
static float4 fc;
static float tt, cd, sd, io, oa, td;
static int es = 0, ec;

float bx(float3 p, float3 s) {
    float3 q = abs(p) - s;
    return min(max(q.x, max(q.y, q.z)), 0.0) + length(max(q, (float3)0));
}

float smin_f(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

float3 lattice(float3 p, int iter, float an) {
    for (int i = 0; i < iter; i++) {
        p.xy = mul(rot(an * DTR), p.xy);
        p.yz = abs(p.yz) - 1.0;
        p.xz = mul(rot(-an * DTR), p.xz);
    }
    return p;
}

float mp(float3 p) {
    // Mouse control removed — no mouse in Alt-Tabby

    p.xz = mul(rot(tt * 0.1), p.xz);
    p.xy = mul(rot(tt * 0.1), p.xy);

    p = lattice(p, 9, 45.0 + cos(tt * 0.1) * 5.0);

    sd = bx(p, (float3)1) - 0.01;

    sd = smin_f(sd, sd, 0.8);

    gl += exp(-sd * 0.001) * normalize(p * p) * 0.003;

    sd = abs(sd) - 0.001;

    if (sd < 0.001) {
        oc = (float3)1;
        io = 1.2;
        oa = 0.0;
        ss = (float3)0;
        vb = float3(0.0, 10.0, 2.8);
        ec = 2;
    }
    return sd;
}

void tr() {
    vb.x = 0.0;
    cd = 0.0;
    for (float i = 0.0; i < 256.0; i++) {
        mp(ro + rd * cd);
        cd += sd;
        td += sd;
        if (sd < 0.0001 || cd > 128.0) break;
    }
}

void nm() {
    float3 k0 = cp - float3(0.001, 0.0, 0.0);
    float3 k1 = cp - float3(0.0, 0.001, 0.0);
    float3 k2 = cp - float3(0.0, 0.0, 0.001);
    cn = normalize(mp(cp) - float3(mp(k0), mp(k1), mp(k2)));
}

void px() {
    cc = float3(0.35, 0.25, 0.45) + length(pow(abs(rd + float3(0.0, 0.5, 0.0)), (float3)3)) * 0.3 + gl;
    float3 l = float3(0.9, 0.7, 0.5);
    if (cd > 128.0) { oa = 1.0; return; }
    float df = clamp(length(cn * l), 0.0, 1.0);
    float3 fr = pow(1.0 - df, 3.0) * lerp(cc, (float3)0.4, 0.5);
    float sp = (1.0 - length(cross(cr, cn * l))) * 0.2;
    float ao = min(mp(cp + cn * 0.3) - 0.3, 0.3) * 0.4;
    cc = lerp((oc * (df + fr + ss) + fr + sp + ao + gl), oc, vb.x);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    tt = fmod(time + 25.0, 260.0);
    g_uv = float2(fragCoord.x / resolution.x, fragCoord.y / resolution.y);
    g_uv -= 0.5;
    g_uv /= float2(resolution.y / resolution.x, 1.0);
    float an = (sin(tt * 0.3) * 0.5 + 0.5);
    an = 1.0 - pow(1.0 - pow(an, 5.0), 10.0);
    ro = float3(0.0, 0.0, -5.0 - an * 15.0);
    rd = normalize(float3(g_uv, 1.0));

    // Reset per-pixel state
    gl = (float3)0;
    fc = (float4)0;
    td = 0.0;
    es = 0;

    for (int i = 0; i < 25; i++) {
        tr();
        cp = ro + rd * cd;
        nm();
        ro = cp - cn * 0.01;
        cr = refract(rd, cn, i % 2 == 0 ? 1.0 / io : io);
        if (length(cr) == 0.0 && es <= 0) { cr = reflect(rd, cn); es = ec; }
        if (max(es, 0) % 3 == 0 && cd < 128.0) rd = cr;
        es--;
        if (vb.x > 0.0 && i % 2 == 1) oa = pow(clamp(cd / vb.y, 0.0, 1.0), vb.z);
        px();
        fc = fc + float4(cc * oa, oa) * (1.0 - fc.a);
        if (fc.a >= 1.0 || cd > 128.0) break;
    }

    float3 color = (fc / fc.a).rgb;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_KaleidoscopeCrystal() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 0, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_KaleidoscopeTunnel() {
    return "
    (
// Kaleidoscope Tunnel
// Combines TheGrid by dila and The Drive Home by BigWings

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI 3.141592654

// GLSL mod: always returns positive remainder (unlike HLSL fmod)
float glsl_mod(float x, float y) { return x - y * floor(x / y); }
float2 glsl_mod(float2 x, float y) { return x - y * floor(x / y); }

float2x2 rot(float x) {
    float c = cos(x), s = sin(x);
    return float2x2(c, s, -s, c);
}

float2 foldRotate(float2 p, float s) {
    float a = PI / s - atan2(p.x, p.y);
    float n = PI * 2.0 / s;
    a = floor(a / n) * n;
    p = mul(rot(a), p);
    return p;
}

float sdRect(float2 p, float2 b) {
    float2 d = abs(p) - b;
    return min(max(d.x, d.y), 0.0) + length(max(d, (float2)0));
}

float tex(float2 p, float z) {
    p = foldRotate(p, 8.0);
    float2 q = (frac(p / 10.0) - 0.5) * 10.0;
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 2; j++) {
            q = abs(q) - 0.25;
            q = mul(rot(PI * 0.25), q);
        }
        q = abs(q) - float2(1.0, 1.5);
        q = mul(rot(PI * 0.25 * z), q);
        q = foldRotate(q, 3.0);
    }
    float d = sdRect(q, float2(1.0, 1.0));
    float f = 1.0 / (1.0 + abs(d));
    return smoothstep(0.9, 1.0, f);
}

float Bokeh(float2 p, float2 sp, float size, float mi, float blur) {
    float d = length(p - sp);
    float c = smoothstep(size, size * (1.0 - blur), d);
    c *= lerp(mi, 1.0, smoothstep(size * 0.8, size, d));
    return c;
}

float2 hash(float2 p) {
    p = float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)));
    return frac(sin(p) * 43758.5453) * 2.0 - 1.0;
}

float dirt(float2 uv, float n) {
    float2 p = frac(uv * n);
    float2 st = (floor(uv * n) + 0.5) / n;
    float2 rnd = hash(st);
    return Bokeh(p, float2(0.5, 0.5) + (float2)0.2 * rnd, 0.05, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);
}

float sm(float start, float end, float t, float smo) {
    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord.xy / resolution.xy;
    uv = uv * 2.0 - 1.0;
    uv.x *= resolution.x / resolution.y;
    uv *= 2.0;

    float3 col = (float3)0;
    #define N 6
    #define NN float(N)
    #define INTERVAL 3.0
    #define INTENSITY (float3)((NN * INTERVAL - t) / (NN * INTERVAL))

    for (int i = 0; i < N; i++) {
        float t;
        float ii = float(N - i);
        t = ii * INTERVAL - glsl_mod(time - INTERVAL * 0.75, INTERVAL);
        col = lerp(col, INTENSITY, dirt(glsl_mod(uv * max(0.0, t) * 0.1 + float2(0.2, -0.2) * time, 1.2), 3.5));

        t = ii * INTERVAL - glsl_mod(time + INTERVAL * 0.5, INTERVAL);
        col = lerp(col, INTENSITY * float3(0.7, 0.8, 1.0) * 1.3, tex(uv * max(0.0, t), 4.45));

        t = ii * INTERVAL - glsl_mod(time - INTERVAL * 0.25, INTERVAL);
        col = lerp(col, INTENSITY, dirt(glsl_mod(uv * max(0.0, t) * 0.1 + float2(-0.2, -0.2) * time, 1.2), 3.5));

        t = ii * INTERVAL - glsl_mod(time, INTERVAL);
        float r = length(uv * 2.0 * max(0.0, t));
        float rr = sm(-24.0, 0.0, r - glsl_mod(time * 30.0, 90.0), 10.0);
        col = lerp(col, lerp(INTENSITY, INTENSITY * float3(0.7, 0.5, 1.0) * 3.0, rr), tex(uv * 2.0 * max(0.0, t), 0.27 + 2.0 * rr));
    }

    float3 color = col;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_KaleidoscopeTunnel() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_LazerBeamz() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float distanceToLine(float2 s, float2 p, float2 q)
{
    return abs((q.y - p.y) * s.x - (q.x - p.x) * s.y
        + q.x * p.y - q.y * p.x) / distance(p, q);
}

float triangleFn(float2 pos, float t, float val, float stp)
{
    float t1 = t * 0.523;
    float t2 = t * 0.645;
    float t3 = t * 0.779;

    float2 p1 = 0.5 + 0.5 * float2(cos(t1      ), sin(t2      ));
    float2 p2 = 0.5 + 0.5 * float2(cos(t2 + 1.0), sin(t3 + 1.0));
    float2 p3 = 0.5 + 0.5 * float2(cos(t3 + 2.0), sin(t1 + 2.0));

    float d = distanceToLine(pos, p1, p2);
    val += d < 0.01 ? stp : 0.0;

    d = distanceToLine(pos, p2, p3);
    val += d < 0.01 ? stp : 0.0;

    d = distanceToLine(pos, p3, p1);
    val += d < 0.01 ? stp : 0.0;

    return val;
}

static const float3 Red     = float3(1.0, 0.0, 0.0);
static const float3 Yellow  = float3(1.0, 1.0, 0.0);
static const float3 Green   = float3(0.0, 1.0, 0.0);
static const float3 Cyan    = float3(0.0, 1.0, 1.0);
static const float3 Blue    = float3(0.0, 0.0, 1.0);
static const float3 Magenta = float3(1.0, 0.0, 1.0);

float3 hue(float t)
{
    float f = 1.0 / 6.0;

    if (t < f)
    {
        return lerp(Red, Yellow, t / f);
    }
    else if (t < 2.0 * f)
    {
        return lerp(Yellow, Green, (t - f) / f);
    }
    else if (t < 3.0 * f)
    {
        return lerp(Green, Cyan, (t - 2.0 * f) / f);
    }
    else if (t < 4.0 * f)
    {
        return lerp(Cyan, Blue, (t - 3.0 * f) / f);
    }
    else if (t < 5.0 * f)
    {
        return lerp(Blue, Magenta, (t - 4.0 * f) / f);
    }
    else
    {
        return lerp(Magenta, Red, (t - 5.0 * f) / f);
    }
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 pos = (fragCoord - 0.5 * resolution) / resolution.y + 0.5;

    float val = 0.0;

    for (float i = 0.0; i < 10.0; i++)
    {
        val += triangleFn(pos, time + i * 0.05, val, 0.01 * i / 10.0);
    }

    val = min(1.0, val);
    val = 1.0 - (1.0 - val) * (1.0 - val);

    float3 col = val * hue(0.5 + 0.5 * sin(time + val));

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_LazerBeamz() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_LimestoneCave() {
    return "
    (
// Limestone Cave - converted from Shadertoy (WXGfz3) by altunenes
// https://www.shadertoy.com/view/WXGfz3

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// Rotation matrix from Z-depth (replaces GLSL #define M)
float2x2 getM(float pz) {
    float4 cv = cos(pz * 1.1 + float4(0, 11, 33, 0));
    return float2x2(cv.x, cv.z, cv.y, cv.w);
}

float n(float2 p) {
    return sin(p.x * 3. + sin(p.y * 2.7)) * cos(p.y * 1.1 + cos(p.x * 2.3));
}

float f(float3 p) {
    float v = 0., a = 1.;
    for (int i = 0; i++ < 7; p *= 2., a /= 2.)
        v += n(p.xy + p.z / 2.) * a;
    return v;
}

float sdf(float3 p) {
    p.xy = mul(getM(p.z), p.xy);
    return (1. - length(p.xy) - f(p + time / 10.) * .3) / 5.;
}

float3 calcNormal(float3 p, float t) {
    float2 e = float2(1e-3 + t / 1e3, 0);
    return normalize(float3(
        sdf(p + e.xyy) - sdf(p - e.xyy),
        sdf(p + e.yxy) - sdf(p - e.yxy),
        sdf(p + e.yyx) - sdf(p - e.yyx)));
}

float calcAO(float3 p, float3 nor) {
    float o = 0., s = 1., h;
    for (int i = 0; i++ < 5; s *= .9) {
        h = .01 + .03 * float(i);
        o += (h - sdf(p + h * nor)) * s;
        if (o > .33) break;
    }
    return max(1. - 3. * o, 0.);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float3 d = normalize(float3(fragCoord - .5 * resolution, resolution.y)),
           o = float3(0, 0, time), p, nor, l, h, c = (float3)0;
    float t = 0., w;
    for (int i = 0; i++ < 99;) {
        p = o + d * t;
        w = sdf(p);
        if (abs(w) < t / 1e3 || t > 20.) break;
        t += w;
    }

    if (t <= 20.) {
        nor = calcNormal(p, t);
        float3 q = p;
        q.xy = mul(getM(p.z), q.xy);
        c = lerp(float3(.1, .3, .7), float3(.8, .4, .2),
            clamp(f(q + time / 10.) + .5, 0., 1.));
        l = normalize(o + float3(0, 0, 4) - p);
        h = normalize(l + normalize(o - p));
        w = length(o + float3(0, 0, 4) - p);

        c = c * .02 +
            (c * max(dot(nor, l), 0.) +
            float3(.8, .8, .8) * pow(abs(max(dot(nor, h), 0.)), 16.) *
            smoothstep(15., 5., t))
            / (1. + w * w / 5.);

        c *= calcAO(p, nor);
    }

    c = lerp(float3(.02, 0, .05), c, 1. / exp(.15 * t));
    c = c * (2.51 * c + .03) / (c * (2.43 * c + .59) + .14);

    c = pow(abs(c), (float3)(1. / 2.2));

    // Darken / desaturate
    float lum = dot(c, float3(0.299, 0.587, 0.114));
    c = lerp(c, float3(lum, lum, lum), desaturate);
    c = c * (1.0 - darken);

    // Premultiplied alpha from brightness
    float a = max(c.r, max(c.g, c.b));
    return float4(c * a, a);
}

    )"
}

_Shader_Meta_LimestoneCave() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 40, timeOffsetMax: 120, timeAccumulate: true}
}

_Shader_HLSL_LineSynapse() {
    return "
    (
// LineSynapse
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define iterations 13
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom   0.800
#define tile   0.850

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation 0.850
#define S(a,b,val) smoothstep(a,b,val)

float3 glsl_mod(float3 x, float3 y) { return x - y * floor(x / y); }

float DistLine(float2 p, float2 a, float2 b) {
    float2 pa = p - a;
    float2 ba = b - a;
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * t);
}

float N21(float2 p) {
    p = frac(p * float2(233.34, 851.73));
    p += dot(p, p + 23.45);
    return frac(p.x * p.y);
}

float2 N22(float2 p) {
    float n = N21(p);
    return float2(n, N21(p + n));
}

float2 GetPos(float2 id, float2 offs) {
    float2 n = N22(id + offs) * time;
    return offs + cos(n) * sin(n) * 0.5;
}

float Line(float2 p, float2 a, float2 b) {
    float d = DistLine(p, a, b);
    float m = S(0.06, 0.01, d);
    float d2 = length(a - b);
    m *= S(2.2, 0.8, d2) + S(0.05, 0.03, abs(d2 - 0.75));
    return m;
}

float Layer(float2 uv) {
    float m = 0.0;
    float2 gv = frac(uv) - 0.5;
    float2 id = floor(uv);

    float2 p[9];
    int idx = 0;
    for (float y = -1.0; y <= 1.0; y++) {
        for (float x = -1.0; x <= 1.0; x++) {
            p[idx++] = GetPos(id, float2(x, y));
        }
    }

    float t = time * 10.0;
    for (int i = 0; i < 9; i++) {
        m += Line(gv, p[4], p[i]);
        float2 j = (p[i] - gv) * 15.0;
        float sparkle = 1.0 / dot(j, j);
        m += sparkle * (sin(t + frac(p[i].x) * 10.0) * 0.5 + 0.5);
    }

    m += Line(gv, p[1], p[3]);
    m += Line(gv, p[1], p[5]);
    m += Line(gv, p[7], p[3]);
    m += Line(gv, p[7], p[5]);
    return m;
}

// Volumetric star field (originally mainVR)
float4 volumetric(float3 ro, float3 rd) {
    float s = 0.1, fade = 1.0;
    float3 v = (float3)0;
    for (int r = 0; r < volsteps; r++) {
        float3 p = ro + s * rd * 0.5;
        p = abs((float3)tile - glsl_mod(p, (float3)(tile * 2.0)));
        float pa = 0.0, a = 0.0;
        for (int i = 0; i < iterations; i++) {
            p = abs(p) / dot(p, p) - formuparam;
            // GLSL mat2 column-major → HLSL row-major (transposed)
            float cs = cos(time * 0.05);
            float sn = sin(time * 0.05);
            p.xy = mul(p.xy, float2x2(cs, -sn, sn, cs));
            a += abs(length(p) - pa);
            pa = length(p);
        }
        float dm = max(0.0, darkmatter - a * a * 0.001);
        a *= a * a;
        if (r > 6) fade *= 1.3 - dm;
        v += fade;
        v += float3(s, s * s, s * s * s * s) * a * brightness * fade;
        fade *= distfading;
        s += stepsize;
    }
    v = lerp((float3)length(v), v, saturation);
    return float4(v * 0.03, 1.0);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord.xy / resolution.xy - 0.5;
    uv.y *= resolution.y / resolution.x;
    float3 dir = float3(uv * zoom, 1.0);

    // Line synapse network (layered at multiple scales)
    float m = 0.0;
    float t = time * 0.1;

    for (float i = 0.0; i <= 1.0; i += 1.0 / 7.0) {
        float z = frac(i * i + t);
        float sz = lerp(59.0, 0.5, z);
        float fade = S(0.0, 0.2, z) * S(1.0, 0.0, z);
        m += Layer(uv * sz + i * 200.0) * fade;
    }

    float3 base = sin(t * 5.0 * float3(0.345, 0.456, 0.657)) * 0.5 + 0.6;
    float3 col = m * base;
    col -= uv.y * base;

    // Volumetric star field
    float3 from = float3(1.0, 0.5, 0.5);
    float4 vr = volumetric(from, dir);
    float3 color = vr.rgb * col;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_LineSynapse() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_LiquidWarp() {
    return "
    (
// Liquid Warp — domain warping based on iq's notes
// https://www.shadertoy.com/view/wtXXD2
// Author: whoadrian | License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// NOISE ////

float noise(in float2 x)
{
    float2 p = floor(x);
    float2 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    float a = iChannel0.SampleLevel(samp0, (p + float2(0.5, 0.5)) / 256.0, 0.0).x;
    float b = iChannel0.SampleLevel(samp0, (p + float2(1.5, 0.5)) / 256.0, 0.0).x;
    float c = iChannel0.SampleLevel(samp0, (p + float2(0.5, 1.5)) / 256.0, 0.0).x;
    float d = iChannel0.SampleLevel(samp0, (p + float2(1.5, 1.5)) / 256.0, 0.0).x;
    return lerp(lerp(a, b, f.x), lerp(c, d, f.x), f.y);
}

static const float2x2 mtx = float2x2(0.80, 0.60, -0.60, 0.80);

float fbm(float2 p)
{
    float f = 0.0;

    f += 0.500000 * noise(p); p = mul(mtx, p) * 2.02;
    f += 0.250000 * noise(p); p = mul(mtx, p) * 2.03;
    f += 0.125000 * noise(p); p = mul(mtx, p) * 2.01;
    f += 0.062500 * noise(p); p = mul(mtx, p) * 2.04;
    f += 0.031250 * noise(p); p = mul(mtx, p) * 2.01;
    f += 0.015625 * noise(p);

    return f / 0.96875;
}

// -----------------------------------------------------------------------

float pattern(in float2 p, in float t, in float2 uv, out float2 q, out float2 r, out float2 g)
{
    q = float2(fbm(p), fbm(p + float2(10, 1.3)));

    r = float2(fbm(p + 4.0 * q + float2(t, t) + float2(1.7, 9.2)), fbm(p + 4.0 * q + float2(t, t) + float2(8.3, 2.8)));
    g = float2(fbm(p + 2.0 * r + float2(t * 20.0, t * 20.0) + float2(2, 6)), fbm(p + 2.0 * r + float2(t * 10.0, t * 10.0) + float2(5, 3)));
    return fbm(p + 5.5 * g + float2(-t * 7.0, -t * 7.0));
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;

    // Normalized pixel coordinates (from 0 to 1)
    float2 uv = fragCoord / resolution;

    // noise
    float2 q, r, g;
    float n = pattern(fragCoord * float2(0.004, 0.004), time * 0.007, uv, q, r, g);

    // base color based on main noise
    float3 col = lerp(float3(0.1, 0.4, 0.4), float3(0.5, 0.7, 0.0), smoothstep(0.0, 1.0, n));

    // other lower-octave colors and mixes
    col = lerp(col, float3(0.35, 0.0, 0.1), dot(q, q) * 1.0);
    col = lerp(col, float3(0, 0.2, 1), 0.2 * g.y * g.y);
    col = lerp(col, float3(0.3, 0, 0), smoothstep(0.0, 0.6, 0.6 * r.y * r.y));
    col = lerp(col, float3(0, 0.5, 0), 0.1 * g.x);

    // some dark outlines/contrast and different steps
    col = lerp(col, float3(0, 0, 0), smoothstep(0.3, 0.5, n) * smoothstep(0.5, 0.3, n));
    col = lerp(col, float3(0, 0, 0), smoothstep(0.7, 0.8, n) * smoothstep(0.8, 0.7, n));

    // contrast
    col *= n * 2.0;

    // vignette
    col *= 0.70 + 0.65 * sqrt(70.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y));

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_LiquidWarp() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "liquid_warp_i0.png"}]}
}

_Shader_HLSL_MandelboxSweeper() {
    return "
    (
// Mandelbox Sweeper - Converted from Shadertoy (3lyXDm)
// Original by evvvvil - Live coded on Twitch
// https://www.shadertoy.com/view/3lyXDm

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// Globals
static float2 z, e = float2(0.000035, -0.000035);
static float t, tt, b, g, g2, bb;
static float3 bp, pp, po, nor, al, ld;

float glmod(float x, float y) { return x - y * floor(x / y); }

float bo(float3 p, float3 r) { p = abs(p) - r; return max(max(p.x, p.y), p.z); }

float2x2 r2(float r) { float c = cos(r), s = sin(r); return float2x2(c, -s, s, c); }

float2 fb(float3 p, float m)
{
    p.y += bb * 0.05;
    float2 h, t = float2(bo(p, float3(5, 1, 3)), 3);
    t.x = max(t.x, -(length(p) - 2.5));
    t.x = max(abs(t.x) - 0.2, (p.y - 0.4));
    h = float2(bo(p, float3(5, 1, 3)), 6);
    h.x = max(h.x, -(length(p) - 2.5));
    h.x = max(abs(h.x) - 0.1, (p.y - 0.5));
    t = t.x < h.x ? t : h;
    h = float2(bo(p + float3(0, 0.4, 0), float3(5.4, 0.4, 3.4)), m);
    h.x = max(h.x, -(length(p) - 2.5));
    t = t.x < h.x ? t : h;
    h = float2(length(p) - 2.0, m);
    t = t.x < h.x ? t : h;
    t.x *= 0.7;
    return t;
}

float2 mp(float3 p)
{
    pp = bp = p;
    p.yz = mul(r2(sin(pp.x * 0.3 - tt * 0.5) * 0.4), p.yz);
    bp.yz = p.yz;
    p.yz = mul(r2(1.57), p.yz);
    b = sin(pp.x * 0.2 + tt);
    bb = cos(pp.x * 0.2 + tt);
    p.x = glmod(p.x - tt * 2.0, 10.0) - 5.0;
    float4 np = float4(p * 0.4, 0.4);
    for (int i = 0; i < 4; i++) {
        np.xyz = abs(np.xyz) - float3(1, 1.2, 0);
        np.xyz = 2.0 * clamp(np.xyz, (float3)0, float3(2, 0, 4.3 + bb)) - np.xyz;
        np = np * (1.3) / clamp(dot(np.xyz, np.xyz), 0.1, 0.92);
    }
    float2 h, t = fb(abs(np.xyz) - float3(2, 0, 0), 5.0);
    t.x /= np.w;
    t.x = max(t.x, bo(p, float3(5, 5, 10)));
    np *= 0.5;
    np.yz = mul(r2(0.785), np.yz);
    np.yz += 2.5;
    h = fb(abs(np.xyz) - float3(0, 4.5, 0), 7.0);
    h.x = max(h.x, -bo(p, float3(20, 5, 5)));
    h.x /= np.w * 1.5;
    t = t.x < h.x ? t : h;
    h = float2(bo(np.xyz, float3(0.0, b * 20.0, 0.0)), 6);
    h.x /= np.w * 1.5;
    g2 += 0.1 / (0.1 * h.x * h.x * (1000.0 - b * 998.0));
    t = t.x < h.x ? t : h;
    h = float2(0.6 * bp.y + sin(p.y * 5.0) * 0.03, 6);
    t = t.x < h.x ? t : h;
    h = float2(length(cos(bp.xyz * 0.6 + float3(tt, tt, 0))) + 0.003, 6);
    g += 0.1 / (0.1 * h.x * h.x * 4000.0);
    t = t.x < h.x ? t : h;
    return t;
}

float2 tr(float3 ro, float3 rd)
{
    float2 h, t = (float2)0.1;
    for (int i = 0; i < 128; i++) {
        h = mp(ro + rd * t.x);
        if (h.x < 0.0001 || t.x > 40.0) break;
        t.x += h.x; t.y = h.y;
    }
    if (t.x > 40.0) t.y = 0.0;
    return t;
}

#define ao(d) clamp(mp(po+nor*d).x/d,0.,1.)
#define ss(d) smoothstep(0.,1.,mp(po+ld*d).x/d)

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    g = 0; g2 = 0;
    float2 uv = (fragCoord.xy / resolution.xy - 0.5) / float2(resolution.y / resolution.x, 1);
    tt = glmod(time, 62.8318);

    float3 ro = lerp((float3)1, float3(-0.5, 1, -1), ceil(sin(tt * 0.5)))
              * float3(10, 2.8 + 0.75 * smoothstep(-1.5, 1.5, 1.5 * cos(tt + 0.2)), cos(tt * 0.3) * 3.1);
    float3 cw = normalize((float3)0 - ro);
    float3 cu = normalize(cross(cw, normalize(float3(0, 1, 0))));
    float3 cv = normalize(cross(cu, cw));
    float3 rd = mul(normalize(float3(uv, 0.5)), float3x3(cu, cv, cw));
    float3 co, fo;

    ld = normalize(float3(0.2, 0.4, -0.3));
    co = fo = float3(0.1, 0.2, 0.3) - length(uv) * 0.1 - rd.y * 0.2;
    z = tr(ro, rd); t = z.x;

    if (z.y > 0.0) {
        po = ro + rd * t;
        nor = normalize(e.xyy * mp(po + e.xyy).x + e.yyx * mp(po + e.yyx).x
                      + e.yxy * mp(po + e.yxy).x + e.xxx * mp(po + e.xxx).x);
        al = lerp(float3(0.1, 0.2, 0.4), float3(0.1, 0.4, 0.7), 0.5 + 0.5 * sin(bp.y * 7.0));
        if (z.y < 5.0) al = (float3)0;
        if (z.y > 5.0) al = (float3)1;
        if (z.y > 6.0) al = lerp(float3(1, 0.5, 0), float3(0.9, 0.3, 0.1), 0.5 + 0.5 * sin(bp.y * 7.0));
        float dif = max(0.0, dot(nor, ld));
        float fr = pow(1.0 + dot(nor, rd), 4.0);
        float sp = pow(max(dot(reflect(-ld, nor), -rd), 0.0), 40.0);
        co = lerp(sp + lerp((float3)0.8, (float3)1, abs(rd)) * al * (ao(0.1) * ao(0.2) + 0.2) * (dif + ss(2.0)), fo, min(fr, 0.2));
        co = lerp(fo, co, exp(-0.0003 * t * t * t));
    }

    float3 color = pow(co + g * 0.2 + g2 * lerp(float3(1, 0.5, 0), float3(0.9, 0.3, 0.1), 0.5 + 0.5 * sin(bp.y * 3.0)), (float3)0.65);

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_MandelboxSweeper() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 50, timeAccumulate: true}
}

_Shader_HLSL_MetalVortex() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define SURF_DIST 0.001
#define MAX_STEPS 256
#define MAX_STEPS_REF 32
#define MAX_STEPS_SHAD 16

static int mat_id;
static float3 ref_vec = float3(0.0, 0.0, 0.0);

float2 rotate2d(float2 a, float d) {
    float s = sin(d);
    float c = cos(d);
    return float2(
        a.x * c - a.y * s,
        a.x * s + a.y * c);
}

float noise(float3 p) {
    return frac(sin(dot(p, float3(41932.238945, 12398.5387294, 18924.178293))) * 123890.12893);
}

float sdVerticalCapsule(float3 p, float h, float r) {
    p.y -= clamp(p.y, 0.0, h);
    return length(p) - r;
}

float smin(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return lerp(d2, d1, h) - k * h * (1.0 - h);
}

float sdSphere(float3 p, float r) {
    return length(p) - r;
}

float sdBox(float3 p, float3 b) {
    float3 d = abs(p) - b;
    return max(max(d.x, d.y), d.z);
}

float sdTriPrism(float3 p, float2 h) {
    float3 q = abs(p);
    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);
}

float sdOctahedron(float3 p, float s) {
    p = abs(p);
    return (p.x + p.y + p.z - s) * 0.57735027;
}

float3 opTwist(float3 p, float k) {
    float c = cos(k * p.y);
    float s = sin(k * p.y);
    float2x2 m = float2x2(c, -s, s, c);
    float2 twisted = mul(m, p.xz);
    return float3(twisted, p.y);
}

float sdHexPrism(float3 p, float2 h) {
    static const float3 k = float3(-0.8660254, 0.5, 0.57735);
    p = abs(p);
    p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;
    float2 d = float2(
        length(p.xy - float2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),
        p.z - h.y);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdHexScrew(float3 p, float2 h, float t) {
    static const float3 k = float3(-0.8660254, 0.5, 0.57735);
    p = abs(opTwist(p, t));
    p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;
    float2 d = float2(
        length(p.xy - float2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),
        p.z - h.y);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float cog(float3 p, float3 tp) {
    float d = 1e10;

    float3 bp = p;
    bp.xy = rotate2d(bp.xy, sin(-time - tp.z * 0.05 - p.x * 0.01) * 10.0);

    float base_d = sdHexPrism(bp, float2(2.0, 0.2));
    d = min(d, base_d);

    bp.zy = rotate2d(bp.zy, 1.5);
    float base2 = sdHexScrew(bp, float2(0.95, 1.0), 2.0);
    d = max(d, -base2);

    return d;
}

float map(float3 p) {
    float3 tp = p;
    p.xy = rotate2d(p.xy, p.z * 0.02);
    float3 cell = float3(5.0, 40.5, 21.5);
    p = fmod(p, cell) - cell * 0.5;

    float3 cp = p;

    float s = sin(time + tp.z * 0.05) * 10.0;
    cp.z += s;

    float d = 1e10;

    float cog_d = cog(cp, tp);
    d = min(d, cog_d);

    p.zy = rotate2d(p.zy, 1.57);
    float screw = sdHexScrew(p, float2(0.85, 11.0), 2.0);
    d = min(d, screw);

    if (d == cog_d) {
        mat_id = 1;
    } else if (d == screw) {
        mat_id = 3;
    }
    return d;
}

float3 calcNormal(float3 p) {
    float2 e = float2(0.01, 0.0);
    return normalize(float3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx)));
}

float4 trace(float3 ro, float3 rd) {
    float t = 0.0;
    float3 col = float3(0.9, 0.9, 0.9);
    float k = 0.0;

    for (int i = 0; i < MAX_STEPS; ++i) {
        k = map(ro + rd * t);
        t += k * 0.5;
        if (abs(k) < SURF_DIST) {
            if (mat_id == 1)
                col = float3(0.5, 0.5, 0.5);
            else if (mat_id == 3)
                col = float3(0.8, 0.8, 0.8);
            else if (mat_id == 2)
                col = float3(1.0, 1.0, 1.0);
            break;
        }
    }

    return float4(t, col);
}

float4 traceRef(float3 ro, float3 rd, float start_d, float end_d) {
    float t = 0.0;
    float3 col = float3(0.9, 0.9, 0.9);
    float k = 0.0;

    for (int i = 0; i < MAX_STEPS_REF; ++i) {
        k = map(ro + rd * t);
        t += k * 0.25;
        if (k < SURF_DIST) {
            float light = dot(calcNormal(ro + rd * t), normalize(float3(1.0, 3.0, -5.0))) * 2.0;
            if (mat_id == 1)
                col = float3(0.5, 0.5, 0.5);
            else if (mat_id == 3)
                col = float3(0.9, 0.9, 0.9);
            break;
        }
    }
    return float4(t, col);
}

float calculateAO(float3 p, float3 n) {
    float r = 0.0;
    float w = 1.0;
    for (float i = 1.0; i <= 5.0; i++) {
        float d0 = i * 0.2;
        r += w * (d0 - map(p + n * d0));
        w *= 0.5;
    }
    return 1.0 - clamp(r, 0.0, 1.0);
}

float softShadow(float3 ro, float3 rd, float start_d, float end_d, float k) {
    float shade = 1.0;
    float d = start_d;

    for (int i = 0; i < MAX_STEPS_SHAD; i++) {
        float h = map(ro + rd * d);
        shade = min(shade, k * h / d);
        d += min(h, d / 2.0);
        if (h < SURF_DIST || d > end_d) break;
    }

    return min(max(shade, 0.0) + 0.3, 1.0);
}

float3 lighting(float3 sp, float3 camPos, int reflectionPass) {
    float3 col = float3(0.0, 0.0, 0.0);
    float3 n = calcNormal(sp);
    float3 objCol = float3(0.5, 0.5, 0.5);

    float3 lp = float3(sin(time) * 50.0, cos(time) * 50.0, time * 10.0);
    float3 ld = lp - sp;
    float3 lcolor = float3(sin(time * 0.2), cos(time * 0.2), 1.0) / 3.0 + float3(1.0, 1.0, 1.0);

    float len = length(ld);
    ld /= len;
    float lightAtten = clamp(0.5 * len * len, 0.0, 1.0);

    ref_vec = reflect(-ld, n);

    float shadowcol = 1.0;
    if (reflectionPass == 0)
        shadowcol = softShadow(sp, ld, 0.005 * 2.0, len, 32.0);

    float ao = 0.5 + 0.5 * calculateAO(sp, n);
    float ambient = 0.05;
    float specPow = 8.0;
    float diff = max(0.0, dot(n, ld));
    float spec = max(0.0, dot(ref_vec, normalize(camPos - sp)));
    spec = pow(spec, specPow);

    col += (objCol * (diff + ambient) + spec * 0.5) * lcolor * lightAtten * shadowcol * ao;

    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float depth = 0.0;
    float3 tot = float3(0.0, 0.0, 0.0);

    float2 uv = (fragCoord - 0.5 * resolution) / resolution.y;

    float t = time * 10.0;

    float3 cam = float3(0.0, 0.0, -10.0 + t);
    float3 dir = normalize(float3(uv, 1.0));

    float4 d = trace(cam, dir);
    float3 p = cam + dir * d.x;
    float3 n = calcNormal(p);

    float4 r = traceRef(p, reflect(dir, n), 0.05, 32.0);
    float3 l = lighting(p, cam, 0);

    depth = r.x;
    float3 rsp = p + ref_vec * r.x;

    float3 col = (lighting(rsp, p, 1) * 0.05 + l) / clamp(d.x * 0.015, 1.0, 10.0);
    // vignette
    col *= 1.0 - dot(uv, uv) * 0.75;

    tot = col;

    // Post-processing
    float lum = dot(tot, float3(0.299, 0.587, 0.114));
    tot = lerp(tot, float3(lum, lum, lum), desaturate);
    tot = tot * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(tot.r, max(tot.g, tot.b));
    return float4(tot * a, a);
}

    )"
}

_Shader_Meta_MetalVortex() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_Monster() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float TK = 1.0;
static const float PI = 3.1415926535;

float2 rot(float2 p, float r) {
    float2x2 m = float2x2(cos(r), sin(r), -sin(r), cos(r));
    return mul(p, m);
}

float2 pmod(float2 p, float n) {
    float np = 2.0 * PI / n;
    float r = atan2(p.x, p.y) - 0.5 * np;
    r = fmod(r, np) - 0.5 * np;
    return length(p) * float2(cos(r), sin(r));
}

float cube(float3 p, float3 s) {
    float3 q = abs(p);
    float3 m = max(s - q, 0.0);
    return length(max(q - s, 0.0)) - min(min(m.x, m.y), m.z);
}

float dist(float3 p) {
    p.z -= 1.0 * TK * time;
    p.xy = rot(p.xy, 1.0 * p.z);
    p.xy = pmod(p.xy, 6.0);
    float k = 0.7;
    float zid = floor(p.z * k);
    p = fmod(p, k) - 0.5 * k;
    for (int i = 0; i < 4; i++) {
        p = abs(p) - 0.3;

        p.xy = rot(p.xy, 1.0 + zid + 0.1 * TK * time);
        p.xz = rot(p.xz, 1.0 + 4.7 * zid + 0.3 * TK * time);
    }
    return min(cube(p, float3(0.3, 0.3, 0.3)), length(p) - 0.4);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = fragCoord / resolution.xy;
    uv = 2.0 * (uv - 0.5);
    uv.y *= resolution.y / resolution.x;
    uv = rot(uv, TK * time);
    float3 ro = float3(0.0, 0.0, 0.1);
    float3 rd = normalize(float3(uv, 0.0) - ro);
    float t = 2.0;
    float d = 0.0;
    float ac = 0.0;
    for (int i = 0; i < 66; i++) {
        d = dist(ro + rd * t) * 0.2;
        d = max(0.0, abs(d));
        t += d;
        if (d < 0.001) ac += 0.1;
    }
    float3 col = float3(0.0, 0.0, 0.0);
    col = float3(0.1, 0.7, 0.7) * 0.2 * float3(ac, ac, ac);
    float3 pn = ro + rd * t;
    float kn = 0.5;
    pn.z += -1.5 * time * TK;
    pn.z = fmod(pn.z, kn) - 0.5 * kn;
    float em = clamp(0.01 / pn.z, 0.0, 100.0);
    col += 3.0 * em * float3(0.1, 1.0, 0.1);
    col = clamp(col, 0.0, 1.0);

    // Apply darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_Monster() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 60}
}

_Shader_HLSL_NanosecondsAfterBigbang() {
    return "
    (
// 5 Nanoseconds After BigBang — converted from Shadertoy (wdtczM)
// Created by Benoit Marini - 2020
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 R = resolution.xy;

    float4 o = (float4)0.0;
    float t = time * 0.1;
    for (float i = 0.0; i > -1.0; i -= 0.06)
    {
        float d = frac(i - 3.0 * t);
        float4 c = float4((fragCoord - R * 0.5) / R.y * d, i, 0.0) * 28.0;
        for (int j = 0; j < 27; j++)
            c.xzyw = abs(c / dot(c, c)
                    - float4(7.0 - 0.2 * sin(t), 6.3, 0.7, 1.0 - cos(t / 0.8)) / 7.0);
        o += c * c.yzww * (d - d * d) / float4(3, 5, 1, 1);
    }

    float3 color = o.rgb;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_NanosecondsAfterBigbang() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_NebulaFlight() {
    return "
    (
// Nebula Flight — Hazel Quantock 2014
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
// Converted from Shadertoy: https://www.shadertoy.com/view/Xs2SzR

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

Texture2D iChannel1 : register(t1);
SamplerState samp1 : register(s1);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float tau = 6.28318530717958647692;

// texture noise
float2 Noise(float3 x)
{
    float3 p = floor(x), f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    float2 uv = (p.xy + float2(37.0, 17.0) * p.z) + f.xy;
    float4 rg = iChannel0.SampleLevel(samp0, (uv + 0.5) / 256.0, 0.0);
    return lerp(rg.yw, rg.xz, f.z);
}

float4 Density(float3 pos)
{
    pos /= 30.0;
    float2 s = (float2)0;
    s += Noise(pos.xyz / 1.0) / 1.0;
    s += Noise(pos.zxy * 2.0) / 2.0;
    s += Noise(pos.yzx * 4.0) / 4.0;
    s += Noise(pos.xzy * 8.0) / 8.0;

    s /= 2.0 - 1.0 / 8.0;

    s.y = pow(s.y, 5.0) * 1.0;

    return float4(pow(sin(float3(1, 2, 5) + tau * s.x) * 0.5 + 0.5, (float3)1.0) * 16.0, s.y);
}

float3 Path(float t)
{
    t *= 0.2;
    float2 a = float2(1, 0.3) * t;
    float r = sin(t * 1.2) * 0.2 + 0.8;

    float2 cs = float2(cos(a.y), sin(a.y));
    return 100.0 * r * float3(cos(a.x), 1, sin(a.x)) * cs.xyx;
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float T = time;

    float3 pos = Path(T);

    float d = 0.5;
    float3 pa = Path(T + d), pb = Path(T - d);
    float3 sky = (pa + pb) / 2.0 - pos;

    // alternate between looking forward and looking toward centre of nebula
    float3 forward = normalize(lerp(normalize(pa - pb), normalize((float3)0 - pos), smoothstep(-0.2, 0.2, sin(T * 0.2))));
    float3 right = normalize(cross(sky, forward));
    float3 up = normalize(cross(forward, right));

    float2 uv = (fragCoord.xy - resolution.xy * 0.5) / resolution.y;
    float3 ray = forward * 1.0 + right * uv.x + up * uv.y;
    ray = normalize(ray);

    float3 c = (float3)0;
    float t = 0.0;
    float baseStride = 3.0;
    float stride = baseStride;
    float visibility = 1.0;
    for (int i = 0; i < 30; i++)
    {
        if (visibility < 0.001) break;

        float4 samplev = Density(pos + t * ray);
        float visibilityAfterSpan = pow(1.0 - samplev.a, stride);

        samplev.rgb *= samplev.a;

        c += samplev.rgb * visibility * (1.0 - visibilityAfterSpan);
        visibility *= visibilityAfterSpan;

        float newStride = baseStride / lerp(1.0, visibility, 0.3);
        t += (stride + newStride) * 0.5;
        stride = newStride;
    }

    c = pow(c, (float3)(1.0 / 2.2));

    // dithering
    c += (iChannel1.SampleLevel(samp1, (fragCoord.xy + 0.5) / 8.0, 0.0).x - 0.5) / 256.0;

    // darken / desaturate
    float lum = dot(c, float3(0.299, 0.587, 0.114));
    c = lerp(c, float3(lum, lum, lum), desaturate);
    c = c * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(c.r, max(c.g, c.b));
    return float4(c * a, a);
}
    )"
}

_Shader_Meta_NebulaFlight() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "nebula_flight_i0.png"}, {index: 1, file: "nebula_flight_i1.png"}], timeOffsetMin: 40, timeOffsetMax: 120, timeAccumulate: true}
}

_Shader_HLSL_NebulaForNatalee() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float fbm(float2 uv) {
    float f = 0.5;

    float amp = 0.5;
    float freq = 2.0;
    for (int i = 0; i < 5; i++) {
        f += amp * (iChannel0.Sample(samp0, uv).r - 0.5);

        uv *= freq;
        uv += 10.0;

        freq *= 2.0;
        amp *= 0.5;
    }

    return f;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution.xy;

    float x0 = fbm(uv * 0.1 + time * 0.007);
    float y0 = fbm(uv * 0.1523 + time * 0.007);

    float3 col = (float3)0.0;

    float amp = 0.5;
    float freq = 0.1;

    float2 off = float2(x0, y0);

    float ff = 0.0;

    for (int i = 0; i < 8; i++) {
        float f = fbm(uv * freq + off * 0.03 + ff * 0.02 + time * 0.0004 * (8.0 - float(i)));

        f = pow(f + 0.25, float(i) * 6.2 + 5.5);
        ff += f;

        float r = sin(x0 * 18.0);
        float g = sin(y0 * 13.0 + 1.7);
        float b = sin(f * 11.0 + 1.1);

        col += amp * f * lerp(float3(0.3, 0.5, 0.9), float3(r, g, b), pow(float(i) / 8.0, f));

        amp *= 0.9;
        freq *= 2.7;
    }

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_NebulaForNatalee() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "nebula_for_natalee_i0.png"}]}
}

_Shader_HLSL_NebulaSmoke() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float polygonDistance(float2 p, float radius, float angleOffset, int sideCount) {
    float a = atan2(p.x, p.y) + angleOffset;
    float b = 6.28319 / float(sideCount);
    return cos(floor(0.5 + a / b) * b - a) * length(p) - radius;
}

// from https://www.shadertoy.com/view/4djSRW
#define HASHSCALE1 443.8975
float hash11(float p) {
    float3 p3 = frac((float3)(p) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return frac((p3.x + p3.y) * p3.z);
}

#define HASHSCALE3 float3(.1031, .1030, .0973)
float2 hash21(float p) {
    float3 p3 = frac((float3)(p) * HASHSCALE3);
    p3 += dot(p3, p3.yzx + 19.19);
    return frac(float2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float2 uv = (float2)0.5 - (fragCoord.xy / resolution.xy);
    uv.x *= resolution.x / resolution.y;

    float accum = 0.0;
    for (int i = 0; i < 83; i++) {
        float fi = float(i);
        float thisYOffset = fmod(hash11(fi * 0.017) * (time + 19.0) * 0.2, 4.0) - 2.0;
        float2 center = (hash21(fi) * 2.0 - 1.0) * float2(1.1, 1.0) - float2(0.0, thisYOffset);
        float radius = 0.5;
        float2 offset = uv - center;
        float twistFactor = (hash11(fi * 0.0347) * 2.0 - 1.0) * 1.9;
        float rotation = 0.1 + time * 0.2 + sin(time * 0.1) * 0.9 + (length(offset) / radius) * twistFactor;
        accum += pow(smoothstep(radius, 0.0, polygonDistance(uv - center, 0.1 + hash11(fi * 2.3) * 0.2, rotation, 5) + 0.1), 3.0);
    }

    float3 subColor = float3(0.4, 0.8, 0.2);
    float3 addColor = float3(0.3, 0.2, 0.1);

    float3 color = (float3)1.0 - accum * subColor + addColor;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_NebulaSmoke() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_NebulaSpace() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define iterations 4
#define formuparam2 0.89

#define volsteps 10
#define stepsize 0.190

#define zoom 3.900
#define tile   0.450
#define speed2  0.010

#define brightness 0.2
#define darkmatter 0.400
#define distfading 0.560
#define saturation 0.400

#define transverseSpeed 1.1
#define cloud 0.2

float triangleFn(float x, float a) {
    float output2 = 2.0 * abs(3.0 * ((x / a) - floor((x / a) + 0.5))) - 1.0;
    return output2;
}

float field(in float3 p) {
    float strength = 7.0 + 0.03 * log(1.e-6 + frac(sin(time) * 4373.11));
    float accum = 0.;
    float prev = 0.;
    float tw = 0.;

    for (int i = 0; i < 6; ++i) {
        float mag = dot(p, p);
        p = abs(p) / mag + float3(-.5, -.8 + 0.1 * sin(time * 0.2 + 2.0), -1.1 + 0.3 * cos(time * 0.15));
        float w = exp(-float(i) / 7.);
        accum += w * exp(-strength * pow(abs(mag - prev), 2.3));
        tw += w;
        prev = mag;
    }
    return max(0., 5. * accum / tw - .7);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv2 = 2. * fragCoord.xy / resolution.xy - 1.;
    float2 uvs = uv2 * resolution.xy / max(resolution.x, resolution.y);

    float time2 = time;

    float speed = speed2;
    speed = 0.005 * cos(time2 * 0.02 + 3.1415926 / 4.0);
    float formuparam = formuparam2;
    float2 uv = uvs;

    float a_xz = 0.9;
    float a_yz = -.6;
    float a_xy = 0.9 + time * 0.04;

    float2x2 rot_xz = float2x2(cos(a_xz), sin(a_xz), -sin(a_xz), cos(a_xz));
    float2x2 rot_yz = float2x2(cos(a_yz), sin(a_yz), -sin(a_yz), cos(a_yz));
    float2x2 rot_xy = float2x2(cos(a_xy), sin(a_xy), -sin(a_xy), cos(a_xy));

    float v2 = 1.0;

    float3 dir = float3(uv * zoom, 1.);
    float3 from = float3(0.0, 0.0, 0.0);

    from.x -= 5.0 * (0.5);
    from.y -= 5.0 * (0.5);

    float3 forward = float3(0., 0., 1.);

    from.x += transverseSpeed * (1.0) * cos(0.01 * time) + 0.001 * time;
    from.y += transverseSpeed * (1.0) * sin(0.01 * time) + 0.001 * time;
    from.z += 0.003 * time;

    dir.xy = mul(dir.xy, rot_xy);
    forward.xy = mul(forward.xy, rot_xy);

    dir.xz = mul(dir.xz, rot_xz);
    forward.xz = mul(forward.xz, rot_xz);

    dir.yz = mul(dir.yz, rot_yz);
    forward.yz = mul(forward.yz, rot_yz);

    from.xy = mul(from.xy, -rot_xy);
    from.xz = mul(from.xz, rot_xz);
    from.yz = mul(from.yz, rot_yz);

    float zooom = (time2 - 3311.) * speed;
    from += forward * zooom;
    float sampleShift = fmod(zooom, stepsize);

    float zoffset = -sampleShift;
    sampleShift /= stepsize;

    float s = 0.24;
    float s3 = s + stepsize / 2.0;
    float3 v = (float3)0.;
    float t3 = 0.0;

    float3 backCol2 = (float3)0.;
    for (int r = 0; r < volsteps; r++) {
        float3 p2 = from + (s + zoffset) * dir;
        float3 p3 = (from + (s3 + zoffset) * dir) * (1.9 / zoom);

        p2 = abs((float3)tile - fmod(p2, (float3)(tile * 2.))); // tiling fold
        p3 = abs((float3)tile - fmod(p3, (float3)(tile * 2.))); // tiling fold

        t3 = field(p3);

        float pa = 0., a = 0.;
        for (int i = 0; i < iterations; i++) {
            p2 = abs(p2) / dot(p2, p2) - formuparam;
            float D = abs(length(p2) - pa);

            if (i > 2) {
                a += i > 7 ? min(12., D) : D;
            }
            pa = length(p2);
        }

        a *= a * a;
        float s1 = s + zoffset;
        float fade = pow(distfading, max(0., float(r) - sampleShift));

        v += fade;

        if (r == 0)
            fade *= (1. - (sampleShift));
        if (r == volsteps - 1)
            fade *= sampleShift;
        v += float3(s1, s1 * s1, s1 * s1 * s1 * s1) * a * brightness * fade;

        backCol2 += lerp(.4, 1., v2) * float3(0.20 * t3 * t3 * t3, 0.4 * t3 * t3, t3 * 0.7) * fade;

        s += stepsize;
        s3 += stepsize;
    }

    v = lerp((float3)length(v), v, saturation);
    float4 forCol2 = float4(v * .01, 1.);

    backCol2 *= cloud;

    float3 color = forCol2.rgb + backCol2;

    // Post-processing: desaturate and darken
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a_out = max(color.r, max(color.g, color.b));
    return float4(color * a_out, a_out);
}

    )"
}

_Shader_Meta_NebulaSpace() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 40, timeOffsetMax: 120, timeAccumulate: true}
}

_Shader_HLSL_NeonCubes() {
    return "
    (
// Neon Cubes — converted from Shadertoy GLSL

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float3 H(float a) {
    return cos(radians(float3(90, 30, -30)) - a * 6.2832) * 0.5 + 0.5;
}

float2x2 makeRot(float a) {
    float4 cs = cos(a * 1.571 + float4(0, -1.571, 1.571, 0));
    return float2x2(cs.x, cs.y, cs.z, cs.w);
}

float cubes(float3 p) {
    p = abs(p - round(p));
    return max(p.x, max(p.y, p.z));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float aa = 2.0;
    float d, s;
    float2 R = resolution;
    float2 m = (float2)(cos(time / 8.0) * 0.5 + 0.5);
    float2 o;
    float3 c = (float3)0;
    float3 cam = float3(0.5, 0.5, time / 4.0);
    float3 u, v;

    float2x2 pitch = makeRot(m.y);
    float2x2 yaw = makeRot(m.x);

    for (int k = 0; k < (int)(aa * aa); k++) {
        o = float2(k % 2, k / 2) / aa;
        u = normalize(float3((fragCoord - 0.5 * R + o) / R.y, 0.7));
        u.yz = mul(pitch, u.yz);
        u.xz = mul(yaw, u.xz);
        d = 0.0;
        for (int i = 0; i < 50; i++) {
            s = smoothstep(0.2, 0.25, cubes(cam + u * d) - 0.05);
            if (s < 0.01) break;
            d += s;
        }
        v = d * 0.01 * H(length(u.xy));
        c += v + max(v, 0.5 - H(d));
    }
    c /= aa * aa;
    float3 color = pow(max(c, (float3)0), (float3)(1.0 / 2.2));

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_NeonCubes() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 0, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_NeonPlasmaStorm() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);
Texture2D iChannel1 : register(t1);
SamplerState samp1 : register(s1);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define NUM_LAYERS              7
#define LAYER_SEPERATION_FACTOR 0.041
#define ZOOM_FACTOR_PERIOD      40.0
#define ZOOM_FACTOR_MIN         0.5
#define ZOOM_FACTOR_MAX         2.8
#define SCROLL_SPEED_AT_MIN_ZOOM 4.0
#define SCROLL_SPEED_AT_MAX_ZOOM 12.000001
#define ROTATION_MATRIX_MAX_SKEW 0.4
#define ROTATION_MATRIX_SKEW_PERIOD 7.4

#define TWO_PI                  6.283185307179586476925286766559
#define LAYER_STEP_SIZE         (1.0 / (float)NUM_LAYERS)

float Hash_From2D(float2 Vec) {
    float f = Vec.x + Vec.y * 37.0;
    return frac(sin(f) * 104003.9);
}

float OscilateSinScalar(float Min, float Max, float Period) {
    return (Max - Min) * (sin(time * TWO_PI / Period) * 0.5 + 0.5) + Min;
}

float GetInterpolant(float Min, float Max, float CurrentValue) {
    return (CurrentValue - Min) / (Max - Min);
}

float2x2 ZRotate_Skewed(float Angle) {
    float Skew = 1.0 - OscilateSinScalar(0.0, ROTATION_MATRIX_MAX_SKEW, ROTATION_MATRIX_SKEW_PERIOD);
    Angle = cos(Angle * 0.1) * cos(Angle * 0.7) * cos(Angle * 0.73) * 2.0;
    return float2x2(sin(Angle * Skew), cos(Angle), -cos(Angle * Skew), sin(Angle));
}

float4 SampleMaterial(float2 uv) {
    float t = time * 0.5;

    float Sample0 = iChannel0.Sample(samp0, uv * 0.1).b;
    Sample0 -= 0.5 + sin(t + sin(uv.x) + sin(uv.y)) * 0.7;
    Sample0 *= 1.6;
    Sample0 = abs(Sample0);
    Sample0 = 1.0 / (Sample0 * 10.0 + 1.0);

    float4 Colour = (float4)Sample0 * iChannel0.Sample(samp0, uv * 0.05);
    return Colour * iChannel1.Sample(samp1, (uv + (time * 1.3)) * 0.001735);
}

float3 PostProcessColour(float3 Colour, float2 uv) {
    Colour -= (float3)length(uv * 0.1);
    Colour += Hash_From2D(uv * time * 0.01) * 0.02;

    float Brightness = length(Colour);
    Colour = lerp(Colour, (float3)Brightness, Brightness - 0.5);

    return Colour;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = fragCoord.xy / resolution.xy - 0.5;
    uv.x *= resolution.x / resolution.y;

    float3 Colour = float3(0.0, 0.0, 0.0);

    float ScaleValue = OscilateSinScalar(ZOOM_FACTOR_MIN, ZOOM_FACTOR_MAX, ZOOM_FACTOR_PERIOD);
    float ScrollInterpolant = GetInterpolant(ZOOM_FACTOR_MIN, ZOOM_FACTOR_MAX, ScaleValue);
    float ScrollValue = lerp(SCROLL_SPEED_AT_MIN_ZOOM, SCROLL_SPEED_AT_MAX_ZOOM, ScrollInterpolant);

    for (float i = 0.0; i < 1.0; i += LAYER_STEP_SIZE) {
        float2 uv2 = uv;
        uv2 = mul(uv2, ZRotate_Skewed(time * i * i * 12.0 * LAYER_SEPERATION_FACTOR));
        uv2 *= ScaleValue * (i * i + 1.0);
        uv2.xy += ScrollValue + time * 0.125;
        Colour += SampleMaterial(uv2).xyz * LAYER_STEP_SIZE * 3.5;
    }

    Colour = PostProcessColour(Colour, uv);

    // Post-processing: darken/desaturate
    float lum = dot(Colour, float3(0.299, 0.587, 0.114));
    Colour = lerp(Colour, float3(lum, lum, lum), desaturate);
    Colour = Colour * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(Colour.r, max(Colour.g, Colour.b));
    return float4(Colour * a, a);
}

    )"
}

_Shader_Meta_NeonPlasmaStorm() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "neon_plasma_storm_i0.png"}, {index: 1, file: "neon_plasma_storm_i1.png"}]}
}

_Shader_HLSL_NoiseAccident() {
    return "
    (
// Noise Accident
// Noise accident study after @Xor
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float3 mod289(float3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float4 mod289(float4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float4 permute(float4 x) { return mod289(((x * 34.0) + 1.0) * x); }
float taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }
float4 taylorInvSqrt(float4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise3D(float3 v) {
    const float2 C = float2(1.0 / 6.0, 1.0 / 3.0);
    const float4 D = float4(0.0, 0.5, 1.0, 2.0);
    float3 i = floor(v + dot(v, C.yyy));
    float3 x0 = v - i + dot(i, C.xxx);
    float3 g = step(x0.yzx, x0.xyz);
    float3 l = 1.0 - g;
    float3 i1 = min(g.xyz, l.zxy);
    float3 i2 = max(g.xyz, l.zxy);
    float3 x1 = x0 - i1 + C.xxx;
    float3 x2 = x0 - i2 + C.yyy;
    float3 x3 = x0 - D.yyy;

    i = mod289(i);
    float4 p = permute(permute(permute(
                 i.z + float4(0.0, i1.z, i2.z, 1.0))
               + i.y + float4(0.0, i1.y, i2.y, 1.0))
               + i.x + float4(0.0, i1.x, i2.x, 1.0));

    float n_ = 0.142857142857;
    float3 ns = n_ * D.wyz - D.xzx;

    float4 j = p - 49.0 * floor(p * ns.z * ns.z);

    float4 x_ = floor(j * ns.z);
    float4 y_ = floor(j - 7.0 * x_);

    float4 x = x_ * ns.x + ns.yyyy;
    float4 y = y_ * ns.x + ns.yyyy;
    float4 h = 1.0 - abs(x) - abs(y);

    float4 b0 = float4(x.xy, y.xy);
    float4 b1 = float4(x.zw, y.zw);

    float4 s0 = floor(b0) * 2.0 + 1.0;
    float4 s1 = floor(b1) * 2.0 + 1.0;
    float4 sh = -step(h, (float4)0);

    float4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    float4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    float3 p0 = float3(a0.xy, h.x);
    float3 p1 = float3(a0.zw, h.y);
    float3 p2 = float3(a1.xy, h.z);
    float3 p3 = float3(a1.zw, h.w);

    float4 norm = taylorInvSqrt(float4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    float4 m = max(0.6 - float4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m * m, float4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float4 diffuse = (float4)0;
    float3 R = float3(resolution, resolution.y);

    for (float i = 1.0; i <= 100.0; i += 1.0) {
        float3 pos = (float3(fragCoord, 1.0) * 2.0 - R) / resolution.y * i * 0.1 + time;
        diffuse += cos(snoise3D(pos) + i + float4(1.0, 2.0, 2.0, 0.0)) / 1e1;
    }

    float3 color = max((float3)0, diffuse.rgb);

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_NoiseAccident() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_NoiseAnimationElectric() {
    return "
    (
// Noise animation - Electric
// by nimitz (stormoid.com) (twitter: @stormoid)
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// Converted from Shadertoy (ldlXRS) to Alt-Tabby HLSL

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define t time*0.15
#define tau 6.2831853

float2x2 makem2(in float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return float2x2(c, -s, s, c);
}

float noise(in float2 x) {
    return iChannel0.Sample(samp0, x * 0.01).x;
}

float fbm(in float2 p) {
    float z = 2.0;
    float rz = 0.0;
    float2 bp = p;
    for (float i = 1.0; i < 6.0; i++) {
        rz += abs((noise(p) - 0.5) * 2.0) / z;
        z = z * 2.0;
        p = p * 2.0;
    }
    return rz;
}

float dualfbm(in float2 p) {
    // get two rotated fbm calls and displace the domain
    float2 p2 = p * 0.7;
    float2 basis = float2(fbm(p2 - t * 1.6), fbm(p2 + t * 1.7));
    basis = (basis - 0.5) * 0.2;
    p += basis;

    // coloring
    return fbm(mul(p, makem2(t * 0.2)));
}

float circ(float2 p) {
    float r = length(p);
    r = log(sqrt(r));
    return abs(fmod(r * 4.0, tau) - 3.14) * 3.0 + 0.2;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // setup system
    float2 p = fragCoord.xy / resolution.xy - 0.5;
    p.x *= resolution.x / resolution.y;
    p *= 4.0;

    float rz = dualfbm(p);

    // rings
    p /= exp(fmod(t * 10.0, 3.14159));
    rz *= pow(abs(0.1 - circ(p)), 0.9);

    // final color
    float3 col = float3(0.2, 0.1, 0.4) / rz;
    col = pow(abs(col), (float3)0.99);

    // darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_NoiseAnimationElectric() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "noise_animation_electric_i0.png"}], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_NoiseAnimationFlow() {
    return "
    (
// Noise animation - Flow
// 2014 by nimitz (twitter: @stormoid)
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// Converted from Shadertoy (MdlXRS) to Alt-Tabby HLSL

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define t time*0.1
#define tau 6.2831853

static const float2x2 m2 = float2x2(0.80, 0.60, -0.60, 0.80);

float2x2 makem2(in float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return float2x2(c, -s, s, c);
}

float noise(in float2 x) {
    return iChannel0.Sample(samp0, x * 0.01).x;
}

float grid(float2 p) {
    float s = sin(p.x) * cos(p.y);
    return s;
}

float flow(in float2 p) {
    float z = 2.0;
    float rz = 0.0;
    float2 bp = p;
    for (float i = 1.0; i < 7.0; i++) {
        bp += t * 1.5;
        float2 gr = float2(grid(p * 3.0 - t * 2.0), grid(p * 3.0 + 4.0 - t * 2.0)) * 0.4;
        gr = normalize(gr) * 0.4;
        gr = mul(gr, makem2((p.x + p.y) * 0.3 + t * 10.0));
        p += gr * 0.5;

        rz += (sin(noise(p) * 8.0) * 0.5 + 0.5) / z;

        p = lerp(bp, p, 0.5);
        z *= 1.7;
        p *= 2.5;
        p = mul(p, m2);
        bp *= 2.5;
        bp = mul(bp, m2);
    }
    return rz;
}

float spiral(float2 p, float scl) {
    float r = length(p);
    r = log(r);
    float a = atan2(p.y, p.x);
    return abs(fmod(scl * (r - 2.0 / scl * a), tau) - 1.0) * 2.0;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 p = fragCoord.xy / resolution.xy - 0.5;
    p.x *= resolution.x / resolution.y;
    p *= 3.0;
    float rz = flow(p);
    p /= exp(fmod(t * 3.0, 2.1));
    rz *= (6.0 - spiral(p, 3.0)) * 0.9;
    float3 col = float3(0.2, 0.07, 0.01) / rz;
    col = pow(abs(col), (float3)1.01);

    // darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_NoiseAnimationFlow() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "noise_animation_flow_i0.png"}], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_NoiseCristal() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

#define PI 3.141592
#define TWOPI 6.283184

#define R2D 180.0/PI*
#define D2R PI/180.0*

float2x2 rotMat(float r) {
    float c = cos(r);
    float s = sin(r);
    return float2x2(c, -s, s, c);
}

float abs1d(float x) { return abs(frac(x) - 0.5); }
float2 abs2d(float2 v) { return abs(frac(v) - 0.5); }
float cos1d(float p) { return cos(p * TWOPI) * 0.25 + 0.25; }
float sin1d(float p) { return sin(p * TWOPI) * 0.25 + 0.25; }

#define OC 15.0

float3 Oilnoise(float2 pos, float3 RGB)
{
    float2 q = (float2)0.0;
    float result = 0.0;

    float s = 2.2;
    float gain = 0.44;
    float2 aPos = abs2d(pos) * 0.5;

    for (float i = 0.0; i < OC; i++)
    {
        pos = mul(rotMat(D2R 30.), pos);
        float t = (sin(time) * 0.5 + 0.5) * 0.2 + time * 0.8;
        q = pos * s + t;
        q = pos * s + aPos + t;
        q = cos(q);

        result += sin1d(dot(q, (float2)0.3)) * gain;

        s *= 1.07;
        aPos += cos(smoothstep(0.0, 0.15, q));
        aPos = mul(rotMat(D2R 5.0), aPos);
        aPos *= 1.232;
    }

    result = pow(result, 4.504);
    return clamp(RGB / abs1d(dot(q, float2(-0.240, 0.000))) * .5 / result, (float3)0.0, (float3)1.0);
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float3 col = (float3)0.0;
    float2 st = fragCoord / resolution.xy;
    st.x = ((st.x - 0.5) * (resolution.x / resolution.y)) + 0.5;

    st *= 3.;

    float3 rgb = float3(0.30, .8, 1.200);

    float AA = 1.0;
    float2 pix = 1.0 / resolution.xy;
    float2 aaST = (float2)0.0;

    for (float i = 0.0; i < AA; i++)
    {
        for (float j = 0.0; j < AA; j++)
        {
            aaST = st + pix * float2((i + 0.5) / AA, (j + 0.5) / AA);
            col += Oilnoise(aaST, rgb);
        }
    }

    col /= AA * AA;

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_NoiseCristal() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_NoiseOil() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI 3.141592
#define TWOPI 6.283184
#define D2R (PI / 180.0)

float2x2 rotMat(float r) {
    float c = cos(r);
    float s = sin(r);
    return float2x2(c, -s, s, c);
}

float abs1d(float x) { return abs(frac(x) - 0.5); }
float2 abs2d(float2 v) { return abs(frac(v) - 0.5); }

#define OC 15.0

float3 Oilnoise(float2 pos, float3 RGB)
{
    float2 q = (float2)0;
    float result = 0.0;

    float s = 2.2;
    float gain = 0.44;
    float2 aPos = abs2d(pos) * 0.5;

    for (float i = 0.0; i < OC; i++)
    {
        pos = mul(pos, rotMat(D2R * 30.0));
        float t = (sin(time) * 0.5 + 0.5) * 0.2 + time * 0.8;
        q = pos * s + aPos + t;
        q = float2(cos(q.x), cos(q.y));

        result += abs1d(dot(q, float2(0.3, 0.3))) * gain;

        s *= 1.07;
        aPos += cos(q);
        aPos = mul(aPos, rotMat(D2R * 5.0));
        aPos *= 1.2;
    }

    result = pow(result, 4.0);
    return clamp(RGB / result, (float3)0, (float3)1);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float3 col = float3(0.0, 0.0, 0.0);
    float2 st = fragCoord / resolution.xy;
    st.x = ((st.x - 0.5) * (resolution.x / resolution.y)) + 0.5;

    st *= 5.0;

    col = Oilnoise(st, float3(0.30, 0.7, 1.200));

    // Darken / desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_NoiseOil() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_Nox() {
    return "
    (
// Nox — based on https://www.shadertoy.com/view/WfKGRD
// Original by diatribes
// Cloud tunnel with moon - noise, turbulence, and translucency

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float d = 0, s = 0, n = 0;
    float t = time * 0.05;
    float2 u = (fragCoord - resolution * 0.5) / resolution.y;

    float4 o = (float4)0;

    for (int iter = 0; iter < 100; iter++) {
        float3 p = float3(u * d, d + t * 4.0);
        p += cos(p.z + t + p.yzx * 0.5) * 0.5;
        s = 5.0 - length(p.xy);

        // Inner noise loop — GLSL used mat2(cos(vec4)) golf trick
        for (n = 0.06; n < 2.0; n += n) {
            float4 rv = cos(t * 0.1 + float4(0, 33, 11, 0));
            // GLSL mat2(v4) fills column-major; for mul(v, m) pattern
            // HLSL float2x2 with same component order works
            p.xy = mul(p.xy, float2x2(rv.x, rv.y, rv.z, rv.w));
            s -= abs(dot(sin(p.z + t + p * n * 20.0), (float3)0.05)) / n;
        }

        s = 0.02 + abs(s) * 0.1;
        d += s;
        o += 1.0 / s;
    }

    o = tanh(o / d / 9e2 / length(u));

    float3 color = o.rgb;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float outA = max(color.r, max(color.g, color.b));
    return float4(color * outA, outA);
}

    )"
}

_Shader_Meta_Nox() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_OVortex() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const int cell_amount = 2;

float2 modulo(float2 divident, float2 divisor) {
    float2 positiveDivident = fmod(divident, divisor) + divisor;
    return fmod(positiveDivident, divisor);
}

float2 random2(float2 value) {
    value = float2(dot(value, float2(127.1, 311.7)),
                   dot(value, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(value) * 43758.5453123);
}

float noise(float2 uv) {
    float2 _period = (float2)3.0;
    uv = uv * float(cell_amount);
    float2 cMin = floor(uv);
    float2 cMax = ceil(uv);
    float2 uvFract = frac(uv);

    cMin = modulo(cMin, _period);
    cMax = modulo(cMax, _period);

    float2 blur = smoothstep(0.0, 1.0, uvFract);

    float2 ll = random2(float2(cMin.x, cMin.y));
    float2 lr = random2(float2(cMax.x, cMin.y));
    float2 ul = random2(float2(cMin.x, cMax.y));
    float2 ur = random2(float2(cMax.x, cMax.y));

    float2 fraction = frac(uv);

    return lerp(lerp(dot(ll, fraction - float2(0, 0)),
                     dot(lr, fraction - float2(1, 0)), blur.x),
                lerp(dot(ul, fraction - float2(0, 1)),
                     dot(ur, fraction - float2(1, 1)), blur.x), blur.y) * 0.8 + 0.5;
}

float fbm(float2 uv) {
    float amplitude = 0.5;
    float frequency = 3.0;
    float value = 0.0;

    for (int i = 0; i < 6; i++) {
        value += amplitude * noise(frequency * uv);
        amplitude *= 0.5;
        frequency *= 2.0;
    }
    return value;
}

float2 polar(float2 uv, float2 center, float zoom, float repeat) {
    float2 dir = uv - center;
    float radius = length(dir) * 2.0;
    float angle = atan2(dir.y, dir.x) * 1.0 / (3.1416 * 2.0);
    return float2(radius * zoom, angle * repeat);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = floor((2.0 * fragCoord - resolution) / resolution.y * 1000.0) / 500.0;
    float2 puv = polar(uv, (float2)0.0, 0.5, 1.0);
    float3 c = (float3)0.0;

    float3 milkBlack = float3(0.050980392156862744, 0.050980392156862744, 0.0784313725490196);
    float3 milkGrey = float3(0.3215686274509804, 0.14901960784313725, 0.24313725490196078);
    float3 milkWhite = float3(0.6745098039215687, 0.19607843137254902, 0.19607843137254902);

    float n = fbm(puv * float2(1.0, 1.0) + float2(time * 0.2, 5.0 / (puv.x) * -0.1) * 0.5);
    n = n * n / sqrt(puv.x) * 0.8;

    c = milkBlack;
    if (n > 0.2) {
        c = milkGrey;
    }
    if (n > 0.25) {
        c = milkWhite;
    }
    if (puv.x < 0.4) {
        c = milkBlack;
    }

    // Post-processing: darken/desaturate
    float lum = dot(c, float3(0.299, 0.587, 0.114));
    c = lerp(c, float3(lum, lum, lum), desaturate);
    c = c * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(c.r, max(c.g, c.b));
    return float4(c * a, a);
}

    )"
}

_Shader_Meta_OVortex() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_OilyThing() {
    return "
    (
// Oily Thing
//  Converted from Shadertoy: https://www.shadertoy.com/view/fdXyRX
//  Author: pancakespeople
//  Gradient Noise by Inigo Quilez - iq/2013

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2 random2(float2 st) {
    st = float2(dot(st, float2(127.1, 311.7)),
                dot(st, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(st) * 43758.5453123);
}

float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(lerp(dot(random2(i + float2(0.0, 0.0)), f - float2(0.0, 0.0)),
                     dot(random2(i + float2(1.0, 0.0)), f - float2(1.0, 0.0)), u.x),
                lerp(dot(random2(i + float2(0.0, 1.0)), f - float2(0.0, 1.0)),
                     dot(random2(i + float2(1.0, 1.0)), f - float2(1.0, 1.0)), u.x), u.y);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution.xy;
    float calmness = 0.1;
    float waveIntensity = 0.5;

    float2 noiseCoord = uv;
    noiseCoord.x += cos(time / 10.0);
    noiseCoord.y += sin(time / 10.0);

    uv.x += noise(noiseCoord / calmness) * waveIntensity;
    uv.y += noise((noiseCoord + 100.0) / calmness) * waveIntensity;

    float4 col = iChannel0.Sample(samp0, uv);
    col += noise(noiseCoord);
    col *= float4(0.3, 0.6, 1.0, 1.0);

    float3 color = col.rgb;

    // Darken/desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_OilyThing() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "oily_thing_i0.png"}], timeAccumulate: true}
}

_Shader_HLSL_OpticalSpaghetti() {
    return "
    (
// Optical Spaghetti — converted from Shadertoy GLSL

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 u = fragCoord.xy;

    float i = 0.0;
    float a = 0.0;
    float d = 0.0;
    float s = 0.0;
    float t = time + 10.0;
    float r = 0.0;

    float3 p = float3(resolution, 1.0);
    u = (u + u - p.xy) / p.y;

    float4 o = (float4)0;

    for (i = 0.0; i++ < 175.0; ) {
        s = 0.004 + abs(s) * 0.1;
        d += s;

        o += s * d;
        o.r += (d * 1.5 - 5.0 / s) * 0.25;
        o.b += sin(d * 0.09 + p.z * 0.3) * 2.0 / s;
        o.g += sin(d * 0.2) * 1.0 / s;

        p = float3(u * d, d + t * 5.0);
        s = min(p.z, 1.9 + sin(p.z) * 0.15);

        for (a = 1.0; a < 2.0; a += a) {
            p += cos(t * 0.1 - p.yzx * 0.5) * 0.5;

            r = p.z * 0.1 + sin(t * 0.2);

            float2x2 rot = float2x2(cos(r), -sin(r), sin(r), cos(r));
            p.xy = mul(p.xy, rot);
            s += abs(sin(p.x * a)) * (2.2 + sin(t * 0.1) * 0.25) * -abs(sin(abs(p.y) * a) / a);
        }
    }

    o = pow(tanh(o * o / 1.5e8 * length(u)), (float4)(1.0 / 2.2));
    o *= o;

    float3 color = o.rgb;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_OpticalSpaghetti() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_OrganicTexture() {
    return "
    (
// Organic Texture - converted from Shadertoy (tt2XDV)
// Author: Eseris - License: CC BY-NC-SA 3.0
// Gradient noise by iq: https://www.shadertoy.com/view/XdXGW8

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define safepow(x,n) pow(abs(x),n)

float2 hash(in float2 x) {
    const float2 k = float2(0.3183099, 0.3678794);
    x = x * k + k.yx;
    return -1.0 + 2.0 * frac(16.0 * k * frac(x.x * x.y * (x.x + x.y)));
}

float noise(in float2 p) {
    float2 i = floor(p);
    float2 f = frac(p);

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(lerp(dot(hash(i + float2(0.0, 0.0)), f - float2(0.0, 0.0)),
                     dot(hash(i + float2(1.0, 0.0)), f - float2(1.0, 0.0)), u.x),
                lerp(dot(hash(i + float2(0.0, 1.0)), f - float2(0.0, 1.0)),
                     dot(hash(i + float2(1.0, 1.0)), f - float2(1.0, 1.0)), u.x), u.y);
}

float heightmap(float2 p) {
    float h = 0.0;
    float2 q = 4.0 * p + noise(-4.0 * p + time * float2(-0.07, 0.03));
    float2 r = 7.0 * p + float2(37.0, 59.0) + noise(5.0 * p + time * float2(0.08, 0.03));
    float2 s = 3.0 * p + noise(5.0 * p + time * float2(0.1, 0.05) + float2(13.0, 37.0));
    float smoothAbs = 0.2;
    h += 1.0 * noise(s);
    h += 0.9 * safepow(noise(q), 1.0 + smoothAbs);
    h += 0.7 * safepow(noise(r), 1.0 + smoothAbs);

    h = 0.65 * h + 0.33;
    return h;
}

float3 calcNormal(float2 p) {
    float2 e = float2(1e-3, 0.0);
    return normalize(float3(
        heightmap(p - e.xy) - heightmap(p + e.xy),
        heightmap(p - e.yx) - heightmap(p + e.yx),
        -2.0 * e.x));
}

float3 getColor(float x) {
    float3 a = float3(0.1, 0.0, 0.03);
    float3 b = float3(1.0, 0.05, 0.07);
    float3 c = float3(0.9, 0.2, 0.3);
    return lerp(a, lerp(b, c, smoothstep(0.4, 0.9, x)), smoothstep(0.0, 0.9, x));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = fragCoord / resolution.y;
    float h = heightmap(uv);
    float3 v = (float3)h;
    v.yz *= 3.0;
    float3 nor = calcNormal(uv);
    nor.xy *= 0.4;
    nor = normalize(nor);

    float3 mtl = getColor(h);
    mtl = clamp(mtl, 0.0, 1.0);
    float3 ld = normalize(float3(1.0, -1.0, 1.0));
    float3 ha = normalize(ld - float3(0.0, 0.0, -1.0));

    float3 col = (float3)0.0;
    col += mtl * 0.8;
    col += 0.2 * mtl * safepow(max(dot(normalize(nor), -ld), 0.0), 3.0);
    col += 0.3 * h * safepow(dot(normalize(nor), ha), 20.0);

    // Darken / desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_OrganicTexture() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_OverstimulatedNeurons() {
    return "
    (
// Overstimulated Neurons by Chaotnix
// Ported from https://www.shadertoy.com/view/NdlSD8
// Fork of Abstract Glassy Field by Shane
// Raymarched blobby field with fake glass refraction, glow, and electric charge

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define FAR 50.

// GLSL mod: x - y * floor(x/y) (differs from HLSL fmod for negatives)
float glsl_mod(float x, float y) { return x - y * floor(x / y); }

// Tri-planar blending for iChannel0
// Based on GPU Gems 3 - Ryan Geiss
float3 tpl0(in float3 p, in float3 n) {
    n = max(abs(n) - .2, 0.001);
    n /= dot(n, (float3)1);
    float3 tx = iChannel0.Sample(samp0, p.zy).xyz;
    float3 ty = iChannel0.Sample(samp0, p.xz).xyz;
    float3 tz = iChannel0.Sample(samp0, p.xy).xyz;
    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);
}

// Camera path
float3 camPath(float t) {
    float a = sin(t * 0.11);
    float b = cos(t * 0.14);
    return float3(a*4. - b*1.5, b*1.7 + a*1.5, t);
}

// Distance field - abstract blobby sinusoidal mutation with fine bumps
float map(float3 p) {
    p.xy -= camPath(p.z).xy;
    p = cos(p*.1490 + sin(p.zxy*.4375));
    float n = dot(p, p);
    p = sin(p*3. + cos(p.yzx*12.));
    return (n - p.x*p.y*p.z*.35 - .9)*1.33 + 0.001 * iChannel0.Sample(samp0, p.xy).x;
}

// Ambient occlusion (based on IQ)
float cao(in float3 p, in float3 n) {
    float sca = 1., occ = 0.;
    [loop]
    for (float i = 0.; i < 5.; i++) {
        float hr = .01 + i*.35/4.;
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= .7;
    }
    return clamp(1. - occ, 0.3, 1.);
}

// Normal via central differences
float3 nr(float3 p) {
    const float2 e = float2(.002, 0);
    return normalize(float3(map(p + e.xyy) - map(p - e.xyy),
                            map(p + e.yxy) - map(p - e.yxy),
                            map(p + e.yyx) - map(p - e.yyx)));
}

// Raymarcher with glow accumulation
float trace(in float3 ro, in float3 rd, inout float ac) {
    ac = 0.;
    float t = 0., h;
    [loop]
    for (int i = 0; i < 128; i++) {
        h = map(ro + rd*t);
        if (abs(h) < .001*(t*.25 + 1.) || t > FAR) break;
        t += h;
        if (abs(h) < .35) ac += (.35 - abs(h))/24.;
    }
    return min(t, FAR);
}

// Soft shadows
float sha(in float3 ro, in float3 rd, in float start, in float end, in float k) {
    float shade = 1.;
    float dist = start;
    [loop]
    for (int i = 0; i < 24; i++) {
        float h = map(ro + rd*dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));
        dist += clamp(h, .01, .2);
        if (abs(h) < .001 || dist > end) break;
    }
    return min(max(shade, 0.) + .4, 1.);
}

// Texture bump mapping using tri-planar iChannel0
float3 db0(in float3 p, in float3 n, float bf) {
    const float2 e = float2(.001, 0);
    float3 m0 = tpl0(p - e.xyy, n);
    float3 m1 = tpl0(p - e.yxy, n);
    float3 m2 = tpl0(p - e.yyx, n);
    float3 lum = float3(.299, .587, .114);
    float3 g = float3(dot(m0, lum), dot(m1, lum), dot(m2, lum));
    g = (g - dot(tpl0(p, n), lum)) / e.x;
    g -= n*dot(n, g);
    return normalize(n + g*bf);
}

// 3D value noise (IQ)
float n3D(float3 p) {
    const float3 s = float3(7, 157, 113);
    float3 ip = floor(p); p -= ip;
    float4 h = float4(0., s.yz, s.y + s.z) + dot(ip, s);
    p = p*p*(3. - 2.*p);
    h = lerp(frac(sin(h)*43758.5453), frac(sin(h + s.x)*43758.5453), p.x);
    h.xy = lerp(h.xz, h.yw, p.y);
    return lerp(h.x, h.y, p.z);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Screen coordinates
    float2 u = (fragCoord - resolution.xy*.5) / resolution.y;

    // Camera setup
    float speed = 3.;
    float3 o = camPath(time*speed);
    float3 lk = camPath(time*speed + .25);
    float3 l = camPath(time*speed + 2.) + float3(0, 1, 0);

    // Ray direction with lens distortion
    float FOV = 3.14159/2.;
    float3 fwd = normalize(lk - o);
    float3 rgt = normalize(float3(fwd.z, 0, -fwd.x));
    float3 up = cross(fwd, rgt);
    float3 r = fwd + FOV*(u.x*rgt + u.y*up);
    r = normalize(float3(r.xy, (r.z - length(r.xy)*.125)));

    // Raymarch
    float accum;
    float t = trace(o, r, accum);

    float3 col = (float3)0;

    if (t < FAR) {
        float3 p = o + r*t;
        float3 n = nr(p);
        float3 svn = n;

        // Texture bump
        float sz = 1./3.;
        n = db0(p*sz, n, .1/(1. + t*.25/FAR));

        l -= p;
        float d = max(length(l), 0.001);
        l /= d;

        float at = 1./(1. + d*.05 + d*d*.0125);

        float ao = cao(p, n);
        float sh = sha(p, l, 0.04, d, 16.);

        float di = max(dot(l, n), 0.);
        float sp = pow(max(dot(reflect(r, n), l), 0.), 64.);
        float fr = clamp(1.0 + dot(r, n), .0, 1.);

        float3 tx = (float3).05;

        // Simple coloring
        col = tx*(di*.1 + ao*.25) + float3(.5, .7, 1)*sp*2. + float3(1, .7, .4)*pow(fr, 8.)*.25;

        // Direct texture lookups for fake reflection and refraction
        float3 halfN = svn*.5 + n*.5;
        float3 refl = iChannel0.Sample(samp0, 0.2 * normalize(reflect(r, halfN)).xy).xyz;
        float3 refr_col = iChannel0.Sample(samp0, 0.2 * normalize(refract(r, halfN, 1./1.31)).xy).xyz;
        refl *= refl*.3;
        refr_col *= refr_col*.4;

        float3 refCol = lerp(refr_col, refl, pow(fr, 5.));
        col += refCol*((di*di*.25 + .75) + ao*.25)*1.5;

        // Hue variation for depth
        col = lerp(col.xzy, col, di*.85 + .15);

        // Glow from raymarching accumulation
        float3 accCol = float3(1, .3, .1)*accum;
        float3 gc = pow(min(float3(1.5, 1, 1)*accum, 1.), float3(1, 2.5, 12.))*.5 + accCol*.5;
        col += col*gc*12.;

        // Purple electric charge
        float hi = abs(glsl_mod(t + 0.02 * iChannel0.Sample(samp0, p.xy).x, 8.) - 4.)*2.;
        float3 cCol = float3(.01, .05, 1)*col*1./(.001 + hi*hi*.2);
        col += lerp(cCol.yxz, cCol, n3D(p*3.));

        // Shading
        col *= ao*sh*at;
    }

    // Fog
    float3 fog = float3(.125, .04, .05)*(r.y*.5 + .5);
    col = lerp(col, fog, smoothstep(0., .95, t/FAR));

    // Vignette
    u = fragCoord / resolution.xy;
    col = lerp((float3)0, col, pow(16.0*u.x*u.y*(1.0 - u.x)*(1.0 - u.y), .125)*.5 + .5);

    // Gamma correction
    col = sqrt(clamp(col, 0., 1.));

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col *= 1.0 - darken;

    // Alpha from brightness, premultiply
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_OverstimulatedNeurons() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "overstimulated_neurons_i0.png"}], timeOffsetMin: 40, timeOffsetMax: 120, timeAccumulate: true}
}

_Shader_HLSL_Paint1() {
    return "
    (
// Paint 1 - JuliaPoo (Shadertoy MlVcDt)
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2x2 rot(float a) {
    float s = sin(a);
    float c = cos(a);
    return float2x2(s, c, -c, s);
}

float noise(in float2 x) { return smoothstep(0., 1., sin(1.5 * x.x) * sin(1.5 * x.y)); }

float fbm(float2 p) {
    float2x2 m = rot(.4);
    float f = 0.0;
    f += 0.500000 * (0.5 + 0.5 * noise(p)); p = mul(p, m) * 2.02;
    f += 0.250000 * (0.5 + 0.5 * noise(p)); p = mul(p, m) * 2.03;
    f += 0.125000 * (0.5 + 0.5 * noise(p)); p = mul(p, m) * 2.01;
    f += 0.062500 * (0.5 + 0.5 * noise(p)); p = mul(p, m) * 2.04;
    f += 0.031250 * (0.5 + 0.5 * noise(p)); p = mul(p, m) * 2.01;
    f += 0.015625 * (0.5 + 0.5 * noise(p));
    return f / 0.96875;
}

float pattern(in float2 p, out float2 q, out float2 r, float t) {

    q.x = fbm(p + float2(0.0, 0.0) + .7 * t);
    q.y = fbm(p + float2(5.2, 1.3) + 1. * t);

    r.x = fbm(p + 10.0 * q + float2(1.7, 9.2) + sin(t));
    r.y = fbm(p + 12.0 * q + float2(8.3, 2.8) + cos(t));

    return fbm(p + 3.0 * r);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // iMouse zeroed — shader looks great without mouse interaction
    float2 uv = fragCoord.xy / resolution.xy * 2.;
    uv.x *= resolution.x / resolution.y;

    float2 q, r;
    float3 col1 = float3(0., .9, .8);
    float3 col2 = float3(1., .6, .5);

    float f = pattern(uv, q, r, 0.1 * time);

    float3 c = lerp(col1, (float3)0, smoothstep(.0, .95, f));
    float3 a = col2 * smoothstep(0., .8, dot(q, r) * 0.6);
    c = sqrt(c * c + a * a);

    // Darken/desaturate post-processing
    float lum = dot(c, float3(0.299, 0.587, 0.114));
    c = lerp(c, float3(lum, lum, lum), desaturate);
    c = c * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(c.r, max(c.g, c.b));
    return float4(c * alpha, alpha);
}

    )"
}

_Shader_Meta_Paint1() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_PaintArchipelago() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float hash(float2 p) { return frac(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

float noise(float2 x) {
    float2 i = floor(x);
    float2 f = frac(x);
    float a = hash(i);
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

#define octaves 14

float fbm(in float2 p) {
    float value = 0.0;
    float freq = 1.0;
    float amp = 0.5;

    for (int i = 0; i < octaves; i++) {
        value += amp * (noise((p - (float2)1.0) * freq));
        freq *= 1.9;
        amp *= 0.6;
    }
    return value;
}

float pattern(in float2 p) {
    float2 aPos = float2(sin(time * 0.005), sin(time * 0.01)) * 6.0;
    float2 aScale = (float2)3.0;
    float a = fbm(p * aScale + aPos);

    float2 bPos = float2(sin(time * 0.01), sin(time * 0.01)) * 1.0;
    float2 bScale = (float2)0.6;
    float b = fbm((p + a) * bScale + bPos);

    float2 cPos = float2(-0.6, -0.5) + float2(sin(-time * 0.001), sin(time * 0.01)) * 2.0;
    float2 cScale = (float2)2.6;
    float c = fbm((p + b) * cScale + cPos);
    return c;
}

float3 palette(in float t) {
    float3 a = float3(0.5, 0.5, 0.5);
    float3 b = float3(0.45, 0.25, 0.14);
    float3 c = float3(1.0, 1.0, 1.0);
    float3 d = float3(0.0, 0.1, 0.2);
    return a + b * cos(6.28318 * (c * t + d));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 p = fragCoord.xy / resolution.xy;
    p.x *= resolution.x / resolution.y;
    float value = pow(pattern(p), 2.0);
    float3 color = palette(value);

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_PaintArchipelago() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_PalaceOfMind() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

float glsl_mod(float x, float y) {
    return x - y * floor(x / y);
}

float3 glsl_mod3(float3 x, float y) {
    return x - y * floor(x / y);
}

float2 rot(float2 p, float r) {
    // GLSL mat2(cos,sin,-sin,cos) is column-major; transpose for HLSL row-major
    float2x2 m = float2x2(cos(r), -sin(r), sin(r), cos(r));
    return mul(m, p);
}

float cube(float3 p, float3 s) {
    float3 q = abs(p);
    float3 m = max(s - q, 0.0);
    return length(max(q - s, 0.0)) - min(min(m.x, m.y), m.z);
}

float hasira(float3 p, float3 s) {
    float2 q = abs(p.xy);
    float2 m = max(s.xy - q.xy, float2(0.0, 0.0));
    return length(max(q.xy - s.xy, 0.0)) - min(m.x, m.y);
}

float closs(float3 p, float3 s) {
    float d1 = hasira(p, s);
    float d2 = hasira(p.yzx, s.yzx);
    float d3 = hasira(p.zxy, s.zxy);
    return min(min(d1, d2), d3);
}

float rand(float2 co) {
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    float a = rand(i);
    float b = rand(i + float2(1.0, 0.0));
    float c = rand(i + float2(0.0, 1.0));
    float d = rand(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float dist(float3 p) {
    float k = 1.2;
    float3 sxyz = floor((p.xyz - 0.5 * k) / k) * k;
    float sz = rand(sxyz.xz);
    float t = time * 0.05 + 50.0;
    p.xy = rot(p.xy, t * sign(sz - 0.5) * (sz * 0.5 + 0.7));
    p.z += t * sign(sz - 0.5) * (sz * 0.5 + 0.7);
    p = glsl_mod3(p, k) - 0.5 * k;
    float s = 7.0;
    p *= s;
    p.yz = rot(p.yz, 0.76);
    for (int i = 0; i < 4; i++) {
        p = abs(p) - 0.4 + (0.25 + 0.1 * sz) * sin(t * (0.5 + sz));
        p.xy = rot(p.xy, t * (0.7 + sz));
        p.yz = rot(p.yz, 1.3 * t + sz);
    }

    float d1 = closs(p, float3(0.06, 0.06, 0.06));

    return d1 / s;
}

float3 gn(float3 p) {
    const float h = 0.001;
    const float2 k = float2(1.0, -1.0);
    return normalize(k.xyy * dist(p + k.xyy * h) +
                     k.yyx * dist(p + k.yyx * h) +
                     k.yxy * dist(p + k.yxy * h) +
                     k.xxx * dist(p + k.xxx * h));
}

float3 lighting(float3 p, float3 view) {
    float3 normal = gn(p);
    float vn = clamp(dot(-view, normal), 0.0, 1.0);
    float3 ld = normalize(float3(-1, 0.9 * sin(time * 0.5) - 0.1, 0));
    float NdotL = max(dot(ld, normal), 0.0);
    float3 R = normalize(-ld + NdotL * normal * 2.0);
    float spec = pow(max(dot(-view, R), 0.0), 20.0) * clamp(sign(NdotL), 0.0, 1.0);
    float3 col = float3(1, 1, 1) * (pow(vn, 2.0) * 0.9 + spec * 0.3);
    float k = 0.5;
    float ks = 0.9;
    float2 sxz = floor((p.xz - 0.5 * ks) / ks) * ks;
    float sx = rand(sxz);
    float sy = rand(sxz + 100.1);
    float emissive = clamp(0.001 / abs(glsl_mod(abs(p.y * sx + p.x * sy) + time * sign(sx - 0.5) * 0.4, k) - 0.5 * k), 0.0, 1.0);
    return clamp(col * float3(0.3, 0.5, 0.9) * 0.7 + emissive * float3(0.2, 0.2, 1.0), 0.0, 1.0);
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 p = (fragCoord.xy * 2.0 - resolution) / resolution.yy;
    float3 tn = time * float3(0.0, 0.0, 1.0) * 0.3;
    float tk = time * 0.3;
    float3 ro = float3(1.0 * cos(tk), 0.2 * sin(tk), 1.0 * sin(tk)) + tn;
    float3 ta = float3(0.0, 0.0, 0.0) + tn;
    float3 cdir = normalize(ta - ro);
    float3 up = float3(0., 1., 0.);
    float3 side = cross(cdir, up);
    up = cross(side, cdir);
    float fov = 1.3;
    float3 rd = normalize(p.x * side + p.y * up + cdir * fov);
    float d = 0.0;
    float t = 0.1;
    float far = 18.;
    float near = t;
    float hit = 0.0001;
    for (int i = 0; i < 100; i++) {
        d = dist(ro + rd * t);
        t += d;
        if (hit > d) break;
    }
    float3 bcol = float3(0.1, 0.1, 0.8);
    float3 col = lighting(ro + rd * t, rd);

    col = lerp(bcol, col, pow(clamp((far - t) / (far - near), 0.0, 1.0), 2.0));

    col.x = pow(col.x, 2.2);
    col.y = pow(col.y, 2.2);
    col.z = pow(col.z, 2.2);
    col *= 2.0;

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float al = saturate(max(col.r, max(col.g, col.b)));
    col = saturate(col);
    return float4(col * al, al);
}

    )"
}

_Shader_Meta_PalaceOfMind() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 20, timeOffsetMax: 80, timeAccumulate: true}
}

_Shader_HLSL_PathToTheColorfulInfinity() {
    return "
    (
// Path to the colorful infinity by benoitM
// Ported from https://www.shadertoy.com/view/WtjyzR
// 2D fractal space-folding with layered depth

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define NUM_LAYERS 16.
#define ITER 23

float4 tex_fractal(float3 p) {
    float t = time + 78.;
    float4 o = float4(p.xyz, 3.*sin(t*.1));
    float4 dec = float4(1., .9, .1, .15) + float4(.06*cos(t*.1), 0, 0, .14*cos(t*.23));
    [loop]
    for (int i = 0; i++ < ITER;) o.xzyw = abs(o / dot(o, o) - dec);
    return o;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = (fragCoord - resolution.xy*.5) / resolution.y;
    float3 col = (float3)0;
    float t = time * .3;

    [loop]
    for (float i = 0.; i <= 1.; i += 1./NUM_LAYERS) {
        float d = frac(i + t);
        float s = lerp(5., .5, d);
        float f = d * smoothstep(1., .9, d);
        col += tex_fractal(float3(uv*s, i*4.)).xyz * f;
    }

    col /= NUM_LAYERS;
    col *= float3(2, 1., 2.);
    col = pow(col, (float3).5);

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col *= 1.0 - darken;

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_PathToTheColorfulInfinity() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_PerhapsAScreensaver() {
    return "
    (
// Perhaps a screensaver — converted from Shadertoy (Wfy3zh)
// Original by pirandello (CC0/Public Domain)
// Forked from Trailing the Twinkling Tunnel by BeRo & Paul Karlik

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float g(float4 p, float s) {
    p *= s;
    return abs(dot(sin(p), cos(p.zxwy)) - 1.0) / s;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float T = time;
    float4 o = (float4)0;
    float4 q = (float4)0;
    float4 p = (float4)0;
    float4 U = float4(2, 1, 0, 3);
    float d = 0.0;
    float z = 0.0;
    float s = 0.0;
    float2 r = resolution;

    for (float i = 0.0; i < 79.0; i += 1.0) {
        z += d + 5e-4;
        q = float4(normalize(float3((fragCoord + fragCoord - r) / r.y, 2.0)) * z, 0.2);
        q.z += T / 30.0;
        s = q.y + 0.1;
        q.y = abs(s);
        p = q;
        p.y -= 0.11;

        // mat2(cos(11. * U.zywz - 2. * p.z))
        float4 angles = 11.0 * U.zywz - 2.0 * p.z;
        float4 cv = cos(angles);
        float2x2 m = float2x2(cv.x, cv.y, cv.z, cv.w);
        p.xy = mul(p.xy, m);

        p.y -= 0.2;
        d = abs(g(p, 8.0) - g(p, 24.0)) / 4.0;

        // Palette color
        p = 1.4 + 1.8 * cos(float4(1.8, 3.1, 4.5, 0.0) + 7.0 * q.z);

        // Glow accumulation
        o += (s > 0.0 ? 1.0 : 0.1) * p.w * p / max(s > 0.0 ? d : d * d * d, 5e-4);
    }

    // Animated, color-shifting, moving tunnelwisp
    float2 wispPos = 1.5 * float2(cos(T * 0.7), sin(T * 0.9));
    float wispDist = length(q.xy - wispPos);
    float3 wispColor = float3(1.0, 0.8 + 0.2 * sin(T), 0.7 + 0.3 * cos(T * 1.3));
    o.xyz += (2.0 + sin(T * 2.0)) * 800.0 * wispColor / (wispDist + 0.4);

    // Tone mapping
    float3 color = tanh(o.xyz / 1e5);

    // Darken/desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_PerhapsAScreensaver() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_PhantomStar() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float pi = 3.14159265358979;
static const float pi2 = pi * 2.0;

float2x2 rot(float a) {
    float c = cos(a), s = sin(a);
    return float2x2(c, s, -s, c);
}

float2 pmod(float2 p, float r) {
    float a = atan2(p.x, p.y) + pi / r;
    float n = pi2 / r;
    a = floor(a / n) * n;
    return mul(p, rot(-a));
}

float box(float3 p, float3 b) {
    float3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

float ifsBox(float3 p) {
    for (int i = 0; i < 5; i++) {
        p = abs(p) - 1.0;
        p.xy = mul(p.xy, rot(time * 0.3));
        p.xz = mul(p.xz, rot(time * 0.1));
    }
    p.xz = mul(p.xz, rot(time));
    return box(p, float3(0.4, 0.8, 0.3));
}

float map(float3 p, float3 cPos) {
    float3 p1 = p;
    p1.x = fmod(p1.x - 5.0, 10.0) - 5.0;
    p1.y = fmod(p1.y - 5.0, 10.0) - 5.0;
    p1.z = fmod(p1.z, 16.0) - 8.0;
    p1.xy = pmod(p1.xy, 5.0);
    return ifsBox(p1);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 p = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);

    float3 cPos = float3(0.0, 0.0, -3.0 * time);
    float3 cDir = normalize(float3(0.0, 0.0, -1.0));
    float3 cUp = float3(sin(time), 1.0, 0.0);
    float3 cSide = cross(cDir, cUp);

    float3 ray = normalize(cSide * p.x + cUp * p.y + cDir);

    // Phantom Mode
    float acc = 0.0;
    float acc2 = 0.0;
    float t = 0.0;
    for (int i = 0; i < 99; i++) {
        float3 pos = cPos + ray * t;
        float dist = map(pos, cPos);
        dist = max(abs(dist), 0.02);
        float a = exp(-dist * 3.0);
        if (fmod(length(pos) + 24.0 * time, 30.0) < 3.0) {
            a *= 2.0;
            acc2 += a;
        }
        acc += a;
        t += dist * 0.5;
    }

    float3 col = float3(acc * 0.01, acc * 0.011 + acc2 * 0.002, acc * 0.012 + acc2 * 0.005);

    // Apply darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Shader provides its own alpha; premultiply
    float a2 = saturate(1.0 - t * 0.03);
    return float4(col * a2, a2);
}

    )"
}

_Shader_Meta_PhantomStar() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 60}
}

_Shader_HLSL_PinwheelTrianglesScreensaver() {
    return "
    (
// Pinwheel Triangles ScreenSaver - Conway pinwheel tiling
// Original: https://www.shadertoy.com/view/XsSfWm by ttoinou

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define SHOW_SEGMENTS 1

// segment.x is distance to closest point
// segment.y is barycentric coefficient for closest point
// segment.z is length of closest point on curve, starting from A
// segment.w is approximate length of curve
float4 segmentDist(float2 p, float2 a, float2 b) {
    a -= p;
    b -= p;
    float3 k = float3(dot(a, a), dot(b, b), dot(a, b));
    float t = (k.x - k.z) / (k.x + k.y - 2.0 * k.z);
    float len = length(b - a);

    if (t < 0.0) {
        return float4(sqrt(k.x), 0.0, 0.0, len);
    } else if (t > 1.0) {
        return float4(sqrt(k.y), 1.0, len, len);
    } else {
        return float4(length(a * (1.0 - t) + b * t), t, t * len, len);
    }
}

#define HASHSCALE3 float3(.1031, .1030, .0973)

float3 hash32(float2 p) {
    float3 p3 = frac(p.xyx * HASHSCALE3);
    p3 += dot(p3, p3.yxz + 19.19);
    return frac((p3.xxy + p3.yzz) * p3.zyx);
}

float3 mixColorLine(float2 uv, float3 currentCol, float3 colLine, float2 lineA, float2 lineB, float scale) {
    return lerp(
        currentCol,
        colLine,
        1.0 - smoothstep(0.0, 1.0, sqrt(segmentDist(uv, lineA, lineB).x * scale)));

}

bool pointsOnSameSideOfLine(float2 pointA, float2 pointB, float2 lineA, float2 lineB) {
    float2 n = lineB - lineA;
    n = float2(n.y, -n.x);
    return dot(pointA - lineA, n) * dot(pointB - lineA, n) > 0.0;
}

static float viewportMagnify = 1.0;

float2 screenToViewport(float2 uv) {
    return (uv - resolution.xy / 2.0) / min(resolution.x, resolution.y) * viewportMagnify;
}

float det22(float2 a, float2 b) {
    return a.x * b.y - a.y * b.x;
}

struct Pinwheel {
    float2 A;
    float2 B;
    float2 C;
    float2 D;
    float2 E;
    float2 F;
    float2 G;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float4 fragColor = (float4)1.0;

    int nbIterations = 5;

    float2 base = float2(2.0, 1.0);

    float2 uv = screenToViewport(fragCoord.xy);

    viewportMagnify = 1.0 / 3.2;
    uv *= viewportMagnify;

    // Rotation matrix from cos(t + offsets)
    float4 cv = cos(time / 48.0 + float4(0.0, 1.6, -1.6, 0.0));
    float2x2 rotMat = float2x2(cv.x, cv.y, cv.z, cv.w);
    uv = mul(uv, rotMat);

    uv += base / 3.2;

    // Base Triangle
    Pinwheel Tri;
    Pinwheel Tri_TMP;
    Tri.A = Tri.B = Tri.C = (float2)0.0;
    Tri.D = Tri.E = Tri.F = Tri.G = (float2)0.0;
    Tri_TMP.A = Tri_TMP.B = Tri_TMP.C = (float2)0.0;
    Tri_TMP.D = Tri_TMP.E = Tri_TMP.F = Tri_TMP.G = (float2)0.0;
    Tri.B.x += base.x;
    Tri.C.y += base.y;
    int PinwheelID = 0;

    for (int i = 0; i < 5; i++) {
        PinwheelID *= 5;
        // EQUERRE_COMPUTE_DEFG
        Tri.E = (Tri.A + Tri.B) / 2.0;
        Tri.F = (3.0 * Tri.B + 2.0 * Tri.C) / 5.0;
        Tri.G = (Tri.B + 4.0 * Tri.C) / 5.0;
        Tri.D = (Tri.G + Tri.A) / 2.0;

        if (pointsOnSameSideOfLine(uv, Tri.F, Tri.E, Tri.G)) {
            if (pointsOnSameSideOfLine(uv, Tri.B, Tri.E, Tri.F)) {
                // GET1
                Tri_TMP.A = Tri.F;
                Tri_TMP.B = Tri.B;
                Tri_TMP.C = Tri.E;
            } else {
                // GET2
                Tri_TMP.A = Tri.F;
                Tri_TMP.B = Tri.G;
                Tri_TMP.C = Tri.E;
                PinwheelID += 1;
            }
        } else if (pointsOnSameSideOfLine(uv, Tri.E, Tri.A, Tri.G)) {
            if (pointsOnSameSideOfLine(uv, Tri.G, Tri.E, Tri.D)) {
                // GET3
                Tri_TMP.A = Tri.D;
                Tri_TMP.B = Tri.E;
                Tri_TMP.C = Tri.G;
                PinwheelID += 2;
            } else {
                // GET4
                Tri_TMP.A = Tri.D;
                Tri_TMP.B = Tri.E;
                Tri_TMP.C = Tri.A;
                PinwheelID += 3;
            }
        } else {
            // GET5
            Tri_TMP.A = Tri.G;
            Tri_TMP.B = Tri.A;
            Tri_TMP.C = Tri.C;
            PinwheelID += 4;
        }

        // EQUERRE_COPY
        Tri.A = Tri_TMP.A;
        Tri.B = Tri_TMP.B;
        Tri.C = Tri_TMP.C;
    }

    float3 v = cos(
        time / float3(63.0, 54.0, 69.0) / float(nbIterations) / 1.2
        + float3(0.0, 0.95, 1.22))
        * float3(36.0, 34.0, 31.0)
        + float3(25.0, 19.0, 42.0);

    // Time-based color shift (replaces iMouse.xy interaction)
    float3 s = float3(
        sin(time / 3.0) * 0.5 + 0.5,
        sin(time * 0.071) * 0.5 + 0.5,
        cos(time * 0.113) * 0.5 + 0.5);

    fragColor.rgb = fmod((float3)PinwheelID, v) / (v - 1.0);
    fragColor.rgb = fmod(fragColor.rgb + s, (float3)1.0);

    float scale = float(nbIterations);
    scale = pow(2.0, scale) / viewportMagnify / scale * 5.5;

    float3 EquerreColor = (float3)0.0;

    #if SHOW_SEGMENTS==1
        fragColor.rgb = mixColorLine(uv, fragColor.rgb, EquerreColor, Tri.A, Tri.B, scale);
        fragColor.rgb = mixColorLine(uv, fragColor.rgb, EquerreColor, Tri.B, Tri.C, scale);
        fragColor.rgb = mixColorLine(uv, fragColor.rgb, EquerreColor, Tri.C, Tri.A, scale);
    #endif

    fragColor.rgb = tanh(fragColor.rgb * 6.0);

    // Darken/desaturate post-processing
    float3 col = fragColor.rgb;
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_PinwheelTrianglesScreensaver() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_PlayingWithFbm() {
    return "
    (
// 'Playing with FBM' by Lallis
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
// Converted from https://www.shadertoy.com/view/XlXXz8

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float noise3D(float3 p)
{
    return frac(sin(dot(p, float3(12.9898, 78.233, 126.7378))) * 43758.5453) * 2.0 - 1.0;
}

float linear3D(float3 p)
{
    float3 p0 = floor(p);
    float3 p1x = float3(p0.x + 1.0, p0.y, p0.z);
    float3 p1y = float3(p0.x, p0.y + 1.0, p0.z);
    float3 p1z = float3(p0.x, p0.y, p0.z + 1.0);
    float3 p1xy = float3(p0.x + 1.0, p0.y + 1.0, p0.z);
    float3 p1xz = float3(p0.x + 1.0, p0.y, p0.z + 1.0);
    float3 p1yz = float3(p0.x, p0.y + 1.0, p0.z + 1.0);
    float3 p1xyz = p0 + 1.0;

    float r0 = noise3D(p0);
    float r1x = noise3D(p1x);
    float r1y = noise3D(p1y);
    float r1z = noise3D(p1z);
    float r1xy = noise3D(p1xy);
    float r1xz = noise3D(p1xz);
    float r1yz = noise3D(p1yz);
    float r1xyz = noise3D(p1xyz);

    float a = lerp(r0, r1x, p.x - p0.x);
    float b = lerp(r1y, r1xy, p.x - p0.x);
    float ab = lerp(a, b, p.y - p0.y);
    float c = lerp(r1z, r1xz, p.x - p0.x);
    float d = lerp(r1yz, r1xyz, p.x - p0.x);
    float cd = lerp(c, d, p.y - p0.y);

    float res = lerp(ab, cd, p.z - p0.z);

    return res;
}

float fbm(float3 p)
{
    float f = 0.5000 * linear3D(p * 1.0);
    f += 0.2500 * linear3D(p * 2.01);
    f += 0.1250 * linear3D(p * 4.02);
    f += 0.0625 * linear3D(p * 8.03);
    f /= 0.9375;
    return f;
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution.xy * 2.0 - 1.0;
    uv.x *= resolution.x / resolution.y;
    float ang = time * 0.1;
    float2x2 rot = float2x2(cos(ang), -sin(ang), sin(ang), cos(ang));
    uv = mul(rot, uv) * 16.0 * (sin(time * 0.1) + 1.5);

    float f = fbm(float3(uv, time) + fbm(float3(uv, time) + fbm(float3(uv, time)))) * 0.5 + 0.5;

    float3 col, col2;
    col = (float3)fbm(float3(uv * f * 0.3, time * 0.75));
    col2 = col;

    col *= float3((sin(time * 0.2) * 0.5 + 1.5), 1.0, 0.6);
    col += float3(0.1, 0.7, 0.8) * f;

    col2 *= float3(0.9, 1.0, (sin(time * 0.2) * 0.5 + 1.5));
    col2 += float3(0.8, 0.5, 0.1) * f;

    col = lerp(col, col2, smoothstep(-50.0, 50.0, uv.x));

    col *= lerp(0.5, sin(time * 0.5) * 0.25 + 1.0, length(col));

    col = clamp(col, 0.0, 1.0);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_PlayingWithFbm() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_PowerChainSawMan() {
    return "
    (
// Power Chain Saw Man — after Pudi (CC BY-NC-SA 3.0)
// Converted from Shadertoy GLSL to HLSL

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// ============= Constants =============

static const float3 BLOOD_COLOR = float3(179, 236, 15) / 255.0;
static const float3 BACKGROUND_COLOR = float3(179, 236, 15) / 255.0;
static const float3 BRIGHT_RED = float3(254, 81, 51) / 255.0;
static const float3 TEETH_COLOR = float3(224, 195, 226) / 255.0 * 1.2;
static const float3 BORDER_COLOR = (float3)0.01;
static const float3 SKIN_COLOR = float3(158, 0, 24) / 255.0;
static const float3 HIGHLIGHT_COLOR = float3(240, 48, 18) / 255.0 * 1.2;
static const float3 HAIR_COLOR = float3(68, 0, 50) / 255.0;
static const float3 HAIR_SHADOW_COLOR = float3(28, 0, 62) / 255.0;

static const float PI = acos(-1.0);

#define sat(x) saturate(x)

// ============= Utility Functions =============

// GLSL mat2(c,-s,s,c) is column-major; HLSL float2x2 is row-major.
// For equivalent mul(M,v): transpose the constructor args.
float2x2 rot(float a) {
    float c = cos(a), s = sin(a);
    return float2x2(c, s, -s, c);
}

// GLSL mat2(0.707,-0.707,0.707,0.707) → transposed for HLSL row-major
static const float2x2 rot45_val = float2x2(0.707, 0.707, -0.707, 0.707);

float pow2(float x) {
    return x * x;
}

float dot2(float2 v) {
    return dot(v, v);
}

float cross2(float2 a, float2 b) {
    return a.x * b.y - a.y * b.x;
}

float smooth_hill(float x, float off, float width, float gap) {
    x -= off;
    float start = width, end_val = width + max(0.0, gap);
    return smoothstep(-end_val, -start, x) - smoothstep(start, end_val, x);
}

float remap(float val, float start1, float stop1, float start2, float stop2) {
    return start2 + (val - start1) / (stop1 - start1) * (stop2 - start2);
}

float remap01(float val, float start, float stop) {
    return start + val * (stop - start);
}

float3 erot(float3 p, float3 ax, float ro) {
    return lerp(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);
}

float hash11(float p) {
    p = frac(p * 0.1031);
    p *= p + 33.33;
    p *= p + p;
    return frac(p);
}

float hash21(float2 p) {
    float3 p3 = frac(p.xyx * 0.1031);
    p3 += dot(p3, p3.yzx + 3.33);
    return frac((p3.x + p3.y) * p3.z);
}

float noise(float2 x) {
    float2 p = floor(x);
    float2 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);

    float a = hash21(p + float2(0, 0));
    float b = hash21(p + float2(1, 0));
    float c = hash21(p + float2(0, 1));
    float d = hash21(p + float2(1, 1));
    return lerp(lerp(a, b, f.x), lerp(c, d, f.x), f.y);
}

float voronoi(float2 uv) {
    float d = 1e9;
    float2 id = floor(uv);
    uv = frac(uv);

    for (float i = -1.0; i <= 1.0; i++) {
        for (float j = -1.0; j <= 1.0; j++) {
            float2 nbor = float2(i, j);
            d = min(d, length(uv - noise(id + nbor) - nbor));
        }
    }
    return d;
}

float2 clog(float2 z) {
    float r = length(z);
    return float2(log(r), atan2(z.y, z.x));
}

float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * (1.0 / 4.0);
}

float smax(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0);
    return max(a, b) + h * h * k * (1.0 / 4.0);
}

// ============= SDF Primitives =============

float sd_circle(float2 p, float r) {
    return length(p) - r;
}

float sd_box(float2 p, float2 h) {
    p = abs(p) - h;
    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));
}

float sd_hook(float2 p, float r, float a, float s) {
    float base_d = max(sd_circle(p, r), -p.x * sign(s));
    p.x -= r;
    p = mul(rot(a), p);
    p.x += r;
    float crop = sd_circle(p, r);
    return max(base_d, -crop);
}

float sd_line(float2 p, float2 a, float2 b) {
    float2 pa = p - a, ba = b - a;
    float k = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return distance(p, lerp(a, b, k));
}

float sd_line_y(float2 p, float h, float r) {
    p.y -= clamp(p.y, 0.0, h);
    return length(p) - r;
}

float op_rem_lim(float p, float s, float l) {
    return p - s * clamp(round(p / s), -l, l);
}

float sd_trig_isosceles(float2 p, float2 q) {
    p.x = abs(p.x);
    float2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);
    float2 b = p - q * float2(clamp(p.x / q.x, 0.0, 1.0), 1.0);
    float s = -sign(q.y);
    float2 d = min(float2(dot(a, a), s * (p.x * q.y - p.y * q.x)),
                   float2(dot(b, b), s * (p.y - q.y)));
    return -sqrt(d.x) * sign(d.y);
}

float sd_uneven_capsule(float2 p, float2 pa, float2 pb, float ra, float rb) {
    p -= pa;
    pb -= pa;
    float h = dot(pb, pb);
    float2 q = float2(dot(p, float2(pb.y, -pb.x)), dot(p, pb)) / h;

    q.x = abs(q.x);
    float b = ra - rb;
    float2 c = float2(sqrt(h - b * b), b);

    float k = cross2(c, q);
    float m = dot(c, q), n = dot(q, q);

    if (k < 0.0) {
        return sqrt(h * n) - ra;
    } else if (k > c.x) {
        return sqrt(h * (n + 1.0 - 2.0 * q.y)) - rb;
    }
    return m - ra;
}

float sd_egg(float2 p, float ra, float rb) {
    const float k = sqrt(3.0);
    p.x = abs(p.x);
    float r = ra - rb;
    return ((p.y < 0.0)             ? length(float2(p.x, p.y)) - r
            : (k * (p.x + r) < p.y) ? length(float2(p.x, p.y - k * r))
                                     : length(float2(p.x + r, p.y)) - 2.0 * r) -
           rb;
}

// ============= Bezier Functions =============

float3 sd_bezier_base(float2 pos, float2 A, float2 B, float2 C) {
    float2 a = B - A;
    float2 b = A - 2.0 * B + C;
    float2 c = a * 2.0;
    float2 d = A - pos;

    float kk = 1.0 / dot(b, b);
    float kx = kk * dot(a, b);
    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;
    float kz = kk * dot(d, a);
    float t = 0.0;

    float res = 0.0;
    float sgn = 1.0;

    float p = ky - kx * kx;
    float p3 = p * p * p;
    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;
    float h = q * q + 4.0 * p3;

    if (h >= 0.0) {
        h = sqrt(h);
        float2 x = (float2(h, -h) - q) / 2.0;
        float2 uv_bz = sign(x) * pow(abs(x), (float2)(1.0 / 3.0));
        t = clamp(uv_bz.x + uv_bz.y - kx, 0.0, 1.0);
        float2 qq = d + (c + b * t) * t;
        res = dot2(qq);
        sgn = cross2(c + 2.0 * b * t, qq);
    } else {
        float z = sqrt(-p);
        float v = acos(q / (p * z * 2.0)) / 3.0;
        float m = cos(v);
        float n = sin(v) * 1.732050808;
        float2 tt = clamp(float2(m + m, -n - m) * z - kx, 0.0, 1.0);
        float2 qx = d + (c + b * tt.x) * tt.x;
        float dx = dot2(qx), sx = cross2(c + 2.0 * b * tt.x, qx);
        float2 qy = d + (c + b * tt.y) * tt.y;
        float dy = dot2(qy), sy = cross2(c + 2.0 * b * tt.y, qy);
        if (dx < dy) {
            res = dx;
            sgn = sx;
        } else {
            res = dy;
            sgn = sy;
        }
        t = res;
    }

    return float3(res, sgn, t);
}

float2 sd_bezier(float2 pos, float2 A, float2 B, float2 C) {
    float3 bz = sd_bezier_base(pos, A, B, C);
    return float2(sqrt(bz.x) * sign(bz.y), bz.z);
}

float sd_bezier_convex(float2 pos, float2 A, float2 B, float2 C) {
    if (cross2(C - A, B - A) < 0.0) {
        float2 tmp = A;
        A = C;
        C = tmp;
    }
    float sa = cross2(A, pos);
    float sc = cross2(C - A, pos - A);
    float s0 = cross2(-C, pos - C);
    float o = cross2(C - A, -A);

    float ts = (sa < 0.0 && sc < 0.0 && s0 < 0.0) ? -1.0 : 1.0;
    float ts2 = (sa > 0.0 && sc > 0.0 && s0 > 0.0) ? -1.0 : 1.0;
    ts = o > 0.0 ? ts2 : ts;

    float3 bz = sd_bezier_base(pos, A, B, C);
    return sqrt(bz.x) * sign(sc < 0.0 ? 1.0 : -bz.y) * ts;
}

// GLSL mat2(normal, tangent) + pos*mm = (dot(pos,normal), dot(pos,tangent))
float4 sd_bezier_rep(float2 pos, float2 A, float2 B, float2 C) {
    float2 bz = sd_bezier(pos, A, B, C);
    float t = bz.y;
    float2 tangent = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));
    float2 normal = float2(tangent.y, -tangent.x);
    pos = lerp(lerp(A, B, t), lerp(B, C, t), t) - pos;
    return float4(bz.x, dot(pos, normal), dot(pos, tangent), t);
}

// ============= Alpha Blending & Rendering =============

float4 alpha_blending(float4 d, float4 s) {
    float4 res = (float4)0;
    res.a = lerp(1.0, d.a, s.a);
    if (res.a == 0.0) {
        res.rgb = (float3)0;
    } else {
        res.rgb = lerp(d.rgb * d.a, s.rgb, s.a) / res.a;
    }
    return res;
}

void alpha_blend_inplace(inout float4 d, float4 s) {
    d = alpha_blending(d, s);
}

float AAstep2(float thre, float val) {
    return smoothstep(-0.5, 0.5, (val - thre) / min(0.03, fwidth(val - thre)));
}

float AAstep(float val) {
    return AAstep2(val, 0.0);
}

float4 render_f4(float d, float4 color) {
    return float4(color.rgb, color.a * AAstep(d));
}

float4 render_f3(float d, float3 color) {
    return render_f4(d, float4(color, 1.0));
}

float4 render_stroked_masked(float d,
                             float4 color,
                             float stroke,
                             float stroke_mask) {
    float4 stroke_layer = float4((float3)0.01, AAstep(d));
    float4 color_layer = float4(color.rgb, AAstep(d + stroke));
    return float4(lerp(lerp(stroke_layer.rgb, color_layer.rgb, AAstep(stroke_mask)),
                       color_layer.rgb, color_layer.a),
                  stroke_layer.a * color.a);
}

float4 render_stroked_f4(float d, float4 color, float stroke) {
    return render_stroked_masked(d, color, stroke, 1.0);
}

float4 render_stroked_f3(float d, float3 color, float stroke) {
    return render_stroked_f4(d, float4(color, 1.0), stroke);
}

// Macros — rely on 'final_color' being in scope as inout parameter.
// HLSL doesn't support function overloading in macros, so we dispatch
// to typed helpers via _Generic-style suffixed names. We use a trick:
// float4 has .a, float3 does not — but preprocessor can't check types.
// Instead we provide explicit typed macros.
#define LayerFlat4(d, color) alpha_blend_inplace(final_color, render_f4(d, color))
#define LayerFlat3(d, color) alpha_blend_inplace(final_color, render_f3(d, color))
#define LayerStroked4(d, color, stroke) \
    alpha_blend_inplace(final_color, render_stroked_f4(d, color, stroke))
#define LayerStroked3(d, color, stroke) \
    alpha_blend_inplace(final_color, render_stroked_f3(d, color, stroke))
#define LayerStrokedMask(d, color, stroke, mask) \
    alpha_blend_inplace(final_color, render_stroked_masked(d, color, stroke, mask))

void draw_highlight(inout float4 final_color, float highlight) {
    LayerFlat3(highlight, HIGHLIGHT_COLOR);
    float s = 0.15;
    alpha_blend_inplace(final_color, float4(HIGHLIGHT_COLOR,
                                            0.07 * smoothstep(s, 0.0, highlight)));
}

// ============= Params Struct =============

struct ShaderParams {
    float stroke;
    float displacement;
    float stime;
    float shift;
};

// ============= Character Functions =============

float fbm(float2 st, float n) {
    st *= 3.0;

    float s = 0.5;
    float ret = 0.0;
    for (float i = min(0.0, (float)frame); i < n; i++) {
        ret += noise(st) * s;
        st *= 2.5;
        s /= 2.0;
        st = mul(rot45_val, st);
        st.y += time * 0.05;
    }
    return ret;
}

float3 background(float2 uv) {
    uv = mul(rot(-PI / 2.0), uv);
    uv = clog(uv);
    uv.x -= time * 0.1;
    uv /= PI;
    float fa1 = fbm(mul(rot(sin(uv.x) * 0.001), uv), 5.0);
    float fb1 = fbm(uv, 5.0);

    float fa2 = fbm(uv + sin(uv.x * 15.0) + fa1 * 5.0, 4.0);
    float fb2 = fbm(uv + fb1, 5.0);

    float3 col = (float3)0;
    col = lerp(col, BACKGROUND_COLOR, pow(sat(fb2 * 2.4), 1.5));
    col = lerp(col, float3(0.4, 0.3, 0.7), pow(sat(fb2 * 0.7), 1.9));
    col = lerp(col, float3(0.3, 0.6, 0.6), pow(sat(fa2 * 1.5), 20.0) * 0.7);
    col = lerp(col, (float3)0, voronoi(uv * 10.0 + fa1 * 4.0) * 0.8);

    col.yz = mul(rot(-0.16), col.yz);

    return col;
}

float sd_teeth(float2 coords,
               float t,
               float width,
               float spacing,
               float2 sz,
               float2 fang_range,
               float fang_length,
               float x) {
    coords.y -= (t - 0.5) * width;
    coords.y = op_rem_lim(coords.y, spacing, width + spacing / 1.3);
    coords = mul(rot(-1.57), coords);
    fang_range *= spacing / width * 2.0;
    float off =
        fang_length * smoothstep(fang_range.x, fang_range.y, abs(t * 2.0 - 1.0));
    sz += float2(x * off, off);
    coords.y += sz.y;
    float tooth = sd_trig_isosceles(coords, sz);
    return tooth;
}

float make_mouth(inout float4 final_color, float2 uv, ShaderParams p) {
    uv *= 1.15;
    uv.y -= -0.02;
    uv = mul(rot(0.03), uv);
    float poff = remap01(p.shift, -0.05, 0.05);
    float lip_off = remap01(p.shift, 0.0, 0.2);

    float2 a = float2(-0.5, 0.0 + poff);
    float2 b = float2(0.0, -0.70);
    float2 c = float2(0.5, 0.0 + poff);

    float width = 3.8;
    float spacing = 0.26;
    float2 sz = float2(0.25, 0.07);
    float4 curve_lower = sd_bezier_rep(uv, a, b, c);
    float teeth_lower = sd_teeth(curve_lower.yz, curve_lower.w, width, spacing,
                                 sz, float2(2.4, 5.3), 0.031, -8.0);

    float2 la = c - float2(0.04, 0.02);
    float2 lb = float2(0.0, 0.1 + lip_off);
    float2 lc = a - float2(-0.04, 0.02);

    width = 3.7;
    spacing = 0.31;
    sz = float2(0.24, 0.09);
    float4 curve_upper = sd_bezier_rep(uv, la, lb, lc);
    float teeth_upper = sd_teeth(curve_upper.yz, curve_upper.w, width, spacing,
                                 sz, float2(3.0, 4.0), 0.06, -1.0);

    float mouth = max(curve_lower.x, curve_upper.x);
    LayerFlat3(mouth, SKIN_COLOR * 0.35);
    float2 tuv = uv - float2(0.0, -0.48 + poff);
    tuv.x = abs(tuv.x);
    float tongue = sd_line(tuv, float2(0.1, 0.20), float2(-0.3, 0.0)) - 0.19 +
                   p.displacement * 0.002;
    tongue = max(tongue, mouth);
    LayerFlat3(tongue, BRIGHT_RED);
    LayerStroked3(teeth_upper, TEETH_COLOR, p.stroke * 1.3);
    LayerStroked3(teeth_lower, TEETH_COLOR, p.stroke * 1.3);
    float border = smin(abs(curve_lower.x), abs(curve_upper.x), 0.1);
    LayerFlat3(border - 0.004, BORDER_COLOR);

    float2 huv = uv - float2(0.06, -0.38 + poff * 0.4);
    huv = mul(rot(-0.15), huv);
    huv *= float2(0.3, 1.0);
    huv.y -= sqrt(pow2(huv.x) + 0.0001) * 0.5;
    float highlight =
        sd_circle(huv, max(0.015, smoothstep(-0.8, 1.0, p.shift) * 0.02));
    draw_highlight(final_color, highlight);

    return curve_lower.x - p.stroke * 0.5;
}

float2 head_tranform(float2 uv, ShaderParams p, float amp) {
    float2 head_uv = uv;
    head_uv.y -= 0.85;
    head_uv -= float2(0.04, 0.1) * p.shift * amp;
    head_uv = mul(rot(remap01(p.shift, 0.0, 0.05)), head_uv);
    return head_uv;
}

float2 head_tranform_point(float2 pt, ShaderParams par, float amp) {
    float2 head_p = pt;
    head_p += float2(0.04, 0.1) * par.shift * amp;
    head_p = mul(rot(-remap01(par.shift, 0.0, 0.05)), head_p);
    return head_p;
}

float make_head(inout float4 final_color, float2 uv, ShaderParams p) {
    uv -= float2(0.00, 0.8);
    float egg = sd_egg(float2(uv.x, -uv.y), 0.95, 0.3);

    float2 euv = uv - float2(0.84, -0.71);
    float b = dot(euv - 0.35, float2(-4.88, 0.2));
    float ear =
        sd_uneven_capsule(euv, float2(0.04, -0.04), float2(0.17, 0.33), 0.07, 0.20);
    ear = smax(ear, -b, 0.4);
    float head = smin(egg, ear, 0.13);
    LayerStroked3(head, SKIN_COLOR, p.stroke);

    float snail =
        sd_uneven_capsule(euv, float2(0.04, 0.05), float2(0.17, 0.35), 0.10, 0.13);
    snail = smax(snail, -b, 0.87);
    snail = smax(snail, -egg, 0.4);
    snail = smax(snail, -sd_circle(euv - float2(0.01, 0.15), 0.05), 0.54);
    LayerStroked3(snail, float3(0.5, 0.1, 0.1) * 0.4, p.stroke * 0.7);
    float snail_inner = sd_uneven_capsule(
        euv - pow2(uv.x) * 0.00, float2(0.08, 0.15), float2(0.09, 0.3), 0.03, 0.07);
    snail_inner = max(snail_inner, snail);
    LayerStroked3(snail_inner, float3(0.5, 0.1, 0.1) * 0.25, p.stroke * 0.9);

    float highlight = 1e9;
    float base_d = abs(egg - 0.015) - 0.01;
    float right = base_d + smooth_hill(uv.x, -0.62, -0.26, 0.505);
    highlight = min(highlight, right);
    float left = base_d + smooth_hill(uv.x, 0.56, -0.39, 0.58) * 0.1;
    left = max(left, dot(uv, float2(2.14, -0.13)) - 1.82);
    highlight = min(highlight, left);
    highlight = max(highlight, egg);
    float on_ear = abs(ear - 0.015) - 0.01;
    on_ear += smooth_hill(uv.x, 1.0, -0.61, 0.98) * 0.1;
    on_ear = max(on_ear, dot(uv, float2(-0.54, 0.54)) + 0.88);
    on_ear = max(on_ear, ear);
    highlight = min(highlight, on_ear);

    draw_highlight(final_color, highlight);

    return head;
}

void make_nose(inout float4 final_color, float2 uv, ShaderParams p) {
    uv.y -= -0.02;
    float2 nuv = float2(abs(uv.x), uv.y);
    uv -= float2(0.08, 0.14 + remap01(p.shift, 0.0, 0.15));
    nuv -= float2(0.08, 0.14 + remap01(p.shift, 0.0, 0.15));
    float2 def = float2(-1.06, 0.21);
    nuv.x -= max(0.0, dot(nuv, def));
    float shadow = sd_line(uv, float2(-0.02, 0.03), float2(0.05, 0.04)) - 0.02;
    float ds =
        sd_line(uv, float2(0.05, 0.06), float2(0.06, 0.08 + p.shift * 0.06)) - 0.01;
    shadow = smin(shadow, ds, 0.10);
    float nostrils = sd_circle(nuv, 0.04);
    shadow = max(shadow, -nostrils + 0.008);
    nostrils = abs(nostrils) - 0.004;
    nostrils = max(nostrils, dot(nuv - float2(0.0, 0.025), float2(-0.06, -0.21)));
    LayerFlat3(nostrils, BORDER_COLOR);
    draw_highlight(final_color, shadow);
}

float2 translate_rotate(float2 p, float2 off, float a) {
    p = p - off;
    p = mul(rot(a), p);
    return p;
}

float intersection_sd(float d1, float d2) {
    float dmin = min(abs(d1), abs(d2));
    return dmin * sign(d1) * sign(d2);
}

float make_body(inout float4 final_color, float2 uv, ShaderParams p) {
    float2 left_shoulder = float2(0.98, -0.33), left_top = float2(0.51, 1.06);
    float2 a = left_shoulder, b = float2(-0.001, -0.29), c = left_top;
    float base_d = sd_bezier_convex(uv, a, b, c);
    float body = base_d;

    float2 right_shoulder = float2(-1.16, -0.22), right_top = float2(-0.37, 1.06);

    right_top += head_tranform_point((float2)1.0, p, 50.0) * 0.05;

    a = right_top; b = float2(-0.16, -0.30); c = right_shoulder;
    base_d = sd_bezier_convex(uv, a, b, c);
    body = intersection_sd(body, base_d);

    a = left_top; c = right_top; b = (a + c) / 2.0 - float2(0.0, 0.1);
    base_d = sd_bezier_convex(uv, a, b, c);
    body = intersection_sd(body, base_d);

    float2 right_side = float2(-2.14, -1.71);
    float2 left_side = float2(2.07, -2.17);

    a = right_side; c = left_side; b = (a + c) / 2.0 + float2(0.0, -0.1);
    base_d = sd_bezier_convex(uv, a, b, c);
    body = intersection_sd(body, base_d);

    a = right_shoulder; b = float2(-2.3, -0.02); c = right_side;
    float rbase = sd_bezier_convex(uv, a, b, c);
    body = intersection_sd(body, rbase);

    a = left_side; b = float2(2.79, -0.24); c = left_shoulder;
    float lbase = sd_bezier_convex(uv, a, b, c);
    body = intersection_sd(body, lbase);

    float arm = sd_line(uv, float2(1.6, -1.03), float2(2.76, -1.73)) - 0.5;
    body = smin(body, arm, 0.1);

    float2 huv = head_tranform(uv, p, 0.5) - float2(0.0, -0.15);
    float head_shadow = sd_egg(float2(huv.x, -huv.y), 0.5, 0.07);
    head_shadow = max(head_shadow, body);

    // collar bones
    float areas = 1e9, strokes = 1e9;
    a = float2(-0.28, 0.09); b = float2(-0.07, -0.53); c = float2(-0.64, -0.56);
    base_d = sd_bezier_convex(uv, a, b, c);
    areas = intersection_sd(areas, base_d);
    b = float2(-0.09, -0.63);
    base_d = sd_bezier_convex(uv, a, b, c);
    areas = intersection_sd(areas, base_d);

    a = float2(-1.27, -0.28); c = float2(-0.26, -0.60); b = float2(-1.06, -0.52);
    float bone_base = sd_bezier(uv, a, b, c).x;
    strokes = min(strokes, abs(bone_base) - 0.005);
    areas = max(areas, bone_base);
    float2 tuv = uv + float2(1.11, 0.345);
    tuv = mul(rot(-2.72), tuv);
    float edge = sd_trig_isosceles(tuv, float2(0.3, 0.2)) - 0.1;
    edge = max(edge, bone_base);
    areas = min(areas, edge);
    c = float2(1.23, -0.43); a = float2(0.22, -0.60); b = float2(1.18, -0.60);
    bone_base = sd_bezier(uv, a, b, c).x;
    strokes = min(strokes, abs(bone_base) - 0.005);
    tuv = uv + float2(-1.09, 0.47);
    tuv = mul(rot(-3.3), tuv);
    edge = sd_trig_isosceles(tuv, float2(0.3, 0.2)) - 0.1;
    edge = max(edge, bone_base);
    areas = min(areas, edge);
    a = float2(-0.24, -0.61); c = float2(0.20, -0.6); b = float2(-0.01, -0.84);
    strokes = smin(strokes, abs(sd_bezier(uv, a, b, c).x) - 0.005, 0.02);

    a = float2(0.28, 0.08); b = float2(0.14, -0.51); c = float2(0.51, -0.60);
    base_d = sd_bezier_convex(uv, a, b, c);
    areas = intersection_sd(areas, base_d);
    b = float2(0.069, -0.62);
    base_d = sd_bezier_convex(uv, a, b, c);
    areas = intersection_sd(areas, base_d);

    // arms
    a = float2(1.70, -1.17); b = float2(1.52, -1.81); c = float2(5.63, -4.82);
    float2 bz = sd_bezier(uv, a, b, c);
    areas = min(areas, abs(bz.x) - 0.6 * smoothstep(-0.04, 0.91, bz.y));
    a = float2(-1.31, -1.09); b = float2(-1.20, -1.48); c = float2(-1.63, -2.13);
    bz = sd_bezier(uv, a, b, c);
    areas = min(areas, abs(bz.x) - 0.05 * smoothstep(-0.11, 0.39, bz.y));

    // chest
    a = float2(-0.26, -0.98); b = float2(0.07, -1.12); c = float2(0.23, -2.24);
    bz = sd_bezier(uv, a, b, c);
    float cleavage = abs(bz.x) - 0.1 * smoothstep(-0.07, 0.9, bz.y) -
                     0.025 * pow2(sin(bz.y * 6.32 + 12.76));
    areas = min(areas, cleavage);

    float w = 0.003;
    float on_neck = sd_line_y(uv - float2(0.17, -0.08), 0.3, w * 2.0);
    on_neck =
        smin(on_neck, sd_line_y(uv - float2(0.16, 0.02), 0.2, w * 2.0), 0.02);
    float2 luv = translate_rotate(uv, float2(0.21, 0.0), 0.1);
    on_neck = min(on_neck, sd_line_y(luv, 0.2, w * 1.5));

    float weirmo = sin(uv.x * 10.0 + p.displacement * 24.0 + 3.1) * 0.003;
    LayerStroked3(body, SKIN_COLOR, p.stroke);
    LayerFlat3(on_neck, BLOOD_COLOR);
    LayerFlat4(head_shadow, float4(SKIN_COLOR * 0.01, 0.5));
    LayerStrokedMask(areas, float4(float3(0.3, 0.1, 0.1) * 0.25, 0.9), p.stroke,
                     weirmo);
    LayerFlat3(strokes + weirmo, BORDER_COLOR);

    float hbase = abs(body - 0.015) - 0.01;
    float highlight = hbase + smooth_hill(uv.x, 1.94, -1.05, 0.55) * 0.05;
    highlight =
        min(highlight, hbase + smooth_hill(uv.x, -1.63, -0.49, 0.28) * 0.05);
    highlight = max(highlight, body);
    draw_highlight(final_color, highlight);

    return body;
}

float make_hair_back(inout float4 final_color, float2 uv, ShaderParams p) {
    // right side
    float2 c = float2(1.16, 1.69), b = float2(1.49, 0.69), a = float2(3.36, -0.04);
    c = head_tranform_point(c, p, 0.75);
    float2 base_bz = sd_bezier(uv, a, b, c);
    float hair = max(base_bz.x, -uv.x);
    float2 cuv = translate_rotate(uv - float2(1.0, 1.0) * p.shift * 0.01,
                                  float2(-0.19, -3.03), -1.11);
    float cuts = sd_hook(cuv, 4.22, 0.25, 1.0);
    cuv = translate_rotate(uv - float2(1.0, 1.0) * p.shift * 0.02,
                           float2(-1.48, -2.51), 5.8);
    cuts = min(cuts, sd_hook(cuv, 4.22, 0.1, 1.0));
    cuv = translate_rotate(uv, float2(-2.65, -1.53), 5.8);
    cuts = min(cuts, sd_hook(cuv, 4.22, 0.25, 1.0));
    cuv = translate_rotate(uv, float2(-3.71, -0.12), 6.24);
    cuts = min(cuts, sd_hook(cuv, 4.22, 0.25, 1.0));

    float highlight = abs(base_bz.x + 0.020) - 0.008;
    highlight = max(highlight, base_bz.x);

    // left side
    a = float2(-1.53, 2.5); c = float2(-1.66, 0.64); b = float2(-0.76, 0.90);
    a = head_tranform_point(a, p, 1.0);
    float left_base = sd_bezier_convex(uv, a, b, c);
    a = float2(-1.56, 0.66); b = float2(-2.98, 0.47); c = float2(-3.15, -0.42);
    c = head_tranform_point(c, p, 1.0);
    left_base = min(left_base, sd_bezier_convex(uv, a, b, c));
    left_base = min(left_base, uv.y);
    hair = min(hair, max(left_base, uv.x));
    cuv = translate_rotate(uv, float2(-1.01, -1.51), 0.73);
    cuts = min(cuts,
               sd_hook(cuv - float2(-1.0, 1.0) * p.shift * 0.02, 2.22, 0.25, -1.0));
    cuv = translate_rotate(uv, float2(1.55, -2.34), 0.3);
    cuts = min(cuts,
               sd_hook(cuv - float2(-1.0, 0.0) * p.shift * 0.02, 4.22, 0.05, -1.0));
    cuv = translate_rotate(uv, float2(2.0, -2.33), 0.33);
    cuts = min(cuts, sd_hook(cuv, 4.22, 0.3, -1.0));
    hair = max(hair, -cuts);

    float left_highlight = abs(left_base + 0.025) - 0.011;
    left_highlight = max(left_highlight, left_base);
    left_highlight = max(left_highlight, uv.x + 0.8);
    left_highlight = max(left_highlight, -uv.y + 0.3);
    highlight = min(highlight, left_highlight);
    float2 luv = translate_rotate(uv - float2(-1.0, 1.0) * p.shift * 0.02,
                                  float2(-0.95, -1.49), 0.72);
    float clight = sd_hook(luv, 2.22, 0.25, -1.0);
    luv = translate_rotate(uv - float2(1.0, 1.0) * p.shift * 0.01,
                           float2(-0.33, -3.00), -1.06);
    clight = min(clight, sd_hook(luv, 4.22, 0.25, 1.0));
    clight = max(hair + p.stroke * 0.9, clight);
    highlight = min(highlight, clight);

    float2 huv = (uv + float2(0.02, 1.02)) * float2(2.0, 1.0);
    huv = head_tranform(huv, p, 1.0);
    float3 hair_color =
        lerp(HAIR_COLOR, HAIR_SHADOW_COLOR, AAstep2(sd_circle(huv, 1.6), 0.0));
    LayerStroked3(hair, hair_color, p.stroke * 1.2);

    draw_highlight(final_color, highlight);

    return hair;
}

void make_hair_front(inout float4 final_color,
                     float2 uv,
                     ShaderParams p,
                     float dhead,
                     float dbody,
                     float dbhair) {
    float2 head_uv = head_tranform(uv, p, 1.0);
    float2 cuv = head_uv - float2(5.14, -0.81);
    float right_hair = sd_circle(cuv, 5.99);
    right_hair = abs(right_hair) - 0.2;
    right_hair = max(right_hair, cuv.x);
    right_hair = max(right_hair, -dbody);

    float hbase = abs(right_hair - 0.015) - 0.01;
    float highlight = hbase + smooth_hill(uv.y, 0.42, -0.67, 1.09) * 0.1;
    highlight = max(highlight, right_hair);
    highlight = max(highlight, uv.x + 0.7);

    float2 suv = uv - float2(2.26, 0.13);
    suv = mul(rot(0.13), suv);
    float right_hair_shadow = sd_hook(suv, 3.1, 0.19, -1.0);
    right_hair_shadow = max(right_hair_shadow, -dbody);

    float skin_shadow = -sd_circle(head_uv - float2(0.91, -0.32), 1.51);
    skin_shadow = max(skin_shadow, dhead);
    skin_shadow = max(skin_shadow, -right_hair);
    skin_shadow = max(skin_shadow, head_uv.x);

    float2 a = float2(-0.22, 1.53), c = float2(-2.9, -1.52), b = float2(-1.11, -1.04);
    a = head_tranform_point(a, p, 0.3);
    float2 vuv = uv;
    float2 base_bz = sd_bezier(vuv, a, b, c);
    float right_curl = base_bz.x;
    right_curl = abs(right_curl) -
                 remap(sin(base_bz.y * 4.93 + 1.93), -1.0, 1.0, 0.01, 0.14) +
                 smoothstep(0.43, 1.94, base_bz.y) * 0.1;
    float2 huv = uv - float2(-3.21, 2.74);
    huv -= 0.1 * p.shift;
    huv = mul(rot(0.64), huv);
    skin_shadow = min(skin_shadow, sd_hook(huv, 3.43, -0.1, 1.0));

    hbase = abs(right_curl - 0.015) - 0.01;
    float clight = hbase + smooth_hill(base_bz.y, 0.31, -0.15, 0.24) * 0.1;
    clight = max(clight, right_curl);
    clight = max(clight, dot(uv, float2(0.28, -0.19)) + 0.26);
    highlight = min(highlight, clight);

    a = float2(1.26, 1.02); c = float2(1.00, -0.24); b = float2(1.55, 0.43);
    a = head_tranform_point(a, p, 0.3);
    base_bz = sd_bezier(uv, a, b, c);
    float left_curl = base_bz.x, t = base_bz.y, tt = base_bz.y;
    a = c; c = float2(1.28, -1.75); b = float2(0.32, -1.07);
    left_curl =
        abs(left_curl) - remap(sin(t * -2.05 + 3.6), -1.0, 1.0, 0.01, 0.20);
    base_bz = sd_bezier(uv, a, b, c);
    float sec = base_bz.x;
    t = 1.0 - base_bz.y;
    sec = abs(sec) - remap(sin(t * -2.05 + 3.6), -1.0, 1.0, 0.01, 0.20);
    left_curl = min(left_curl, sec);
    huv = translate_rotate(uv, float2(1.99, -1.3), 0.47);
    float lcurl_shadow = sd_hook(huv, 1.5, 0.2, -1.0);
    lcurl_shadow = max(lcurl_shadow, left_curl + p.stroke);
    huv = translate_rotate(uv, float2(-0.19, 0.95), 0.05);
    float sh = sd_hook(huv, 1.5, 0.2, 1.0);
    sh = max(sh, -left_curl);
    sh = max(sh, -dbody);
    sh = max(sh, dbhair + p.stroke * 1.2);
    lcurl_shadow = min(lcurl_shadow, sh);

    hbase = abs(left_curl - 0.015) - 0.01;
    clight = hbase + smooth_hill(tt, 0.54, -0.46, 0.7) * 0.1;
    clight = max(clight, left_curl);
    clight = max(clight, dot(uv, float2(-0.47, 0.07)) + 0.62);
    highlight = min(highlight, clight);

    LayerFlat4(skin_shadow, float4(final_color.rgb * 0.2, 0.5));
    float mask = dot(head_uv, float2(5.13, 1.31)) + 3.81;
    LayerStrokedMask(right_hair, float4(HAIR_COLOR, 1.0), p.stroke, mask);
    mask = dot(suv, float2(-3.86, -0.54)) + -12.0;
    LayerStrokedMask(right_hair_shadow, float4(HAIR_SHADOW_COLOR, 1.0),
                     p.stroke * 1.4, mask);

    LayerStroked3(right_curl, HAIR_COLOR, p.stroke * 1.1);
    mask = dot(uv, float2(0.6, -0.48)) + -0.33;
    LayerStrokedMask(left_curl, float4(HAIR_COLOR, 1.0), p.stroke * 1.4, mask);
    LayerFlat4(lcurl_shadow, float4(HAIR_SHADOW_COLOR, 1.0));

    draw_highlight(final_color, highlight);
}

void make_blood(inout float4 final_color,
                float2 uv,
                ShaderParams p,
                float dmouth,
                float dhead) {
    float2 head_uv = head_tranform(uv, p, 1.0);
    float blood = 1e9;

    float w = 0.003;
    float2 luv = translate_rotate(head_uv, float2(0.64, 0.04), -0.53);
    float lines = sd_line_y(luv, 0.15, w);
    luv = translate_rotate(head_uv, float2(0.66, 0.07), -0.53);
    lines = min(lines, sd_line_y(luv, 0.11, w));
    luv = translate_rotate(head_uv, float2(0.68, 0.09), -0.63);
    lines = min(lines, sd_line_y(luv, 0.09, w * 1.5));
    blood = min(blood, lines);

    luv = translate_rotate(head_uv, float2(0.55, -0.18), -0.1);
    float on_chin = sd_line_y(luv, 0.15, 0.015);
    on_chin =
        smin(on_chin, sd_circle(head_uv - float2(0.57, -0.24), 0.015), 0.09);
    float cut_plane = dot(head_uv, float2(0.71, 0.52)) - 0.36;
    on_chin = max(on_chin, cut_plane);
    blood = min(blood, on_chin);

    float on_mouth = sd_circle(head_uv - float2(0.24, -0.53), 0.016);
    on_mouth = smin(
        on_mouth, sd_line_y(head_uv - float2(0.235, -0.53), 0.34, w * 2.5), 0.05);
    on_mouth =
        max(on_mouth, -sd_line_y(head_uv - float2(0.22, -0.535), 0.19, w * 3.5));
    float poff = remap01(p.shift, -0.05, 0.05);
    luv =
        translate_rotate(uv, float2(0.19 + poff * 0.3, 0.64 + poff * 1.40), 0.9);
    float s = 0.12;
    on_mouth = smin(
        on_mouth,
        sd_line_y(luv / s, 1.4, 0.0025) * s - fbm(head_uv * 2.73 + 0.1, 4.0) * s,
        0.06);
    on_mouth = smin(on_mouth, dmouth + 0.004, 0.07);
    on_mouth = max(on_mouth, -dmouth + 0.002);
    blood = min(blood, on_mouth);

    LayerFlat3(blood, BLOOD_COLOR);
}

// ============= Entry Point =============

float4 PSMain(PSInput input) : SV_Target {
    // Y-flip: character faces upward in Shadertoy convention
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 uv = (2.0 * fragCoord - resolution.xy) / resolution.y;

    uv *= 1.5;
    uv.y -= 0.1;

    float t = time + 0.1;
    uv += (float2(fbm(float2(t, 0.0), 3.0), fbm(float2(t, 1.0), 3.0)) * 2.0 - 1.0) * 0.025 *
          (1.0 - length(uv * 0.05));
    ShaderParams p;
    p.stime = time;
    p.shift = cos(p.stime) * 0.5 + 0.5;
    p.displacement = fbm(uv * 2.91, 2.0) * 0.42;
    p.stroke = fwidth(uv.y) * 0.5 + p.displacement * 0.05;

    uv = mul(rot(0.05), uv);

    float4 final_color = float4((float3)0.051, 1.0);
    final_color.rgb = background(uv);

    float dbhair = make_hair_back(final_color, uv, p);
    float dbody = make_body(final_color, uv, p);
    float2 head_uv = head_tranform(uv, p, 1.0);
    float dhead = 1e9, dmouth = 1e9;
    if (uv.y > -0.1) {
        dhead = make_head(final_color, head_uv, p);
        dmouth = make_mouth(final_color, head_uv, p);
        make_nose(final_color, head_uv, p);
        make_blood(final_color, uv, p, dmouth, dhead);
    }
    make_hair_front(final_color, uv, p, dhead, dbody, dbhair);

    final_color.rgb =
        lerp(final_color.rgb, (float3)0, smoothstep(1.50, -2.84, uv.y));

    float3 col = final_color.rgb;

    col = sat(col);
    col = pow(col, (float3)(1.0 / 1.9));
    col = smoothstep(0.0, 1.0, col);
    col = pow(col, float3(1.74, 1.71, 1.48));

    float2 in_uv = fragCoord / resolution.xy;
    col *= sat(pow(500.0 * in_uv.x * in_uv.y * (1.0 - in_uv.x) * (1.0 - in_uv.y), 0.256));

    col += noise(uv * 500.0) * 0.015 * smoothstep(-1.47, 0.58, uv.y);

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_PowerChainSawMan() {
    return {opacity: 0.55, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_PrettyColors() {
    return "
    (
// Pretty Colors — fbm warp inspired by IQ
// https://www.shadertoy.com/view/MtcXDr
// Author: anprogrammer | License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define N_DELTA 0.015625

float rand(float3 n) {
    return frac(sin(dot(n, float3(95.43583, 93.323197, 94.993431))) * 65536.32);
}

float perlin2(float3 n)
{
    float3 base = floor(n / N_DELTA) * N_DELTA;
    float3 dd = float3(N_DELTA, 0.0, 0.0);
    float
        tl = rand(base + dd.yyy),
        tr = rand(base + dd.xyy),
        bl = rand(base + dd.yxy),
        br = rand(base + dd.xxy);
    float3 p = (n - base) / dd.xxx;
    float t = lerp(tl, tr, p.x);
    float b = lerp(bl, br, p.x);
    return lerp(t, b, p.y);
}

float perlin3(float3 n)
{
    float3 base = float3(n.x, n.y, floor(n.z / N_DELTA) * N_DELTA);
    float3 dd = float3(N_DELTA, 0.0, 0.0);
    float3 p = (n - base) / dd.xxx;
    float front = perlin2(base + dd.yyy);
    float back = perlin2(base + dd.yyx);
    return lerp(front, back, p.z);
}

float fbm(float3 n)
{
    float total = 0.0;
    float m1 = 1.0;
    float m2 = 0.1;
    for (int i = 0; i < 5; i++)
    {
        total += perlin3(n * m1) * m2;
        m2 *= 2.0;
        m1 *= 0.5;
    }
    return total;
}

float nebula1(float3 uv)
{
    float n1 = fbm(uv * 2.9 - 1000.0);
    float n2 = fbm(uv + n1 * 0.05);
    return n2;
}

float nebula2(float3 uv)
{
    float n1 = fbm(uv * 1.3 + 115.0);
    float n2 = fbm(uv + n1 * 0.35);
    return fbm(uv + n2 * 0.17);
}

float nebula3(float3 uv)
{
    float n1 = fbm(uv * 3.0);
    float n2 = fbm(uv + n1 * 0.15);
    return n2;
}

float3 nebula(float3 uv)
{
    uv *= 10.0;
    return nebula1(uv * 0.5) * float3(1.0, 0.0, 0.0) +
           nebula2(uv * 0.4) * float3(0.0, 1.0, 0.0) +
           nebula3(uv * 0.6) * float3(0.0, 0.0, 1.0);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;

    float size = max(resolution.x, resolution.y);
    float2 xy = (fragCoord - resolution * 0.5) / size * 2.0;
    float2 uv = xy * 0.5 + 0.5;

    float3 col = nebula(float3(uv * 5.1, time * 0.1) * 0.1) - 1.0;

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    a = saturate(a);
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_PrettyColors() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_PrettyHip() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float PI = 3.14159265359;

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float aspect = resolution.y / resolution.x;
    float value;
    float2 uv = fragCoord.xy / resolution.x;
    uv -= float2(0.5, 0.5 * aspect);
    float rot = PI / 4.0; // radians(45.0)
    float c = cos(rot);
    float s = sin(rot);
    // mat2 m = (c, -s, s, c); uv = m * uv
    float2 rotated_uv = float2(
        uv.x * c + uv.y * (-s),
        uv.x * s + uv.y * c);
    uv = rotated_uv;
    uv += float2(0.5, 0.5 * aspect);
    uv.y += 0.5 * (1.0 - aspect);
    float2 pos = 10.0 * uv;
    float2 rep = frac(pos);
    float dist = 2.0 * min(min(rep.x, 1.0 - rep.x), min(rep.y, 1.0 - rep.y));
    float squareDist = length((floor(pos) + float2(0.5, 0.5)) - float2(5.0, 5.0));

    float edge = sin(time - squareDist * 0.5) * 0.5 + 0.5;

    edge = (time - squareDist * 0.5) * 0.5;
    edge = 2.0 * frac(edge * 0.5);
    value = frac(dist * 2.0);
    value = lerp(value, 1.0 - value, step(1.0, edge));
    edge = pow(abs(1.0 - edge), 2.0);

    value = smoothstep(edge - 0.05, edge, 0.95 * value);

    value += squareDist * 0.1;
    float3 color = lerp(float3(1.0, 1.0, 1.0), float3(0.5, 0.75, 1.0), value);

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness + premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_PrettyHip() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_ProcessingData() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float N21(float2 uv) { return frac(sin(uv.x * 21.281 + uv.y * 93.182) * 5821.92); }

float lineFn(float2 uv) { return smoothstep(0.0, 0.05, uv.x) - smoothstep(0.0, 0.95, uv.x); }

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord / resolution) * 2.0 - 1.0;

    float2 offset = abs(uv.yx) / float2(30.0, 5.2);
    uv = uv + uv * offset * offset;
    uv = uv * 0.5 + 0.5;

    float2 sc = float2(128.0, 90.0);

    float2 lUV = frac(uv * sc);
    float2 gID = floor(uv * sc);

    float rowNoise = N21(float2(0.0, gID.y));
    float dir = ((rowNoise * 2.0) - 1.0) + 0.2;
    gID.x += floor(time * dir * 30.0);

    float cellNoise = N21(gID);
    float drawBlock = (float)(cellNoise > 0.38);
    int even = (int)gID.y % 2;

    float3 col = (float3)lineFn(lUV) * drawBlock * (float)even;
    col *= frac(sin(gID.y)) + 0.24;
    col *= float3(0.224, 0.996, 0.557);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_ProcessingData() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_ProteanClouds() {
    return "
    (
// Protean Clouds - Volumetric cloud raymarching with swirling motion
// Original: Protean clouds by nimitz (Shadertoy 3l23Rh)
// License: CC BY-NC-SA 3.0
// Mouse input removed; camera follows automated path.

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// --- Globals set per-frame in PSMain ---
static float prm1;
static float2 bsMo;

// --- Helpers ---

// Rotation macro: GLSL mat2(cos(a+vec4(0,11,33,0))) with v*M convention.
// GLSL column-major → HLSL row-major transposed for mul(v, M).
float2x2 rot(float a) {
    float4 c = cos(a + float4(0, 11, 33, 0));
    return float2x2(c.x, c.z, c.y, c.w);
}

float linstep(float m, float M, float x) {
    return clamp((x - m) / (M - m), 0.0, 1.0);
}

float2 disp(float t) {
    return 2.0 * float2(sin(t * 0.22), cos(t * 0.175));
}

// GLSL mat3 column-major → HLSL row-major transposed for mul(v, M).
// Original columns: (.33338,.56034,-.71817), (-.87887,.32651,-.15323), (.15162,.69596,.61339)
static const float3x3 rotM3 = float3x3(
     0.33338, -0.87887,  0.15162,
     0.56034,  0.32651,  0.69596,
    -0.71817, -0.15323,  0.61339);

// --- Volumetric map ---

float2 map(float3 p) {
    float2 q = p.xy - disp(p.z);
    p.xy = mul(p.xy, rot(sin(p.z + time) * (0.1 + prm1 * 0.05) + time * 0.09));
    float d = 0.0, z = 1.0, trk = 1.0,
          dspAmp = 0.1 + prm1 * 0.2;

    p *= 0.61;
    for (int i = 0; i < 5; i++) {
        p += dspAmp * sin(trk * (p.zxy * 0.75 + time * 0.8));
        d -= z * abs(dot(cos(p), sin(p.yzx)));
        p = mul(p, rotM3) * 1.93;
        z *= 0.57;
        trk *= 1.4;
    }

    d = abs(d + prm1 * 3.0) + prm1 * 0.3 - 2.5 + bsMo.y;
    return float2(d + 0.25, 0.0) + dot(q, q) * float2(0.2, 1.0);
}

// --- Raymarcher ---

float4 render(float3 ro, float3 rd, float animTime) {
    float4 rez = (float4)0;
    float ldst = 8.0, t = 1.5, T = animTime + ldst, fogT = 0.0;
    float3 lpos = float3(disp(T) * 0.5, T);

    for (int i = 0; rez.a < 0.99 && i < 130; i++) {
        float3 pos = ro + t * rd;
        float2 mpv = map(pos);
        float den = clamp(mpv.x - 0.3, 0.0, 1.0) * 1.12,
              dn  = clamp(mpv.x + 2.0, 0.0, 3.0);

        float4 C = (float4)0;
        if (mpv.x > 0.6) {
            C = float4(sin(float3(5.0, 0.4, 0.2) + mpv.y * 0.1 + sin(pos.z * 0.4) * 0.5 + 1.8) * 0.5 + 0.5, 0.08);
            C *= den * den * den;
            C.rgb *= linstep(4.0, -2.5, mpv.x) * 2.3;
            float dif = clamp((den - map(pos + 0.8).x) / 9.0, 0.001, 1.0)
                      + clamp((den - map(pos + 0.35).x) / 2.5, 0.001, 1.0);
            C.xyz *= den * (float3(0.005, 0.045, 0.075) + 1.5 * dif * float3(0.033, 0.07, 0.03));
        }

        float fogC = exp(t * 0.2 - 2.2);
        C += float4(0.06, 0.11, 0.11, 0.1) * clamp(fogC - fogT, 0.0, 1.0);
        fogT = fogC;

        rez += C * (1.0 - rez.a);
        t += clamp(0.5 - dn * dn * 0.05, 0.09, 0.3);
    }
    return rez;
}

// --- Saturation-preserving interpolation ---

float getsat(float3 c) {
    float mx = max(max(c.x, c.y), c.z);
    if (mx <= 0.0) return 0.0;
    return 1.0 - min(min(c.x, c.y), c.z) / mx;
}

float3 iLerp(float3 a, float3 b, float x) {
    float3 ic = lerp(a, b, x);
    float lgt = dot(float3(1, 1, 1), ic),
          sd  = abs(getsat(ic) - lerp(getsat(a), getsat(b), x));
    float3 dir = normalize(ic * 3.0 - lgt);
    ic += 1.5 * dir * sd * lgt * dot(dir, normalize(ic));
    return ic;
}

// --- Entry point ---

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 R = resolution;
    float2 q = fragCoord / R;
    float2 p = (fragCoord - 0.5 * R) / R.y;
    bsMo = (float2)0;
    prm1 = smoothstep(-0.4, 0.4, sin(time * 0.3));

    float animTime = time * 3.0,
          tgtDst   = 3.5,
          dspAmp   = 0.85;
    float3 P = float3(sin(time) * 0.5, 0.0, animTime);
    P.xy += disp(P.z) * dspAmp;

    float3 target    = normalize(P - float3(disp(animTime + tgtDst) * dspAmp, animTime + tgtDst)),
           rightdir  = normalize(cross(target, float3(0, 1, 0))),
           updir     = normalize(cross(rightdir, target)),
           rightdir2 = cross(updir, target),
           D         = normalize(p.x * rightdir2 + p.y * updir - target);
    D.xy = mul(D.xy, rot(-disp(animTime + 3.5).x * 0.2));

    float3 C = render(P, D, animTime).rgb;

    C = iLerp(C, C.bgr, min(prm1, 0.95));
    C = pow(C, float3(0.55, 0.65, 0.6)) * float3(1.0, 0.97, 0.9);
    C *= pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.12) * 0.7 + 0.3;

    float3 color = C;

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_ProteanClouds() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 30, timeOffsetMax: 90, timeAccumulate: true}
}

_Shader_HLSL_RainbowScreensaverAnimation() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// cosine based palette, 4 float3 params
float3 palette(float t, float3 a, float3 b, float3 c, float3 d)
{
    return a + b * cos(6.28318 * (c * t + d));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Normalized pixel coordinates (from 0 to 1)
    float2 uv = fragCoord / resolution;

    float t = time * 0.2;

    // Calculate two points on screen.
    float2 c1 = float2(sin(t) * 0.5, cos(time) * 0.7);
    float2 c2 = float2(sin(t * 0.7) * 0.9, cos(time * 0.65) * 0.6);

    // Determine length to point 1 & calculate color.
    float d1 = length(uv - c1);
    float3 col1 = palette(d1 + t, float3(0.5, 0.5, 0.5), float3(0.5, 0.5, 0.5), float3(1.0, 1.0, 1.0), float3(0.0, 0.33, 0.67));

    // Determine length to point 2 & calculate color.
    float d2 = length(uv - c2);
    float3 col2 = palette(d2 + t, float3(0.5, 0.5, 0.5), float3(0.5, 0.5, 0.5), float3(1.0, 1.0, 1.0), float3(0.0, 0.33, 0.67));

    // Output to screen
    float3 color = (col1 + col2) / 2.0;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_RainbowScreensaverAnimation() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_RaindropsGlass() {
    return "
    (
// Raindrops on Glass - Raindrop refraction overlay
// Original: Raindrops on glass by YeHaike (Shadertoy DdKyR1)
// License: All Rights Reserved (NonCommercial)
// iChannel0 replaced with procedural gradient; non-drop areas are transparent.

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// --- Constants ---

#define RandomSeed 4.3315
#define NumberScaleOfStaticRaindrops 0.35
#define NumberScaleOfRollingRaindrops 0.35
#define RaindropBlur 0.0
#define BackgroundBlur 2.0
#define StaticRaindropUVScale 20.0
#define RollingRaindropUVScaleLayer01 2.25
#define RollingRaindropUVScaleLayer02 2.25

// --- 3D OpenSimplex2S noise with derivatives ---
// Output: float4(dF/dx, dF/dy, dF/dz, value)

float4 permute(float4 t) {
    return t * (t * 34.0 + 133.0);
}

// Gradient set is a normalized expanded rhombic dodecahedron
float3 grad(float hash) {
    // Random vertex of a cube, +/- 1 each
    float3 cube = fmod(floor(hash / float3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;

    // Random edge of the three edges connected to that vertex
    float3 cuboct = cube;
    int idx = (int)(hash / 16.0);
    if (idx == 0) cuboct.x = 0.0;
    else if (idx == 1) cuboct.y = 0.0;
    else cuboct.z = 0.0;

    // Pick one of the four points on the rhombic face
    float tp = fmod(floor(hash / 8.0), 2.0);
    float3 rhomb = (1.0 - tp) * cube + tp * (cuboct + cross(cube, cuboct));

    // Expand so new edges match existing length
    float3 g = cuboct * 1.22474487139 + rhomb;
    g *= (1.0 - 0.042942436724648037 * tp) * 3.5946317686139184;
    return g;
}

// BCC lattice split into 2 cube lattices
float4 os2NoiseWithDerivativesPart(float3 X) {
    float3 b = floor(X);
    float4 i4 = float4(X - b, 2.5);

    float3 v1 = b + floor(dot(i4, (float4)0.25));
    float3 v2 = b + float3(1, 0, 0) + float3(-1, 1, 1) * floor(dot(i4, float4(-0.25, 0.25, 0.25, 0.35)));
    float3 v3 = b + float3(0, 1, 0) + float3(1, -1, 1) * floor(dot(i4, float4(0.25, -0.25, 0.25, 0.35)));
    float3 v4 = b + float3(0, 0, 1) + float3(1, 1, -1) * floor(dot(i4, float4(0.25, 0.25, -0.25, 0.35)));

    // Gradient hashes
    float4 hashes = permute(fmod(float4(v1.x, v2.x, v3.x, v4.x), 289.0));
    hashes = permute(fmod(hashes + float4(v1.y, v2.y, v3.y, v4.y), 289.0));
    hashes = fmod(permute(fmod(hashes + float4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);

    // Gradient extrapolations & kernel function
    float3 d1 = X - v1; float3 d2 = X - v2; float3 d3 = X - v3; float3 d4 = X - v4;
    float4 a = max(0.75 - float4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);
    float4 aa = a * a; float4 aaaa = aa * aa;
    float3 g1 = grad(hashes.x); float3 g2 = grad(hashes.y);
    float3 g3 = grad(hashes.z); float3 g4 = grad(hashes.w);
    float4 extrapolations = float4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));

    // Derivatives: -8.0 * mat4x3(d1,d2,d3,d4) * (aa*a*extrapolations) + mat4x3(g1,g2,g3,g4) * aaaa
    // mat4x3(col0,col1,col2,col3) * vec4(e) = col0*e.x + col1*e.y + col2*e.z + col3*e.w
    float4 aaa_ext = aa * a * extrapolations;
    float3 derivative = -8.0 * (d1 * aaa_ext.x + d2 * aaa_ext.y + d3 * aaa_ext.z + d4 * aaa_ext.w)
        + (g1 * aaaa.x + g2 * aaaa.y + g3 * aaaa.z + g4 * aaaa.w);

    return float4(derivative, dot(aaaa, extrapolations));
}

// Rotates domain, preserves shape
float4 os2NoiseWithDerivatives_Fallback(float3 X) {
    X = dot(X, (float3)(2.0 / 3.0)) - X;
    float4 result = os2NoiseWithDerivativesPart(X) + os2NoiseWithDerivativesPart(X + 144.5);
    return float4(dot(result.xyz, (float3)(2.0 / 3.0)) - result.xyz, result.w);
}

// Triangular XY alignment, Z moves up main diagonal
float4 os2NoiseWithDerivatives_ImproveXY(float3 X) {
    // Orthonormal map - GLSL column-major transposed for HLSL row-major mul(M, v)
    static const float3x3 orthonormalMap = float3x3(
         0.788675134594813, -0.211324865405187,  0.577350269189626,
        -0.211324865405187,  0.788675134594813,  0.577350269189626,
        -0.577350269189626, -0.577350269189626,  0.577350269189626);

    X = mul(orthonormalMap, X);
    float4 result = os2NoiseWithDerivativesPart(X) + os2NoiseWithDerivativesPart(X + 144.5);

    // result.xyz * orthonormalMap (GLSL row*mat = HLSL mul(v, M) with transposed matrix)
    // Since we already transposed for mul(M,v), mul(v, M) with same matrix = GLSL's v*M^T = v*original
    return float4(mul(result.xyz, orthonormalMap), result.w);
}

// --- Utility functions ---

float GradientWave(float b, float t) {
    return smoothstep(0.0, b, t) * smoothstep(1.0, b, t);
}

float Random(float2 UV, float Seed) {
    return frac(sin(dot(UV.xy * 13.235, float2(12.9898, 78.233)) * 0.000001) * 43758.5453123 * Seed);
}

float3 RandomVec3(float2 UV, float Seed) {
    return float3(Random(UV, Seed), Random(UV * 2.0, Seed), Random(UV * 3.0, Seed));
}

float4 RandomVec4(float2 UV, float Seed) {
    return float4(Random(UV * 1.5, Seed), Random(UV * 2.5, Seed), Random(UV * 3.5, Seed), Random(UV * 4.5, Seed));
}

// --- Raindrop surface ---
// Returns float3(height, dz/dx, dz/dy)

float3 RaindropSurface(float2 XY, float DistanceScale, float ZScale) {
    float A = DistanceScale;
    float x = XY.x;
    float y = XY.y;
    float N = 1.5;
    float M = 0.5;
    float S = ZScale;

    float TempZ = 1.0 - pow(x / A, 2.0) - pow(y / A, 2.0);
    float Z = pow(max(TempZ, 0.0), A / 2.0);
    float ZInMAndN = (Z - M) / (N - M);
    float t = min(max(ZInMAndN, 0.0), 1.0);

    float Height = S * t * t * (3.0 - 2.0 * t);

    float Part01 = S * (6.0 * t - 8.0 * t * t);
    float Part02 = 1.0 / (N - M);
    float Part03 = -1.0 / A * pow(max(TempZ, 0.0), A / 2.0 - 1.0);

    float Part03OfX = x * Part03;
    float Part03OfY = y * Part03;

    float TempValue = (ZInMAndN > 0.0 && ZInMAndN < 1.0) ? Part01 * Part02 : 0.0;

    float PartialDerivativeX = TempValue * Part03OfX;
    float PartialDerivativeY = TempValue * Part03OfY;
    float2 PartialDerivative = Height > 0.0 ? float2(PartialDerivativeX, PartialDerivativeY) : float2(0.0, 0.0);
    return float3(Height, PartialDerivative);
}

float MapToRange(float edge0, float edge1, float x) {
    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
}

float ProportionalMapToRange(float edge0, float edge1, float x) {
    return edge0 + (edge1 - edge0) * x;
}

// --- Static raindrops ---
// Returns float3(height, normal.xy)

float3 StaticRaindrops(float2 UV, float Time, float UVScale) {
    float2 TempUV = UV;
    TempUV *= UVScale;

    float2 ID = floor(TempUV);
    float3 RandVal = RandomVec3(float2(ID.x * 470.15, ID.y * 653.58), RandomSeed);
    TempUV = frac(TempUV) - 0.5;
    float2 RandomPoint = (RandVal.xy - 0.5) * 0.25;
    float2 XY = RandomPoint - TempUV;
    float Distance = length(TempUV - RandomPoint);

    float3 X = float3(float2(TempUV.x * 305.0 * 0.02, TempUV.y * 305.0 * 0.02), 1.8660254037844386);
    float4 noiseResult = os2NoiseWithDerivatives_ImproveXY(X);
    float EdgeRandomCurveAdjust = noiseResult.w * lerp(0.02, 0.175, frac(RandVal.x));

    Distance = EdgeRandomCurveAdjust * 0.5 + Distance;
    Distance = Distance * clamp(lerp(1.0, 55.0, RandomPoint.x), 1.0, 3.0);
    float Height = smoothstep(0.2, 0.0, Distance);

    float GradientFade = GradientWave(0.0005, frac(Time * 0.02 + RandVal.z));

    float DistanceMaxRange = 1.45 * GradientFade;
    float2 Direction = (TempUV - RandomPoint);

    float Theta = 3.141592653 - acos(dot(normalize(Direction), float2(0.0, 1.0)));
    Theta = Theta * RandVal.z;
    float DistanceScale = 0.2 / (1.0 - 0.8 * cos(Theta - 3.141593 / 2.0 - 1.6));
    float YDistance = length(float2(0.0, TempUV.y) - float2(0.0, RandomPoint.y));

    float NewDistance = MapToRange(0.0, DistanceMaxRange * pow(DistanceScale, 1.0), Distance);

    float Scale = 1.65 * (0.2 + DistanceScale * 1.0) * DistanceMaxRange * lerp(1.5, 0.5, RandVal.x);
    float2 TempXY = float2(XY.x * 1.0, XY.y) * 4.0;
    float RandomScale = ProportionalMapToRange(0.85, 1.35, RandVal.z);
    TempXY.x = RandomScale * lerp(TempXY.x, TempXY.x / smoothstep(1.0, 0.4, YDistance * RandVal.z), smoothstep(1.0, 0.0, RandVal.x));
    TempXY = TempXY + EdgeRandomCurveAdjust * 1.0;
    float3 HeightAndNormal = RaindropSurface(TempXY, Scale, 1.0);
    HeightAndNormal.yz = -HeightAndNormal.yz;

    float RandomVisible = (frac(RandVal.z * 10.0 * RandomSeed) < NumberScaleOfStaticRaindrops ? 1.0 : 0.0);
    HeightAndNormal.yz = HeightAndNormal.yz * RandomVisible;
    HeightAndNormal.x = smoothstep(0.0, 1.0, HeightAndNormal.x) * RandomVisible;

    return HeightAndNormal;
}

// --- Rolling raindrops ---
// Returns float4(height, normal.xy, trail)

float4 RollingRaindrops(float2 UV, float Time, float UVScale) {
    float2 LocalUV = UV * UVScale;
    float2 TempUV = LocalUV;

    float2 ConstantA = float2(6.0, 1.0);
    float2 GridNum = ConstantA * 2.0;
    float2 GridID = floor(LocalUV * GridNum);

    float RandomFloat = Random(float2(GridID.x * 131.26, GridID.x * 101.81), RandomSeed);

    float TimeMovingY = Time * 0.85 * ProportionalMapToRange(0.1, 0.25, RandomFloat);
    LocalUV.y += TimeMovingY;
    float YShift = RandomFloat;
    LocalUV.y += YShift;

    float2 ScaledUV = LocalUV * GridNum;
    GridID = floor(ScaledUV);
    float3 RandVec3 = RandomVec3(float2(GridID.x * 17.32, GridID.y * 2217.54), RandomSeed);

    float2 GridUV = frac(ScaledUV) - float2(0.5, 0.0);

    float SwingX = RandVec3.x - 0.5;

    float SwingY = TempUV.y * 20.0;
    float SwingPosition = sin(SwingY + sin(GridID.y * RandVec3.z + SwingY) + GridID.y * RandVec3.z);
    SwingX += SwingPosition * (0.5 - abs(SwingX)) * (RandVec3.z - 0.5);
    SwingX *= 0.65;
    float RandomNormalizedTime = frac(TimeMovingY + RandVec3.z) * 1.0;
    SwingY = (GradientWave(0.87, RandomNormalizedTime) - 0.5) * 0.9 + 0.5;
    SwingY = clamp(SwingY, 0.15, 0.85);
    float2 Position = float2(SwingX, SwingY);

    float2 XY = Position - GridUV;
    float2 Direction = (GridUV - Position) * ConstantA.yx;
    float Distance = length(Direction);

    float3 X = float3(float2(TempUV.x * 513.20 * 0.02, TempUV.y * 779.40 * 0.02), 2.1660251037743386);
    float4 NoiseResult = os2NoiseWithDerivatives_ImproveXY(X);
    float EdgeRandomCurveAdjust = NoiseResult.w * lerp(0.02, 0.175, frac(RandVec3.y));

    Distance = EdgeRandomCurveAdjust + Distance;
    float Height = smoothstep(0.2, 0.0, Distance);
    float NewDistance = MapToRange(0.0, 0.2, Distance);

    float DistanceMaxRange = 1.45;

    float Theta = 3.141592653 - acos(dot(normalize(Direction), float2(0.0, 1.0)));
    Theta = Theta * RandVec3.z;
    float DistanceScale = 0.2 / (1.0 - 0.8 * cos(Theta - 3.141593 / 2.0 - 1.6));
    float Scale = 1.65 * (0.2 + DistanceScale * 1.0) * DistanceMaxRange * lerp(1.0, 0.25, RandVec3.x * 1.0);
    float2 TempXY = float2(XY.x * 1.0, XY.y) * 4.0;
    float RandomScale = ProportionalMapToRange(0.85, 1.35, RandVec3.z);
    TempXY = TempXY * float2(1.0, 4.2) + EdgeRandomCurveAdjust * 0.85;
    float3 HeightAndNormal = RaindropSurface(TempXY, Scale, 1.0);

    // Trail
    float TrailY = pow(smoothstep(1.0, SwingY, GridUV.y), 0.5);
    float TrailX = abs(GridUV.x - SwingX) * lerp(0.8, 4.0, smoothstep(0.0, 1.0, RandVec3.x));
    float Trail = smoothstep(0.25 * TrailY, 0.15 * TrailY * TrailY, TrailX);
    float TrailClamp = smoothstep(-0.02, 0.02, GridUV.y - SwingY);
    Trail *= TrailClamp * TrailY;

    float SignOfTrailX = sign(GridUV.x - SwingX);
    float3 NoiseInput = float3(float2(TempUV.x * 513.20 * 0.02 * SignOfTrailX, TempUV.y * 779.40 * 0.02), 2.1660251037743386);
    float4 TrailNoiseResult = os2NoiseWithDerivatives_ImproveXY(NoiseInput);
    float TrailEdgeRandomCurveAdjust = TrailNoiseResult.w * lerp(0.002, 0.175, frac(RandVec3.y));
    float TrailXDistance = MapToRange(0.0, 0.1, TrailEdgeRandomCurveAdjust * 0.5 + TrailX);
    float2 TrailDirection = SignOfTrailX * float2(1.0, 0.0) + float2(0.0, 1.0) * smoothstep(1.0, 0.0, Trail) * 0.5;
    float2 TrailXY = TrailDirection * 1.0 * TrailXDistance;

    float3 TrailHeightAndNormal = RaindropSurface(TrailXY, 1.0, 1.0);

    TrailHeightAndNormal = TrailHeightAndNormal * pow(Trail * RandVec3.y, 2.0);
    TrailHeightAndNormal.x = smoothstep(0.0, 1.0, TrailHeightAndNormal.x);

    // Remain trail droplets
    SwingY = TempUV.y;
    float RemainTrail = smoothstep(0.2 * TrailY, 0.0, TrailX);
    float RemainDroplet = max(0.0, (sin(SwingY * (1.0 - SwingY) * 120.0) - GridUV.y)) * RemainTrail * TrailClamp * RandVec3.z;
    SwingY = frac(SwingY * 10.0) + (GridUV.y - 0.5);
    float2 RemainDropletXY = GridUV - float2(SwingX, SwingY);
    RemainDropletXY = RemainDropletXY * float2(1.2, 0.8);

    RemainDropletXY = RemainDropletXY + EdgeRandomCurveAdjust * 0.85;
    float3 RemainDropletHeightAndNormal = RaindropSurface(RemainDropletXY, 2.0 * RemainDroplet, 1.0);

    RemainDropletHeightAndNormal.x = smoothstep(0.0, 1.0, RemainDropletHeightAndNormal.x);
    RemainDropletHeightAndNormal = TrailHeightAndNormal.x > 0.0 ? (float3)0 : RemainDropletHeightAndNormal;

    float4 ReturnValue;
    ReturnValue.x = HeightAndNormal.x + TrailHeightAndNormal.x * TrailY * TrailClamp + RemainDropletHeightAndNormal.x * TrailY * TrailClamp;
    ReturnValue.yz = HeightAndNormal.yz + TrailHeightAndNormal.yz + RemainDropletHeightAndNormal.yz;
    ReturnValue.w = Trail;

    float RandomVisible = (frac(RandVec3.z * 20.0 * RandomSeed) < NumberScaleOfRollingRaindrops ? 1.0 : 0.0);
    ReturnValue = ReturnValue * RandomVisible;
    return ReturnValue;
}

// --- Combined raindrops ---

float4 Raindrops(float2 UV, float Time, float UVScale00, float UVScale01, float UVScale02) {
    float3 StaticRaindrop = StaticRaindrops(UV, Time, UVScale00);
    float4 RollingRaindrop01 = RollingRaindrops(UV, Time, UVScale01);

    float Height = StaticRaindrop.x + RollingRaindrop01.x;
    float2 Normal = StaticRaindrop.yz + RollingRaindrop01.yz;
    float Trail = RollingRaindrop01.w;

    return float4(Height, Normal, Trail);
}

// --- Procedural backdrop (replaces iChannel0 texture) ---
// Simple gradient so raindrop refraction has something to distort.

float3 ProceduralBackdrop(float2 uv, float blur) {
    // Subtle cool-toned gradient: darker at top, lighter at bottom
    float3 topColor = float3(0.08, 0.10, 0.14);
    float3 botColor = float3(0.18, 0.22, 0.28);
    float3 base = lerp(topColor, botColor, uv.y);

    // Add slight horizontal variation
    base += 0.02 * sin(uv.x * 6.28318 + 0.5);

    // Blur softens contrast (simulate textureLod mip level)
    float blurFade = saturate(blur * 0.15);
    float3 avg = (topColor + botColor) * 0.5;
    base = lerp(base, avg, blurFade);

    return base;
}

// --- Entry point ---

float4 PSMain(PSInput input) : SV_Target {
    // Flip Y to match Shadertoy convention (Y=0 at bottom) so rain falls downward
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float Time = time;
    float ScaledTime = Time * 0.2;
    float2 GlobalUV = fragCoord.xy / resolution.xy;
    float2 LocalUV = (fragCoord.xy - 0.5 * resolution.xy) / resolution.y;

    float RaindropsAmount = sin(Time * 0.25) * 0.5 + 0.5;

    float MaxBlur = lerp(BackgroundBlur, BackgroundBlur * 2.0, RaindropsAmount);
    float MinBlur = RaindropBlur;

    float StaticRaindropsAmount = smoothstep(-0.5, 1.0, RaindropsAmount) * 2.0;
    float RollingRaindropsAmount01 = smoothstep(0.25, 0.75, RaindropsAmount);
    float RollingRaindropsAmount02 = smoothstep(0.0, 0.5, RaindropsAmount);

    float4 Raindrop = Raindrops(LocalUV, Time,
        StaticRaindropUVScale, RollingRaindropUVScaleLayer01, RollingRaindropUVScaleLayer02);

    float RaindropHeight = Raindrop.x;
    float RaindropTrail = Raindrop.w;
    float2 RaindropNormal = -Raindrop.yz;
    RaindropNormal = RaindropHeight > 0.0 ? RaindropNormal * 0.15 : float2(0.0, 0.0);

    float2 UVWithNormal = GlobalUV + RaindropNormal;
    float EdgeColorScale = smoothstep(0.2, 0.0, length(RaindropNormal));
    EdgeColorScale = RaindropHeight > 0.0 ? pow(EdgeColorScale, 0.5) * 0.2 + 0.8 : 1.0;

    float Blur = lerp(MinBlur, MaxBlur, smoothstep(0.0, 1.6, length(RaindropNormal)));
    Blur = RaindropHeight > 0.0 ? Blur : MaxBlur;
    Blur = ProportionalMapToRange(MinBlur, Blur, 1.0 - RaindropTrail);
    EdgeColorScale = pow(EdgeColorScale, 0.85);

    float3 FinalColor = ProceduralBackdrop(UVWithNormal, Blur) * EdgeColorScale;

    // Darken / desaturate post-processing
    float lum = dot(FinalColor, float3(0.299, 0.587, 0.114));
    FinalColor = lerp(FinalColor, float3(lum, lum, lum), desaturate);
    FinalColor = FinalColor * (1.0 - darken);

    // Transparency: raindrop areas visible, non-drop areas transparent
    // so the underlying acrylic/mica backdrop shows through
    float dropMask = saturate(RaindropHeight + RaindropTrail * 0.3);
    float alpha = dropMask;

    // Premultiplied alpha
    return float4(FinalColor * alpha, alpha);
}

    )"
}

_Shader_Meta_RaindropsGlass() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_RaymarchingWaves() {
    return "
    (
// Is it still raymarching? — converted from Shadertoy 7sdyWX
// By VPas, inspired by https://www.shadertoy.com/view/MtX3Ws
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 r = resolution.xy;
    float mr = 1.0 / min(r.x, r.y);
    float c, f, t = time;
    float3 k = (float3)0;
    float3 n, p;
    float3 l = float3(sin(t * .035), sin(t * .089) * cos(t * .073), cos(t * .1)) * .3 + (float3).3;

    // 2x2 AA loop
    [unroll] for (int ax = 1; ax <= 2; ax++) {
        [unroll] for (int ay = 1; ay <= 2; ay++) {
            n = float3((fragCoord * 2.0 - r + float2(ax, ay)) * mr * 4.0, 1.0);
            float3 g = (float3)0;
            float u = .2, d = 0.0;

            [loop] for (int ii = 0; ii < 3; ii++) {
                d += u;
                p = n * d - l;
                c = 0.0;

                [loop] for (int jj = 0; jj < 7; jj++) {
                    p = (sin(t * .05) * .1 + .9) * abs(p) / dot(p, p) - (cos(t * .09) * .02 + .8);
                    p.xy = float2(p.x * p.x - p.y * p.y, (smoothstep(0., 4., time) * 3. + .8 * cos(t * .07)) * p.x * p.y);
                    p = p.yxz;
                    c += exp(-9. * abs(dot(p, p.zxy)));
                }

                u *= exp(-c * .6);
                f = c * c * .09;
                g = g * 1.5 + .5 * float3(c * f * .3, f, f);
            }

            g *= g;
            k += g * .4;
        }
    }

    float3 col = k / (1.0 + k);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_RaymarchingWaves() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_ReflectiveTruchet() {
    return "
    (
// Reflective truchet' — mrange
// https://www.shadertoy.com/view/w3GBD3
// License: CC0
// Reflective truchet torus tiles with colored lighting

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2x2 ROT(float a) {
    float c = cos(a), s = sin(a);
    return float2x2(c, s, -s, c);
}

static const float MaxDistance = 30.0;
static const float ColorOffset = 0.5;
// normalize(float3(1, 2, -1)) precomputed
static const float3 LD = float3(0.40824829, 0.81649658, -0.40824829);
static const float3 RO = float3(0, 0, -3);
static const float3 ColorBase = float3(0.5, 1.5, 2.5);

static float2x2 R0;
static float2x2 R1;

float length4(float2 p) {
    return sqrt(length(p * p));
}

float3 hash(float3 r) {
    float h = frac(sin(dot(r.xy, float2(1.38984 * sin(r.z), 1.13233 * cos(r.z)))) * 653758.5453);
    return frac(h * float3(1, 3667, 8667));
}

// License: MIT, author: Inigo Quilez
float torus(float3 p) {
    const float2 t = 0.5 * float2(1.0, 0.3);
    float2 q = float2(length(p.xz) - t.x, p.y);
    return length4(q) - t.y;
}

// License: MIT, author: Inigo Quilez
float pmin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

float pmax(float a, float b, float k) {
    return -pmin(-a, -b, k);
}

float df(float3 p) {
    float D, k, d, j;
    float3 P, h, n;

    D = length(p - RO) - 0.75;
    k = 4.0 / dot(p, p);
    p *= k;
    p.xz = mul(R0, p.xz);
    p.xy = mul(R1, p.xy);
    p.z -= 0.25 * time;
    d = 1e3;
    for (j = 0.0; j < 2.0; ++j) {
        P = p + j * 0.5;
        n = floor(P + 0.5);
        h = hash(n + 123.4);
        P -= n;
        P *= -1.0 + 2.0 * step(h, (float3)0.5);
        d = min(d, torus(P - float3(0.5, 0, 0.5)));
        d = min(d, torus(P.yzx + float3(0.5, 0, 0.5)));
        d = min(d, torus(P.yxz - float3(0.5, 0, -0.5)));
    }
    d /= k;
    d = pmax(d, -D, 0.5);

    return d;
}

float3 normal(float3 p) {
    float2 e = float2(1e-3, 0);
    return normalize(float3(
        df(p + e.xyy) - df(p - e.xyy),
        df(p + e.yxy) - df(p - e.yxy),
        df(p + e.yyx) - df(p - e.yyx)));
}

float march(float3 P, float3 I) {
    float i, d, z = 0.0, nz = 0.0, nd = 1e3;

    for (i = 0.0; i < 77.0; ++i) {
        d = df(z * I + P);
        if (d < 1e-3 || z > MaxDistance) break;
        if (d < nd) {
            nd = d;
            nz = z;
        }
        z += d;
    }

    if (i == 77.0) {
        z = nz;
    }

    return z;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float i, f, z, A = 1.0;
    float3 o = (float3)0, c, p, n, r;
    float3 P = RO;
    float3 I = normalize(float3(fragCoord - 0.5 * resolution, resolution.y));

    R0 = ROT(0.213 * 0.5 * time);
    R1 = ROT(0.123 * 0.5 * time);

    for (i = 0.0; i < 4.0 && A > 0.07; ++i) {
        c = (float3)0;
        z = march(P, I);
        p = z * I + P;
        n = normal(p);
        r = reflect(I, n);
        f = 1.0 + dot(n, I);
        f *= f;
        if (z < MaxDistance)
            c += pow(max(0.0, dot(n, LD)), 9.0);
        o += A * c * (1.1 + sin(2.5 * f + ColorBase));
        A *= lerp(0.3, 0.7, f);
        P = p + 0.05 * n;
        I = r;
    }

    o *= 3.0;
    o = sqrt(o) - 0.07;
    o = max(o, 0.0);

    float3 color = o;

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_ReflectiveTruchet() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_RetroScreensaverLines() {
    return "
    (
// 80's style screen saver with simple lines
// Original: https://www.shadertoy.com/view/dsKfRz by bschu
// Line function by gPlati: https://www.shadertoy.com/view/MlcGDB

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float lineSDF(float2 P, float2 A, float2 B, float r) {
    float2 g = B - A;
    float d = abs(dot(normalize(float2(g.y, -g.x)), P - A));
    return smoothstep(r, 0.5 * r, d);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution.xy;

    // A fancy changing color
    float r = abs(sin(time / 2.0));
    float g = abs(cos(time / 3.0));
    float b = abs(-sin(time / 4.0));

    float3 changing = float3(r, g, b);
    float3 color = (float3)(abs(cos(time / 2.0)) - 0.8);

    // Points for our lines
    float speed = 0.3;
    float x1 = sin(time * speed);
    float x2 = cos(time * speed);
    float y1 = sin(time * speed);
    float y2 = cos(time * speed);

    float l = 0.0;
    float amount = 100.0;
    float width = 0.005;

    for (float i = -amount; i < amount; i += 1.0) {
        float start = i * 0.05;
        l = lineSDF(uv, float2(x1 + start, y1 - start), float2(x2 + start, y2), width);
        color = (1.0 - l) * color + (l * changing);
    }

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_RetroScreensaverLines() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_Rocaille() {
    return "
    (
// Rocaille - Converted from Shadertoy (WXyczK)
// Original by Xor (@XorDev)
// Multi-layer turbulence with time and color offsets
// https://www.shadertoy.com/view/WXyczK

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;

    // Centered and scaled coordinates
    float2 p = (fragCoord * 2.0 - resolution) / resolution.y / 0.3;

    // Turbulence layers
    float4 O = (float4)0;
    float2 v;
    for (float i = 1.0; i <= 9.0; i += 1.0) {
        // Turbulence accumulation
        v = p;
        for (float f = 1.0; f <= 9.0; f += 1.0)
            v += sin(v.yx * f + i + time) / f;
        // Color layer attenuated by turbulent distance
        O += (cos(i + float4(0, 1, 2, 3)) + 1.0) / 6.0 / length(v);
    }

    // Tanh tonemapping
    O = tanh(O * O);
    float3 color = O.rgb;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_Rocaille() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_RotatingTorus() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float pi = 3.1416;

static const int steps = 256;
static const float4 background = float4((float3)0.0, 1.0);
static const float ringRadius = 1.5;
static const float pipeRadius = 0.3;

float3 toSRGB(float3 color) { return pow(color, (float3)(1.0 / 2.2)); }

struct Ray {
    float3 origin;
    float3 direction;
};

Ray createRayPerspective(float2 res, float2 screenPosition, float verticalFov) {
    float2 topLeft = float2(-res.x, -res.y) * 0.5;
    float z = (res.x * 0.5) / abs(tan(verticalFov / 2.0));

    Ray r;
    r.origin = (float3)0.0;
    r.direction = normalize(float3(topLeft + screenPosition, -z));
    return r;
}

float3 positionOnRay(Ray ray, float t) {
    return ray.origin + ray.direction * t;
}

float sdTorus(float3 position, float rRadius, float pRadius) {
    float2 q = float2(length(position.xz) - rRadius, position.y);
    return length(q) - pRadius;
}

float2 textureCoordinates(float3 position, float rRadius) {
    float2 q = float2(length(position.xz) - rRadius, position.y);
    float u = (atan2(position.x, position.z) + pi) / (2.0 * pi);
    float v = (atan2(q.x, q.y) + pi) / (2.0 * pi);
    return float2(u, v);
}

float map(float3 position) {
    return -sdTorus(position, ringRadius, pipeRadius);
}

float sdSegment(float2 pt, float2 a, float2 b) {
    float2 pa = pt - a;
    float2 ba = b - a;

    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);

    return length(pa - ba * h);
}

void drawSegment(float2 fragmentCoordinates, float2 p0, float2 p1,
                 float thickness, float4 color, inout float4 outputColor) {
    float d = sdSegment(fragmentCoordinates, p0, p1);
    float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);

    outputColor = lerp(outputColor, color, a * color.a);
}

float4 tex(float2 uv) {
    float2 res = (float2)400.0;
    uv *= res;
    float4 color = float4((float3)0.0, 1.0);

    float thickness = res.x / 100.0;

    float2 position = uv;
    position.x -= position.y - thickness * 3.0 - 2.0;
    position.x = fmod(position.x, res.x / 8.0);
    position.y = fmod(position.y, res.x / 30.0);
    drawSegment(position, float2(2.0, res.x / 30.0 * 0.5),
                float2(res.x / 8.0 * 0.5, res.x / 30.0 * 0.5),
                thickness * 0.01, (float4)1.0, color);

    float2 margin = (float2)50.0;
    float2 offset = float2(res.x + 0.5, 0.5);
    thickness *= 3.0;
    drawSegment(uv, -margin, res + margin, thickness * 1.5, float4((float3)0.0, 1.0), color);
    drawSegment(uv, -margin, res + margin, thickness, (float4)1.0, color);
    drawSegment(uv, -margin - offset, res + margin - offset, thickness * 1.5, float4((float3)0.0, 1.0), color);
    drawSegment(uv, -margin - offset, res + margin - offset, thickness, (float4)1.0, color);
    drawSegment(uv, -margin + offset, res + margin + offset, thickness * 1.5, float4((float3)0.0, 1.0), color);
    drawSegment(uv, -margin + offset, res + margin + offset, thickness, (float4)1.0, color);

    return color;
}

float4 trace(Ray ray) {
    ray.origin += float3(0.0, 1.53, 0.85);

    float t = 0.0;
    for (int i = 0; i < steps; i++) {
        float3 position = positionOnRay(ray, t).yxz;
        float distance = map(position);

        if (distance < 0.002) {
            float2 uv = textureCoordinates(position, 1.5);
            uv.x += time * 0.1;
            uv.x = fmod(uv.x * 10.0, 1.0);
            return tex(uv) * clamp(1.2 - t * 0.25, 0.0, 1.0);
        }

        t += distance * 0.999;
    }

    return background;
}

float4 takeSample(float2 fragCoord) {
    float fov = pi / 2.0;

    Ray ray = createRayPerspective(resolution, fragCoord, fov);
    return trace(ray);
}

float4 superSample(float2 fragCoord, int samples) {
    if (samples == 1) {
        return takeSample(fragCoord);
    }

    float divided = 1.0 / (float)samples;

    float4 outColor = (float4)0.0;
    for (int x = 0; x < samples; x++) {
        for (int y = 0; y < samples; y++) {
            float2 offset = float2(((float)x + 0.5) * divided - 0.5,
                                   ((float)y + 0.5) * divided - 0.5);
            float2 samplePosition = fragCoord + offset;
            outColor += takeSample(samplePosition);
        }
    }

    return outColor / (float)(samples * samples);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float4 fragColor = superSample(fragCoord, 2);
    float3 color = toSRGB(fragColor.rgb);

    // Darken/desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_RotatingTorus() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_SailingBeyondHyperTunnel() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define FAR 1e3
#define INFINITY_VAL 1e32

#define T time
#define FOV 70.0
#define FOG 0.06

#define PI 3.14159265
#define TAU (2*PI)
#define PHI (1.618033988749895)

// Synthetic beat to replace audio input
float getBeat() {
    return smoothstep(0.6, 0.9, pow(sin(time * 1.5) * 0.5 + 0.5, 4.0)) * 0.3 + 0.4;
}

float getBeatLow() {
    return smoothstep(0.5, 0.8, pow(sin(time * 0.8) * 0.5 + 0.5, 3.0)) * 0.5 + 0.5;
}

float hash12(float2 p) {
    float h = dot(p, float2(127.1, 311.7));
    return frac(sin(h) * 43758.5453123);
}

// 3d noise
float noise_3(in float3 p) {
    float3 i = floor(p);
    float3 f = frac(p);
    // Original GLSL: vec3 u = 1.-(--f)*f*f*f*-f;
    // --f means f = f - 1, then expression is 1 - (f-1)*(f)*(f)*(f)*(-f)
    // Actually: u = f*f*f*(f*(f*6-15)+10) (quintic smoothstep)
    float3 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    float2 ii = i.xy + i.z * float2(5.0, 5.0);
    float a = hash12(ii + float2(0.0, 0.0));
    float b = hash12(ii + float2(1.0, 0.0));
    float c = hash12(ii + float2(0.0, 1.0));
    float d = hash12(ii + float2(1.0, 1.0));
    float v1 = lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);

    ii += float2(5.0, 5.0);
    a = hash12(ii + float2(0.0, 0.0));
    b = hash12(ii + float2(1.0, 0.0));
    c = hash12(ii + float2(0.0, 1.0));
    d = hash12(ii + float2(1.0, 1.0));
    float v2 = lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);

    return max(lerp(v1, v2, u.z), 0.0);
}

float fbm(float3 x) {
    float r = 0.0;
    float w = 1.0, s = 1.0;
    for (int i = 0; i < 4; i++) {
        w *= 0.25;
        s *= 3.0;
        r += w * noise_3(s * x);
    }
    return r;
}

float yC(float x) {
    return cos(x * -0.134) * 1.0 * sin(x * 0.13) * 15.0 + fbm(float3(x * 0.1, 0.0, 0.0) * 55.4);
}

void pR(inout float2 p, float a) {
    p = cos(a) * p + sin(a) * float2(p.y, -p.x);
}

struct geometry {
    float dist;
    float3 hit;
    int iterations;
};

// Cylinder with infinite height
float fCylinderInf(float3 p, float r) {
    return length(p.xz) - r;
}

geometry map(float3 p) {
    p.x -= yC(p.y * 0.1) * 3.0;
    p.z += yC(p.y * 0.01) * 4.0;

    float n = pow(abs(fbm(p * 0.06)) * 12.0, 1.3);
    float s = fbm(p * 0.01 + float3(0.0, T * 0.14, 0.0)) * 128.0;

    geometry obj;
    obj.dist = 0.0;
    obj.hit = (float3)0;
    obj.iterations = 0;

    obj.dist = max(0.0, -fCylinderInf(p, s + 18.0 - n));

    p.x -= sin(p.y * 0.02) * 34.0 + cos(p.z * 0.01) * 62.0;

    obj.dist = max(obj.dist, -fCylinderInf(p, s + 28.0 + n * 2.0));

    return obj;
}

static float t_min = 10.0;
static float t_max = FAR;
static const int MAX_ITERATIONS = 100;

geometry trace(float3 o, float3 d) {
    float omega = 1.3;
    float t = t_min;
    float candidate_error = INFINITY_VAL;
    float candidate_t = t_min;
    float previousRadius = 0.0;
    float stepLength = 0.0;
    float pixelRadius = 1.0 / 1000.0;

    geometry mp = map(o);

    float functionSign = mp.dist < 0.0 ? -1.0 : 1.0;
    float minDist = FAR;

    for (int i = 0; i < MAX_ITERATIONS; ++i) {
        mp = map(d * t + o);
        mp.iterations = i;

        float signedRadius = functionSign * mp.dist;
        float radius = abs(signedRadius);
        bool sorFail = omega > 1.0 && (radius + previousRadius) < stepLength;

        if (sorFail) {
            stepLength -= omega * stepLength;
            omega = 1.0;
        } else {
            stepLength = signedRadius * omega;
        }
        previousRadius = radius;
        float error = radius / t;

        if (!sorFail && error < candidate_error) {
            candidate_t = t;
            candidate_error = error;
        }

        if ((!sorFail && error < pixelRadius) || t > t_max) break;

        t += stepLength * 0.5;
    }

    mp.dist = candidate_t;

    if (t > t_max || candidate_error > pixelRadius)
        mp.dist = INFINITY_VAL;

    return mp;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 ouv = fragCoord.xy / resolution.xy;
    float2 uv = ouv - 0.5;

    uv *= tan(radians(FOV) / 2.0) * 4.0;

    float3 vuv = normalize(float3(cos(T), sin(T * 0.11), sin(T * 0.41))); // up
    float3 ro = float3(0.0, 30.0 + time * 100.0, -0.1);

    ro.x += yC(ro.y * 0.1) * 3.0;
    ro.z -= yC(ro.y * 0.01) * 4.0;

    float3 vrp = float3(0.0, 50.0 + time * 100.0, 2.0);

    vrp.x += yC(vrp.y * 0.1) * 3.0;
    vrp.z -= yC(vrp.y * 0.01) * 4.0;

    float3 vpn = normalize(vrp - ro);
    float3 u = normalize(cross(vuv, vpn));
    float3 v = cross(vpn, u);
    float3 vcv = ro + vpn;
    float3 scrCoord = vcv + uv.x * u * resolution.x / resolution.y + uv.y * v;
    float3 rd = normalize(scrCoord - ro);
    float3 oro = ro;

    float3 sceneColor = (float3)0;

    geometry tr = trace(ro, rd);

    tr.hit = ro + rd * tr.dist;

    float3 col = float3(1.0, 0.5, 0.4) * fbm(tr.hit.xzy * 0.01) * 20.0;
    col.b *= fbm(tr.hit * 0.01) * 10.0;

    sceneColor += min(0.8, (float)tr.iterations / 90.0) * col + col * 0.03;
    sceneColor *= 1.0 + 0.9 * (abs(fbm(tr.hit * 0.002 + 3.0) * 10.0) * (fbm(float3(0.0, 0.0, time * 0.05) * 2.0)) * 1.0);
    // Replace audio: texelFetch(iChannel0, ivec2(128, 0), 0).r with synthetic beat
    sceneColor = pow(sceneColor, (float3)1.0) * getBeat() * min(1.0, time * 0.1);

    float3 steamColor1 = float3(0.0, 0.4, 0.5);
    float3 rro = oro;

    ro = tr.hit;

    float distC = tr.dist;
    float f = 0.0;
    float st = 0.9;

    for (float i = 0.0; i < 24.0; i++) {
        rro = ro - rd * distC;
        f += fbm(rro * float3(0.1, 0.1, 0.1) * 0.3) * 0.1;
        distC -= 3.0;
        if (distC < 3.0) break;
    }

    // Replace audio: texelFetch(iChannel0, ivec2(32, 0), 0).r with synthetic low beat
    steamColor1 *= getBeatLow();
    sceneColor += steamColor1 * pow(abs(f * 1.5), 3.0) * 4.0;

    float4 fragColor = float4(clamp(sceneColor * (1.0 - length(uv) / 2.0), 0.0, 1.0), 1.0);
    fragColor = pow(abs(fragColor / tr.dist * 130.0), (float4)0.8);

    // Post-processing: darken/desaturate
    float3 color = fragColor.rgb;
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_SailingBeyondHyperTunnel() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_Satinlike() {
    return "
    (
// Satinlike (Simple FBM Warp) by CaliCoastReplay
// Ported from https://www.shadertoy.com/view/ll3GD7
// FBM domain warping inspired by IQ's warp tutorial

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// Color space helpers

float3 rgb2hsv(float3 c) {
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float3 hsv2rgb(float3 c) {
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// FBM (Fractal Brownian Motion)

float rand_val(float2 n) {
    return frac(cos(dot(n, float2(12.9898, 4.1414))) * 3758.5453);
}

float noise_val(float2 n) {
    float2 d = float2(0.0, 1.0);
    float2 b = floor(n);
    float2 f = smoothstep((float2)0, (float2)1, frac(n));
    return lerp(lerp(rand_val(b), rand_val(b + d.yx), f.x),
                lerp(rand_val(b + d.xy), rand_val(b + d.yy), f.x), f.y);
}

float fbm(float2 n) {
    float total = 0.0;
    float amplitude = 1.0;
    [loop]
    for (int i = 0; i < 10; i++) {
        total += noise_val(n) * amplitude;
        amplitude *= 0.4;
    }
    return total;
}

float pattern(float2 p) {
    float2 q = float2(
        fbm(p),
        fbm(p + float2(5.2 + sin(time) / 10.0, 1.3 - cos(time) / 10.0)));

    float2 r = float2(
        fbm(p + 4.0 * q + float2(1.7 + sin(time) / 10.0, 9.2)),
        fbm(p + 4.0 * q + float2(8.3, 2.8 - cos(time) / 10.0)));

    float2 ac = p + 4.0 * r;
    ac.x += sin(time);
    ac.y += cos(time);
    return sqrt(pow(fbm(ac + time
               + fbm(ac - time
                    + fbm(ac + sin(time)))), -2.0));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution;
    float intensity = pattern(uv);
    float3 color = float3(uv, 0.5 + 0.5 * sin(time));
    float3 hsv = rgb2hsv(color);
    hsv.z = cos(hsv.y) - 0.1;
    color = hsv2rgb(hsv);
    color *= intensity;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color *= 1.0 - darken;

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_Satinlike() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_Satori() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static float k = 20.0;
static float field = 0.0;
static float2 g_fragCoord;

// Time-based sweep replacing iMouse for color palette and circle position
static float2 fakeMouse;

float2 centerPos(float2 border, float2 offset, float2 vel) {
    float2 c;
    if (vel.x == 0.0 && vel.y == 0.0) {
        c = fakeMouse * resolution;
    } else {
        c = offset + vel * time * 0.5;
        c = fmod(c, 2.0 - 4.0 * border);
        c = abs(c);
        if (c.x > 1.0 - border.x) c.x = 2.0 - c.x - 2.0 * border.x;
        if (c.x < border.x) c.x = 2.0 * border.x - c.x;
        if (c.y > 1.0 - border.y) c.y = 2.0 - c.y - 2.0 * border.y;
        if (c.y < border.y) c.y = 2.0 * border.y - c.y;
    }
    return c;
}

void circle(float r, float3 col, float2 offset, float2 vel) {
    float2 pos = g_fragCoord.xy / resolution.y;
    float aspect = resolution.x / resolution.y;
    float2 c = centerPos(float2(r / aspect, r), offset, vel);
    c.x *= aspect;
    float d = distance(pos, c);
    field += (k * r) / (d * d);
}

float3 band(float shade, float low, float high, float3 col1, float3 col2) {
    if ((shade >= low) && (shade <= high)) {
        float delta = (shade - low) / (high - low);
        float3 colDiff = col2 - col1;
        return col1 + (delta * colDiff);
    } else {
        return float3(0.0, 0.0, 0.0);
    }
}

float3 gradient(float shade) {
    float3 colour = float3((sin(time / 2.0) * 0.25) + 0.25, 0.0, (cos(time / 2.0) * 0.25) + 0.25);

    float2 mouseScaled = fakeMouse;
    float3 col1 = float3(mouseScaled.x, 0.0, 1.0 - mouseScaled.x);
    float3 col2 = float3(1.0 - mouseScaled.x, 0.0, mouseScaled.x);
    float3 col3 = float3(mouseScaled.y, 1.0 - mouseScaled.y, mouseScaled.y);
    float3 col4 = float3((mouseScaled.x + mouseScaled.y) / 2.0, (mouseScaled.x + mouseScaled.y) / 2.0,
                         1.0 - (mouseScaled.x + mouseScaled.y) / 2.0);
    float3 col5 = float3(mouseScaled.y, mouseScaled.y, mouseScaled.y);

    colour += band(shade, 0.0, 0.3, colour, col1);
    colour += band(shade, 0.3, 0.6, col1, col2);
    colour += band(shade, 0.6, 0.8, col2, col3);
    colour += band(shade, 0.8, 0.9, col3, col4);
    colour += band(shade, 0.9, 1.0, col4, col5);

    return colour;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    g_fragCoord = fragCoord;
    field = 0.0;
    fakeMouse = float2(sin(time * 0.05) * 0.5 + 0.5, cos(time * 0.07) * 0.5 + 0.5);

    circle(0.03, float3(0.7, 0.2, 0.8), (float2)0.6, float2(0.30, 0.70));
    circle(0.05, float3(0.7, 0.9, 0.6), (float2)0.1, float2(0.02, 0.20));
    circle(0.07, float3(0.3, 0.4, 0.1), (float2)0.1, float2(0.10, 0.04));
    circle(0.10, float3(0.2, 0.5, 0.1), (float2)0.3, float2(0.10, 0.20));
    circle(0.20, float3(0.1, 0.3, 0.7), (float2)0.2, float2(0.40, 0.25));
    circle(0.30, float3(0.9, 0.4, 0.2), (float2)0.0, float2(0.15, 0.20));
    circle(0.30, float3(0.0, 0.0, 0.0), (float2)0.0, float2(0.0, 0.0));

    float shade = min(1.0, max(field / 256.0, 0.0));

    float3 color = gradient(shade);

    // Post-processing: darken/desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_Satori() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_ScreensaverWarpedGradWaves() {
    return "
    (
// Screensaver warped grad waves
// Converted from: https://www.shadertoy.com/view/mdSXWV

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float2 rot2(float2 st, float theta) {
    float c = cos(theta);
    float s = sin(theta);
    float2x2 M = float2x2(c, -s, s, c);
    return mul(M, st);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution;
    uv -= 0.5;
    uv *= 5.0;

    uv = rot2(uv, 0.5 * 3.1415 * uv.x);

    float3 col = 0.5 + 0.5 * cos(time + uv.xyx + float3(0, 2, 4));

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_ScreensaverWarpedGradWaves() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_SeaAdventure() {
    return "
    (
// Credits to TDM https://www.shadertoy.com/view/Ms2SD1

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// Per-pixel mutable state (reset each pixel invocation)
static float g_fire = 0.;
static float g_moonlight = 0.;
static bool g_isGhost = true;
static bool g_isWater = true;
static float g_at = 0.;
static float g_at1 = 0.;
static const float3 g_lpos = float3(0, 200, 200);

float smin(float a, float b, float h)
{
    float k = clamp((a - b) / h * .5 + .5, 0., 1.);
    return lerp(a, b, k) - k * (1. - k) * h;
}

float2x2 rot(float a)
{
    float c = cos(a), s = sin(a);
    return float2x2(c, -s, s, c);
}

float box(float3 p, float3 s)
{
    p = abs(p) - s;
    return max(p.x, max(p.y, p.z));
}

float repeatF(float p, float s)
{
    return (frac(p / s - .5) - .5) * s;
}

float2 repeatF2(float2 p, float2 s)
{
    return (frac(p / s - .5) - .5) * s;
}

float3 repeatF3(float3 p, float3 s)
{
    return (frac(p / s - .5) - .5) * s;
}

float3 kifs(float3 p, float t)
{
    p.xz = repeatF2(p.xz, (float2)10.);
    p.xz = abs(p.xz);

    float2 s = float2(10, 7) * 0.7;
    for (float i = 0.; i < 5.; ++i)
    {
        p.xz = mul(p.xz, rot(t));
        p.xz = abs(p.xz) - s;
        p.y -= 0.1 * abs(p.z);
        s *= float2(0.68, 0.55);
    }

    return p;
}

float3 kifs3d(float3 p, float t)
{
    p.xz = repeatF2(p.xz, (float2)32.);
    p = abs(p);

    float2 s = float2(10, 7) * 0.6;
    for (float i = 0.; i < 5.; ++i)
    {
        p.yz = mul(p.yz, rot(t * .7));
        p.xz = mul(p.xz, rot(t));
        p.xz = abs(p.xz) - s;
        p.y -= 0.1 * abs(p.z);
        s *= float2(0.68, 0.55);
    }

    return p;
}

float3 tunnel(float3 p)
{
    float3 off = (float3)0;
    float dd = p.z * 0.02;
    dd = floor(dd) + smoothstep(0., 1., smoothstep(0., 1., frac(dd)));
    dd *= 1.7;
    off.x += sin(dd) * 10.;
    return off;
}

float solid(float3 p)
{
    float t = time * .2;
    float3 pp = p;
    float3 p5 = p;
    pp += tunnel(p);

    float path = abs(pp.x) - 1.;

    float3 p2 = kifs(p, 0.5);
    float3 p3 = kifs(p + float3(1, 0, 0), 1.9);

    float d5 = -1.;
    p5.xy = mul(p5.xy, rot(2.8));
    p5.xz = mul(p5.xz, rot(0.5));

    float trk = 1.;
    float z = 1.;
    int iterations = 10;
    for (int i = 0; i < iterations; ++i)
    {
        p5 += sin(p5.zxy * 0.75 * trk + t * trk * .8);
        d5 -= abs(dot(cos(p5), sin(p5.yzx)) * z);
        trk *= 1.6;
        z *= 0.4;
        p5.y += t * 3.;
    }

    float d;
    float b1 = box(p2, float3(1, 1, 0.5));
    float b2 = box(p3, float3(0.5, 1.3, 1));

    float m1 = max(abs(b1), abs(b2)) - 0.2;
    d = m1;
    d = max(d, -path);
    d5 = abs(d5);
    d += sin(time * 0.1) * .3 + .5;
    if (p5.y - t * 3. * float(iterations) > -10.)
    {
        d = smin(d, d5, 3.);
    }

    g_fire += 0.2 / (0.1 + abs(d));
    return d;
}

float ghost(float3 p)
{
    float3 p2 = kifs3d(p - float3(0, 2, 3), 0.8 + time * 0.1);
    float3 p3 = kifs3d(p - float3(3, 0, 0), 1.2 + time * 0.07);

    float b1 = box(p2, (float3)5);
    float b2 = box(p3, (float3)3);

    float m1 = max(abs(b1), abs(b2)) - .2;
    float d = abs(m1) - 0.02;
    return d;
}

float hash2(float2 p) {
    float h = dot(p, float2(127.1, 311.7));
    return frac(sin(h) * 43758.5453123);
}

float noise2(float2 p) {
    float2 i = floor(p);
    float2 f = frac(p);
    float2 u = f * f * (3.0 - 2.0 * f);
    return -1.0 + 2.0 * lerp(lerp(hash2(i + float2(0, 0)),
                     hash2(i + float2(1, 0)), u.x),
                lerp(hash2(i + float2(0, 1)),
                     hash2(i + float2(1, 1)), u.x), u.y);
}

float noise3(float3 p) {
    float3 ip = floor(p);
    p = frac(p);
    p = smoothstep(0.0, 1.0, p);
    float3 st = float3(7, 137, 235);
    float4 val = dot(ip, st) + float4(0, st.y, st.z, st.y + st.z);
    float4 v = lerp(frac(sin(val) * 5672.655), frac(sin(val + st.x) * 5672.655), p.x);
    float2 v2 = lerp(v.xz, v.yw, p.y);
    return lerp(v2.x, v2.y, p.z);
}

float sea_octave(float2 uv, float choppy) {
    uv += noise2(uv);
    float2 wv = 1.0 - abs(sin(uv));
    float2 swv = abs(cos(uv));
    wv = lerp(wv, swv, wv);
    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
}

float water(float3 p)
{
    float freq = 0.16;
    float amp = 0.6;
    float choppy = 4.;
    float sea_time = 1. + time * 0.8;
    float2 uv = p.xz; uv.x *= 0.75;
    float2x2 octave_m = float2x2(1.6, 1.2, -1.2, 1.6);

    float d, h = 0.0;
    for (int i = 0; i < 5; i++) {
        d = sea_octave((uv + sea_time) * freq, choppy);
        d += sea_octave((uv - sea_time) * freq, choppy);
        h += d * amp;
        uv = mul(uv, octave_m); freq *= 1.9; amp *= 0.22;
        choppy = lerp(choppy, 1.0, 0.2);
    }
    return p.y - h + 1.;
}

float mapScene(float3 p)
{
    float sol = solid(p);
    float wat = water(p);
    float gho = ghost(p);
    float d = smin(sol, wat, 0.1);
    g_isWater = wat < sol;
    g_isGhost = gho < d;
    g_at += 0.1 / (0.1 + abs(gho));
    g_at1 += 0.01 / (0.1 + abs(gho));
    g_at -= g_at1;
    g_at = (g_at + abs(g_at)) / 2.;

    // moon
    float d1 = length(p - g_lpos) - 30.;
    g_moonlight += 0.5 / (0.5 + (d1 + abs(d1)));
    d = min(d, d1);

    d *= 0.7;
    return d;
}

float3 starsField(float2 uv)
{
    float iterations = 17.;
    float formuparam = 0.53;

    float volsteps = 20.;
    float stepsize = 0.1;

    float zoom = 0.200;
    float tile = 0.850;

    float brightness = 0.0015;
    float darkmatter_val = 0.300;
    float distfading = 0.730;
    float saturation = 0.850;

    uv = mul(uv, rot(time * 0.001));
    float3 dir = float3(uv * zoom, 1.);

    float s = 0.1, fade = 0.2;
    float3 v = (float3)0;
    for (float r = 0.; r < volsteps; r++) {
        float3 p = s * dir * .5;
        p = abs((float3)tile - fmod(p, (float3)(tile * 2.)));
        float pa = 0., a = 0.;
        for (float i = 0.; i < iterations; i++) {
            p = abs(p) / dot(p, p) - formuparam;
            a += abs(length(p) - pa);
            pa = length(p);
        }
        float dm = max(0., darkmatter_val - a * a * .001);
        a *= a * a;
        if (r > 6.) fade *= 1. - dm;
        v += fade;
        v += float3(s, s * s, s * s * s * s) * a * brightness * fade;
        fade *= distfading;
        s += stepsize;
    }
    v = lerp((float3)length(v), v, saturation);
    return v * .01;
}

float3 lin2srgb(float3 cl)
{
    float3 c_lo = 12.92 * cl;
    float3 c_hi = 1.055 * pow(cl, (float3)0.41666) - 0.055;
    float3 s = step((float3)0.0031308, cl);
    return lerp(c_lo, c_hi, s);
}

float3 getPixel(float2 coord)
{
    float2 uv = coord / resolution.xy;
    uv = uv * 2.0 - 1.0;
    uv.x *= resolution.x / resolution.y;

    float adv = (sin(time * 0.01) + 1.) * 100.;

    float3 s = float3(0, .6, 0);
    float3 t = float3(0, .6, 1);

    s.z += adv;
    t.z += adv;

    s -= tunnel(s);
    t -= tunnel(t);

    float3 cz = normalize(t - s);
    float3 cx = normalize(cross(float3(0, 1, 0), cz));
    float3 cy = normalize(cross(cz, cx));

    float fov = 1.;
    float3 r = normalize(uv.x * cx + uv.y * cy + cz * fov);

    float3 sky = (float3)0;

    float3 p = s;
    float2 off = float2(0.01, 0.);
    float3 n = (float3)0;
    float dd = 0.;
    float i = 0.;
    for (i = 0.; i < 100.; ++i)
    {
        float d = mapScene(p);
        dd += d;
        if (dd > 1000.)
        {
            sky = starsField(float2(r.x, r.y));
            break;
        }
        if (d < 0.001)
        {
            if (!g_isGhost)
            {
                if (!g_isWater) break;

                n = normalize(mapScene(p) - float3(mapScene(p - off.xyy), mapScene(p - off.yxy), mapScene(p - off.yyx)));
                r = reflect(r, n);
            }
            d = 0.01;
        }
        p += r * d;
    }

    float3 l = normalize(p - g_lpos);

    float falloff = 3.;

    float3 col = (float3)0;
    col = (float3)((dot(l, -n) * .5 + .5) * (1. / (0.01 + dd * falloff)));
    col += pow(g_at * .2, 0.5) * float3(1, 0, 0);
    col += pow(g_at1 * .2, 1.) * float3(0, 153. / 255., 153. / 255.);
    col += pow(g_moonlight * 2., 2.);
    col += pow(g_fire * 0.01, 2.) * float3(1, 0, 0);
    col += sky;

    return col;
}

float hash3(float3 p) {
    float h = dot(p, float3(127.1, 311.7, 527.53));
    return frac(sin(h) * 43758.5453123);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    // Reset per-pixel state
    g_fire = 0.;
    g_moonlight = 0.;
    g_isGhost = true;
    g_isWater = true;
    g_at = 0.;
    g_at1 = 0.;

    float3 col = getPixel(fragCoord);

    col = pow(col, (float3)2.2);
    col = lin2srgb(col);

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_SeaAdventure() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 20, timeOffsetMax: 90, timeAccumulate: true}
}

_Shader_HLSL_Shadetober29Injured() {
    return "
    (
// shadetober #29 (injured) — percentcer (Shadertoy tscSWf)
// CC BY-NC-SA 3.0
// Converted from GLSL to HLSL for Alt-Tabby
// Domain warping FBM based on https://iquilezles.org/articles/warp

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float noise(float3 p) {
    float3 ip = floor(p);
    p -= ip;
    float3 s = float3(7, 157, 113);
    float4 h = float4(0.0, s.yz, s.y + s.z) + dot(ip, s);
    p = p * p * (3.0 - 2.0 * p);
    h = lerp(frac(sin(h) * 43758.5), frac(sin(h + s.x) * 43758.5), p.x);
    h.xy = lerp(h.xz, h.yw, p.y);
    return lerp(h.x, h.y, p.z);
}

float fbm(float2 x, float hurst) {
    float gain = exp2(-hurst);
    float f = 1.0;
    float a = 1.0;
    float t = 0.0;
    [unroll]
    for (int i = 0; i < 4; i++) {
        t += a * noise((f * x).xyy);
        f *= 2.0;
        a *= gain;
    }
    return t;
}

float3 fbms(float2 uv) {
    float h = 1.0;
    float2 t1 = float2(fbm(uv, h), fbm(uv + float2(4.3, -2.1) * sin(time * 0.02), h));
    float2 t2 = float2(fbm(uv + 2.0 * t1 + float2(-1.9, 3.9) * cos(time * 0.07), h),
                        fbm(uv + 2.0 * t1 + float2(2.2, 3.1) * sin(time * 0.05), h));
    float t3 = fbm(uv + 2.0 * t2 + float2(5.6, 1.4) * cos(time * 0.06), h);
    return float3(t3, t3 - 1.0, t3 - 1.0);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = (2.0 * fragCoord - resolution.xy) / resolution.y;
    uv *= 2.0;
    uv += 10.0;
    float3 c = fbms(uv);

    // Darken/desaturate post-processing
    float lum = dot(c, float3(0.299, 0.587, 0.114));
    c = lerp(c, (float3)lum, desaturate);
    c = c * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(c.r, max(c.g, c.b));
    return float4(c * a, a);
}

    )"
}

_Shader_Meta_Shadetober29Injured() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 30, timeOffsetMax: 90, timeAccumulate: true}
}

_Shader_HLSL_SimpleScreensaver() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = fragCoord.xy / resolution.xy;
    uv.y = uv.y * ( resolution.x / resolution.y );
    float tt = 1024.0 * frac( time / 16384.0 );
    float3 c = float3( cos( ( uv.x*uv.y + uv.y + 5.0*tt ) * 3.0 ),
                        cos( ( 3.0*uv.y*uv.x + 7.0*tt ) * 2.0 ),
                        cos( sin(tt)*(1.0-uv.x-uv.y)*3.0 ) );
    float3 color = c * 0.5 + 0.5;

    // Desaturate and darken
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_SimpleScreensaver() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_Simplex3dFbm() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define t (time / 2.0)

float noise3D(float3 p)
{
    return frac(sin(dot(p, float3(12.9898, 78.233, 128.852))) * 43758.5453) * 2.0 - 1.0;
}

float simplex3D(float3 p)
{
    float f3 = 1.0 / 3.0;
    float s = (p.x + p.y + p.z) * f3;
    int i = (int)floor(p.x + s);
    int j = (int)floor(p.y + s);
    int k = (int)floor(p.z + s);

    float g3 = 1.0 / 6.0;
    float tt = (float)(i + j + k) * g3;
    float x0 = (float)i - tt;
    float y0 = (float)j - tt;
    float z0 = (float)k - tt;
    x0 = p.x - x0;
    y0 = p.y - y0;
    z0 = p.z - z0;

    int i1, j1, k1;
    int i2, j2, k2;

    if (x0 >= y0)
    {
        if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
        else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
        else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
    }
    else
    {
        if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
        else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
        else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
    }

    float x1 = x0 - (float)i1 + g3;
    float y1 = y0 - (float)j1 + g3;
    float z1 = z0 - (float)k1 + g3;
    float x2 = x0 - (float)i2 + 2.0 * g3;
    float y2 = y0 - (float)j2 + 2.0 * g3;
    float z2 = z0 - (float)k2 + 2.0 * g3;
    float x3 = x0 - 1.0 + 3.0 * g3;
    float y3 = y0 - 1.0 + 3.0 * g3;
    float z3 = z0 - 1.0 + 3.0 * g3;

    float3 ijk0 = float3(i, j, k);
    float3 ijk1 = float3(i + i1, j + j1, k + k1);
    float3 ijk2 = float3(i + i2, j + j2, k + k2);
    float3 ijk3 = float3(i + 1, j + 1, k + 1);

    float3 gr0 = normalize(float3(noise3D(ijk0), noise3D(ijk0 * 2.01), noise3D(ijk0 * 2.02)));
    float3 gr1 = normalize(float3(noise3D(ijk1), noise3D(ijk1 * 2.01), noise3D(ijk1 * 2.02)));
    float3 gr2 = normalize(float3(noise3D(ijk2), noise3D(ijk2 * 2.01), noise3D(ijk2 * 2.02)));
    float3 gr3 = normalize(float3(noise3D(ijk3), noise3D(ijk3 * 2.01), noise3D(ijk3 * 2.02)));

    float n0 = 0.0;
    float n1 = 0.0;
    float n2 = 0.0;
    float n3 = 0.0;

    float t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
    if (t0 >= 0.0)
    {
        t0 *= t0;
        n0 = t0 * t0 * dot(gr0, float3(x0, y0, z0));
    }
    float t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
    if (t1 >= 0.0)
    {
        t1 *= t1;
        n1 = t1 * t1 * dot(gr1, float3(x1, y1, z1));
    }
    float t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
    if (t2 >= 0.0)
    {
        t2 *= t2;
        n2 = t2 * t2 * dot(gr2, float3(x2, y2, z2));
    }
    float t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
    if (t3 >= 0.0)
    {
        t3 *= t3;
        n3 = t3 * t3 * dot(gr3, float3(x3, y3, z3));
    }
    return 96.0 * (n0 + n1 + n2 + n3);
}

float fbm(float3 p)
{
    float f;
    f  = 0.50000 * simplex3D(p); p = p * 2.01;
    f += 0.25000 * simplex3D(p); p = p * 2.02;
    f += 0.12500 * simplex3D(p); p = p * 2.03;
    f += 0.06250 * simplex3D(p); p = p * 2.04;
    f += 0.03125 * simplex3D(p);
    return f * 0.5 + 0.5;
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord.xy / resolution.xy * 2.0 - 1.0;
    uv.x *= (resolution.x / resolution.y);
    float n = fbm(float3(t, uv * 5.0));

    float3 color = float3(n, n, n);

    // Darken / desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_Simplex3dFbm() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_Singularity() {
    return "
    (
// Singularity by @XorDev — https://www.shadertoy.com/view/3csSWB
// A whirling blackhole.

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Iterator and attenuation (distance-squared)
    float i = .2, a;
    // Resolution for scaling and centering
    float2 r = resolution;
    // Centered ratio-corrected coordinates
    float2 p = (fragCoord + fragCoord - r) / r.y / .7;
    // Diagonal vector for skewing
    float2 d = float2(-1, 1);
    // Blackhole center
    float2 b = p - i * d;
    // Rotate and apply perspective
    float2 dExpr = d / (.1 + i / dot(b, b));
    // GLSL: p * mat2(1, 1, dExpr.x, dExpr.y) → HLSL: mul(float2x2(same args), p)
    float2 c = mul(float2x2(1, 1, dExpr.x, dExpr.y), p);
    // Rotate into spiraling coordinates
    a = dot(c, c);
    float4 cosVal = cos(.5 * log(a) + time * i + float4(0, 33, 11, 0));
    float2 v = mul(float2x2(cosVal.x, cosVal.y, cosVal.z, cosVal.w), c) / i;
    // Waves cumulative total for coloring
    float2 w = (float2)0;

    // Loop through waves
    [unroll]
    for (; i++ < 9.; w += 1. + sin(v))
        // Distort coordinates
        v += .7 * sin(v.yx * i + time) / i + .5;
    // Acretion disk radius
    i = length(sin(v / .3) * .4 + c * (3. + d));
    // Red/blue gradient
    float4 color = 1. - exp(-exp(c.x * float4(.6, -.4, -1, 0))
                          // Wave coloring
                          / w.xyyx
                          // Acretion disk brightness
                          / (2. + i * i / 4. - i)
                          // Center darkness
                          / (.5 + 1. / a)
                          // Rim highlight
                          / (.03 + abs(length(p) - .7)));

    // Apply darken/desaturate
    float3 col = color.rgb;
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_Singularity() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_SmokeFlythrough() {
    return "
    (
// Smoke Flythrough — volumetric smoke tunnel
// https://www.shadertoy.com/view/ms3GDs
// Author: Poisson | License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define NUM_STEPS 256

// aces tonemapping
float3 ACES(float3 x) {
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return (x * (a * x + b)) / (x * (c * x + d) + e);
}

// camera path
float2 camPath(float t) {
    return float2(0.4 * sin(t), 0.4 * cos(t * 0.5));
}

float hash(float n) { return frac(sin(n) * 43758.5453123); }

// procedural 3D hash (replaces volume texture)
float hash3d(float3 p) {
    p = frac(p * float3(443.8975, 397.2973, 491.1871));
    p += dot(p, p.yzx + 19.19);
    return frac((p.x + p.y) * p.z);
}

// 3d value noise (replaces volume texture lookup)
float noise(float3 x) {
    float3 i = floor(x);
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);

    float a = hash3d(i);
    float b = hash3d(i + float3(1, 0, 0));
    float c = hash3d(i + float3(0, 1, 0));
    float d = hash3d(i + float3(1, 1, 0));
    float e = hash3d(i + float3(0, 0, 1));
    float f0 = hash3d(i + float3(1, 0, 1));
    float g = hash3d(i + float3(0, 1, 1));
    float h = hash3d(i + float3(1, 1, 1));

    return lerp(lerp(lerp(a, b, f.x), lerp(c, d, f.x), f.y),
                lerp(lerp(e, f0, f.x), lerp(g, h, f.x), f.y), f.z);
}

// smooth minimum (iq)
float smin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

// volume density
float map(float3 p) {
    float f = 0.0;

    float3 q = p;
    p *= 3.0;
    f += 0.5 * noise(p);
    f += 0.25 * noise(2.0 * p);
    f += 0.0625 * noise(7.0 * p);
    f += 0.03125 * noise(16.0 * p);
    f -= 0.35;

    q.xy -= camPath(q.z);
    f = smin(f, 0.1 - length(q.xy), -0.4);

    return -256.0 * f;
}

// light intensity
float getLight(float h, float k, float3 ce, float3 p) {
    float3 lig = ce - p;
    float llig = length(lig);
    lig = normalize(lig);
    float sha = clamp((h - map(p + lig * k)) / 128.0, 0.0, 1.0);
    float att = 1.0 / (llig * llig);
    return sha * att;
}

// volumetric rendering
float3 render(float3 ro, float3 rd, float2 fragCoord) {
    float tmax = 6.0;
    float s = tmax / float(NUM_STEPS);
    float t = 0.0;
    // dithering
    t += s * hash(fragCoord.x * 8315.9213 / resolution.x + fragCoord.y * 2942.5192 / resolution.y);
    float4 sum = float4(0, 0, 0, 1);

    for (int i = 0; i < NUM_STEPS; i++) {
        float3 p = ro + rd * t;
        float h = map(p);

        if (h > 0.0) {
            float occ = exp(-h * 0.1);

            float k = 0.08;
            float3 col = 3.0 * float3(0.3, 0.6, 1) * getLight(h, k, ro + float3(1, 0, 2), p) * occ
                       + 3.0 * float3(1, 0.2, 0.1) * getLight(h, k, ro + float3(-1, 0, 2.5), p) * occ;

            sum.rgb += h * s * sum.a * col;
            sum.a *= exp(-h * s);
        }

        if (sum.a < 0.01) break;
        t += s;
    }

    return sum.rgb;
}

// camera
float3x3 setCamera(float3 ro, float3 ta) {
    float3 w = normalize(ta - ro);
    float3 u = normalize(cross(w, float3(0, 1, 0)));
    float3 v = cross(u, w);
    return float3x3(u, v, w);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 p = (fragCoord - 0.5 * resolution) / resolution.y;

    float3 ro = float3(0, 0, time);
    float3 ta = ro + float3(0, 0, 1);

    ro.xy += camPath(ro.z);
    ta.xy += camPath(ta.z);

    float3x3 ca = setCamera(ro, ta);
    float3 rd = mul(normalize(float3(p, 1.5)), ca);

    float3 col = render(ro, rd, fragCoord);

    col = ACES(col);
    col = pow(col, float3(0.4545, 0.4545, 0.4545));

    // vignette
    float2 q = fragCoord / resolution;
    col *= pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1);

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_SmokeFlythrough() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_SnowIsFalling() {
    return "
    (
// Snow is Falling - tholzer (Shadertoy 4lfcz4)
// Converted from GLSL to HLSL for Alt-Tabby
// Background: https://www.shadertoy.com/view/4dl3R4
// Snow: https://www.shadertoy.com/view/ldsGDn

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// GLSL-compatible mod (always positive for positive divisor)
float glsl_mod(float x, float y) { return x - y * floor(x / y); }
float2 glsl_mod(float2 x, float y) { return x - y * floor(x / y); }
float3 glsl_mod(float3 x, float y) { return x - y * floor(x / y); }
float2 glsl_mod2(float2 x, float2 y) { return x - y * floor(x / y); }

#define mod289(x) glsl_mod((x), 289.0)

float3 permute(float3 x) { return mod289(((x * 34.0) + 1.0) * x); }

//-----------------------------------------------------
float snoise(float2 v)
{
    const float4 C = float4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    float2 i = floor(v + dot(v, C.yy));
    float2 x0 = v - i + dot(i, C.xx);

    float2 i1;
    i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;

    i = mod289(i); // Avoid truncation effects in permutation
    float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0))
                + i.x + float3(0.0, i1.x, 1.0));

    float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
    m = m * m;
    m = m * m;

    float3 x = 2.0 * frac(p * C.www) - 1.0;
    float3 h = abs(x) - 0.5;
    float3 ox = floor(x + 0.5);
    float3 a0 = x - ox;

    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

    float3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;

    return 130.0 * dot(m, g);
}

//-----------------------------------------------------
float fbm(float2 p)
{
    float f = 0.0;
    float w = 0.5;
    for (int i = 0; i < 5; i++)
    {
        f += w * snoise(p);
        p *= 2.;
        w *= 0.5;
    }
    return f;
}

//-----------------------------------------------------
float background(float2 uv)
{
    // iMouse zeroed (only active on click in Shadertoy)
    uv.x += -1.0;

    float2 sunCenter = float2(0.3, 0.9);
    float suns = clamp(1.2 - distance(uv, sunCenter), 0.0, 1.0);
    float sunsh = smoothstep(0.85, 0.95, suns);

    float slope = 1.0 - smoothstep(0.55, 0.0, 0.8 + uv.x - 2.3 * uv.y);

    float n = abs(fbm(uv * 1.5));
    slope = (n * 0.2) + (slope - ((1.0 - n) * slope * 0.1)) * 0.6;
    slope = clamp(slope, 0.0, 1.0);

    return 0.35 + (slope * (suns + 0.3)) + (sunsh * 0.6);
}

//-----------------------------------------------------

#define LAYERS 66

#define DEPTH1 .3
#define WIDTH1 .4
#define SPEED1 .6

#define DEPTH2 .1
#define WIDTH2 .3
#define SPEED2 .1

float snowing(in float2 uv, in float2 fragCoord)
{
    const float3x3 p = float3x3(13.323122, 23.5112, 21.71123, 21.1212, 28.7312, 11.9312, 21.8112, 14.7212, 61.3934);
    // iMouse zeroed — default snow parameters
    float depth = smoothstep(DEPTH1, DEPTH2, 0.0);
    float width = smoothstep(WIDTH1, WIDTH2, 0.0);
    float speed = smoothstep(SPEED1, SPEED2, 0.0);
    float acc = 0.0;
    float dof = 5.0 * sin(time * 0.1);
    for (int i = 0; i < LAYERS; i++)
    {
        float fi = float(i);
        float2 q = uv * (1.0 + fi * depth);
        float w = width * glsl_mod(fi * 7.238917, 1.0) - width * 0.1 * sin(time * 2. + fi);
        q += float2(q.y * w, speed * time / (1.0 + fi * depth * 0.03));
        float3 n = float3(floor(q), 31.189 + fi);
        float3 m = floor(n) * 0.00001 + frac(n);
        float3 mp = (31415.9 + m) / frac(mul(m, p));
        float3 r = frac(mp);
        float2 s = abs(glsl_mod2(q, (float2)1.0) - 0.5 + 0.9 * r.xy - 0.45);
        s += 0.01 * abs(2.0 * frac(10. * q.yx) - 1.);
        float d = 0.6 * max(s.x - s.y, s.x + s.y) + max(s.x, s.y) - .01;
        float edge = 0.05 + 0.05 * min(.5 * abs(fi - 5. - dof), 1.);
        acc += smoothstep(edge, -edge, d) * (r.x / (1. + .02 * fi * depth));
    }
    return acc;
}

//-----------------------------------------------------
float4 PSMain(PSInput input) : SV_Target {
    // Y-flip: snow falls downward, background has ground orientation
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 uv = fragCoord.xy / resolution.y;

    float bg = background(uv);
    float3 col = float3(bg * 0.9, bg, bg * 1.1);

    float snowOut = snowing(uv, fragCoord);
    col += (float3)snowOut;

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_SnowIsFalling() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_SoftWhisper() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define TIME        (time * 3.0)
#define PI          3.141592654
#define PI_2        (0.5 * PI)
#define TAU         (2.0 * PI)

static const float hf = 0.01;

static const float4 hsv2rgb_K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);

float3 hsv2rgb(float3 c) {
    float3 p = abs(frac(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
    return c.z * lerp(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
}

float3 HSV2RGB(float3 c) {
    return c.z * lerp(hsv2rgb_K.xxx, clamp(abs(frac(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
}

float3 sRGB(float3 t) {
    float3 lo = 12.92 * t;
    float3 hi = 1.055 * pow(t, (float3)(1.0 / 2.4)) - 0.055;
    return lerp(hi, lo, step(t, (float3)0.0031308));
}

float3 aces_approx(float3 v) {
    v = max(v, 0.0);
    v *= 0.6;
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);
}

float tanh_approx(float x) {
    float x2 = x * x;
    return clamp(x * (27.0 + x2) / (27.0 + 9.0 * x2), -1.0, 1.0);
}

float pmin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

float pabs(float a, float k) {
    return -pmin(a, -a, k);
}

float2x2 rot(float a) {
    float s = sin(a);
    float c = cos(a);
    return float2x2(c, s, -s, c);
}

float height(float2 p) {
    float tm = TIME;
    const float xm = 0.5 * 0.005123;
    float ym = lerp(0.125, 0.25, 0.5 - 0.5 * sin(cos(TAU * TIME / 600.0)));

    p *= 0.4;

    float d = length(p);
    float c = 1E6;
    float x = pow(d, 0.1);
    float y = (atan2(p.x, p.y) + 0.05 * tm - 2.0 * d) / TAU;

    for (float i = 0.0; i < 4.0; i += 1.0) {
        float v = length(frac(float2(x - tm * i * xm, frac(y + i * ym) * 0.125) * 16.0) * 2.0 - 1.0);
        c = pmin(c, v, 0.0125);
    }

    float h = (-hf + hf * (pabs(tanh_approx(5.5 * d - 40.0 * c * c * d * d * (0.55 - d)) - 0.25 * d, 0.25)));
    return h;
}

float3 calc_normal(float2 p) {
    float2 e = float2(4.0 / resolution.y, 0.0);

    float3 n;
    n.x = height(p + e.xy) - height(p - e.xy);
    n.y = -2.0 * e.x;
    n.z = height(p + e.yx) - height(p - e.yx);

    return normalize(n);
}

float3 calc_color(float2 p) {
    const float ss = 1.0;
    const float hh = 1.95;

    float3 lp1 = -float3(1.0, hh, -1.0) * float3(ss, 1.0, ss);
    float3 lp2 = -float3(-1.0, hh, -1.0) * float3(ss, 1.0, ss);

    float3 lcol1 = HSV2RGB(float3(0.70, 0.55, 2.0));
    float3 lcol2 = HSV2RGB(float3(0.67, 0.7, 1.0));
    float3 mat_col = HSV2RGB(float3(0.55, 0.5, 0.05));
    const float spe = 7.0;

    float h = height(p);
    float3 n = calc_normal(p);

    float3 ro = float3(0.0, 8.0, 0.0);

    float3 po = float3(p.x, 0.0, p.y);
    float3 rd = normalize(ro - po);

    float3 ld1 = normalize(lp1 - po);
    float3 ld2 = normalize(lp2 - po);

    float diff1 = max(dot(n, ld1), 0.0);
    float diff2 = max(dot(n, ld2), 0.0);

    float3 rn = n;
    float3 ref_vec = reflect(rd, rn);
    float ref1 = max(dot(ref_vec, ld1), 0.0);
    float ref2 = max(dot(ref_vec, ld2), 0.0);

    float dm = tanh_approx(abs(h) * 120.0);
    float rm = dm;
    dm *= dm;

    float3 lpow1 = dm * mat_col * lcol1;
    float3 lpow2 = dm * mat_col * lcol2;

    float3 col = float3(0.0, 0.0, 0.0);
    col += diff1 * diff1 * lpow1;
    col += diff2 * diff2 * lpow2;

    col += rm * pow(ref1, spe) * lcol1;
    col += rm * pow(ref2, spe) * lcol2;

    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 q = fragCoord / resolution.xy;
    float2 p = -1.0 + 2.0 * q;
    p.x *= resolution.x / resolution.y;
    float3 col = calc_color(p);

    col = aces_approx(col);
    col = sRGB(col);

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_SoftWhisper() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_SpaceEye2() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

float hash_f(float n)
{
    return frac(sin(n) * 758.5453) * 2.;
}

float noise(float3 x)
{
    float3 p = floor(x);
    float3 f = frac(x);
    f = f * f * (3.0 - 2.0 * f);
    float n = p.x + p.y * 57.0 + p.z * 800.0;
    float res = lerp(lerp(lerp(hash_f(n + 0.0), hash_f(n + 1.0), f.x), lerp(hash_f(n + 57.0), hash_f(n + 58.0), f.x), f.y),
            lerp(lerp(hash_f(n + 800.0), hash_f(n + 801.0), f.x), lerp(hash_f(n + 857.0), hash_f(n + 858.0), f.x), f.y), f.z);
    return res;
}

float fbm(float3 p)
{
    float f = 0.0;
    f += 0.50000 * noise(p); p = p * 2.02 + 0.15;
    f -= 0.25000 * noise(p); p = p * 2.03 + 0.15;
    f += 0.12500 * noise(p); p = p * 2.01 + 0.15;
    f += 0.06250 * noise(p); p = p * 2.04 + 0.15;
    f -= 0.03125 * noise(p);
    return f;
}

float cloud(float3 p)
{
    p -= fbm(float3(p.x, p.y, 0.0) * 0.5) * 0.7;

    float a = 0.0;
    a -= fbm(p * 3.0) * 2.2 - 1.1;
    if (a < 0.0) a = 0.0;
    a = a * a;
    return a;
}

float2x2 rot(float th) {
    float2 a = sin(float2(1.5707963, 0) + th);
    return float2x2(a.x, -a.y, a.y, a.x);
}

float3 hash33(float3 p)
{
    static const float UIF = 2.3283064365386963e-10; // 1.0 / 0xFFFFFFFF
    static const uint3 UI3 = uint3(1597334673u, 3812015801u, 2798796415u);
    uint3 q = (uint3)((int3)p) * UI3;
    q = (q.x ^ q.y ^ q.z) * UI3;
    return (float3)q * UIF;
}

// 3D Voronoi (IQ)
float voronoi(float3 p) {
    float3 b, r, g = floor(p);
    p = frac(p);
    float d = 1.;
    for (int j = -1; j <= 1; j++)
    {
        for (int i = -1; i <= 1; i++)
        {
            b = float3(i, j, -1);
            r = b - p + hash33(g + b);
            d = min(d, dot(r, r));
            b.z = 0.0;
            r = b - p + hash33(g + b);
            d = min(d, dot(r, r));
            b.z = 1.;
            r = b - p + hash33(g + b);
            d = min(d, dot(r, r));
        }
    }
    return d;
}

// fbm layer
float noiseLayers(float3 p) {
    float3 pp = float3(0., 0., p.z + time * .09);
    float t = 0.;
    float s = 0.;
    float amp = 1.;
    for (int i = 0; i < 5; i++)
    {
        t += voronoi(p + pp) * amp;
        p *= 2.;
        pp *= 1.5;
        s += amp;
        amp *= .5;
    }
    return t / s;
}

float3 n2(float2 fragCoord)
{
    float2 uv = (fragCoord.xy - 0.5 * resolution.xy) / resolution.y;
    float dd = length(uv * uv) * .025;

    float3 rd = float3(uv.x, uv.y, 1.0);

    float rip = 0.5 + sin(length(uv) * 20.0 + time) * 0.5;
    rip = pow(rip * .38, 4.15);
    rd.z = 1.0 + rip * 1.15;
    rd = normalize(rd);
    rd.xy = mul(rot(dd + time * .0125), rd.xy);
    rd *= 2.0;

    float c = noiseLayers(rd * 1.85);
    float oc = c;
    c = max(c + dot(hash33(rd) * 2. - 1., (float3).006), 0.);
    c = pow(c * 1.55, 2.5);
    float3 col = float3(.55, 0.85, .25);
    float3 col2 = float3(1.4, 1.4, 1.4) * 5.0;
    float pulse2 = voronoi(float3(rd.xy * 1.5, time * .255));
    float pulse = pow(oc * 1.35, 4.0);
    col = lerp(col, col2, pulse * pulse2) * c;
    return col;
}

#define PI 3.14159

float vDrop(float2 uv, float t)
{
    uv.y *= 0.25;
    uv.x = uv.x * 128.0;
    float dx = frac(uv.x);
    uv.x = floor(uv.x);
    uv.y *= 0.05;
    float o = sin(uv.x * 215.4);
    float s = cos(uv.x * 33.1) * .3 + .7;
    float trail = lerp(95.0, 35.0, s);
    float yv = frac(uv.y + t * s + o) * trail;
    yv = 1.0 / yv;
    yv = smoothstep(0.0, 1.0, yv * yv);
    yv = sin(yv * PI) * (s * 5.0);
    float d2 = sin(dx * PI);
    return yv * (d2 * d2);
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 position = (fragCoord.xy - 0.5 * resolution.xy) / resolution.y;
    float ss = sin(length(position * 2.2) + time * 0.1) * 3.5;
    ss += 8.0;
    float2 coord = ss * position;

    coord.y *= 1.0 + (sin(time * 0.04 + coord.x * .24) * 0.3);

    coord = mul(rot(ss * 0.04 + time * 0.017), coord);
    coord *= 0.25;
    coord += fbm(sin(float3(coord * 8.0, time * 0.001))) * 0.05;
    coord += time * 0.0171;
    float q = cloud(float3(coord * 1.0, 0.222));
    coord += time * 0.0171;
    q += cloud(float3(coord * 0.6, 0.722));
    coord += time * 0.0171;
    q += cloud(float3(coord * 0.3, .722));
    coord += time * 0.1171;
    q += cloud(float3(coord * 0.1, 0.722));

    float vv1 = sin(time + ss + coord.x) * 0.3;
    float vv2 = sin(time * 0.9 + ss + coord.y) * 0.2;

    float3 col = float3(1.7 - vv2, 1.7, 1.7 + vv1) + q * float3(0.7 + vv1, 0.5, 0.3 + vv2 * 1.15);
    col = pow(col, (float3)2.2) * 0.08;

    float dd = length(col * .48) + vv1;

    float nn = 0.5 + sin(ss * 2.7 + position.x * 2.41 + time * 0.9) * 0.5;

    float3 col2 = n2(fragCoord) * 0.9;

    float2 p = (fragCoord.xy - 0.5 * resolution.xy) / resolution.y;
    float d = length(p);
    p = float2(atan2(p.x, p.y) / PI, 2.5 / d);
    float t = -time * 0.04;
    float drop = vDrop(p, t);
    drop += vDrop(p, t + 0.5);
    drop *= d;

    col2 += (col * .965);

    col = lerp(col, col2, nn);
    col = lerp(col, col * 1.075, drop);

    col += col * ((d + dd) * 0.28);
    col *= d;

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_SpaceEye2() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_SpiralsForWindowsTerminal() {
    return "
    (
// CC0: Spirals for windows terminal
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float PI = 3.141592654;
static const float TAU = 2.0 * PI;

// GLSL mod: x - y * floor(x/y)
float glsl_mod(float x, float y) { return x - y * floor(x / y); }

// Rotation helper: returns float2(cos(a)*v.x - sin(a)*v.y, sin(a)*v.x + cos(a)*v.y)
float2 rot2(float2 v, float a) {
    float c = cos(a);
    float s = sin(a);
    return float2(c * v.x - s * v.y, s * v.x + c * v.y);
}

float3 sRGB(float3 t) {
    return lerp(1.055 * pow(t, (float3)(1.0 / 2.4)) - 0.055, 12.92 * t, step(t, (float3)0.0031308));
}

float3 aces_approx(float3 v) {
    v = max(v, 0.0);
    v *= 0.6;
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);
}

float hash_val(float co) {
    return frac(sin(co * 12.9898) * 13758.5453);
}

float mod1(inout float p, float size) {
    float halfsize = size * 0.5;
    float c = floor((p + halfsize) / size);
    p = glsl_mod(p + halfsize, size) - halfsize;
    return c;
}

float2 rayCylinder(float3 ro, float3 rd, float3 cb, float3 ca, float cr) {
    float3 oc = ro - cb;
    float card = dot(ca, rd);
    float caoc = dot(ca, oc);
    float a = 1.0 - card * card;
    float b = dot(oc, rd) - caoc * card;
    float c = dot(oc, oc) - caoc * caoc - cr * cr;
    float h = b * b - a * c;
    if (h < 0.0) return float2(-1.0, -1.0);
    h = sqrt(h);
    return float2(-b - h, -b + h) / a;
}

float3 skyColor(float3 ro, float3 rd) {
    float3 l = normalize(float3(0.0, 0.0, -1.0));
    float3 baseCol = 0.005 * float3(0.05, 0.33, 1.0);
    return baseCol / (1.00025 + dot(rd, l));
}

float3 color_val(float3 ww, float3 uu, float3 vv, float3 ro, float2 p) {
    float rdd = 2.0;
    float mm = 3.0;
    float rep = 27.0;

    float3 rd = normalize(-p.x * uu + p.y * vv + rdd * ww);

    float3 skyCol = skyColor(ro, rd);

    float2 etc = rayCylinder(ro, rd, ro, float3(0.0, 0.0, 1.0), 1.0);
    float3 etcp = ro + rd * etc.y;
    // rd.yx *= ROT(0.3*etcp.z) — rotate (rd.y, rd.x)
    float2 rd_yx = rot2(float2(rd.y, rd.x), 0.3 * etcp.z);
    rd.y = rd_yx.x;
    rd.x = rd_yx.y;

    float3 col = skyCol;

    float a = atan2(rd.y, rd.x);
    for (float i = 0.0; i < mm; ++i) {
        float ma = a;
        float sz = rep + i * 6.0;
        float slices = TAU / sz;
        float na = mod1(ma, slices);

        float h1 = hash_val(na + 13.0 * i + 123.4);
        float h2 = frac(h1 * 3677.0);
        float h3 = frac(h1 * 8677.0);

        float tr = lerp(0.5, 3.0, h1);
        float2 tc = rayCylinder(ro, rd, ro, float3(0.0, 0.0, 1.0), tr);
        float3 tcp = ro + tc.y * rd;
        float2 tcp2 = float2(tcp.z, atan2(tcp.y, tcp.x));

        float zz = lerp(0.025, 0.05, sqrt(h1)) * rep / sz;
        float tnpy = mod1(tcp2.y, slices);
        float fo = smoothstep(0.5 * slices, 0.25 * slices, abs(tcp2.y));
        tcp2.x += -h2 * time;
        tcp2.y *= tr * PI / 3.0;
        float w = lerp(0.2, 1.0, h2);

        tcp2 /= zz;
        float d = abs(tcp2.y);
        d *= zz;

        float3 bcol = (1.0 + cos(float3(0.0, 1.0, 2.0) + TAU * h3 + 0.5 * h2 * h2 * tcp.z)) * 0.00005;
        bcol /= max(d * d, 5E-7 * tc.y * tc.y);
        bcol *= exp(-0.04 * tc.y * tc.y);
        bcol *= smoothstep(-0.5, 1.0, sin(lerp(0.125, 1.0, h2) * tcp.z));
        bcol *= fo;
        col += bcol;
    }

    return col;
}

float3 effect(float2 p, float2 pp) {
    float tm = time;
    float3 ro = float3(0.0, 0.0, tm);
    float3 dro = normalize(float3(1.0, 0.0, 3.0));
    // dro.xz *= ROT(0.2*sin(0.05*tm))
    float2 dro_xz = rot2(float2(dro.x, dro.z), 0.2 * sin(0.05 * tm));
    dro.x = dro_xz.x;
    dro.z = dro_xz.y;
    // dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)))
    float2 dro_yz = rot2(float2(dro.y, dro.z), 0.2 * sin(0.05 * tm * sqrt(0.5)));
    dro.y = dro_yz.x;
    dro.z = dro_yz.y;
    float3 up = float3(0.0, 1.0, 0.0);
    float3 ww = normalize(dro);
    float3 uu = normalize(cross(up, ww));
    float3 vv = cross(ww, uu);
    float3 col = color_val(ww, uu, vv, ro, p);
    col -= 0.125 * float3(1.0, 2.0, 0.0) * length(pp);
    col = aces_approx(col);
    col = sRGB(col);
    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 q = fragCoord / resolution.xy;
    float2 p = -1.0 + 2.0 * q;
    float2 pp = p;
    p.x *= resolution.x / resolution.y;

    float3 col = effect(p, pp);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness + premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_SpiralsForWindowsTerminal() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 40, timeAccumulate: true}
}

_Shader_HLSL_StarNew() {
    return "
    (
// Star New by nayk
// Ported from https://www.shadertoy.com/view/lcjyDR
// Volumetric starfield with animated ellipse trails and star overlay

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define iterations 17
#define formuparam 0.53
#define volsteps 20
#define stepsize 0.1
#define zoom 0.800
#define tile 0.850
#define brightness_val 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation_val 0.850

// GLSL mod: x - y * floor(x/y)
float3 glsl_mod3(float3 x, float3 y) { return x - y * floor(x / y); }

float3 pal(in float t, in float3 a, in float3 b, in float3 c, in float3 d) {
    return a + b*cos(6.28318*(c*t + d));
}

float h21(float2 a) {
    return frac(sin(dot(a, float2(1., 10.233))) * 40000.5453123);
}

float sdEllipse(in float2 p, in float2 ab) {
    p = abs(p); if (p.x > p.y) { p = p.yx; ab = ab.yx; }
    float l = ab.y*ab.y - ab.x*ab.x;
    float m = ab.x*p.x/l;      float m2 = m*m;
    float n = ab.y*p.y/l;      float n2 = n*n;
    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;
    float q = c3 + m2*n2*2.0;
    float d = c3 + m2*n2;
    float g = m + m*n2;
    float co;
    if (d < 0.0) {
        float h = acos(q/c3)/3.0;
        float s = cos(h);
        float tv = sin(h)*sqrt(3.0);
        float rx = sqrt(-c*(s + tv + 2.0) + m2);
        float ry = sqrt(-c*(s - tv + 2.0) + m2);
        co = (ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;
    } else {
        float h = 2.0*m*n*sqrt(d);
        float s = sign(q + h)*pow(abs(q + h), 1.0/3.0);
        float u = sign(q - h)*pow(abs(q - h), 1.0/3.0);
        float rx = -s - u - c*4.0 + 2.0*m2;
        float ry = (s - u)*sqrt(3.0);
        float rm = sqrt(rx*rx + ry*ry);
        co = (ry/sqrt(rm - rx) + 2.0*g/rm - m)/2.0;
    }
    float2 r = ab * float2(co, sqrt(1.0 - co*co));
    return length(r - p) * sign(p.y - r.y);
}

// Ellipse trail between two points
float ellipse_shape(float2 uv_in, float2 p, float2 q) {
    float quadTest = 0.5 * (sign(q.x - p.x) * sign(q.y - p.y) + 1.);
    float i = 1. - quadTest;
    float2 c = (i == 1.) ? float2(p.x, q.y) : float2(q.x, p.y);
    float x = abs(q.x - p.x), y = abs(q.y - p.y);
    float d = sdEllipse(uv_in - c, float2(x, y));
    return exp(-100. * abs(d));
}

// Volumetric starfield rendering
float4 starfield(float3 from, float3 dir) {
    float s = 0.1, fade = 1.;
    float3 v = (float3)0;
    float c_rot = cos(time*0.02), s_rot = sin(time*0.02);
    [loop]
    for (int r = 0; r < volsteps; r++) {
        float3 p = from + s*dir*.5;
        p = abs((float3)tile - glsl_mod3(p, (float3)(tile*2.)));
        float pa = 0., a = 0.;
        [loop]
        for (int i = 0; i < iterations; i++) {
            p = abs(p)/dot(p, p) - (float3)formuparam;
            p.xy = mul(float2x2(c_rot, s_rot, -s_rot, c_rot), p.xy);
            a += abs(length(p) - pa);
            pa = length(p);
        }
        float dm = max(0., darkmatter - a*a*.001);
        a *= a*a;
        if (r > 6) fade *= 1. - dm;
        v += (float3)fade;
        v += float3(s, s*s, s*s*s*s)*a*brightness_val*fade;
        fade *= distfading;
        s += stepsize;
    }
    v = lerp((float3)length(v), v, saturation_val);
    return float4(v*.01, 1.);
}

float happy_star(float2 uv_in, float anim) {
    uv_in = abs(uv_in);
    float2 pos = min(uv_in.xy/uv_in.yx, (float2)anim);
    float p = (2.0 - pos.x - pos.y);
    return (2.0 + p*(p*p - 1.5)) / (uv_in.x + uv_in.y);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = fragCoord.xy/resolution.xy - .5;
    uv.y *= resolution.y/resolution.x;
    float3 dir = float3(uv*zoom, 1.);

    uv *= 1.1 + 0.15 * cos(uv.y - 0.6 * time);
    uv.y += 0.02 * cos(time);

    float t_anim = 10. * time + 8. * h21(uv) + 15. * exp(-0.01 * length(uv)) * (650. + time);
    int f = int(floor(t_anim));

    float s_acc = 0.;
    float2 pp = (float2)0;

    float3 e = (float3)1;
    float3 col = (float3)0;

    float n = 20.;
    [loop]
    for (float i = 0.; i <= n; i++) {
        float f2 = 0.0001 * float(f);
        float f3 = 0.0001 * float(f + 1);

        float2 qp = pp;

        pp = float2(h21((float2)f2), h21((float2)(0.01 + f2)));
        pp = pow(4. * pp * (1. - pp), (float2)4);

        float2 pp2 = float2(h21((float2)f3), h21((float2)(0.01 + f3)));
        float fr = frac(t_anim);
        fr = smoothstep(0., 1., fr);
        pp = lerp(pp, pp2, fr);
        pp = 0.3 * (pp - 0.5);
        f++;

        float s2 = 0.;
        if (i > 0.) s2 = ellipse_shape(uv, pp, qp);
        s_acc = clamp(s_acc + s2, 0., 1.);
        float3 col2 = pal(i/n, e, e, e, (i/n) * float3(0, 1, 2)/3.);
        col = lerp(col, col2, s2);
    }

    col += 0.03;
    col += 0.35 * exp(-3. * length(uv));

    float3 from = float3(1., .5, 0.5);
    float4 fragColor = starfield(from, dir);
    fragColor *= float4(col*3., 1.);

    uv *= 2.0 * (cos(time * 2.0) - 2.5);
    float anim = sin(time * 12.0) * 0.1 + 1.0;
    fragColor += float4(happy_star(uv, anim) * float3(0.35, 0.2, 0.55)*0.1, 1.0);

    float3 color = fragColor.rgb;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, (float3)lum, desaturate);
    color *= 1.0 - darken;

    // Alpha from brightness, premultiply
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_StarNew() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_StarShine() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define SIZE 3.8
#define RADIUS 0.15
#define INNER_FADE 0.08
#define OUTER_FADE 0.02
#define SPEED 0.21
#define BORDER 0.21

#define iterations 17
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom_val 0.800
#define tile_val 0.850
#define speed_val 0.010

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation_val 0.850

// GLSL mod: x - y * floor(x/y) (always positive for positive y)
float glsl_mod(float x, float y) { return x - y * floor(x / y); }
float2 glsl_mod2(float2 x, float2 y) { return x - y * floor(x / y); }
float3 glsl_mod3(float3 x, float3 y) { return x - y * floor(x / y); }

float random_val(in float2 p) {
    float3 p3 = frac(float3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

float noise_val(in float2 _st) {
    float2 i = floor(_st);
    float2 f = frac(_st);

    float a = random_val(i);
    float b = random_val(i + float2(1.0, 0.0));
    float c = random_val(i + float2(0.0, 1.0));
    float d = random_val(i + float2(1.0, 1.0));

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(a, b, u.x) +
            (c - a) * u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

float light_val(in float2 pos, in float size, in float radius, in float inner_fade, in float outer_fade) {
    float len = length(pos / size);
    return pow(clamp((1.0 - pow(clamp(len - radius, 0.0, 1.0), 1.0 / inner_fade)), 0.0, 1.0), 1.0 / outer_fade);
}

float flare(in float angle, in float alpha, in float t_val) {
    float t = t_val;
    float n = noise_val(float2(t + 0.5 + abs(angle) + pow(alpha, 0.6), t - abs(angle) + pow(alpha + 0.1, 0.6)) * 7.0);

    float split_val = (15.0 + sin(t * 2.0 + n * 4.0 + angle * 20.0 + alpha * 1.0 * n) * (0.3 + 0.5 + alpha * 0.6 * n));

    float rotate = sin(angle * 20.0 + sin(angle * 15.0 + alpha * 4.0 + t * 30.0 + n * 5.0 + alpha * 4.0)) * (0.5 + alpha * 1.5);

    float g = pow((2.0 + sin(split_val + n * 1.5 * alpha + rotate) * 1.4) * n * 4.0, n * (1.5 - 0.8 * alpha));

    g *= alpha * alpha * alpha * 0.5;
    g += alpha * 0.7 + g * g * g;
    return g;
}

float2 project_val(float2 position, float2 a, float2 b) {
    float2 q = b - a;
    float u = dot(position - a, q) / dot(q, q);
    u = clamp(u, 0.0, 1.0);
    return lerp(a, b, u);
}

float segment_val(float2 position, float2 a, float2 b) {
    return distance(position, project_val(position, a, b));
}

float contour(float x) {
    return 1.0 - clamp(x * 2048.0, 0.0, 1.0);
}

float line_val(float2 p, float2 a, float2 b) {
    return contour(segment_val(p, a, b));
}

float2 neighbor_offset(float i) {
    float c = abs(i - 2.0);
    float s = abs(i - 4.0);
    return float2(c > 1.0 ? (c > 2.0 ? 1.0 : 0.0) : -1.0, s > 1.0 ? (s > 2.0 ? -1.0 : 0.0) : 1.0);
}

float happy_star(float2 uv, float anim) {
    uv = abs(uv);
    float2 pos = min(uv.xy / uv.yx, (float2)anim);
    float p = (2.0 - pos.x - pos.y);
    return (2.0 + p * (p * p - 1.5)) / (uv.x + uv.y);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord.xy - resolution.xy * 0.5) / resolution.y;
    float f = 0.0;
    float f2 = 0.0;

    float3 dir = float3(uv * zoom_val, 1.0);

    float3 from_val = float3(1.0, 0.5, 0.5);

    // Volumetric rendering
    float s2 = 0.1, fade = 1.0;
    float3 v = (float3)0.0;
    for (int r = 0; r < volsteps; r++) {
        float3 p = from_val + s2 * dir * 0.5;
        p = abs((float3)tile_val - glsl_mod3(p, (float3)(tile_val * 2.0)));
        float pa, a;
        pa = 0.0;
        a = 0.0;
        float cos_t = cos(time * 0.05);
        float sin_t = sin(time * 0.05);
        for (int i = 0; i < iterations; i++) {
            p = abs(p) / dot(p, p) - formuparam;
            // mat2 rotation expanded
            float2 rotated = float2(
                p.x * cos_t + p.y * sin_t,
                p.x * (-sin_t) + p.y * cos_t);
            p.x = rotated.x;
            p.y = rotated.y;
            a += abs(length(p) - pa);
            pa = length(p);
        }
        float dm = max(0.0, darkmatter - a * a * 0.001);
        a *= a * a;
        if (r > 6) fade *= 1.0 - dm;

        v += fade;
        v += float3(s2, s2 * s2, s2 * s2 * s2 * s2) * a * brightness * fade;
        fade *= distfading;
        s2 += stepsize;
    }
    v = lerp((float3)length(v), v, saturation_val);
    uv *= 0.5;

    float4 result = float4(0.0, 0.0, 0.0, 1.0);

    float t2 = abs(sin(time * 0.1));
    float c = cos(t2);
    float s = sin(t2);
    // mat2 rm = (c, s, -s, c)
    float2 position = float2(0.0, 0.0);
    for (float i = 0.0; i < 256.0; i++) {
        float2 rm_pos = float2(
            position.x * c + position.y * s,
            position.x * (-s) + position.y * c);
        float2 sample2 = neighbor_offset(glsl_mod(i, 8.0)) / resolution.y + rm_pos;
        result += line_val(uv, position, sample2);
        position = sample2;
    }

    float t = time * SPEED;
    float alpha = light_val(uv, SIZE, RADIUS, INNER_FADE, OUTER_FADE);
    float angle = atan2(uv.x, uv.y);
    float n = noise_val(float2(uv.x * 10.0 + time, uv.y * 20.0 + time));

    float l = length(uv * v.xy * 0.01);
    if (l < BORDER) {
        t *= 0.8;
        alpha = (1.0 - pow(((BORDER - l) / BORDER), 0.22) * 0.7);
        alpha = clamp(alpha - light_val(uv, 0.02, 0.0, 0.3, 0.7) * 0.55, 0.0, 1.0);
        f = flare(angle * 1.0, alpha, -t * 0.5 + alpha);
        f2 = flare(angle * 1.0, alpha * 1.2, ((-t + alpha * 0.5 + 0.38134)));
    }
    f = flare(angle, alpha, t) * 1.3;

    float4 fragColor = float4(float3(f * (1.0 + sin(angle - t * 4.0) * 0.3) + f2 * f2 * f2, f * alpha + f2 * f2 * 2.0, f * alpha * 0.5 + f2 * (1.0 + sin(angle + t * 4.0) * 0.3)), 1.0);

    uv *= 2.0 * (cos(time * 2.0) - 2.5);
    float anim = sin(time * 12.0) * 0.1 + 1.0;
    fragColor *= float4(happy_star(uv, anim) * float3(0.55, 0.5, 1.15), 1.0);
    fragColor += float4(happy_star(uv, anim) * float3(0.55, 0.5, 1.15) * 0.01, 1.0);

    // Alpha from brightness + premultiply
    float3 color = fragColor.rgb;
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);
    float a_val = max(color.r, max(color.g, color.b));
    return float4(color * a_val, a_val);
}

    )"
}

_Shader_Meta_StarShine() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_StarfieldScreensaver() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float speed = 1.5;
    int starCount = 600;
    float starSize = 0.0015;
    float minZ = 0.3;

    float2 uv = (2.0 * fragCoord - resolution) / resolution.y;

    float3 color = (float3)0.0;

    for (int i = 0; i < starCount; i++) {
        float seed = float(i) * 0.01337;

        float2 starXY = float2(
            frac(sin(seed * 734.631) * 5623.541) * 2.0 - 1.0,
            frac(cos(seed * 423.891) * 3245.721) * 2.0 - 1.0);

        float z = fmod(time * speed * -0.2 + seed, 1.0) + minZ * 0.1;

        float size = starSize / z;
        float brightness = 0.7 / z;

        float2 starUV = uv - starXY * (0.5 / z);
        float star = smoothstep(size, 0.0, length(starUV));

        color += (float3)(star * brightness);
    }

    color = min(color, (float3)1.0);
    color *= 0.9 + 0.1 * sin(fragCoord.y * 3.14159 * 2.0); // scanlines

    // Post-processing: darken/desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_StarfieldScreensaver() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_StarfieldSimV2() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// divisions of grid
static const float repeats = 30.0;

// number of layers
static const float layers = 21.0;

// star colours
static const float3 blue_c = float3(51.0, 64.0, 195.0) / 255.0;
static const float3 cyan_c = float3(117.0, 250.0, 254.0) / 255.0;
static const float3 white_c = float3(255.0, 255.0, 255.0) / 255.0;
static const float3 yellow_c = float3(251.0, 245.0, 44.0) / 255.0;
static const float3 red_c = float3(247.0, 2.0, 20.0) / 255.0;

// spectrum function
float3 spectrum(float2 pos) {
    pos.x *= 4.0;
    float3 outCol = (float3)0;
    if (pos.x > 0.0) {
        outCol = lerp(blue_c, cyan_c, frac(pos.x));
    }
    if (pos.x > 1.0) {
        outCol = lerp(cyan_c, white_c, frac(pos.x));
    }
    if (pos.x > 2.0) {
        outCol = lerp(white_c, yellow_c, frac(pos.x));
    }
    if (pos.x > 3.0) {
        outCol = lerp(yellow_c, red_c, frac(pos.x));
    }

    return 1.0 - (pos.y * (1.0 - outCol));
}

float N21(float2 p) {
    p = frac(p * float2(233.34, 851.73));
    p += dot(p, p + 23.45);
    return frac(p.x * p.y);
}

float2 N22(float2 p) {
    float n = N21(p);
    return float2(n, N21(p + n));
}

float2x2 scale2(float2 _scale) {
    return float2x2(_scale.x, 0.0,
                    0.0, _scale.y);
}

// 2D Noise based on Morgan McGuire @morgan3d
float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);

    // Four corners in 2D of a tile
    float a = N21(i);
    float b = N21(i + float2(1.0, 0.0));
    float c = N21(i + float2(0.0, 1.0));
    float d = N21(i + float2(1.0, 1.0));

    // Cubic Hermite Curve
    float2 u = f * f * (3.0 - 2.0 * f);

    // Mix 4 corners percentages
    return lerp(a, b, u.x) +
            (c - a) * u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

float perlin2(float2 uv, int octaves, float pscale) {
    float col = 1.0;
    float initScale = 4.0;
    for (int l = 0; l < octaves; l++) {
        float val = noise(uv * initScale);
        if (col <= 0.01) {
            col = 0.0;
            break;
        }
        val -= 0.01;
        val *= 0.5;
        col *= val;
        initScale *= pscale;
    }
    return col;
}

float3 stars(float2 uv, float offset) {

    float timeScale = -(time + offset) / layers;

    float trans = frac(timeScale);

    float newRnd = floor(timeScale);

    float3 col = (float3)0;

    // translate uv then scale for center
    uv -= float2(0.5, 0.5);
    uv = mul(scale2(float2(trans, trans)), uv);
    uv += float2(0.5, 0.5);

    // create square aspect ratio
    uv.x *= resolution.x / resolution.y;

    // add nebula colours
    float colR = N21(float2(offset + newRnd, offset + newRnd));
    float colB = N21(float2(offset + newRnd * 123.0, offset + newRnd * 123.0));

    // generate perlin noise nebula on every third layer
    if (fmod(offset, 3.0) == 0.0) {
        float perl = perlin2(uv + offset + newRnd, 3, 2.0);
        col += float3(perl * colR, perl * 0.1, perl * colB);
    }

    // create boxes
    uv *= repeats;

    // get position
    float2 ipos = floor(uv);

    // return uv as 0 to 1
    uv = frac(uv);

    // calculate random xy and size
    float2 rndXY = N22(newRnd + ipos * (offset + 1.0)) * 0.9 + 0.05;
    float rndSize = N21(ipos) * 100.0 + 200.0;

    float2 j = (rndXY - uv) * rndSize;
    float sparkle = 1.0 / dot(j, j);

    col += spectrum(frac(rndXY * newRnd * ipos)) * float3(sparkle, sparkle, sparkle);

    col *= smoothstep(1.0, 0.8, trans);
    col *= smoothstep(0.0, 0.1, trans);
    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Normalized pixel coordinates (from 0 to 1)
    float2 uv = fragCoord / resolution;

    float3 color = (float3)0;

    for (float i = 0.0; i < layers; i++) {
        color += stars(uv, i);
    }

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_StarfieldSimV2() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_StarfieldWithFbm() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

#define iterations 17
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom   0.800
#define tile   0.850
#define speed  0.000

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation 0.850

float3 glsl_mod(float3 a, float3 b) {
    return a - b * floor(a / b);
}

float2 hash(float2 p)
{
    p = float2(dot(p, float2(127.1, 311.7)),
               dot(p, float2(175., 100.)));
    return -1.0 + 2.0 * frac(sin(p) * 45000.0);
}

float noise(float2 p)
{
    const float K1 = 0.36;
    const float K2 = 0.22;

    float2 i = floor(p + (p.x + p.y) * K1);

    float2 a = p - i + (i.x + i.y) * K2;
    float2 o = (a.x > a.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float2 b = a - o + K2;
    float2 c = a - 1.0 + 2.0 * K2;

    float3 h = max(0.5 - float3(dot(a, a), dot(b, b), dot(c, c)), 0.0);

    float3 n = h * h * h * h * float3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));

    return dot(n, (float3)70.0);
}

float fbm(float2 uv)
{
    float f;
    float2x2 m = float2x2(1.6, -1.2, 1.2, 1.6);
    f  = 0.5000 * noise(uv); uv = mul(m, uv);
    f += 0.2500 * noise(uv); uv = mul(m, uv);
    f += 0.1250 * noise(uv); uv = mul(m, uv);
    f += 0.0625 * noise(uv); uv = mul(m, uv);
    f = 0.5 + 0.5 * f;

    return f;
}

float field2(float3 p, float s) {
    float strength = 7. + .03 * log(1.e-6 + frac(sin(time * 10.) * 4500.0));
    float accum = s * 3.;
    float prev = 0.;
    float tw = 0.;
    for (int i = 0; i < 12; ++i) {
        float mag = dot(p, p) * s;
        p = abs(p) / mag + float3(-.9, -1.0, -1.);
        float w = exp(-(float)i / 9.);
        accum += w * exp(-strength * pow(abs(mag - prev), 2.2));
        tw += w;
        prev = mag;
    }
    return max(0., 5. * accum / tw - .8);
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // get coords and direction
    float2 uv = fragCoord.xy / resolution.xy - 0.5;
    uv.y *= resolution.y / resolution.x;
    float3 dir = float3(uv * zoom, 1.);

    float3 from = float3(1., .5, 0.5);

    float2 pos = (fragCoord.xy / resolution.xy) * 2.0 - 1.0;
    pos.x *= resolution.x / resolution.y;

    float2 pos2 = pos;
    pos2.y -= time * .10;
    float4 o = (float4)0;
    float2 F = fragCoord;

    float s = fbm(pos2);

    float f = field2(float3(pos, 1.0), s / 1.275);
    float2 R = resolution.xy;

    float d, t_loop, loop_i;
    t_loop = time * .01;
    [loop]
    for (loop_i = 0.; loop_i > -1.; loop_i -= .06)
    {
        d = frac(loop_i - 3. * t_loop);
        float4 c = float4((F - R * .5) / R.y * d, loop_i, 0) * 28.;
        for (int j = 0; j < 27; j++)
            c.xzyw = abs(c / dot(c, c)
                    - float4(7. - .2 * sin(t_loop), 6.3, .7, 1. - cos(t_loop / .8)) / 7.);
        o -= c * c.yzww * d * (d - 1.0) / float4(1, 4, 1, 1);
    }

    float3 color = float3(f * 0.1, f * f * 0.2, f * f * f * 0.79 + -0.3);

    // volumetric rendering
    float s2 = 0.1, fade = 1.;
    float3 v = (float3)0.;
    for (int r = 0; r < volsteps; r++) {
        float3 p = from + s * dir * .5 + o.xyz;
        p = abs((float3)tile - glsl_mod(p, (float3)(tile * 2.))) + o.xyz;
        float pa = 0., a = 0.;
        for (int k = 0; k < iterations; k++) {
            p = abs(p) / dot(p, p) - formuparam;
            float ct = cos(time * 0.05);
            float sn = sin(time * 0.05);
            p.xy = mul(float2x2(ct, -sn, sn, ct), p.xy);
            a += abs(length(p) - pa);
            pa = length(p);
        }
        float dm = max(0., darkmatter - a * a * .001);
        a *= a * a;
        if (r > 6) fade *= 1.2 - dm * f;
        v += fade;
        v += float3(s, s * f * s, s * s * s * s) * a * brightness * fade;
        fade *= distfading;
        s += stepsize;
    }
    v = lerp((float3)length(v), v, saturation);
    float3 col = v * .01 * f;

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_StarfieldWithFbm() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_Starleidoscope() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define NUM_LAYERS 10.

float2x2 Rot(float a) {
    float c = cos(a), s = sin(a);
    return float2x2(c, -s, s, c);
}

float Star(float2 uv, float flare) {
    float d = length(uv);
    float m = 0.02 / d;

    float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));
    m += rays * flare;
    uv = mul(uv, Rot(3.1415 / 4.0));
    rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));
    m += rays * 0.3 * flare;

    m *= smoothstep(1.0, 0.2, d);

    return m;
}

float Hash21(float2 p) {
    p = frac(p * float2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return frac(p.x * p.y);
}

float3 StarLayer(float2 uv) {
    float3 col = (float3)0;

    float2 gv = frac(uv) - 0.5;
    float2 id = floor(uv);

    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            float2 offs = float2(x, y);

            float n = Hash21(id + offs);
            float size = frac(n * 345.32);

            float2 p = float2(n, frac(n * 34.0));

            float star = Star(gv - offs - p + 0.5, smoothstep(0.8, 1.0, size) * 0.6);

            // Replace audio-reactive hue shift with time-based variation
            float2 audioReplace = float2(sin(time * 0.3) * 0.5 + 0.5, cos(time * 0.2) * 0.5 + 0.5);
            float3 hueShift = frac(n * 2345.2 + dot(uv / 420.0, audioReplace)) * float3(0.2, 0.3, 0.9) * 123.2;

            float3 color = sin(hueShift) * 0.5 + 0.5;
            color = color * float3(1.0, 0.25, 1.0 + size);

            star *= sin(time * 3.0 + n * 6.2831) * 0.4 + 1.0;
            col += star * size * color;
        }
    }

    return col;
}

float2 N(float angle) {
    return float2(sin(angle), cos(angle));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 uv = (fragCoord - 0.5 * resolution.xy) / resolution.y;
    float t = time * 0.01;

    uv.x = abs(uv.x);
    uv.y += tan((5.0 / 6.0) * 3.1415) * 0.5;

    float2 n = N((5.0 / 6.0) * 3.1415);
    float d = dot(uv - float2(0.5, 0.0), n);
    uv -= n * max(0.0, d) * 2.0;

    n = N((2.0 / 3.0) * 3.1415);
    uv.x += 1.5 / 1.25;
    for (int i = 0; i < 5; i++) {
        uv *= 1.25;
        uv.x -= 1.5;

        uv.x = abs(uv.x);
        uv.x -= 0.5;
        uv -= n * min(0.0, dot(uv, n)) * 2.0;
    }

    uv = mul(uv, Rot(t));
    float3 col = (float3)0;

    for (float li = 0.0; li < 1.0; li += 1.0 / NUM_LAYERS) {
        float depth = frac(li + t);
        float sc = lerp(20.0, 0.5, depth);
        float fade = depth * smoothstep(1.0, 0.9, depth);
        col += StarLayer(uv * sc + li * 453.2) * fade;
    }

    // Post-processing: darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_Starleidoscope() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_Starship() {
    return "
    (
// Starship by @XorDev — https://www.shadertoy.com/view/l3cfW4
// Inspired by the debris from SpaceX's 7th Starship test.

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float2 r = resolution;
    // Center, rotate and scale
    float2 v = (fragCoord + fragCoord - r) / r.y;
    float2 p = mul(v, float2x2(3, 4, 4, -3)) / 1e2;

    // Sum of colors, RGB color shift and wave
    float4 S = (float4)0;
    float4 C = float4(1, 2, 3, 0);
    float4 W;

    float t = time;
    float T = 0.1 * t + p.y;

    // Iterate through 50 particles
    for (float i = 1.0; i <= 50.0; i += 1.0) {
        // Body: shift position for each particle
        p += 0.02 * cos(i * (C.xz + 8.0 + i) + T + T);

        // Increment: accumulate color
        W = sin(i) * C;
        float noiseVal = iChannel0.Sample(samp0, p / exp(W.x) + float2(i, t) / 8.0).r;
        S += (cos(W) + 1.0)
            * exp(sin(i + i * T))
            / length(max(p, p / float2(2.0, noiseVal * 40.0)))
            / 1e4;
    }

    // Sky background and tanh tonemap
    C -= 1.0;
    float4 O = tanh(p.x * C + S * S);

    float3 color = O.rgb;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_Starship() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "starship_i0.png"}], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_SunSurface() {
    return "
    (
// Sun Surface — converted from Shadertoy XlSSzK by Duke
// Based on Shanes' Fiery Spikeball
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define DITHERING

static const float pi = 3.14159265;

// IQ's noise
float pn(float3 p)
{
    float3 ip = floor(p);
    p = frac(p);
    p *= p * (3.0 - 2.0 * p);
    float2 uv = (ip.xy + float2(37.0, 17.0) * ip.z) + p.xy;
    float2 s = iChannel0.SampleLevel(samp0, (uv + 0.5) / 256.0, 0.0).yx;
    return lerp(s.x, s.y, p.z);
}

// FBM
float fpn(float3 p) {
    return pn(p * 0.06125) * 0.57 + pn(p * 0.125) * 0.28 + pn(p * 0.25) * 0.15;
}

float rand2d(float2 co) {
    return frac(sin(dot(co * 0.123, float2(12.9898, 78.233))) * 43758.5453);
}

float cosNoise(float2 p)
{
    return 0.5 * (sin(p.x) + sin(p.y));
}

// mat2 m2 = mat2(1.6,-1.2, 1.2,1.6) applied as multiply
float2 mulM2(float2 v) {
    return float2(1.6 * v.x - 1.2 * v.y, 1.2 * v.x + 1.6 * v.y);
}

float sdTorus(float3 p, float2 t)
{
    return length(float2(length(p.xz) - t.x * 1.2, p.y)) - t.y;
}

float smin(float a, float b, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return lerp(b, a, h) - k * h * (1.0 - h);
}

float SunSurface(float3 pos)
{
    float h = 0.0;
    float2 q = pos.xz * 0.5;

    float s = 0.5;

    for (int i = 0; i < 6; i++)
    {
        h += s * cosNoise(q);
        q = mulM2(q) * 0.85;
        q += float2(2.41, 8.13);
        s *= 0.48 + 0.2 * h;
    }
    h *= 2.0;

    float d1 = pos.y - h;

    // rings — GLSL mod(a,b) = a - b*floor(a/b)
    float3 modArg = 2.3 + pos + 1.0;
    float3 r1 = modArg - 10.0 * floor(modArg / 10.0) - 5.0;
    r1.y = pos.y - 0.1 - 0.7 * h + 0.5 * sin(3.0 * time + pos.x + 3.0 * pos.z);
    float c = cos(pos.x);
    float s1 = 1.0;
    float2 rxz = float2(c * r1.x + s1 * r1.z, c * r1.z - s1 * r1.x);
    r1.x = rxz.x;
    r1.z = rxz.y;
    float d2 = sdTorus(r1.xzy, float2(clamp(abs(pos.x / pos.z), 0.7, 2.5), 0.20));

    return smin(d1, d2, 1.0);
}

float map(float3 p) {
    p.z += 1.0;
    // R(p.yz, -25.5)
    float a1 = -25.5;
    float c1 = cos(a1); float s1 = sin(a1);
    float2 pyz = c1 * p.yz + s1 * float2(p.z, -p.y);
    p.y = pyz.x; p.z = pyz.y;
    // R(p.xz, time*0.1) — iMouse zeroed, just time rotation
    float a2 = time * 0.1;
    float c2 = cos(a2); float s2 = sin(a2);
    float2 pxz = c2 * p.xz + s2 * float2(p.z, -p.x);
    p.x = pxz.x; p.z = pxz.y;
    return SunSurface(p) + fpn(p * 50.0 + time * 25.0) * 0.45;
}

// Fire palette from Combustible Voronoi
float3 firePalette(float i) {
    float T = 1400.0 + 1300.0 * i;
    float3 L = float3(7.4, 5.6, 4.4);
    L = pow(L, (float3)5.0) * (exp(1.43876719683e5 / (T * L)) - 1.0);
    return 1.0 - exp(-5e8 / L);
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float3 rd = normalize(float3((fragCoord - 0.5 * resolution) / resolution.y, 1.0));
    float3 ro = float3(0.0, 0.0, -22.0);

    float ld = 0.0, td = 0.0, w = 0.0;
    float d = 1.0, t = 1.0;

    const float h = 0.1;
    float3 tc = (float3)0.0;

#ifdef DITHERING
    float2 pos2 = fragCoord / resolution;
    float2 seed = pos2 + frac(time);
#endif

    [loop]
    for (int i = 0; i < 56; i++) {
        if (td > (1.0 - 1.0 / 80.0) || d < 0.001 * t || t > 40.0) break;

        d = map(ro + t * rd);

        ld = (h - d) * step(d, h);
        w = (1.0 - td) * ld;

        tc += w * w + 1.0 / 50.0;
        td += w + 1.0 / 200.0;

#ifdef DITHERING
        d = abs(d) * (0.8 + 0.28 * rand2d(seed * float2((float)i, (float)i)));
        d = max(d, 0.04);
#else
        d = max(d, 0.04);
#endif

        t += d * 0.5;
    }

    tc = firePalette(tc.x);

    float3 color = tc;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_SunSurface() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "sun_surface_i0.png"}], timeOffsetMin: 5, timeOffsetMax: 30, timeAccumulate: true}
}

_Shader_HLSL_Surveillance() {
    return "
    (
// Surveillance — Virgill
// https://www.shadertoy.com/view/ltV3Rz
// License: CC BY-NC-SA 3.0
// Dusty menger scene with circle-of-confusion depth of field

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static float2 g_fragCoord;

// Circle of confusion idea by eiffie
// More interesting menger by shane
static float focalDistance = 20.0;
static const float aperature = 0.04;
static const float fudgeFactor = 0.9;
static const float shadowCone = 0.5;
static float4 orbitTrap = (float4)0;
static float3 pcoc = (float3)0;
static float rCoC_g;
static float h_g;
static float4 col = (float4)0;
static float pixelSize;

float CircleOfConfusion(float t) {
    return max(abs(focalDistance - t) * aperature, pixelSize * (1.0 + t));
}

float linstep(float a, float b, float t) {
    float v = (t - a) / (b - a);
    return clamp(v, 0.0, 1.0);
}

float3 rotXaxis(float3 p, float rad) {
    float z2 = cos(rad) * p.z - sin(rad) * p.y;
    float y2 = sin(rad) * p.z + cos(rad) * p.y;
    p.z = z2;
    p.y = y2;
    return p;
}

float3 rotYaxis(float3 p, float rad) {
    float x2 = cos(rad) * p.x - sin(rad) * p.z;
    float z2 = sin(rad) * p.x + cos(rad) * p.z;
    p.x = x2;
    p.z = z2;
    return p;
}

float3 rotZaxis(float3 p, float rad) {
    float x2 = cos(rad) * p.x - sin(rad) * p.y;
    float y2 = sin(rad) * p.x + cos(rad) * p.y;
    p.x = x2;
    p.y = y2;
    return p;
}

float rand1(float2 co) {
    return frac(sin(dot(co, float2(12.9898, 78.233))) * 43758.5453);
}

// New and interesting menger formula (shane)
float NewMenger(float3 q) {
    float3 p = abs(frac(q / 3.0) * 3.0 - 1.5);
    float d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.0 + 0.05;
    p = abs(frac(q) - 0.5);
    d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.0 / 3.0 + 0.05);
    p = abs(frac(q * 2.0) * 0.5 - 0.25);
    d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 0.5 / 3.0 - 0.015);
    p = abs(frac(q * 3.0 / 0.5) * 0.5 / 3.0 - 0.5 / 6.0);
    return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.0 / 18.0 - 0.015);
}

float map(float3 p) {
    orbitTrap = float4(length(p) - 0.8 * p.z, length(p) - 0.8 * p.y, length(p) - 0.8 * p.x, 0.0);
    return NewMenger(p);
}

static const float ShadowContrast = 0.99;

float FuzzyShadow(float3 ro, float3 rd, float coneGrad, float rCoCp) {
    float t = rCoCp * 2.0, s = 1.0;
    for (int i = 0; i < 9; i++) {
        if (s < 0.1) continue;
        float r = rCoCp + t * coneGrad + 0.05;
        float d = map(ro + rd * t) + r * 0.6;
        s *= linstep(-r, r, d);
        t += abs(d) * (0.8 + 0.2 * rand1(g_fragCoord * (float)i));
    }
    return clamp(s * ShadowContrast + (1.0 - ShadowContrast), 0.0, 1.0);
}

static const float Cycles = 4.0;

float3 cycle_color(float3 c, float s) {
    return (float3)0.5 + 0.5 * float3(cos(s * Cycles + c.x), cos(s * Cycles + c.y), cos(s * Cycles + c.z));
}

static const float3 BaseColor = float3(0.2, 0.2, 0.2);
static const float3 OrbitStrength = float3(0.8, 0.8, 0.8);
static const float4 Xot = float4(0.6, 0.5, 0.6, 0.2);
static const float4 Yot = float4(1.0, 0.5, 0.1, 0.7);
static const float4 Zot = float4(0.7, 0.8, 1.0, 0.3);
static const float4 Rot = float4(0.7, 0.7, 0.5, 0.1);

float3 getColor() {
    orbitTrap.w = sqrt(orbitTrap.w);
    float3 orbitColor = cycle_color(Xot.xyz, orbitTrap.x) * Xot.w * orbitTrap.x
                      + cycle_color(Yot.xyz, orbitTrap.y) * Yot.w * orbitTrap.y
                      + cycle_color(Zot.xyz, orbitTrap.z) * Zot.w * orbitTrap.z
                      + cycle_color(Rot.xyz, orbitTrap.w) * Rot.w * orbitTrap.w;
    float3 color = lerp(BaseColor, 3.0 * orbitColor, OrbitStrength);
    return color;
}

void castRay(float3 ro, float3 rd) {
    float3 lig = normalize(float3(0.4 + cos((25.0 + time) * 0.33), 0.2, 0.6));
    float t = 0.0;
    for (int i = 0; i < 70; i++) {
        if (col.w > 0.999 || t > 15.0) continue;
        rCoC_g = CircleOfConfusion(t);
        h_g = map(ro) + 0.5 * rCoC_g;
        if (h_g < rCoC_g) {
            pcoc = ro - rd * abs(h_g - rCoC_g);
            float2 v = float2(rCoC_g * 0.5, 0.0);
            float3 N = normalize(float3(
                -map(pcoc - v.xyy) + map(pcoc + v.xyy),
                -map(pcoc - v.yxy) + map(pcoc + v.yxy),
                -map(pcoc - v.yyx) + map(pcoc + v.yyx)));
            float3 scol = 2.3 * getColor();
            float newdiff = clamp(dot(lig, N), 0.0, 1.0);
            float newspec = pow(clamp(dot(reflect(rd, N), lig), 0.0, 1.0), 16.0);
            float newsh = FuzzyShadow(pcoc, lig, shadowCone, rCoC_g);
            scol *= 0.5 * newdiff + newspec;
            scol *= newsh;
            float alpha = (1.0 - col.w) * linstep(-rCoC_g, rCoC_g, -h_g * 1.7);
            col += float4(scol * alpha, alpha);
        }
        h_g = abs(fudgeFactor * h_g * (0.3 + 0.05 * rand1(g_fragCoord * (float)i)));
        ro += h_g * rd;
        t += h_g;
    }
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    g_fragCoord = fragCoord;

    // Reset per-pixel mutable state
    col = (float4)0;
    orbitTrap = (float4)0;
    pcoc = (float3)0;

    focalDistance = 6.5 + 3.0 * cos((25.0 + time) * 0.133);
    pixelSize = 1.0 / resolution.y;

    float3 rd = float3(2.0 * fragCoord - resolution, resolution.y);
    rd = normalize(float3(rd.xy, sqrt(max(rd.z * rd.z - dot(rd.xy, rd.xy) * 0.2, 0.0))));

    float2 m = sin(float2(0, 1.57079632) + (25.0 + time) / 4.0);
    float2x2 rot = float2x2(m.y, m.x, -m.x, m.y);
    rd.xy = mul(rot, rd.xy);
    rd.xz = mul(rot, rd.xz);

    float3 ro = float3(0.0, 2.0, 5.0 + sin((25.0 + time) / 2.0));

    castRay(ro, rd);

    float2 uv2 = -0.3 + 2.0 * fragCoord / resolution;
    // Anti-branding noise
    col -= 0.10 * rand1(uv2 * time);

    float3 color = col.rgb * 0.7;

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_Surveillance() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_TentaclesOfLight() {
    return "
    (
// Tentacles of Light - iMac screensaver inspired
// Original: https://www.shadertoy.com/view/WsyfRh by oneshade

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float Hash11(float x) {
    return frac(sin(x * 1254.5763) * 57465.57);
}

float3 hue2rgb(float hue) {
    hue *= 6.0;
    float x = 1.0 - abs(fmod(hue, 2.0) - 1.0);

    float3 rgb = float3(1.0, x, 0.0);
    if (hue < 2.0 && hue >= 1.0) {
        rgb = float3(x, 1.0, 0.0);
    }

    if (hue < 3.0 && hue >= 2.0) {
        rgb = float3(0.0, 1.0, x);
    }

    if (hue < 4.0 && hue >= 3.0) {
        rgb = float3(0.0, x, 1.0);
    }

    if (hue < 5.0 && hue >= 4.0) {
        rgb = float3(x, 0.0, 1.0);
    }

    if (hue < 6.0 && hue >= 5.0) {
        rgb = float3(1.0, 0.0, x);
    }

    return rgb;
}

float lineDist(float2 p, float2 a, float2 b) {
    float2 pa = p - a, ba = b - a;
    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord - 0.5 * resolution.xy) / resolution.y;
    float3 color = (float3)0.0;

    float t = time * 0.25;
    float c = cos(t), s = sin(t);
    uv -= float2(cos(t), sin(t)) * 0.15;

    for (float tentacleID = 0.0; tentacleID < 8.0; tentacleID++) {
        float distFromOrigin = length(uv);
        float tentacleHash = Hash11(tentacleID + 1.0);
        float angle = tentacleID / 4.0 * 3.14 + time * (tentacleHash - 0.5);

        float3 tentacleColor = hue2rgb(frac(0.5 * (distFromOrigin - 0.1 * time)));
        float fadeOut = 1.0 - pow(distFromOrigin, sin(tentacleHash * time) + 1.5);

        float2 offsetVector = uv.yx * float2(-1.0, 1.0);
        float2 offset = offsetVector * sin(tentacleHash * (distFromOrigin + tentacleHash * time)) * (1.0 - distFromOrigin);

        color += smoothstep(0.03, 0.0, lineDist(uv + offset, float2(0.0, 0.0), float2(cos(angle), sin(angle)) * 1000.0)) * fadeOut * tentacleColor;
    }

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_TentaclesOfLight() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_TileableWaterCaustic() {
    return "
    (
// Converted from Shadertoy: Tileable Water Caustic by Dave_Hoskins
// https://www.shadertoy.com/view/MdlXz8
// Original water turbulence effect by joltz0r

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define TAU 6.28318530718
#define MAX_ITER 5

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float stime = time * 0.5 + 23.0;
    float2 uv = fragCoord / resolution;

    float2 p = fmod(uv * TAU, TAU) - 250.0;
    float2 i = p;
    float c = 1.0;
    float inten = 0.005;

    for (int n = 0; n < MAX_ITER; n++)
    {
        float t = stime * (1.0 - (3.5 / float(n + 1)));
        i = p + float2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
        c += 1.0 / length(float2(p.x / (sin(i.x + t) / inten), p.y / (cos(i.y + t) / inten)));
    }
    c /= float(MAX_ITER);
    c = 1.17 - pow(c, 1.4);
    float v = pow(abs(c), 8.0);
    float3 colour = clamp(float3(v, v, v) + float3(0.0, 0.35, 0.5), 0.0, 1.0);

    float3 color = colour;

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_TileableWaterCaustic() {
    return {opacity: 0.45, iChannels: []}
}

_Shader_HLSL_TilesInterestingPatterns() {
    return "
    (
// Tiles, Interesting Patterns
//  Converted from Shadertoy: https://www.shadertoy.com/view/mdBSRt
//  Author: Johnrobmiller

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float aspect_ratio = resolution.y / resolution.x;
    float2 uv = fragCoord.xy / resolution.x;
    uv -= float2(0.5, 0.5 * aspect_ratio);

    float rot = radians(-30.0 - time);
    float cr = cos(rot);
    float sr = sin(rot);
    uv = float2(cr * uv.x + sr * uv.y, -sr * uv.x + cr * uv.y);

    float2 scaled_uv = 20.0 * uv;
    float2 tile = frac(scaled_uv);
    float tile_dist = min(min(tile.x, 1.0 - tile.x), min(tile.y, 1.0 - tile.y));
    float square_dist = length(floor(scaled_uv));

    float edge = sin(time - square_dist * 20.0);
    edge = frac(edge * edge); // mod(edge*edge, 1.0) for non-negative values

    float value = lerp(tile_dist, 1.0 - tile_dist, step(1.0, edge));
    edge = pow(abs(1.0 - edge), 2.2) * 0.5;

    value = smoothstep(edge - 0.05, edge, 0.95 * value);

    value += square_dist * 0.1;
    value *= 0.6;

    float3 col = float3(pow(value, 2.0), pow(value, 1.5), pow(value, 1.2));

    // Darken/desaturate
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_TilesInterestingPatterns() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_ToxicLake() {
    return "
    (
// Toxic Lake - Converted from Shadertoy (Xls3WM)
// Created by Reinder Nijhoff 2015
// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
// Based on https://www.shadertoy.com/view/4ls3D4 by Dave_Hoskins

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define n b = .5*(b + iChannel0.Sample(samp0, (c.xy + float2(37, 17) * floor(c.z)) / 256.).x); c *= .4;

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float3 p = float3(fragCoord.xy / resolution.xy - .5, .2);
    float3 d = p, a = p, b = (float3)0, c;

    [loop]
    for(int i = 0; i < 99; i++) {
        c = p; c.z += time * 5.;
        n
        n
        n
        a += (1. - a) * b.x * abs(p.y) / 4e2;
        p += d;
    }
    float3 color = 1. - a*a;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiply
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_ToxicLake() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "toxic_lake_i0.png"}], timeOffsetMin: 10, timeOffsetMax: 60, timeAccumulate: true}
}

_Shader_HLSL_TriangleNoise() {
    return "
    (
// Triangle Noise
// Converted from: https://www.shadertoy.com/view/ws33Ws

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float Perlin3D(float3 P)
{
    // https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl

    // establish our grid cell and unit position
    float3 Pi = floor(P);
    float3 Pf = P - Pi;
    float3 Pf_min1 = Pf - 1.0;

    // clamp the domain
    Pi.xyz = Pi.xyz - floor(Pi.xyz * (1.0 / 69.0)) * 69.0;
    float3 Pi_inc1 = step(Pi, (float3)(69.0 - 1.5)) * (Pi + 1.0);

    // calculate the hash
    float4 Pt = float4(Pi.xy, Pi_inc1.xy) + float2(50.0, 161.0).xyxy;
    Pt *= Pt;
    Pt = Pt.xzxz * Pt.yyww;
    const float3 SOMELARGEFLOATS = float3(635.298681, 682.357502, 668.926525);
    const float3 ZINC = float3(48.500388, 65.294118, 63.934599);
    float3 lowz_mod = 1.0 / (SOMELARGEFLOATS + Pi.zzz * ZINC);
    float3 highz_mod = 1.0 / (SOMELARGEFLOATS + Pi_inc1.zzz * ZINC);
    float4 hashx0 = frac(Pt * lowz_mod.xxxx);
    float4 hashx1 = frac(Pt * highz_mod.xxxx);
    float4 hashy0 = frac(Pt * lowz_mod.yyyy);
    float4 hashy1 = frac(Pt * highz_mod.yyyy);
    float4 hashz0 = frac(Pt * lowz_mod.zzzz);
    float4 hashz1 = frac(Pt * highz_mod.zzzz);

    // calculate the gradients
    float4 grad_x0 = hashx0 - 0.49999;
    float4 grad_y0 = hashy0 - 0.49999;
    float4 grad_z0 = hashz0 - 0.49999;
    float4 grad_x1 = hashx1 - 0.49999;
    float4 grad_y1 = hashy1 - 0.49999;
    float4 grad_z1 = hashz1 - 0.49999;
    float4 grad_results_0 = rsqrt(grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0) * (float2(Pf.x, Pf_min1.x).xyxy * grad_x0 + float2(Pf.y, Pf_min1.y).xxyy * grad_y0 + Pf.zzzz * grad_z0);
    float4 grad_results_1 = rsqrt(grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1) * (float2(Pf.x, Pf_min1.x).xyxy * grad_x1 + float2(Pf.y, Pf_min1.y).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1);

    // Classic Perlin Interpolation
    float3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);
    float4 res0 = lerp(grad_results_0, grad_results_1, blend.z);
    float4 blend2 = float4(blend.xy, 1.0 - blend.xy);
    float result = dot(res0, blend2.zxzx * blend2.wwyy);
    return (result * 1.1547005383792515290182975610039); // scale to strict -1.0->1.0 range *= 1.0/sqrt(0.75)
}

float2 Rotate(float2 xy, float angle) {
    return float2(xy.x * cos(angle) - xy.y * sin(angle), xy.x * sin(angle) + xy.y * cos(angle));
}

float2 Triangle(float2 uv, float c) {
    float r = 0.5235988;
    float2 o = uv;
    o.x = floor(uv.x * c + 0.5);
    o.y = lerp(floor(Rotate(uv * c + 0.5, r).y), floor(Rotate(uv * c + 0.5, -r).y), 0.5);
    o.y *= 1.154700555;
    return o / c;
}

float2 TriangleUV(float2 uv, float c, float r, float s) {
    uv = Rotate(uv, r);
    uv.y += s;
    uv = Triangle(uv, c);
    uv.y -= s;
    uv = Rotate(uv, -r);
    uv += 0.5;
    return uv;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float Time = time;
    float Scroll = 0.0125;
    float Rotation = -0.7854;
    float NoiseSpeed = 1.0;
    float4 Color1 = float4(0.07451, 0.09022, 0.2471, 1.0); // Background
    float4 Color2 = float4(0.1804, 0.1922, 0.4942, 1.0); // Foreground

    // Fixed resolution UV (screen-independent pattern)
    float2 uv = fragCoord.xy * 0.00025;

    // Create triangular noise pattern
    float n1 = Perlin3D(float3(TriangleUV(uv, 11.0, Rotation, Time * Scroll) * 10.0, Time * NoiseSpeed));
    float n2 = Perlin3D(float3(TriangleUV(uv * 2.0 + float2(10.0, 10.0), 11.0, Rotation, Time * Scroll) * 10.0, Time * NoiseSpeed));
    n1 = clamp((n1 + n2) * 0.5 + 0.5, 0.0, 1.0);

    // Final output
    float3 col = lerp(Color1.rgb, Color2.rgb, n1);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, (float3)lum, desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_TriangleNoise() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_TurbulenceTexture() {
    return "
    (
// Turbulence Texture — abs(perlin) fbm
// https://www.shadertoy.com/view/ssj3Wc
// Author: penghuailiang | License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float3 random_perlin(float3 p) {
    p = float3(
            dot(p, float3(127.1, 311.7, 69.5)),
            dot(p, float3(269.5, 183.3, 132.7)),
            dot(p, float3(247.3, 108.5, 96.5)));
    return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

float noise_perlin(float3 p) {
    float3 i = floor(p);
    float3 s = frac(p);

    float a = dot(random_perlin(i), s);
    float b = dot(random_perlin(i + float3(1, 0, 0)), s - float3(1, 0, 0));
    float c = dot(random_perlin(i + float3(0, 1, 0)), s - float3(0, 1, 0));
    float d = dot(random_perlin(i + float3(0, 0, 1)), s - float3(0, 0, 1));
    float e = dot(random_perlin(i + float3(1, 1, 0)), s - float3(1, 1, 0));
    float f = dot(random_perlin(i + float3(1, 0, 1)), s - float3(1, 0, 1));
    float g = dot(random_perlin(i + float3(0, 1, 1)), s - float3(0, 1, 1));
    float h = dot(random_perlin(i + float3(1, 1, 1)), s - float3(1, 1, 1));

    float3 u = smoothstep(0.0, 1.0, s);

    return lerp(lerp(lerp(a, b, u.x),
                lerp(c, e, u.x), u.y),
            lerp(lerp(d, f, u.x),
                lerp(g, h, u.x), u.y), u.z);
}

float noise_turbulence(float3 p)
{
    float f = 0.0;
    float a = 1.0;
    p = 4.0 * p;
    for (int i = 0; i < 5; i++) {
        f += a * abs(noise_perlin(p));
        p = 2.0 * p;
        a /= 2.0;
    }
    return f;
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution;

    float c1 = noise_turbulence(float3(1.0 * uv, time / 10.0));
    float3 col = float3(1.5 * c1, 1.5 * c1 * c1 * c1, c1 * c1 * c1 * c1 * c1 * c1);

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_TurbulenceTexture() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_UltraLiquidBokeh() {
    return "
    (
// Ultra Liquid Bokeh — converted from Shadertoy (MtdXzr)
// Created by inigo quilez - iq/2013 : https://www.shadertoy.com/view/4dl3zn
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
// Messed up by Weyland

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);

    float2 uv = -1.0 + 2.0 * fragCoord.xy / resolution.xy;
    uv.x *= resolution.x / resolution.y;
    float3 color = (float3)0.0;
    for (int i = 0; i < 128; i++)
    {
        float pha =      sin(float(i) * 546.13 + 1.0) * 0.5 + 0.5;
        float siz = pow( sin(float(i) * 651.74 + 5.0) * 0.5 + 0.5, 4.0 );
        float pox =      sin(float(i) * 321.55 + 4.1) * resolution.x / resolution.y;
        float rad = 0.1 + 0.5 * siz + sin(pha + siz) / 4.0;
        float2 pos = float2( pox + sin(time / 15. + pha + siz), -1.0 - rad + (2.0 + 2.0 * rad) * fmod(pha + 0.3 * (time / 7.) * (0.2 + 0.8 * siz), 1.0));
        float dis = length( uv - pos );
        float3 col = lerp( float3(0.194 * sin(time / 6.0) + 0.3, 0.2, 0.3 * pha), float3(1.1 * sin(time / 9.0) + 0.3, 0.2 * pha, 0.4), 0.5 + 0.5 * sin(float(i)));
        float f = length(uv - pos) / rad;
        f = sqrt(clamp(1.0 + (sin(time * siz) * 0.5) * f, 0.0, 1.0));
        color += col.zyx * (1.0 - smoothstep( rad * 0.15, rad, dis ));
    }
    color *= sqrt(1.5 - 0.5 * length(uv));

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_UltraLiquidBokeh() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_UnderwaterCaustics() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define tau 6.28318530718

float sin01(float x) {
    return (sin(x * tau) + 1.0) / 2.0;
}

float cos01(float x) {
    return (cos(x * tau) + 1.0) / 2.0;
}

float2 rand01(float2 p) {
    float3 a = frac(p.xyx * float3(123.5, 234.34, 345.65));
    a += dot(a, a + 34.45);
    return frac(float2(a.x * a.y, a.y * a.z));
}

float circ(float2 uv, float2 pos, float r) {
    return smoothstep(r, 0.0, length(uv - pos));
}

float smoothFract(float x, float blurLevel) {
    return pow(cos01(x), 1.0 / blurLevel);
}

float manDist(float2 f, float2 t) {
    return abs(f.x - t.x) + abs(f.y - t.y);
}

float distFn(float2 f, float2 t) {
    float x = length(f - t);
    return pow(x, 4.0);
}

float voronoi(float2 uv, float t, float seed, float size) {
    float minDist = 100.0;
    float gridSize = size;

    float2 cellUv = frac(uv * gridSize) - 0.5;
    float2 cellCoord = floor(uv * gridSize);

    for (float x = -1.0; x <= 1.0; x += 1.0) {
        for (float y = -1.0; y <= 1.0; y += 1.0) {
            float2 cellOffset = float2(x, y);

            // Random 0-1 for each cell
            float2 rand01Cell = rand01(cellOffset + cellCoord + seed);

            // Get position of cell point
            float2 pt = cellOffset + sin(rand01Cell * (t + 10.0)) * 0.5;

            // Get distance between pixel and point
            float dist = distFn(cellUv, pt);
            minDist = min(minDist, dist);
        }
    }

    return minDist;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    // Center coordinates at 0
    float2 uv = (2.0 * fragCoord - resolution.xy) / resolution.y;

    float t = time * 0.35;

    // Distort uv coordinates
    float amplitude = 0.12;
    float turbulence = 0.5;
    uv.xy += sin01(uv.x * turbulence + t) * amplitude;
    uv.xy -= sin01(uv.y * turbulence + t) * amplitude;

    // Apply two layers of voronoi, one smaller
    float v = 0.0;
    float sizeDistortion = abs(uv.x) / 3.0;
    v += voronoi(uv, t * 2.0, 0.5, 2.5 - sizeDistortion);
    v += voronoi(uv, t * 4.0, 0.0, 4.0 - sizeDistortion) / 2.0;

    // Foreground color
    float3 col = v * float3(0.55, 0.75, 1.0);

    // Background color
    col += (1.0 - v) * float3(0.0, 0.3, 0.5);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_UnderwaterCaustics() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_VistaEsqueWallpaper() {
    return "
    (
// Vista-Esque wallpaper thing
// Converted from: https://www.shadertoy.com/view/mlGXRc

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float3 palette(float t) {
    float3 a = float3(0.667, 0.500, 0.500);
    float3 b = float3(0.500, 0.667, 0.500);
    float3 c = float3(0.667, 0.666, 0.500);
    float3 d = float3(0.200, 0.000, 0.500);

    return a + b * cos(6.28318 * (c * t * d));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float wave = sin(time * 2.0);

    float2 uv = fragCoord / resolution;
    float3 finalCol = (float3)0;

    for (float i = 0.0; i < 7.0; i++) {
        float d = uv.y;
        float w = uv.x;

        d = sin(d - 0.3 * 0.1 * (wave / 5.0 + 5.0)) + sin(uv.x * 2.0 + time / 2.0) / 20.0 - sin(i) / 10.0 + sin(uv.x * 4.3 + time * 1.3 * i * 0.2) / 20.0;
        d = abs(d / 2.0);
        d = 0.003 / d / 8.0 * i;

        w += sin(uv.y * 2.0 + time) / 60.0;
        w = abs(sin(w * 20.0 * i / 4.0 + time * sin(i)) / 20.0 + sin(w * 10.0 * i) / 17.0) * 30.0;
        w += uv.y * 2.4 - 1.6;
        w /= 3.0;
        w = smoothstep(0.4, 0.7, w) / 20.0;

        float3 col = palette(uv.x + time / 3.0);

        col *= d + w;
        finalCol += col;
    }

    // Darken/desaturate post-processing
    float lum = dot(finalCol, float3(0.299, 0.587, 0.114));
    finalCol = lerp(finalCol, (float3)lum, desaturate);
    finalCol = finalCol * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(finalCol.r, max(finalCol.g, finalCol.b));
    return float4(finalCol * a, a);
}

    )"
}

_Shader_Meta_VistaEsqueWallpaper() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_VolumetricFire() {
    return "
    (
// Volumetric Fire — gyroid fBm volumetric ray marcher
// https://www.shadertoy.com/view/NttBWj
// Author: myth0genesis | License: CC BY-NC-SA 3.0
// Based on nimitz's Protean clouds

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

static const float3x3 m3 = float3x3(0.3338, 0.56034, -0.71817,
                                     -0.87887, 0.32651, -0.15323,
                                     0.15162, 0.69596, 0.61339) * 1.93;

float LinStep(float mn, float mx, float x) {
    return clamp((x - mn) / (mx - mn), 0.0, 1.0);
}

float2x2 rotate(float a) {
    float c = cos(a);
    float s = sin(a);
    return float2x2(c, s, -s, c);
}

// nimitz's genius fast gyroid fBm
float gyroidFBM3D(float3 p, float cl) {
    float d = 0.0;
    p *= 0.185;
    p.z -= time;
    float z = 1.0;
    float trk = 1.0;
    float dspAmp = 0.1;
    for (int i = 0; i < 5; i++) {
        p += sin(p.yzx * 1.5 * trk) * dspAmp;
        d -= abs(dot(cos(p), sin(p.zxy)) * z);
        z *= 0.7;
        trk *= 1.4;
        p = mul(p, m3);
        p -= time * 2.0;
    }
    return (cl + d * 6.5) * 0.5;
}

// nimitz's volumetric ray marcher
float3 transRender(float3 ro, float3 rd) {
    float4 rez = float4(0.0, 0.0, 0.0, 0.0);
    float t = 20.0;
    for (int i = 0; i < 100; i++) {
        if (rez.w > 0.99) break;
        float3 pos = ro + t * rd;
        float mpv = gyroidFBM3D(pos, -pos.z);
        float den = clamp(mpv - 0.2, 0.0, 1.0) * 0.71;
        float dn = clamp(mpv * 2.0, 0.0, 3.0);
        float4 col = float4(0.0, 0.0, 0.0, 0.0);
        if (mpv > 0.6) {
            col = float4(11.0, 1.0, 0.0, 0.08);
            col *= den;
            col.xyz *= LinStep(3.0, -1.0, mpv) * 3.0;
            float dif = clamp((den - mpv + 1.5) * 0.125, 0.08, 1.0);
            col.xyz *= den * (1.5 * float3(0.005, 0.045, 0.075) + 1.5 * float3(0.033, 0.05, 0.030) * dif);
        }
        rez += col * (1.0 - rez.w);
        t += clamp(0.25 - dn * dn * 0.05, 0.15, 1.4);
    }
    return clamp(rez.xyz, 0.0, 1.0);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 uv = (fragCoord - 0.5 * resolution) / resolution.y;
    float3 ro = float3(0.0, 0.0, -3.0);

    float3 rd = normalize(float3(uv.x, 1.0, uv.y));

    // Gentle time-based camera rotation (replaces mouse drag)
    rd.xy = mul(rd.xy, rotate(sin(time * 0.15) * 0.3));

    float3 col = transRender(ro, rd);

    // darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}
    )"
}

_Shader_Meta_VolumetricFire() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 5, timeOffsetMax: 30}
}

_Shader_HLSL_VoronoiBurning() {
    return "
    (
// Domain warping applied to Voronoi noise
// Written by Claus O. Wilke, 2022 (MIT License)
// Noise functions adapted from Inigo Quilez (MIT License)
// Converted from https://www.shadertoy.com/view/NdtcRr

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

Texture2D iChannel0 : register(t0);
SamplerState samp0 : register(s0);

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// ACES tone mapping (from Common tab)
float3 s_curve(float3 x)
{
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    x = max(x, 0.0);
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

// voronoi smoothness
static const float voronoi_smooth = 0.05;

float hash(float2 p)
{
    int2 texp = int2(
        int(fmod(p.x, 256.0)),
        int(fmod(p.y, 256.0)));

    return -1.0 + 2.0 * iChannel0.Load(int3(texp, 0)).x;
}

float2 hash2(float2 p)
{
    return float2(hash(p), hash(p + float2(32.0, 18.0)));
}

// value noise (Inigo Quilez, MIT License)
float noise1(float2 p)
{
    float2 i = floor(p);
    float2 f = frac(p);

    float2 u = f * f * (3.0 - 2.0 * f);

    return lerp(lerp(hash(i + float2(0.0, 0.0)),
                     hash(i + float2(1.0, 0.0)), u.x),
                lerp(hash(i + float2(0.0, 1.0)),
                     hash(i + float2(1.0, 1.0)), u.x), u.y);
}

// voronoi (Inigo Quilez, MIT License)
float voronoi(float2 x, float w)
{
    float2 n = floor(x);
    float2 f = frac(x);

    float dout = 8.0;
    for (int j = -2; j <= 2; j++)
    for (int i = -2; i <= 2; i++)
    {
        float2 g = float2((float)i, (float)j);
        float2 o = 0.5 + 0.5 * hash2(n + g);

        float d = length(g - f + o);

        float h = smoothstep(-1.0, 1.0, (dout - d) / w);
        dout = lerp(dout, d, h) - h * (1.0 - h) * w / (1.0 + 3.0 * w);
    }

    return dout;
}

float fbm1(float2 p, int octaves)
{
    float2x2 m = 2.0 * float2x2(4.0 / 5.0, 3.0 / 5.0, -3.0 / 5.0, 4.0 / 5.0);

    float scale = 0.5;
    float f = scale * noise1(p);
    float norm = scale;
    for (int i = 0; i < octaves; i++) {
        p = mul(m, p);
        scale *= 0.5;
        norm += scale;
        f += scale * noise1(p);
    }
    return 0.5 + 0.5 * f / norm;
}

float voronoise(float2 p)
{
    return voronoi(p, voronoi_smooth);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float2 uv = (2.0 * fragCoord - resolution.xy) / resolution.y;

    float2 toff = 0.1 * time * float2(4.0, 2.0);

    float2 p = (0.6 + 0.5 * sin(0.07 * time)) * float2(4.0, 4.0) * uv;

    float2 r = float2(fbm1(p + float2(5.0, 2.0), 4), fbm1(p + float2(1.0, 4.0), 4));

    float3 col = 1.2 * float3(1.4, 1.0, 0.5) *
        pow(float3(
            voronoise(p + 1.5 * r + toff),
            voronoise(p + 1.5 * r + toff + 0.005 * float2(2.0, 4.0)),
            voronoise(p + 1.5 * r + toff + 0.01 * float2(5.0, 1.0))),
            float3(1.5, 2.5, 2.9));

    col = s_curve(col);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_VoronoiBurning() {
    return {opacity: 0.50, iChannels: [{index: 0, file: "voronoi_burning_i0.png"}]}
}

_Shader_HLSL_WarpedLiquidMetal() {
    return "
    (
// Warped Liquid Metal - mrange (Shadertoy 3t2czh)
// Licence CC0
// Converted from GLSL to HLSL for Alt-Tabby

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define PI  3.141592654
#define TAU (2.0*PI)

void rot(inout float2 p, float a) {
    float c = cos(a);
    float s = sin(a);
    p = float2(c * p.x + s * p.y, -s * p.x + c * p.y);
}

float hash(in float2 co) {
    return frac(sin(dot(co.xy, float2(12.9898, 58.233))) * 13758.5453);
}

float2 hash2(float2 p) {
    p = float2(dot(p, float2(127.1, 311.7)), dot(p, float2(269.5, 183.3)));
    return frac(sin(p) * 18.5453);
}

float psin(float a) {
    return 0.5 + 0.5 * sin(a);
}

float tanh_approx(float x) {
    float x2 = x * x;
    return clamp(x * (27.0 + x2) / (27.0 + 9.0 * x2), -1.0, 1.0);
}

float onoise(float2 x) {
    x *= 0.5;
    float a = sin(x.x);
    float b = sin(x.y);
    float c = lerp(a, b, psin(TAU * tanh_approx(a * b + a + b)));

    return c;
}

float vnoise(float2 x) {
    float2 i = floor(x);
    float2 w = frac(x);

    // quintic interpolation
    float2 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);

    float a = hash(i + float2(0.0, 0.0));
    float b = hash(i + float2(1.0, 0.0));
    float c = hash(i + float2(0.0, 1.0));
    float d = hash(i + float2(1.0, 1.0));

    float k0 = a;
    float k1 = b - a;
    float k2 = c - a;
    float k3 = d - c + a - b;

    float aa = lerp(a, b, u.x);
    float bb = lerp(c, d, u.x);
    float cc = lerp(aa, bb, u.y);

    return k0 + k1 * u.x + k2 * u.y + k3 * u.x * u.y;
}

float fbm1(float2 p) {
    float2 op = p;
    const float aa = 0.45;
    const float pp = 2.03;
    const float2 oo = -float2(1.23, 1.5);
    const float rr = 1.2;

    float h = 0.0;
    float d = 0.0;
    float a = 1.0;

    for (int i = 0; i < 5; ++i) {
        h += a * onoise(p);
        d += a;
        a *= aa;
        p += oo;
        p *= pp;
        rot(p, rr);
    }

    return lerp((h / d), -0.5 * (h / d), pow(vnoise(0.9 * op), 0.25));
}

float fbm2(float2 p) {
    float2 op = p;
    const float aa = 0.45;
    const float pp = 2.03;
    const float2 oo = -float2(1.23, 1.5);
    const float rr = 1.2;

    float h = 0.0;
    float d = 0.0;
    float a = 1.0;

    for (int i = 0; i < 7; ++i) {
        h += a * onoise(p);
        d += a;
        a *= aa;
        p += oo;
        p *= pp;
        rot(p, rr);
    }

    return lerp((h / d), -0.5 * (h / d), pow(vnoise(0.9 * op), 0.25));
}

float fbm3(float2 p) {
    float2 op = p;
    const float aa = 0.45;
    const float pp = 2.03;
    const float2 oo = -float2(1.23, 1.5);
    const float rr = 1.2;

    float h = 0.0;
    float d = 0.0;
    float a = 1.0;

    for (int i = 0; i < 3; ++i) {
        h += a * onoise(p);
        d += a;
        a *= aa;
        p += oo;
        p *= pp;
        rot(p, rr);
    }

    return lerp((h / d), -0.5 * (h / d), pow(vnoise(0.9 * op), 0.25));
}

float warp(float2 p) {
    float2 v = float2(fbm1(p), fbm1(p + 0.7 * float2(1.0, 1.0)));

    rot(v, 1.0 + time * 0.1);

    float2 vv = float2(fbm2(p + 3.7 * v), fbm2(p + -2.7 * v.yx + 0.7 * float2(1.0, 1.0)));

    rot(vv, -1.0 + time * 0.21315);

    return fbm3(p + 1.4 * vv);
}

float height(float2 p) {
    float a = 0.005 * time;
    p += 5.0 * float2(cos(a), sin(a));
    p *= 2.0;
    p += 13.0;
    float h = warp(p);
    float rs = 3.0;
    return 0.35 * tanh_approx(rs * h) / rs;
}

float3 calcNormal(float2 p) {
    // As suggested by IQ, thanks!
    float2 eps = -float2(2.0 / resolution.y, 0.0);

    float3 n;

    n.x = height(p + eps.xy) - height(p - eps.xy);
    n.y = 2.0 * eps.x;
    n.z = height(p + eps.yx) - height(p - eps.yx);

    return normalize(n);
}

float3 postProcess(float3 col, float2 q) {
    col = pow(clamp(col, 0.0, 1.0), (float3)0.75);
    col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col);  // contrast
    col = lerp(col, (float3)dot(col, float3(0.33, 0.33, 0.33)), -0.4);  // saturation
    col *= 0.5 + 0.5 * pow(19.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);  // vignetting
    return col;
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 q = fragCoord / resolution.xy;
    float2 p = -1. + 2. * q;
    p.x *= resolution.x / resolution.y;

    const float3 lp1 = float3(0.9, -0.5, 0.8);
    const float3 lp2 = float3(-0.9, -1.5, 0.9);

    float h = height(p);
    float3 pp = float3(p.x, h, p.y);
    float ll1 = length(lp1.xz - pp.xz);
    float3 ld1 = normalize(lp1 - pp);
    float3 ld2 = normalize(lp2 - pp);

    float3 n = calcNormal(p);
    float diff1 = max(dot(ld1, n), 0.0);
    float diff2 = max(dot(ld2, n), 0.0);

    float3 baseCol = float3(1.0, 0.8, 0.6);

    float oh = height(p + ll1 * 0.05 * normalize(ld1.xz));
    const float level0 = 0.0;
    const float level1 = 0.125;
    // VERY VERY fake shadows + hilight
    float3 scol = baseCol * (smoothstep(level0, level1, h) - smoothstep(level0, level1, oh));

    float3 col = (float3)0.0;
    col += baseCol * pow(diff1, 6.0);
    col += 0.1 * baseCol * pow(diff1, 1.5);
    col += 0.15 * baseCol.zyx * pow(diff2, 8.0);
    col += 0.015 * baseCol.zyx * pow(diff2, 2.0);
    col += scol * 0.5;

    col = postProcess(col, q);

    // Darken/desaturate post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(col.r, max(col.g, col.b));
    return float4(col * alpha, alpha);
}

    )"
}

_Shader_Meta_WarpedLiquidMetal() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 20, timeOffsetMax: 80, timeAccumulate: true}
}

_Shader_HLSL_WarpedNoiseWithShadows() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

#define CONT 0.1
#define MOD3 float3(.1031, .11369, .13787)

float r_f(float n)
{
    return frac(cos(n * 89.42) * 343.42);
}

float2 r_v(float2 n)
{
    return float2(r_f(n.x * 23.62 - 300.0 + n.y * 34.35), r_f(n.x * 45.13 + 256.0 + n.y * 38.89));
}

float worley(float2 n, float s)
{
    float dis = 2.0;
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            float2 p = floor(n / s) + float2(x, y);
            float d = length(r_v(p) + float2(x, y) - frac(n / s));
            if (dis > d)
            {
                dis = d;
            }
        }
    }
    return 1.0 - dis;
}

float3 hash33(float3 p3)
{
    p3 = frac(p3 * MOD3);
    p3 += dot(p3, p3.yxz + 19.19);
    return -1.0 + 2.0 * frac(float3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));
}

float perlin_noise(float3 p)
{
    float3 pi = floor(p);
    float3 pf = p - pi;

    float3 w = pf * pf * (3.0 - 2.0 * pf);

    return lerp(
            lerp(
                lerp(dot(pf - float3(0, 0, 0), hash33(pi + float3(0, 0, 0))),
                     dot(pf - float3(1, 0, 0), hash33(pi + float3(1, 0, 0))),
                     w.x),
                lerp(dot(pf - float3(0, 0, 1), hash33(pi + float3(0, 0, 1))),
                     dot(pf - float3(1, 0, 1), hash33(pi + float3(1, 0, 1))),
                     w.x),
                w.z),
            lerp(
                lerp(dot(pf - float3(0, 1, 0), hash33(pi + float3(0, 1, 0))),
                     dot(pf - float3(1, 1, 0), hash33(pi + float3(1, 1, 0))),
                     w.x),
                lerp(dot(pf - float3(0, 1, 1), hash33(pi + float3(0, 1, 1))),
                     dot(pf - float3(1, 1, 1), hash33(pi + float3(1, 1, 1))),
                     w.x),
                w.z),
            w.y);
}

float noise(float2 v)
{
    float dis = (1.0 + perlin_noise(float3(v, sin(time * 0.15)) * 5.0))
        * (1.0 + (worley(v, 32.0) +
        0.5 * worley(2.0 * v, 32.0) +
        0.25 * worley(4.0 * v, 32.0)));

    return dis * 0.25;
}

float frct(float2 v)
{
    return noise(v + noise(v - noise(v)));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float c = (frct(fragCoord / resolution) - frct((fragCoord + CONT) / resolution)) / CONT + 0.5;

    float3 color = (float3)abs(sqrt(c));

    // Post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness — premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}
    )"
}

_Shader_Meta_WarpedNoiseWithShadows() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 10, timeOffsetMax: 60}
}

_Shader_HLSL_WavyHexagon() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float hexDist(float2 p)
{
    p = abs(p);
    float d = dot(p, normalize(float2(1.0, 1.73)));
    return max(p.x, d);
}

float4 hexCoords(float2 uv)
{
    float2 r = float2(1.0, 1.73);
    float2 h = 0.5 * r;
    float2 a = fmod(uv, r) - h;
    float2 b = fmod(uv - h, r) - h;

    float2 gv = length(a) < length(b) ? a : b;

    float x = atan2(gv.x, gv.y);
    float y = 0.5 - hexDist(gv);
    float2 id = uv - gv;

    return float4(x, y, id);
}

float4 PSMain(PSInput input) : SV_Target
{
    float2 fragCoord = input.pos.xy;
    float2 uv = (fragCoord.xy - 0.5 * resolution.xy) / resolution.y;

    uv *= 10.0;

    float3 col = (float3)0;
    float4 hc = hexCoords(uv);

    float t = time * 0.5;
    float wavy = pow(sin(length(hc.zw) - t), 4.0) + 0.1;

    float c = smoothstep(0., 15./resolution.y, hc.y);

    col = (float3)(c * wavy);

    // Post-processing
    float lum = dot(col, float3(0.299, 0.587, 0.114));
    col = lerp(col, float3(lum, lum, lum), desaturate);
    col = col * (1.0 - darken);

    // Alpha from brightness, premultiply
    float a = max(col.r, max(col.g, col.b));
    return float4(col * a, a);
}

    )"
}

_Shader_Meta_WavyHexagon() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_WorleyNoiseWaters() {
    return "
    (
cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float length2(float2 p) {
    return dot(p, p);
}

float noise(float2 p) {
    return frac(sin(frac(sin(p.x) * 43.13311) + p.y) * 31.0011);
}

float worley(float2 p) {
    float d = 1e30;
    for (int xo = -1; xo <= 1; ++xo) {
        for (int yo = -1; yo <= 1; ++yo) {
            float2 tp = floor(p) + float2(xo, yo);
            d = min(d, length2(p - tp - noise(tp)));
        }
    }
    return 3.0 * exp(-4.0 * abs(2.5 * d - 1.0));
}

float fworley(float2 p) {
    return sqrt(sqrt(sqrt(
        worley(p * 5.0 + 0.05 * time) *
        sqrt(worley(p * 50.0 + 0.12 + -0.1 * time)) *
        sqrt(sqrt(worley(p * -10.0 + 0.03 * time))))));
}

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord.xy / resolution.xy;
    float t = fworley(uv * resolution.xy / 1500.0);
    t *= exp(-length2(abs(0.7 * uv - 1.0)));
    float3 color = t * float3(0.1, 1.1 * t, pow(t, 0.5 - t));

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_WorleyNoiseWaters() {
    return {opacity: 0.50, iChannels: [], timeAccumulate: true}
}

_Shader_HLSL_WormCity() {
    return "
    (
// Shader by Frostbyte
// Licensed under CC BY-NC-SA 4.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 u = fragCoord.xy;

    float i = 0.0;
    float a = 0.0;
    float d = 0.0;
    float s = 0.0;
    float t = time + 10.0;
    float r = 0.0;

    float3 p = float3(resolution, 1.0);
    u = (u + u - p.xy) / p.y;

    float4 o = (float4)0.0;

    for (i = 0.0; i++ < 175.0; ) {
        s = 0.004 + abs(s) * 0.1;
        d += s;
        o.r += (length(d * 1.5 - 5.0) / s) * 0.25;
        o.b += sin(d * 0.09 + d * 0.1) * 2.0 / s;
        o.g += sin(d * 0.2) * 1.0 / s;

        p = float3(u * d, d + t * 1.0);
        s = min(p.z, 1.9);

        for (a = 1.0; a < 2.0; a += a) {
            p += cos(t * 1.5 - p.yzx * 1.0 + t) * 0.5;
            p.xy += t * 0.011;
            r = sin(t * 0.2);

            float2x2 rot = float2x2(cos(r), -sin(r), sin(r), cos(r));
            p.xy = mul(rot, p.xy);
            s += abs(sin(p.x * a)) * 3.7 * -abs(sin(abs(p.y) * a) * sin(p.z * 0.1 + t) / a);
        }
    }

    o = pow(tanh(o * o / 3e8 * length(u)), (float4)(1.0 / 2.2));
    o *= o;

    float3 color = o.rgb;

    // Darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float alpha = max(color.r, max(color.g, color.b));
    return float4(color * alpha, alpha);
}
    )"
}

_Shader_Meta_WormCity() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 0, timeOffsetMax: 30}
}

_Shader_HLSL_ZippyZaps() {
    return "
    (
// Zippy Zaps - converted from Shadertoy (XXyGzh) by SnoopethDuckDuck
// https://www.shadertoy.com/view/XXyGzh

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = float2(input.pos.x, resolution.y - input.pos.y);
    float2 v = resolution;
    float2 u = 0.2 * (2.0 * fragCoord - v) / v.y;

    float4 z = float4(1, 2, 3, 0);
    float4 o = z;

    float a = 0.5;
    float t = time;
    float i = 0;

    [loop] for (; ++i < 19.;) {
        // Side effects extracted from original comma-operator expression
        t += 1.0;
        a += 0.03;
        v = cos(t - 7. * u * pow(a, i)) - 5. * u;

        // Rotation matrix: z.wxzw*11 = float4(0,11,33,0)
        float4 cv = cos(i + 0.02 * t - float4(0, 11, 33, 0));
        u = mul(float2x2(cv.x, cv.z, cv.y, cv.w), u);

        u += tanh(40. * dot(u, u) * cos(1e2 * u.yx + t)) / 2e2
           + 0.2 * a * u
           + cos(4. / exp(dot(o, o) / 1e2) + t) / 3e2;

        // For-loop increment expression
        o += (1. + cos(z + t))
           / length((1. + i * dot(v, v))
                  * sin(1.5 * u / (0.5 - dot(u, u)) - 9. * u.yx + t));
    }

    o = 25.6 / (min(o, 13.) + 164. / o)
      - dot(u, u) / 250.;

    float3 color = saturate(o.rgb);

    // Darken / desaturate
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Premultiplied alpha from brightness
    float al = max(color.r, max(color.g, color.b));
    return float4(color * al, al);
}

    )"
}

_Shader_Meta_ZippyZaps() {
    return {opacity: 0.50, iChannels: []}
}

