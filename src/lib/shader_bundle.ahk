; AUTO-GENERATED by tools/shader_bundle.ps1 -- DO NOT EDIT
; Source: src/shaders/
; Regenerate: powershell -File tools/shader_bundle.ps1
#Requires AutoHotkey v2.0
#Warn VarUnset, Off

global SHADER_NAMES := ["None", "Jasz Universe", "Matrix Rain", "Protean Clouds"]

Shader_RegisterAll() {
    Shader_Register("jaszUniverse", _Shader_HLSL_JaszUniverse(), _Shader_Meta_JaszUniverse())
    Shader_Register("matrixRain", _Shader_HLSL_MatrixRain(), _Shader_Meta_MatrixRain())
    Shader_Register("proteanClouds", _Shader_HLSL_ProteanClouds(), _Shader_Meta_ProteanClouds())
}

_Shader_HLSL_JaszUniverse() {
    return "
    (
// Jasz Universe - Volumetric nebula fog with camera movement
// Original: Shadertoy by Jan Mroz (jaszunio15)
// License: CC BY 3.0
// Audio reactivity stripped; replaced with time-based pulse.

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// --- Constants (from Shadertoy Common tab, non-HQ branch) ---
static const float NOISE_ALPHA_MULTIPLIER = 0.5;
static const float NOISE_SIZE_MULTIPLIER  = 1.8;
static const int   RAYS_COUNT             = 54;
static const float STEP_MODIFIER          = 1.0175;
static const float SHARPNESS              = 0.02;
static const float NOISE_LAYERS_COUNT     = 4.0;
static const float JITTERING              = 0.08;
static const float DITHER                 = 0.3;
static const float NEAR_PLANE             = 0.6;
static const float RENDER_DISTANCE        = 2.0;
static const float BRIGHTNESS             = 5.0;
static const float3 COLOR1                = float3(0.0, 1.0, 1.0);
static const float3 COLOR2                = float3(1.0, 0.0, 0.9);
static const float CAMERA_SPEED           = 0.04;
static const float CAMERA_ROTATION_SPEED  = 0.06;

// --- Helper functions ---

float hash(float3 v) {
    return frac(sin(dot(v, float3(11.51721, 67.12511, 9.7561))) * 1551.4172);
}

float getNoiseFromVec3(float3 v) {
    float3 rootV = floor(v);
    float3 f = smoothstep(0.0, 1.0, frac(v));

    float n000 = hash(rootV);
    float n001 = hash(rootV + float3(0, 0, 1));
    float n010 = hash(rootV + float3(0, 1, 0));
    float n011 = hash(rootV + float3(0, 1, 1));
    float n100 = hash(rootV + float3(1, 0, 0));
    float n101 = hash(rootV + float3(1, 0, 1));
    float n110 = hash(rootV + float3(1, 1, 0));
    float n111 = hash(rootV + float3(1, 1, 1));

    float4 n = lerp(float4(n000, n010, n100, n110), float4(n001, n011, n101, n111), f.z);
    n.xy = lerp(float2(n.x, n.z), float2(n.y, n.w), f.y);
    return lerp(n.x, n.y, f.x);
}

float volumetricFog(float3 v, float noiseMod) {
    float noise = 0.0;
    float alpha = 1.0;
    float3 pt = v;
    for (float i = 0.0; i < NOISE_LAYERS_COUNT; i++) {
        noise += getNoiseFromVec3(pt) * alpha;
        pt *= NOISE_SIZE_MULTIPLIER;
        alpha *= NOISE_ALPHA_MULTIPLIER;
    }

    noise *= 0.575;

    // MUTATE_SHAPE enabled: animate fog edge over time
    float edge = 0.1 + getNoiseFromVec3(v * 0.5 + float3(time * 0.03, time * 0.03, time * 0.03)) * 0.8;

    noise = (0.5 - abs(edge * (1.0 + noiseMod * 0.05) - noise)) * 2.0;
    return (smoothstep(1.0 - SHARPNESS * 2.0, 1.0 - SHARPNESS, noise * noise)
          + (1.0 - smoothstep(1.3, 0.6, noise))) * 0.2;
}

float3 nearPlanePoint(float2 v, float t) {
    return float3(v.x, NEAR_PLANE * (1.0 + sin(t * 0.2) * 0.4), v.y);
}

float3 fogMarch(float3 rayStart, float3 rayDirection, float t, float disMod) {
    float stepLen = RENDER_DISTANCE / (float)RAYS_COUNT;
    float3 fog = float3(0.0, 0.0, 0.0);
    float3 pt = rayStart;

    for (int i = 0; i < RAYS_COUNT; i++) {
        pt += rayDirection * stepLen;
        fog += volumetricFog(pt, disMod)
             * lerp(COLOR1, COLOR2 * (1.0 + disMod * 0.5),
                    getNoiseFromVec3((pt + float3(12.51, 52.167, 1.146)) * 0.5))
             * lerp(1.0, getNoiseFromVec3(pt * 40.0) * 2.0, DITHER)
             * getNoiseFromVec3(pt * 0.2 + 20.0) * 2.0;

        stepLen *= STEP_MODIFIER;
    }

    fog = (fog / (float)RAYS_COUNT)
        * (pow(getNoiseFromVec3(rayStart + rayDirection * RENDER_DISTANCE), 2.0) * 3.0
           + disMod * 0.5);

    return fog;
}

// Audio stripped - gentle time-based pulse as substitute
float getBeat() {
    return smoothstep(0.6, 0.9, pow(sin(time * 1.5) * 0.5 + 0.5, 4.0)) * 0.3;
}

// --- Entry point ---

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float musicVolume = getBeat();
    float2 res = resolution;
    float2 uv = (2.0 * fragCoord - res) / res.x;

    // Camera movement
    float3 cameraCenter = float3(
        sin(time * CAMERA_SPEED) * 10.0,
        time * CAMERA_SPEED * 10.0,
        cos(time * 0.78 * CAMERA_SPEED + 2.14) * 10.0);

    // Rotation matrix (GLSL column-major -> HLSL row-major transposed)
    float angleY = sin(time * CAMERA_ROTATION_SPEED * 2.0);
    float angleX = cos(time * 0.712 * CAMERA_ROTATION_SPEED);
    float angleZ = sin(time * 1.779 * CAMERA_ROTATION_SPEED);

    float3x3 rotX = float3x3(
        1, 0,            0,
        0, sin(angleX), -cos(angleX),
        0, cos(angleX),  sin(angleX));

    float3x3 rotZ = float3x3(
        sin(angleZ), -cos(angleZ), 0,
        cos(angleZ),  sin(angleZ), 0,
        0,            0,           1);

    float3x3 rotY = float3x3(
        sin(angleY),  0, -cos(angleY),
        0,            1,  0,
        cos(angleY),  0,  sin(angleY));

    float3x3 rotation = mul(rotX, mul(rotZ, rotY));

    float3 rayDirection = mul(rotation, normalize(nearPlanePoint(uv, time)));
    float3 rayStart = rayDirection * 0.2 + cameraCenter;

    // Jittering
    rayStart += rayDirection * (hash(float3(uv + 4.0, frac(time) + 2.0)) - 0.5) * JITTERING;

    float3 fog = fogMarch(rayStart, rayDirection, time, musicVolume);

    // Postprocess
    fog *= 2.5 * BRIGHTNESS;
    fog += 0.07 * lerp(COLOR1, COLOR2, 0.5);
    fog = sqrt(smoothstep(0.0, 1.5, fog));

    float3 color = fog * smoothstep(0.0, 10.0, time);

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_JaszUniverse() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 40, timeOffsetMax: 120}
}

_Shader_HLSL_MatrixRain() {
    return "
    (
// Matrix Rain — Shadertoy-style digital rain converted to HLSL.
// Original: https://www.shadertoy.com/view/ldccW4
// Author: Reinder
// License: CC BY-NC-SA 3.0

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

// Hash function for pseudo-random
float hash(float2 p) {
    float h = dot(p, float2(127.1, 311.7));
    return frac(sin(h) * 43758.5453);
}

// Character-like pattern (simplified glyph)
float charPattern(float2 uv, float id) {
    // Grid of dots/bars simulating matrix glyphs
    float2 g = frac(uv * float2(3.0, 4.0) + hash(float2(id, id * 0.7)) * 10.0);
    float d = step(0.3, g.x) * step(0.3, g.y);
    // Mix patterns based on ID
    float pattern2 = step(0.5, frac(sin(id * 91.7) * 437.5));
    float bar = step(0.4, g.x) * step(g.y, 0.8);
    return lerp(d, bar, pattern2);
}

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;
    float2 uv = fragCoord / resolution;

    // Grid parameters
    float colWidth = 14.0;  // pixels per column
    float rowHeight = 16.0; // pixels per row

    float col = floor(fragCoord.x / colWidth);
    float row = floor(fragCoord.y / rowHeight);

    // Per-column properties
    float colHash = hash(float2(col, 0.0));
    float speed = 2.0 + colHash * 4.0;        // Fall speed varies per column
    float offset = colHash * 100.0;             // Start offset
    float trailLen = 8.0 + colHash * 16.0;      // Trail length varies

    // Current position in the rain stream
    float rainPos = time * speed + offset;
    float headRow = frac(rainPos / 40.0) * (resolution.y / rowHeight + trailLen);

    // Distance from head of trail
    float dist = headRow - row;

    // Only draw if within trail
    if (dist < 0.0 || dist > trailLen) {
        return float4(0, 0, 0, 0);
    }

    // Brightness: bright at head, fading tail
    float brightness = 1.0 - (dist / trailLen);
    brightness = brightness * brightness; // Quadratic falloff

    // Head glow (first 2 chars are brighter/whiter)
    float headGlow = saturate(1.0 - dist * 0.5);

    // Character cell UV
    float2 cellUV = float2(frac(fragCoord.x / colWidth), frac(fragCoord.y / rowHeight));

    // Character ID changes over time (scrolling effect)
    float charId = hash(float2(col, floor(row + time * speed * 0.3)));

    // Character shape
    float ch = charPattern(cellUV, charId + floor(time * 2.0));

    // Color: green with white head
    float3 green = float3(0.1, 0.9, 0.3);
    float3 white = float3(0.8, 1.0, 0.85);
    float3 color = lerp(green, white, headGlow * 0.7);

    // Apply darken/desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Final alpha from character shape and trail brightness
    float alpha = ch * brightness * 0.9;

    // Slight column brightness variation
    alpha *= 0.6 + 0.4 * hash(float2(col * 7.3, 1.0));

    // Premultiplied alpha output for D2D compositing
    return float4(color * alpha, alpha);
}

    )"
}

_Shader_Meta_MatrixRain() {
    return {opacity: 0.50, iChannels: []}
}

_Shader_HLSL_ProteanClouds() {
    return "
    (
// Protean Clouds - Volumetric cloud raymarching with swirling motion
// Original: Protean clouds by nimitz (Shadertoy 3l23Rh)
// License: CC BY-NC-SA 3.0
// Mouse input removed; camera follows automated path.

cbuffer Constants : register(b0) {
    float time;
    float2 resolution;
    float timeDelta;
    uint frame;
    float darken;
    float desaturate;
    float _pad;
};

struct PSInput {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
};

// --- Globals set per-frame in PSMain ---
static float prm1;
static float2 bsMo;

// --- Helpers ---

// Rotation macro: GLSL mat2(cos(a+vec4(0,11,33,0))) with v*M convention.
// GLSL column-major → HLSL row-major transposed for mul(v, M).
float2x2 rot(float a) {
    float4 c = cos(a + float4(0, 11, 33, 0));
    return float2x2(c.x, c.z, c.y, c.w);
}

float linstep(float m, float M, float x) {
    return clamp((x - m) / (M - m), 0.0, 1.0);
}

float2 disp(float t) {
    return 2.0 * float2(sin(t * 0.22), cos(t * 0.175));
}

// GLSL mat3 column-major → HLSL row-major transposed for mul(v, M).
// Original columns: (.33338,.56034,-.71817), (-.87887,.32651,-.15323), (.15162,.69596,.61339)
static const float3x3 rotM3 = float3x3(
     0.33338, -0.87887,  0.15162,
     0.56034,  0.32651,  0.69596,
    -0.71817, -0.15323,  0.61339);

// --- Volumetric map ---

float2 map(float3 p) {
    float2 q = p.xy - disp(p.z);
    p.xy = mul(p.xy, rot(sin(p.z + time) * (0.1 + prm1 * 0.05) + time * 0.09));
    float d = 0.0, z = 1.0, trk = 1.0,
          dspAmp = 0.1 + prm1 * 0.2;

    p *= 0.61;
    for (int i = 0; i < 5; i++) {
        p += dspAmp * sin(trk * (p.zxy * 0.75 + time * 0.8));
        d -= z * abs(dot(cos(p), sin(p.yzx)));
        p = mul(p, rotM3) * 1.93;
        z *= 0.57;
        trk *= 1.4;
    }

    d = abs(d + prm1 * 3.0) + prm1 * 0.3 - 2.5 + bsMo.y;
    return float2(d + 0.25, 0.0) + dot(q, q) * float2(0.2, 1.0);
}

// --- Raymarcher ---

float4 render(float3 ro, float3 rd, float animTime) {
    float4 rez = (float4)0;
    float ldst = 8.0, t = 1.5, T = animTime + ldst, fogT = 0.0;
    float3 lpos = float3(disp(T) * 0.5, T);

    for (int i = 0; rez.a < 0.99 && i < 130; i++) {
        float3 pos = ro + t * rd;
        float2 mpv = map(pos);
        float den = clamp(mpv.x - 0.3, 0.0, 1.0) * 1.12,
              dn  = clamp(mpv.x + 2.0, 0.0, 3.0);

        float4 C = (float4)0;
        if (mpv.x > 0.6) {
            C = float4(sin(float3(5.0, 0.4, 0.2) + mpv.y * 0.1 + sin(pos.z * 0.4) * 0.5 + 1.8) * 0.5 + 0.5, 0.08);
            C *= den * den * den;
            C.rgb *= linstep(4.0, -2.5, mpv.x) * 2.3;
            float dif = clamp((den - map(pos + 0.8).x) / 9.0, 0.001, 1.0)
                      + clamp((den - map(pos + 0.35).x) / 2.5, 0.001, 1.0);
            C.xyz *= den * (float3(0.005, 0.045, 0.075) + 1.5 * dif * float3(0.033, 0.07, 0.03));
        }

        float fogC = exp(t * 0.2 - 2.2);
        C += float4(0.06, 0.11, 0.11, 0.1) * clamp(fogC - fogT, 0.0, 1.0);
        fogT = fogC;

        rez += C * (1.0 - rez.a);
        t += clamp(0.5 - dn * dn * 0.05, 0.09, 0.3);
    }
    return rez;
}

// --- Saturation-preserving interpolation ---

float getsat(float3 c) {
    float mx = max(max(c.x, c.y), c.z);
    if (mx <= 0.0) return 0.0;
    return 1.0 - min(min(c.x, c.y), c.z) / mx;
}

float3 iLerp(float3 a, float3 b, float x) {
    float3 ic = lerp(a, b, x);
    float lgt = dot(float3(1, 1, 1), ic),
          sd  = abs(getsat(ic) - lerp(getsat(a), getsat(b), x));
    float3 dir = normalize(ic * 3.0 - lgt);
    ic += 1.5 * dir * sd * lgt * dot(dir, normalize(ic));
    return ic;
}

// --- Entry point ---

float4 PSMain(PSInput input) : SV_Target {
    float2 fragCoord = input.pos.xy;

    float2 R = resolution;
    float2 q = fragCoord / R;
    float2 p = (fragCoord - 0.5 * R) / R.y;
    bsMo = (float2)0;
    prm1 = smoothstep(-0.4, 0.4, sin(time * 0.3));

    float animTime = time * 3.0,
          tgtDst   = 3.5,
          dspAmp   = 0.85;
    float3 P = float3(sin(time) * 0.5, 0.0, animTime);
    P.xy += disp(P.z) * dspAmp;

    float3 target    = normalize(P - float3(disp(animTime + tgtDst) * dspAmp, animTime + tgtDst)),
           rightdir  = normalize(cross(target, float3(0, 1, 0))),
           updir     = normalize(cross(rightdir, target)),
           rightdir2 = cross(updir, target),
           D         = normalize(p.x * rightdir2 + p.y * updir - target);
    D.xy = mul(D.xy, rot(-disp(animTime + 3.5).x * 0.2));

    float3 C = render(P, D, animTime).rgb;

    C = iLerp(C, C.bgr, min(prm1, 0.95));
    C = pow(C, float3(0.55, 0.65, 0.6)) * float3(1.0, 0.97, 0.9);
    C *= pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.12) * 0.7 + 0.3;

    float3 color = C;

    // Darken / desaturate post-processing
    float lum = dot(color, float3(0.299, 0.587, 0.114));
    color = lerp(color, float3(lum, lum, lum), desaturate);
    color = color * (1.0 - darken);

    // Alpha from brightness, premultiplied
    float a = max(color.r, max(color.g, color.b));
    return float4(color * a, a);
}

    )"
}

_Shader_Meta_ProteanClouds() {
    return {opacity: 0.50, iChannels: [], timeOffsetMin: 30, timeOffsetMax: 90, timeAccumulate: true}
}

