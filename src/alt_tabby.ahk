#Requires AutoHotkey v2.0
#SingleInstance Off  ; Multiple instances allowed for multi-process

;@Ahk2Exe-Base C:\Program Files\AutoHotkey\v2\AutoHotkey64.exe

; Ahk2Exe directives - customize exe metadata (removes AutoHotkey identification)
;@Ahk2Exe-SetDescription Alt-Tabby Window Switcher
;@Ahk2Exe-SetProductName Alt-Tabby
;@Ahk2Exe-SetCopyright Alt-Tabby
;@Ahk2Exe-SetOrigFilename AltTabby.exe
;@Ahk2Exe-SetCompanyName Alt-Tabby

; Version info - generated by compile.bat from VERSION file
; This file may not exist in dev mode (that's OK, GetAppVersion reads VERSION directly)
#Include *i version_info.ahk

; Embed resources - eliminates need for /img folder in compiled exe
; Icon is set via compile.bat /icon flag (becomes main exe icon)
; PNG is embedded as RCDATA resource with ID 10
;@Ahk2Exe-AddResource ..\img\logo.png, 10
;@Ahk2Exe-AddResource ..\img\icon.png, 11

; ============================================================
; Alt-Tabby - Unified Launcher & Mode Router
; ============================================================
; Usage:
;   alt_tabby.exe             - Launch GUI + Store (default)
;   alt_tabby.exe --store     - Run as WindowStore server
;   alt_tabby.exe --viewer    - Run as Debug Viewer
;   alt_tabby.exe --gui-only  - Run as GUI only (store must be running)
;   alt_tabby.exe --config    - Run Config Editor
;   alt_tabby.exe --blacklist - Run Blacklist Editor
;
; IMPORTANT: Mode flag is set BEFORE includes. Each module checks
; this flag and only initializes if it matches.
; ============================================================

; ============================================================
; MODE FLAG - SET BEFORE ANY INCLUDES!
; ============================================================
global g_AltTabbyMode := "launch"
global g_TestingMode := false  ; Skip wizard and install mismatch dialogs (for automated testing)
global g_SkipMismatchCheck := false  ; Skip mismatch dialog (after one-time elevation from mismatch)

for _, arg in A_Args {
    switch StrLower(arg) {
        case "--store":
            g_AltTabbyMode := "store"
            A_IconHidden := true  ; Hide tray icon IMMEDIATELY to minimize flicker
        case "--viewer":
            g_AltTabbyMode := "viewer"
            A_IconHidden := true
        case "--gui-only":
            g_AltTabbyMode := "gui"
            A_IconHidden := true
        case "--config":
            g_AltTabbyMode := "config"
            ; Config editor shows its own window, no tray icon needed
        case "--blacklist":
            g_AltTabbyMode := "blacklist"
            ; Blacklist editor shows its own window, no tray icon needed
        case "--wizard-continue":
            g_AltTabbyMode := "wizard-continue"
            ; Continue wizard after self-elevation (elevated instance)
        case "--enable-admin-task":
            g_AltTabbyMode := "enable-admin-task"
            ; Create admin task after self-elevation (from tray menu toggle)
        case "--apply-update":
            g_AltTabbyMode := "apply-update"
            ; Apply downloaded update after self-elevation
        case "--update-installed":
            g_AltTabbyMode := "update-installed"
            ; Update installed version after self-elevation (from mismatch detection)
        case "--repair-admin-task":
            g_AltTabbyMode := "repair-admin-task"
            ; Repair stale admin task after self-elevation
        case "--testing-mode":
            g_TestingMode := true
            A_IconHidden := true  ; No tray icon during automated testing
            ; Skip wizard and install mismatch dialogs (for automated testing)
        case "--skip-mismatch":
            g_SkipMismatchCheck := true
            ; Skip mismatch dialog (after one-time elevation from mismatch prompt)
    }
}

; Launcher mode globals (declared early, initialization happens after includes)
if (g_AltTabbyMode = "launch" || g_AltTabbyMode = "wizard-continue") {
    global g_StorePID := 0
    global g_GuiPID := 0
    global g_ViewerPID := 0
    global g_ConfigEditorPID := 0
    global g_BlacklistEditorPID := 0
    global g_MismatchDialogShown := false  ; Prevents auto-update race condition
}

; Note: Subprocess tray icon hiding is done immediately in arg parsing above
; to minimize flicker (A_IconHidden := true set as soon as mode detected)

; Note: Launcher initialization moved to after includes (needs ConfigLoader_Init)

; ============================================================
; INCLUDES
; ============================================================
; Use #Include <Dir> to set the include base directory before
; including each module, so relative paths resolve correctly.

; Shared libraries (from src/shared/)
#Include %A_ScriptDir%\shared\
#Include config_loader.ahk
#Include cjson.ahk
#Include ipc_pipe.ahk
#Include blacklist.ahk
#Include setup_utils.ahk
#Include process_utils.ahk
#Include win_utils.ahk
#Include pump_utils.ahk

; Editor subprocesses (from src/editors/)
#Include %A_ScriptDir%\editors\
#Include config_editor.ahk
#Include blacklist_editor.ahk

; Launcher module (from src/launcher/)
#Include %A_ScriptDir%\launcher\
#Include launcher_utils.ahk
#Include launcher_splash.ahk
#Include launcher_shortcuts.ahk
#Include launcher_install.ahk
#Include launcher_wizard.ahk
#Include launcher_about.ahk
#Include launcher_stats.ahk
#Include launcher_tray.ahk
#Include launcher_main.ahk

; Store module (from src/store/)
#Include %A_ScriptDir%\store\
#Include windowstore.ahk
#Include winenum_lite.ahk
#Include mru_lite.ahk
#Include komorebi_lite.ahk
#Include komorebi_sub.ahk
#Include icon_pump.ahk
#Include proc_pump.ahk
#Include winevent_hook.ahk
#Include store_server.ahk

; Viewer module (from src/viewer/)
#Include %A_ScriptDir%\viewer\
#Include viewer.ahk

; GUI module (from src/gui/)
#Include %A_ScriptDir%\gui\
#Include gui_gdip.ahk
#Include gui_win.ahk
#Include gui_overlay.ahk
#Include gui_workspace.ahk
#Include gui_paint.ahk
#Include gui_input.ahk
#Include gui_store.ahk
#Include gui_state.ahk
#Include gui_interceptor.ahk
#Include gui_main.ahk

; ============================================================
; CONFIG MODE HANDLER
; ============================================================
; Run config editor and exit when launched with --config
if (g_AltTabbyMode = "config") {
    launcherHwnd := 0
    for _, arg in A_Args {
        if (SubStr(arg, 1, 16) = "--launcher-hwnd=")
            launcherHwnd := Integer(SubStr(arg, 17))
    }
    ConfigEditor_Run(launcherHwnd)
    ExitApp()
}

; Run blacklist editor and exit when launched with --blacklist
if (g_AltTabbyMode = "blacklist") {
    BlacklistEditor_Run()
    ExitApp()
}

; ============================================================
; WIZARD-CONTINUE MODE (After Self-Elevation)
; ============================================================
if (g_AltTabbyMode = "wizard-continue") {
    ConfigLoader_Init()
    _Launcher_EnsureInstallationId()  ; Must be before WizardContinue (may create admin task)
    wizardResult := WizardContinue()

    if (wizardResult = "installed") {
        ; Installed to different location - new exe was launched, we exit
        ExitApp()
    } else if (wizardResult) {
        ; Wizard completed - launch normally (from same location)

        ; Acquire mutex before running as launcher
        ; Bug fix: Without this, wizard-continue could run alongside another launcher
        if (!_Launcher_AcquireMutex()) {
            MsgBox("Alt-Tabby is already running.", APP_NAME, "Icon!")
            ExitApp()
        }

        ; Show splash screen if enabled (skip in testing mode)
        if (cfg.LauncherShowSplash && !g_TestingMode)
            ShowSplashScreen()

        SetupLauncherTray()
        OnMessage(0x404, TrayIconClick)
        OnMessage(0x4A, _Launcher_OnCopyData)  ; WM_COPYDATA from child processes

        ; Register cleanup BEFORE launching subprocesses to prevent orphaned processes
        ; Safe to call early: handler guards all operations (try blocks, PID checks, mutex check)
        OnExit(_Launcher_OnExit)

        LaunchStore()
        Sleep(TIMING_SUBPROCESS_LAUNCH)
        LaunchGui()

        ; Hide splash after duration
        if (cfg.LauncherShowSplash && !g_TestingMode) {
            elapsed := A_TickCount - g_SplashStartTick
            remaining := cfg.LauncherSplashDurationMs - elapsed
            if (remaining > 0)
                Sleep(remaining)
            HideSplashScreen()
        }

        ; Auto-update check if enabled
        if (cfg.SetupAutoUpdateCheck)
            SetTimer(() => CheckForUpdates(false), -5000)

        Persistent()
    } else {
        ; No wizard data found - exit
        MsgBox("No wizard continuation data found.", APP_NAME, "Icon!")
        ExitApp()
    }
}

; ============================================================
; ENABLE-ADMIN-TASK MODE (After Self-Elevation from Tray Menu)
; ============================================================
if (g_AltTabbyMode = "enable-admin-task") {
    ConfigLoader_Init()
    _Launcher_EnsureInstallationId()  ; Must be before CreateAdminTask

    exePath := A_ScriptFullPath
    exeDir := ""
    SplitPath(exePath, , &exeDir)

    ; Warn if admin task would point to a temporary location
    if (!WarnIfTempLocation_AdminTask(exePath, exeDir)) {
        _AdminToggle_WriteResult("cancelled")
        ExitApp()
    }

    if (CreateAdminTask(exePath)) {
        cfg.SetupRunAsAdmin := true
        _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", true, false, "bool")
        RecreateShortcuts()  ; Update to point to schtasks
        _AdminToggle_WriteResult("ok")
    } else {
        _AdminToggle_WriteResult("failed")
    }

    ExitApp()
}

; ============================================================
; REPAIR-ADMIN-TASK MODE (After Self-Elevation for Stale Task)
; ============================================================
if (g_AltTabbyMode = "repair-admin-task") {
    ConfigLoader_Init()
    _Launcher_EnsureInstallationId()  ; Must be before CreateAdminTask

    ; Recreate task with current exe path
    exePath := A_ScriptFullPath
    DeleteAdminTask()
    if (CreateAdminTask(exePath)) {
        cfg.SetupRunAsAdmin := true
        _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", true, false, "bool")

        ; Update SetupExePath to current location (handles renamed exe case)
        cfg.SetupExePath := exePath
        try _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "ExePath", exePath, "", "string")

        ; Update shortcuts to point to new exe path
        RecreateShortcuts()

        TrayTip("Admin Mode Repaired", "Scheduled task and shortcuts updated.", "Iconi")

        ; Now launch via the repaired task
        Sleep(TIMING_TASK_READY_WAIT)  ; Brief pause for task to be ready
        exitCode := RunWait('schtasks /run /tn "Alt-Tabby"',, "Hide")

        if (exitCode != 0) {
            ; Task run failed - launch directly instead
            MsgBox("Task repaired but failed to launch (code " exitCode ").`nLaunching directly.", APP_NAME, "Icon!")
            Run('"' exePath '"')
        }
    } else {
        MsgBox("Failed to repair scheduled task.", APP_NAME, "Iconx")
        ; Fall back to direct launch
        Run('"' exePath '"')
    }
    ExitApp()
}

; ============================================================
; APPLY-UPDATE MODE (After Self-Elevation for Update)
; ============================================================
if (g_AltTabbyMode = "apply-update") {
    ConfigLoader_Init()  ; Required for admin task recreation in _Update_ApplyAndRelaunch
    ; Apply the downloaded update (we're now elevated)
    if (!_Update_ContinueFromElevation()) {
        MsgBox("Update continuation failed. Please try updating again.", APP_NAME, "Icon!")
    }
    ExitApp()
}

; ============================================================
; UPDATE-INSTALLED MODE (After Self-Elevation for Install Mismatch)
; ============================================================
if (g_AltTabbyMode = "update-installed") {
    ConfigLoader_Init()  ; Required for admin task recreation
    updateFile := A_Temp "\alttabby_install_update.txt"

    if (!FileExist(updateFile)) {
        MsgBox("Update information not found.", APP_NAME, "Icon!")
        ExitApp()
    }

    try {
        content := FileRead(updateFile, "UTF-8")
        FileDelete(updateFile)

        parts := StrSplit(content, UPDATE_INFO_DELIMITER)
        if (parts.Length != 2) {
            MsgBox("Invalid update information.", APP_NAME, "Icon!")
            ExitApp()
        }

        sourcePath := parts[1]
        targetPath := parts[2]

        ; Security validation: ensure paths are valid
        if (!FileExist(sourcePath)) {
            MsgBox("Update source file not found:`n" sourcePath, APP_NAME, "Icon!")
            ExitApp()
        }

        ; Validate target path looks like an Alt-Tabby executable
        ; Allow renamed exes (e.g., "alttabby v4.exe") as long as they contain "tabby"
        targetName := ""
        SplitPath(targetPath, &targetName)
        if (!RegExMatch(targetName, "i)\.exe$") || !InStr(StrLower(targetName), "tabby")) {
            MsgBox("Invalid update target path:`n" targetPath, APP_NAME, "Icon!")
            ExitApp()
        }

        _Launcher_DoUpdateInstalled(sourcePath, targetPath)
    } catch as e {
        MsgBox("Update failed:`n" e.Message, APP_NAME, "Icon!")
    }
    ExitApp()
}

; ============================================================
; LAUNCHER MODE INITIALIZATION
; ============================================================
; Must be after includes so we can use ConfigLoader_Init
if (g_AltTabbyMode = "launch") {
    ; Initialize config first
    ConfigLoader_Init()

    ; Run main launcher initialization
    Launcher_Init()
}
