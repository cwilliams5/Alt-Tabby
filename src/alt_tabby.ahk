#Requires AutoHotkey v2.0
#SingleInstance Off  ; Multiple instances allowed for multi-process

;@Ahk2Exe-Base C:\Program Files\AutoHotkey\v2\AutoHotkey64.exe

; Ahk2Exe directives - customize exe metadata (removes AutoHotkey identification)
;@Ahk2Exe-SetDescription Alt-Tabby Window Switcher
;@Ahk2Exe-SetProductName Alt-Tabby
;@Ahk2Exe-SetCopyright Alt-Tabby
;@Ahk2Exe-SetOrigFilename AltTabby.exe
;@Ahk2Exe-SetCompanyName Alt-Tabby

; Version info - generated by compile.bat from VERSION file
; This file may not exist in dev mode (that's OK, GetAppVersion reads VERSION directly)
#Include *i version_info.ahk

; Embed resources - eliminates need for /img folder in compiled exe
; Icon is set via compile.bat /icon flag (becomes main exe icon)
; PNG is embedded as RCDATA resource with ID 10
;@Ahk2Exe-AddResource ..\resources\img\logo.png, 10
;@Ahk2Exe-AddResource ..\resources\img\icon.png, 11
; Animation splash resources (WebP + DLLs)
;@Ahk2Exe-AddResource ..\resources\animation.webp, 15
;@Ahk2Exe-AddResource ..\resources\dll\libsharpyuv-0.dll, 16
;@Ahk2Exe-AddResource ..\resources\dll\libwebp-7.dll, 17
;@Ahk2Exe-AddResource ..\resources\dll\libwebpdemux-2.dll, 18
; WebView2 config editor resources
; NOTE: HTML uses .txt extension because Ahk2Exe silently fails to embed .html files
;@Ahk2Exe-AddResource ..\resources\dll\WebView2Loader.dll, 20
;@Ahk2Exe-AddResource ..\resources\html\config_editor.txt, 25

; ============================================================
; Alt-Tabby - Unified Launcher & Mode Router
; ============================================================
; Usage:
;   alt_tabby.exe             - Launch GUI + Store (default)
;   alt_tabby.exe --store     - Run as WindowStore server
;   alt_tabby.exe --viewer    - Run as Debug Viewer
;   alt_tabby.exe --gui-only  - Run as GUI only (store must be running)
;   alt_tabby.exe --config    - Run Config Editor
;   alt_tabby.exe --blacklist - Run Blacklist Editor
;
; IMPORTANT: Mode flag is set BEFORE includes. Each module checks
; this flag and only initializes if it matches.
; ============================================================

; ============================================================
; MODE FLAG - SET BEFORE ANY INCLUDES!
; ============================================================
global g_AltTabbyMode := "launch"
global g_TestingMode := false  ; Skip wizard and install mismatch dialogs (for automated testing)
global g_SkipMismatchCheck := false  ; Skip mismatch dialog (after one-time elevation from mismatch)

for _, arg in A_Args {
    switch StrLower(arg) {
        case "--store":
            g_AltTabbyMode := "store"
            A_IconHidden := true  ; Hide tray icon IMMEDIATELY to minimize flicker
        case "--viewer":
            g_AltTabbyMode := "viewer"
            A_IconHidden := true
        case "--gui-only":
            g_AltTabbyMode := "gui"
            A_IconHidden := true
        case "--config":
            g_AltTabbyMode := "config"
            A_IconHidden := true  ; Editors show their own window, no tray icon needed
        case "--blacklist":
            g_AltTabbyMode := "blacklist"
            A_IconHidden := true  ; Editors show their own window, no tray icon needed
        case "--wizard-continue":
            g_AltTabbyMode := "wizard-continue"
            ; Continue wizard after self-elevation (elevated instance)
        case "--enable-admin-task":
            g_AltTabbyMode := "enable-admin-task"
            ; Create admin task after self-elevation (from tray menu toggle)
        case "--apply-update":
            g_AltTabbyMode := "apply-update"
            ; Apply downloaded update after self-elevation
        case "--update-installed":
            g_AltTabbyMode := "update-installed"
            ; Update installed version after self-elevation (from mismatch detection)
        case "--repair-admin-task":
            g_AltTabbyMode := "repair-admin-task"
            ; Repair stale admin task after self-elevation
        case "--disable-admin-task":
            g_AltTabbyMode := "disable-admin-task"
            ; Delete admin task after self-elevation (from "Always run from here")
        case "--testing-mode":
            g_TestingMode := true
            A_IconHidden := true  ; No tray icon during automated testing
            ; Skip wizard and install mismatch dialogs (for automated testing)
        case "--skip-mismatch":
            g_SkipMismatchCheck := true
            ; Skip mismatch dialog (after one-time elevation from mismatch prompt)
    }
}

; Launcher mode globals (declared early, initialization happens after includes)
if (g_AltTabbyMode = "launch" || g_AltTabbyMode = "wizard-continue") {
    global g_StorePID := 0
    global g_GuiPID := 0
    global g_ViewerPID := 0
    global g_ConfigEditorPID := 0
    global g_BlacklistEditorPID := 0
    global g_MismatchDialogShown := false  ; Prevents auto-update race condition
}

; Note: Subprocess tray icon hiding is done immediately in arg parsing above
; to minimize flicker (A_IconHidden := true set as soon as mode detected)

; Note: Launcher initialization moved to after includes (needs ConfigLoader_Init)

; ============================================================
; INCLUDES
; ============================================================
; Use #Include <Dir> to set the include base directory before
; including each module, so relative paths resolve correctly.

; Third-party libraries (from src/lib/)
#Include %A_ScriptDir%\lib\
#Include cjson.ahk
#Include *i WebView2.ahk
#Include *i ComVar.ahk
#Include *i Promise.ahk

; Shared libraries (from src/shared/)
#Include %A_ScriptDir%\shared\
#Include config_loader.ahk
#Include gui_antiflash.ahk
#Include ipc_pipe.ahk
#Include blacklist.ahk
#Include setup_utils.ahk
#Include process_utils.ahk
#Include win_utils.ahk
#Include pump_utils.ahk
#Include resource_utils.ahk

; Editor subprocesses (from src/editors/)
#Include %A_ScriptDir%\editors\
#Include config_editor.ahk
#Include config_editor_native.ahk
#Include config_editor_webview.ahk
#Include blacklist_editor.ahk

; Launcher module (from src/launcher/)
#Include %A_ScriptDir%\launcher\
#Include launcher_utils.ahk
#Include launcher_splash.ahk
#Include launcher_shortcuts.ahk
#Include launcher_install.ahk
#Include launcher_wizard.ahk
#Include launcher_about.ahk
#Include launcher_stats.ahk
#Include launcher_tray.ahk
#Include launcher_main.ahk

; Store module (from src/store/)
#Include %A_ScriptDir%\store\
#Include windowstore.ahk
#Include winenum_lite.ahk
#Include mru_lite.ahk
#Include komorebi_lite.ahk
#Include komorebi_sub.ahk
#Include icon_pump.ahk
#Include proc_pump.ahk
#Include winevent_hook.ahk
#Include store_server.ahk

; Viewer module (from src/viewer/)
#Include %A_ScriptDir%\viewer\
#Include viewer.ahk

; GUI module (from src/gui/)
#Include %A_ScriptDir%\gui\
#Include gui_gdip.ahk
#Include gui_win.ahk
#Include gui_overlay.ahk
#Include gui_workspace.ahk
#Include gui_paint.ahk
#Include gui_input.ahk
#Include gui_store.ahk
#Include gui_state.ahk
#Include gui_interceptor.ahk
#Include gui_main.ahk

; ============================================================
; CONFIG MODE HANDLER
; ============================================================
; Run config editor and exit when launched with --config
; Supports --force-native flag to skip WebView2 and use AHK GUI
if (g_AltTabbyMode = "config") {
    global ARG_LAUNCHER_HWND, ARG_LAUNCHER_HWND_LEN
    launcherHwnd := 0
    forceNative := false
    for _, arg in A_Args {
        if (SubStr(arg, 1, ARG_LAUNCHER_HWND_LEN) = ARG_LAUNCHER_HWND)
            launcherHwnd := Integer(SubStr(arg, ARG_LAUNCHER_HWND_LEN + 1))
        else if (arg = "--force-native")
            forceNative := true
    }
    ConfigEditor_Run(launcherHwnd, forceNative)
    ExitApp()
}

; Run blacklist editor and exit when launched with --blacklist
if (g_AltTabbyMode = "blacklist") {
    BlacklistEditor_Run()
    ExitApp()
}

; ============================================================
; WIZARD-CONTINUE MODE (After Self-Elevation)
; ============================================================
if (g_AltTabbyMode = "wizard-continue") {
    ConfigLoader_Init()
    _Launcher_EnsureInstallationId()  ; Must be before WizardContinue (may create admin task)
    wizardResult := WizardContinue()

    if (wizardResult = "installed") {
        ; Installed to different location - new exe was launched, we exit
        ExitApp()
    } else if (wizardResult) {
        ; Wizard completed - launch normally (from same location)

        ; Acquire mutex before running as launcher
        ; Bug fix: Without this, wizard-continue could run alongside another launcher
        if (!_Launcher_AcquireMutex()) {
            MsgBox("Alt-Tabby is already running.", APP_NAME, "Iconi")
            ExitApp()
        }

        ; Acquire system-wide active mutex before launching subprocesses
        ; Skip in testing mode to allow parallel test execution
        if (!g_TestingMode && !_Launcher_AcquireActiveMutex()) {
            result := MsgBox(
                "Another Alt-Tabby installation is already running.`n`n"
                "Only one installation can be active at a time.`n"
                "Close the other installation and try again?",
                APP_NAME,
                "YesNo Iconx"
            )
            if (result = "Yes") {
                _Launcher_KillAllAltTabbyProcesses()
                Sleep(TIMING_MUTEX_RELEASE_WAIT)
                if (!_Launcher_AcquireActiveMutex()) {
                    MsgBox("Could not acquire active lock.`nPlease close Alt-Tabby manually and try again.", APP_NAME, "Iconx")
                    ExitApp()
                }
            } else {
                ExitApp()
            }
        }

        ; Show splash screen if enabled (skip in testing mode)
        if (cfg.LauncherSplashScreen != "None" && !g_TestingMode)
            ShowSplashScreen()

        SetupLauncherTray()
        OnMessage(WM_TRAYICON, TrayIconClick)
        OnMessage(WM_COPYDATA, _Launcher_OnCopyData)  ; WM_COPYDATA from child processes

        ; Register cleanup BEFORE launching subprocesses to prevent orphaned processes
        ; Safe to call early: handler guards all operations (try blocks, PID checks, mutex check)
        OnExit(_Launcher_OnExit)

        LaunchStore()
        Sleep(TIMING_SUBPROCESS_LAUNCH)
        LaunchGui()

        ; Hide splash after duration/loops complete
        if (cfg.LauncherSplashScreen != "None" && !g_TestingMode) {
            if (cfg.LauncherSplashScreen = "Image") {
                ; Image mode: wait for configured duration
                elapsed := A_TickCount - g_SplashStartTick
                remaining := cfg.LauncherSplashImageDurationMs - elapsed
                if (remaining > 0)
                    Sleep(remaining)
                HideSplashScreen()
            } else if (cfg.LauncherSplashScreen = "Animation") {
                ; Animation mode: wait for animation to complete its loops
                maxLoops := cfg.LauncherSplashAnimLoops
                if (maxLoops > 0) {
                    ; Poll until animation completes (loop count reached or window destroyed)
                    while (IsSplashActive()) {
                        Sleep(100)
                    }
                }
                ; Always call HideSplashScreen to ensure cleanup
                HideSplashScreen()
            }
        }

        ; Auto-update check if enabled
        if (cfg.SetupAutoUpdateCheck)
            SetTimer(() => CheckForUpdates(false), -5000)

        Persistent()
    } else {
        ; No wizard data found - exit
        MsgBox("No wizard continuation data found.", APP_NAME, "Iconx")
        ExitApp()
    }
}

; ============================================================
; ENABLE-ADMIN-TASK MODE (After Self-Elevation from Tray Menu)
; ============================================================
if (g_AltTabbyMode = "enable-admin-task") {
    ConfigLoader_Init()
    _Launcher_EnsureInstallationId()  ; Must be before CreateAdminTask

    exePath := A_ScriptFullPath
    exeDir := ""
    SplitPath(exePath, , &exeDir)

    ; Warn if admin task would point to a temporary location
    if (!WarnIfTempLocation_AdminTask(exePath, exeDir)) {
        _AdminToggle_WriteResult("cancelled")
        ExitApp()
    }

    if (CreateAdminTask(exePath)) {
        cfg.SetupRunAsAdmin := true
        _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", true, false, "bool")
        RecreateShortcuts()  ; Update to point to schtasks
        _AdminToggle_WriteResult("ok")
    } else {
        _AdminToggle_WriteResult("failed")
    }

    ExitApp()
}

; ============================================================
; REPAIR-ADMIN-TASK MODE (After Self-Elevation for Stale Task)
; ============================================================
if (g_AltTabbyMode = "repair-admin-task") {
    ConfigLoader_Init()
    _Launcher_EnsureInstallationId()  ; Must be before CreateAdminTask

    ; Recreate task with current exe path
    exePath := A_ScriptFullPath
    DeleteAdminTask()
    if (CreateAdminTask(exePath)) {
        cfg.SetupRunAsAdmin := true
        _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", true, false, "bool")

        ; Update SetupExePath to current location (handles renamed exe case)
        cfg.SetupExePath := exePath
        try _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "ExePath", exePath, "", "string")

        ; Update shortcuts to point to new exe path
        RecreateShortcuts()

        TrayTip("Admin Mode Repaired", "Scheduled task and shortcuts updated.", "Iconi")

        ; Now launch via the repaired task
        Sleep(TIMING_TASK_READY_WAIT)  ; Brief pause for task to be ready
        exitCode := RunWait('schtasks /run /tn "Alt-Tabby"',, "Hide")

        if (exitCode != 0) {
            ; Task run failed - launch directly instead
            MsgBox("Task repaired but failed to launch (code " exitCode ").`nLaunching directly.", APP_NAME, "Icon!")
            Run('"' exePath '"')
        }
    } else {
        MsgBox("Failed to repair scheduled task.", APP_NAME, "Iconx")
        ; Fall back to direct launch
        Run('"' exePath '"')
    }
    ExitApp()
}

; ============================================================
; DISABLE-ADMIN-TASK MODE (After Self-Elevation from "Always run from here")
; ============================================================
if (g_AltTabbyMode = "disable-admin-task") {
    ConfigLoader_Init()

    ; Delete the admin task
    if (AdminTaskExists()) {
        DeleteAdminTask()
        cfg.SetupRunAsAdmin := false
        try _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", false, false, "bool")
    }
    ; Silently exit - the non-elevated caller will continue
    ExitApp()
}

; ============================================================
; APPLY-UPDATE MODE (After Self-Elevation for Update)
; ============================================================
if (g_AltTabbyMode = "apply-update") {
    ConfigLoader_Init()  ; Required for admin task recreation in _Update_ApplyAndRelaunch
    ; Apply the downloaded update (we're now elevated)
    if (!_Update_ContinueFromElevation()) {
        MsgBox("Update continuation failed. Please try updating again.", APP_NAME, "Iconx")
        ; Attempt to relaunch the current exe (rollback should have restored it)
        ; This ensures user doesn't end up with no running instance after failed update
        if (FileExist(A_ScriptFullPath)) {
            try Run('"' A_ScriptFullPath '"')
        }
    }
    ExitApp()
}

; ============================================================
; UPDATE-INSTALLED MODE (After Self-Elevation for Install Mismatch)
; ============================================================
if (g_AltTabbyMode = "update-installed") {
    ConfigLoader_Init()  ; Required for admin task recreation
    updateFile := A_Temp "\alttabby_install_update.txt"

    if (!FileExist(updateFile)) {
        MsgBox("Update information not found.", APP_NAME, "Iconx")
        ExitApp()
    }

    try {
        content := FileRead(updateFile, "UTF-8")
        FileDelete(updateFile)

        parts := StrSplit(content, UPDATE_INFO_DELIMITER)
        if (parts.Length != 2) {
            MsgBox("Invalid update information.", APP_NAME, "Iconx")
            ExitApp()
        }

        sourcePath := parts[1]
        targetPath := parts[2]

        ; Security validation: ensure paths are valid
        if (!FileExist(sourcePath)) {
            MsgBox("Update source file not found:`n" sourcePath, APP_NAME, "Iconx")
            ExitApp()
        }

        ; Validate target path looks like an Alt-Tabby executable
        ; Allow renamed exes (e.g., "alttabby v4.exe") as long as they contain "tabby"
        targetName := ""
        SplitPath(targetPath, &targetName)
        if (!RegExMatch(targetName, "i)\.exe$") || !InStr(StrLower(targetName), "tabby")) {
            MsgBox("Invalid update target path:`n" targetPath, APP_NAME, "Iconx")
            ExitApp()
        }

        _Launcher_DoUpdateInstalled(sourcePath, targetPath)
    } catch as e {
        MsgBox("Update failed:`n" e.Message, APP_NAME, "Iconx")
    }
    ExitApp()
}

; ============================================================
; LAUNCHER MODE INITIALIZATION
; ============================================================
; Must be after includes so we can use ConfigLoader_Init
if (g_AltTabbyMode = "launch") {
    ; Initialize config first
    ConfigLoader_Init()

    ; Run main launcher initialization
    Launcher_Init()
}
