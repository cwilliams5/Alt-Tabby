#Requires AutoHotkey v2.0
#SingleInstance Off  ; Multiple instances allowed for multi-process

;@Ahk2Exe-Base C:\Program Files\AutoHotkey\v2\AutoHotkey64.exe

; Ahk2Exe directives - customize exe metadata (removes AutoHotkey identification)
;@Ahk2Exe-SetDescription Alt-Tabby Window Switcher
;@Ahk2Exe-SetProductName Alt-Tabby
;@Ahk2Exe-SetCopyright Alt-Tabby
;@Ahk2Exe-SetOrigFilename AltTabby.exe
;@Ahk2Exe-SetCompanyName Alt-Tabby

; Version info - generated by compile.bat from VERSION file
; This file may not exist in dev mode (that's OK, GetAppVersion reads VERSION directly)
#Include *i version_info.ahk

; Embed resources - eliminates need for /img folder in compiled exe
; Icon is set via compile.bat /icon flag (becomes main exe icon)
; PNG is embedded as RCDATA resource with ID 10
;@Ahk2Exe-AddResource ..\img\logo.png, 10

; ============================================================
; Alt-Tabby - Unified Launcher & Mode Router
; ============================================================
; Usage:
;   alt_tabby.exe             - Launch GUI + Store (default)
;   alt_tabby.exe --store     - Run as WindowStore server
;   alt_tabby.exe --viewer    - Run as Debug Viewer
;   alt_tabby.exe --gui-only  - Run as GUI only (store must be running)
;   alt_tabby.exe --config    - Run Config Editor
;   alt_tabby.exe --blacklist - Run Blacklist Editor
;
; IMPORTANT: Mode flag is set BEFORE includes. Each module checks
; this flag and only initializes if it matches.
; ============================================================

; ============================================================
; MODE FLAG - SET BEFORE ANY INCLUDES!
; ============================================================
global g_AltTabbyMode := "launch"
global g_SkipWizard := false

for _, arg in A_Args {
    switch StrLower(arg) {
        case "--store":
            g_AltTabbyMode := "store"
            A_IconHidden := true  ; Hide tray icon IMMEDIATELY to minimize flicker
        case "--viewer":
            g_AltTabbyMode := "viewer"
            A_IconHidden := true
        case "--gui-only":
            g_AltTabbyMode := "gui"
            A_IconHidden := true
        case "--config":
            g_AltTabbyMode := "config"
            ; Config editor shows its own window, no tray icon needed
        case "--blacklist":
            g_AltTabbyMode := "blacklist"
            ; Blacklist editor shows its own window, no tray icon needed
        case "--wizard-continue":
            g_AltTabbyMode := "wizard-continue"
            ; Continue wizard after self-elevation (elevated instance)
        case "--enable-admin-task":
            g_AltTabbyMode := "enable-admin-task"
            ; Create admin task after self-elevation (from tray menu toggle)
        case "--apply-update":
            g_AltTabbyMode := "apply-update"
            ; Apply downloaded update after self-elevation
        case "--update-installed":
            g_AltTabbyMode := "update-installed"
            ; Update installed version after self-elevation (from mismatch detection)
        case "--skip-wizard":
            g_SkipWizard := true
            ; Skip first-run wizard (for automated testing)
    }
}

; Launcher mode globals (declared early, initialization happens after includes)
if (g_AltTabbyMode = "launch" || g_AltTabbyMode = "wizard-continue") {
    global g_StorePID := 0
    global g_GuiPID := 0
    global g_ViewerPID := 0
    ; Splash screen globals
    global g_SplashHwnd := 0
    global g_SplashStartTick := 0
    global g_SplashBitmap := 0
    global g_SplashHdc := 0
    global g_SplashHdcScreen := 0
    global g_SplashToken := 0
    global g_SplashHModule := 0
    global g_SplashImgW := 0
    global g_SplashImgH := 0
    global g_SplashPosX := 0
    global g_SplashPosY := 0
    global g_SplashDIB := 0  ; DIB bitmap handle (must be deleted to avoid leak)
    ; First-run wizard globals
    global g_WizardGui := 0
}

; Note: Subprocess tray icon hiding is done immediately in arg parsing above
; to minimize flicker (A_IconHidden := true set as soon as mode detected)

; Note: Launcher initialization moved to after includes (needs ConfigLoader_Init)

; ============================================================
; INCLUDES
; ============================================================
; Use #Include <Dir> to set the include base directory before
; including each module, so relative paths resolve correctly.

; Shared libraries (from src/shared/)
#Include %A_ScriptDir%\shared\
#Include config_loader.ahk
#Include config_editor.ahk
#Include blacklist_editor.ahk
#Include json.ahk
#Include ipc_pipe.ahk
#Include blacklist.ahk
#Include setup_utils.ahk

; Store module (from src/store/)
#Include %A_ScriptDir%\store\
#Include windowstore.ahk
#Include winenum_lite.ahk
#Include mru_lite.ahk
#Include komorebi_lite.ahk
#Include komorebi_sub.ahk
#Include icon_pump.ahk
#Include proc_pump.ahk
#Include winevent_hook.ahk
#Include store_server.ahk

; Viewer module (from src/viewer/)
#Include %A_ScriptDir%\viewer\
#Include viewer.ahk

; GUI module (from src/gui/)
#Include %A_ScriptDir%\gui\
#Include gui_gdip.ahk
#Include gui_win.ahk
#Include gui_overlay.ahk
#Include gui_workspace.ahk
#Include gui_paint.ahk
#Include gui_input.ahk
#Include gui_store.ahk
#Include gui_state.ahk
#Include gui_interceptor.ahk
#Include gui_main.ahk

; ============================================================
; CONFIG MODE HANDLER
; ============================================================
; Run config editor and exit when launched with --config
if (g_AltTabbyMode = "config") {
    ConfigEditor_Run(false)  ; false = standalone mode, show "restart needed" message
    ExitApp()
}

; Run blacklist editor and exit when launched with --blacklist
if (g_AltTabbyMode = "blacklist") {
    BlacklistEditor_Run()
    ExitApp()
}

; ============================================================
; WIZARD-CONTINUE MODE (After Self-Elevation)
; ============================================================
if (g_AltTabbyMode = "wizard-continue") {
    ConfigLoader_Init()
    if (WizardContinue()) {
        ; Wizard completed - launch normally

        ; Show splash screen if enabled
        if (cfg.LauncherShowSplash)
            ShowSplashScreen()

        SetupLauncherTray()
        OnMessage(0x404, TrayIconClick)
        LaunchStore()
        Sleep(300)
        LaunchGui()

        ; Hide splash after duration
        if (cfg.LauncherShowSplash) {
            elapsed := A_TickCount - g_SplashStartTick
            remaining := cfg.LauncherSplashDurationMs - elapsed
            if (remaining > 0)
                Sleep(remaining)
            HideSplashScreen()
        }

        ; Auto-update check if enabled
        if (cfg.SetupAutoUpdateCheck)
            SetTimer(() => CheckForUpdates(false), -5000)

        Persistent()
    } else {
        ; No wizard data found - exit
        MsgBox("No wizard continuation data found.", "Alt-Tabby", "Icon!")
        ExitApp()
    }
}

; ============================================================
; ENABLE-ADMIN-TASK MODE (After Self-Elevation from Tray Menu)
; ============================================================
if (g_AltTabbyMode = "enable-admin-task") {
    ConfigLoader_Init()

    exePath := _Shortcut_GetEffectiveExePath()
    if (CreateAdminTask(exePath)) {
        cfg.SetupRunAsAdmin := true
        _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", true, false, "bool")
        RecreateShortcuts()  ; Update to point to schtasks
        TrayTip("Admin Mode Enabled", "Alt-Tabby will now run with administrator privileges.", "Iconi")
    } else {
        MsgBox("Failed to create scheduled task.", "Alt-Tabby", "Iconx")
    }
    ExitApp()
}

; ============================================================
; APPLY-UPDATE MODE (After Self-Elevation for Update)
; ============================================================
if (g_AltTabbyMode = "apply-update") {
    ; Apply the downloaded update (we're now elevated)
    if (!_Update_ContinueFromElevation()) {
        MsgBox("Update continuation failed. Please try updating again.", "Alt-Tabby", "Icon!")
    }
    ExitApp()
}

; ============================================================
; UPDATE-INSTALLED MODE (After Self-Elevation for Install Mismatch)
; ============================================================
if (g_AltTabbyMode = "update-installed") {
    updateFile := A_Temp "\alttabby_install_update.txt"

    if (!FileExist(updateFile)) {
        MsgBox("Update information not found.", "Alt-Tabby", "Icon!")
        ExitApp()
    }

    try {
        content := FileRead(updateFile, "UTF-8")
        FileDelete(updateFile)

        parts := StrSplit(content, "|")
        if (parts.Length != 2) {
            MsgBox("Invalid update information.", "Alt-Tabby", "Icon!")
            ExitApp()
        }

        sourcePath := parts[1]
        targetPath := parts[2]
        _Launcher_DoUpdateInstalled(sourcePath, targetPath)
    } catch as e {
        MsgBox("Update failed:`n" e.Message, "Alt-Tabby", "Icon!")
    }
    ExitApp()
}

; ============================================================
; LAUNCHER MODE INITIALIZATION
; ============================================================
; Must be after includes so we can use ConfigLoader_Init
if (g_AltTabbyMode = "launch") {
    ; Initialize config to get splash settings
    ConfigLoader_Init()

    ; Check if running from different location than installed version
    ; (e.g., user downloaded new version and ran from Downloads)
    _Launcher_CheckInstallMismatch()

    ; Check if another launcher is already running (named mutex)
    if (!_Launcher_AcquireMutex()) {
        result := MsgBox(
            "Alt-Tabby is already running.`n`n"
            "Would you like to restart it?",
            "Alt-Tabby",
            "YesNo Icon?"
        )
        if (result = "Yes") {
            _Launcher_KillExistingInstances()
            Sleep(500)  ; Wait for mutex to be released
            if (!_Launcher_AcquireMutex()) {
                MsgBox("Could not restart Alt-Tabby. Please try again.", "Alt-Tabby", "Icon!")
                ExitApp()
            }
            ; Continue with normal startup below
        } else {
            ExitApp()
        }
    }

    ; Clean up old exe from previous update
    _Update_CleanupOldExe()

    ; Check if we should redirect to scheduled task (admin mode)
    if (_ShouldRedirectToScheduledTask()) {
        Run('schtasks /run /tn "Alt-Tabby"',, "Hide")
        ExitApp()
    }

    ; Check for first-run (config exists but FirstRunCompleted is false)
    configPath := A_IsCompiled ? A_ScriptDir "\config.ini" : A_ScriptDir "\..\config.ini"
    if (!cfg.SetupFirstRunCompleted && !g_SkipWizard) {
        ; Show first-run wizard
        ShowFirstRunWizard()
        ; If wizard was shown and exited (self-elevated), we exit here
        ; Otherwise continue to normal startup
    }

    ; Show splash screen if enabled
    if (cfg.LauncherShowSplash)
        ShowSplashScreen()

    ; Set up tray with on-demand menu updates
    SetupLauncherTray()
    OnMessage(0x404, TrayIconClick)  ; WM_TRAYICON

    ; Launch store and GUI
    LaunchStore()
    Sleep(300)
    LaunchGui()

    ; Hide splash after duration (or immediately if duration is 0)
    if (cfg.LauncherShowSplash) {
        ; Calculate remaining time after launches
        elapsed := A_TickCount - g_SplashStartTick
        remaining := cfg.LauncherSplashDurationMs - elapsed
        if (remaining > 0)
            Sleep(remaining)
        HideSplashScreen()
    }

    ; Auto-update check if enabled
    if (cfg.SetupAutoUpdateCheck)
        SetTimer(() => CheckForUpdates(false), -5000)

    ; Stay alive to manage subprocesses
    Persistent()
}

; ============================================================
; LAUNCHER FUNCTIONS
; ============================================================

; Check if we should redirect to scheduled task instead of running directly
; Returns true if: admin mode enabled, task exists, and we're NOT already elevated
_ShouldRedirectToScheduledTask() {
    global cfg

    ; Only redirect if:
    ; 1. Admin mode is enabled in config
    ; 2. The scheduled task actually exists
    ; 3. We're NOT already running as admin (avoid infinite loop)
    if (!cfg.SetupRunAsAdmin)
        return false
    if (!AdminTaskExists())
        return false
    if (A_IsAdmin)
        return false  ; Already elevated, don't redirect

    return true
}

; Try to acquire the launcher mutex
; Returns true if acquired (we're the only launcher), false if already held
global g_LauncherMutex := 0

_Launcher_AcquireMutex() {
    global g_LauncherMutex

    ; Try to create named mutex
    g_LauncherMutex := DllCall("CreateMutex", "ptr", 0, "int", 1, "str", "AltTabby_Launcher", "ptr")
    lastError := DllCall("GetLastError")

    ; ERROR_ALREADY_EXISTS = 183
    if (lastError = 183) {
        ; Mutex already exists - another launcher is running
        if (g_LauncherMutex) {
            DllCall("CloseHandle", "ptr", g_LauncherMutex)
            g_LauncherMutex := 0
        }
        return false
    }

    return (g_LauncherMutex != 0)
}

; Kill all existing AltTabby.exe processes except ourselves
_Launcher_KillExistingInstances() {
    myPID := ProcessExist()  ; Get our own PID

    ; Find and kill all AltTabby.exe processes
    for proc in ComObject("WinMgmts:").ExecQuery("SELECT ProcessId FROM Win32_Process WHERE Name='AltTabby.exe'") {
        pid := proc.ProcessId
        if (pid != myPID) {
            ProcessClose(pid)
        }
    }
}

; Check if we're running from a different location than the installed version
; Offers to update or launch the installed version
_Launcher_CheckInstallMismatch() {
    global cfg

    ; Only relevant for compiled exe
    if (!A_IsCompiled)
        return

    ; Check if we have an installed path recorded
    if (!cfg.HasOwnProp("SetupExePath") || cfg.SetupExePath = "")
        return

    installedPath := cfg.SetupExePath
    currentPath := A_ScriptFullPath

    ; Normalize paths for comparison (case-insensitive)
    if (StrLower(installedPath) = StrLower(currentPath))
        return  ; Running from installed location, all good

    ; Check if installed exe actually exists
    if (!FileExist(installedPath))
        return  ; Installed exe is gone, continue normally

    ; Get versions
    currentVersion := GetAppVersion()
    try {
        installedVersion := FileGetVersion(installedPath)
    } catch {
        installedVersion := "0.0.0"
    }

    versionCompare := CompareVersions(currentVersion, installedVersion)

    if (versionCompare > 0) {
        ; Current version is NEWER than installed
        result := MsgBox(
            "Alt-Tabby is installed at:`n" installedPath "`n`n"
            "You're running a newer version (" currentVersion " vs " installedVersion ").`n`n"
            "Update the installed version?",
            "Alt-Tabby - Update Installed Version?",
            "YesNo Icon?"
        )

        if (result = "Yes") {
            _Launcher_UpdateInstalledVersion(installedPath)
            ; If we return, update failed - continue running from current location
        }
        ; "No" - continue running from current location
    } else {
        ; Current version is SAME or OLDER than installed
        result := MsgBox(
            "Alt-Tabby is already installed at:`n" installedPath "`n`n"
            "Launch the installed version instead?",
            "Alt-Tabby - Already Installed",
            "YesNo Icon?"
        )

        if (result = "Yes") {
            ; Launch installed version and exit
            try {
                Run('"' installedPath '"')
                ExitApp()
            } catch as e {
                MsgBox("Could not launch installed version:`n" e.Message, "Alt-Tabby", "Icon!")
            }
        }
        ; "No" - continue running from current location
    }
}

; Update the installed version with the current exe
_Launcher_UpdateInstalledVersion(installedPath) {
    global cfg, gConfigIniPath

    installedDir := ""
    SplitPath(installedPath, , &installedDir)

    ; Check if we need elevation
    if (_Update_NeedsElevation(installedDir)) {
        ; Save update info and self-elevate
        updateInfo := A_ScriptFullPath "|" installedPath
        updateFile := A_Temp "\alttabby_install_update.txt"
        try FileDelete(updateFile)
        FileAppend(updateInfo, updateFile, "UTF-8")

        try {
            Run('*RunAs "' A_ScriptFullPath '" --update-installed')
            ExitApp()
        } catch {
            MsgBox("Update requires administrator privileges.", "Alt-Tabby", "Icon!")
            try FileDelete(updateFile)
            return
        }
    }

    ; Apply update directly
    _Launcher_DoUpdateInstalled(A_ScriptFullPath, installedPath)
}

; Actually perform the update (called directly or after elevation)
_Launcher_DoUpdateInstalled(sourcePath, targetPath) {
    targetDir := ""
    SplitPath(targetPath, , &targetDir)
    backupPath := targetPath ".old"

    try {
        ; Kill all other AltTabby.exe processes (store, gui, viewer)
        ; This releases file locks so we can rename/delete the exe
        _Update_KillOtherProcesses()
        Sleep(500)  ; Give processes time to fully exit

        ; Remove any previous backup
        if (FileExist(backupPath))
            FileDelete(backupPath)

        ; Backup current installed version
        FileMove(targetPath, backupPath)

        ; Copy new version
        FileCopy(sourcePath, targetPath)

        ; Success - launch from installed location and exit
        TrayTip("Update Complete", "Alt-Tabby has been updated at:`n" targetPath, "Iconi")
        Sleep(1000)

        ; Schedule cleanup of .old file after we exit
        ; The ping command adds a ~1 second delay for our process to fully exit
        cleanupCmd := 'cmd.exe /c ping 127.0.0.1 -n 2 > nul && del "' backupPath '"'
        Run(cleanupCmd,, "Hide")

        Run('"' targetPath '"')
        ExitApp()

    } catch as e {
        ; Try to restore backup
        if (!FileExist(targetPath) && FileExist(backupPath)) {
            try FileMove(backupPath, targetPath)
        }
        MsgBox("Update failed:`n" e.Message, "Alt-Tabby", "Icon!")
    }
}

LaunchStore() {
    global g_StorePID
    if (A_IsCompiled) {
        Run('"' A_ScriptFullPath '" --store', , , &g_StorePID)
    } else {
        Run('"' A_AhkPath '" "' A_ScriptDir '\store\store_server.ahk"', , , &g_StorePID)
    }
}

LaunchGui() {
    global g_GuiPID
    if (A_IsCompiled) {
        Run('"' A_ScriptFullPath '" --gui-only', , , &g_GuiPID)
    } else {
        Run('"' A_AhkPath '" "' A_ScriptDir '\gui\gui_main.ahk"', , , &g_GuiPID)
    }
}

LaunchViewer() {
    global g_ViewerPID
    if (A_IsCompiled) {
        Run('"' A_ScriptFullPath '" --viewer', , , &g_ViewerPID)
    } else {
        Run('"' A_AhkPath '" "' A_ScriptDir '\viewer\viewer.ahk"', , , &g_ViewerPID)
    }
}

; ============================================================
; SPLASH SCREEN (Transparent PNG with fade in/out)
; ============================================================

ShowSplashScreen() {
    global g_SplashHwnd, g_SplashStartTick, g_SplashBitmap, g_SplashHdc, g_SplashToken
    global g_SplashHdcScreen, g_SplashImgW, g_SplashImgH, g_SplashPosX, g_SplashPosY, g_SplashHModule
    global g_SplashDIB, cfg

    g_SplashStartTick := A_TickCount

    ; Load GDI+ library first (required before GdiplusStartup)
    g_SplashHModule := DllCall("LoadLibrary", "str", "gdiplus", "ptr")
    if (!g_SplashHModule)
        return

    ; Start GDI+
    si := Buffer(A_PtrSize = 8 ? 24 : 16, 0)
    NumPut("UInt", 1, si, 0)
    g_SplashToken := 0
    DllCall("gdiplus\GdiplusStartup", "ptr*", &g_SplashToken, "ptr", si.Ptr, "ptr", 0)
    if (!g_SplashToken) {
        DllCall("FreeLibrary", "ptr", g_SplashHModule)
        g_SplashHModule := 0
        return
    }

    ; Load PNG - from embedded resource (compiled) or file (dev mode)
    g_SplashBitmap := 0
    if (A_IsCompiled) {
        ; Load from embedded resource (ID 10, RT_RCDATA=10)
        g_SplashBitmap := _LoadBitmapFromResource(10)
    } else {
        ; Dev mode: load from file
        imgPath := A_ScriptDir "\..\img\logo.png"
        if (FileExist(imgPath))
            DllCall("gdiplus\GdipCreateBitmapFromFile", "wstr", imgPath, "ptr*", &g_SplashBitmap)
    }

    if (!g_SplashBitmap) {
        DllCall("gdiplus\GdiplusShutdown", "uptr", g_SplashToken)
        DllCall("FreeLibrary", "ptr", g_SplashHModule)
        g_SplashToken := 0
        g_SplashHModule := 0
        return
    }

    ; Get image dimensions
    g_SplashImgW := 0, g_SplashImgH := 0
    DllCall("gdiplus\GdipGetImageWidth", "ptr", g_SplashBitmap, "uint*", &g_SplashImgW)
    DllCall("gdiplus\GdipGetImageHeight", "ptr", g_SplashBitmap, "uint*", &g_SplashImgH)

    ; Create layered window (WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TOOLWINDOW)
    WS_POPUP := 0x80000000
    WS_EX_LAYERED := 0x80000
    WS_EX_TOPMOST := 0x8
    WS_EX_TOOLWINDOW := 0x80

    ; Center on screen
    screenW := A_ScreenWidth, screenH := A_ScreenHeight
    g_SplashPosX := (screenW - g_SplashImgW) // 2
    g_SplashPosY := (screenH - g_SplashImgH) // 2

    g_SplashHwnd := DllCall("CreateWindowEx"
        , "uint", WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TOOLWINDOW
        , "str", "Static", "str", ""
        , "uint", WS_POPUP
        , "int", g_SplashPosX, "int", g_SplashPosY, "int", g_SplashImgW, "int", g_SplashImgH
        , "ptr", 0, "ptr", 0, "ptr", 0, "ptr", 0, "ptr")

    if (!g_SplashHwnd) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", g_SplashBitmap)
        DllCall("gdiplus\GdiplusShutdown", "uptr", g_SplashToken)
        DllCall("FreeLibrary", "ptr", g_SplashHModule)
        g_SplashBitmap := 0
        g_SplashToken := 0
        g_SplashHModule := 0
        return
    }

    ; Create compatible DC and draw image
    g_SplashHdcScreen := DllCall("GetDC", "ptr", 0, "ptr")
    g_SplashHdc := DllCall("CreateCompatibleDC", "ptr", g_SplashHdcScreen, "ptr")

    ; Create 32-bit DIB for alpha (top-down with negative height)
    bi := Buffer(40, 0)
    NumPut("UInt", 40, bi, 0)           ; biSize
    NumPut("Int", g_SplashImgW, bi, 4)  ; biWidth
    NumPut("Int", -g_SplashImgH, bi, 8) ; biHeight (negative = top-down)
    NumPut("UShort", 1, bi, 12)         ; biPlanes
    NumPut("UShort", 32, bi, 14)        ; biBitCount

    pvBits := 0
    g_SplashDIB := DllCall("CreateDIBSection", "ptr", g_SplashHdc, "ptr", bi.Ptr, "uint", 0, "ptr*", &pvBits, "ptr", 0, "uint", 0, "ptr")
    DllCall("SelectObject", "ptr", g_SplashHdc, "ptr", g_SplashDIB, "ptr")

    ; Clear the bitmap to transparent (important!)
    DllCall("gdi32\PatBlt", "ptr", g_SplashHdc, "int", 0, "int", 0, "int", g_SplashImgW, "int", g_SplashImgH, "uint", 0x00000042)  ; BLACKNESS

    ; Draw PNG onto DIB using GDI+
    pGraphics := 0
    DllCall("gdiplus\GdipCreateFromHDC", "ptr", g_SplashHdc, "ptr*", &pGraphics)
    ; Set compositing mode to SourceOver for proper alpha blending
    DllCall("gdiplus\GdipSetCompositingMode", "ptr", pGraphics, "int", 0)  ; CompositingModeSourceOver
    DllCall("gdiplus\GdipDrawImageRectI", "ptr", pGraphics, "ptr", g_SplashBitmap, "int", 0, "int", 0, "int", g_SplashImgW, "int", g_SplashImgH)
    DllCall("gdiplus\GdipDeleteGraphics", "ptr", pGraphics)

    ; Show window first, then update with alpha=0 for fade-in start
    DllCall("ShowWindow", "ptr", g_SplashHwnd, "int", 8)  ; SW_SHOWNA

    ; Start with alpha=0 for fade-in
    _SplashUpdateLayeredWindow(0)

    ; Fade in
    _SplashFade(0, 255, cfg.LauncherSplashFadeMs)
}

HideSplashScreen() {
    global g_SplashHwnd, g_SplashBitmap, g_SplashHdc, g_SplashToken, g_SplashHdcScreen, g_SplashHModule
    global g_SplashDIB, cfg

    if (g_SplashHwnd) {
        ; Fade out
        _SplashFade(255, 0, cfg.LauncherSplashFadeMs)

        ; Cleanup window
        DllCall("DestroyWindow", "ptr", g_SplashHwnd)
        g_SplashHwnd := 0
    }

    ; Delete DIB before DC (must delete bitmap before the DC it's selected into)
    if (g_SplashDIB) {
        DllCall("DeleteObject", "ptr", g_SplashDIB)
        g_SplashDIB := 0
    }

    if (g_SplashHdc) {
        DllCall("DeleteDC", "ptr", g_SplashHdc)
        g_SplashHdc := 0
    }

    if (g_SplashHdcScreen) {
        DllCall("ReleaseDC", "ptr", 0, "ptr", g_SplashHdcScreen)
        g_SplashHdcScreen := 0
    }

    if (g_SplashBitmap) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", g_SplashBitmap)
        g_SplashBitmap := 0
    }

    if (g_SplashToken) {
        DllCall("gdiplus\GdiplusShutdown", "uptr", g_SplashToken)
        g_SplashToken := 0
    }

    if (g_SplashHModule) {
        DllCall("FreeLibrary", "ptr", g_SplashHModule)
        g_SplashHModule := 0
    }
}

; Update layered window with specified alpha - uses UpdateLayeredWindow for per-pixel alpha
_SplashUpdateLayeredWindow(alpha) {
    global g_SplashHwnd, g_SplashHdc, g_SplashHdcScreen
    global g_SplashImgW, g_SplashImgH, g_SplashPosX, g_SplashPosY

    if (!g_SplashHwnd)
        return

    ptSrc := Buffer(8, 0)  ; Source point (0,0)
    ptDst := Buffer(8, 0)
    NumPut("Int", g_SplashPosX, ptDst, 0)
    NumPut("Int", g_SplashPosY, ptDst, 4)
    sizeWnd := Buffer(8, 0)
    NumPut("Int", g_SplashImgW, sizeWnd, 0)
    NumPut("Int", g_SplashImgH, sizeWnd, 4)

    blendFunc := Buffer(4, 0)
    NumPut("UChar", 0, blendFunc, 0)      ; BlendOp = AC_SRC_OVER
    NumPut("UChar", 0, blendFunc, 1)      ; BlendFlags
    NumPut("UChar", alpha, blendFunc, 2)  ; SourceConstantAlpha
    NumPut("UChar", 1, blendFunc, 3)      ; AlphaFormat = AC_SRC_ALPHA

    DllCall("UpdateLayeredWindow", "ptr", g_SplashHwnd
        , "ptr", g_SplashHdcScreen, "ptr", ptDst.Ptr, "ptr", sizeWnd.Ptr
        , "ptr", g_SplashHdc, "ptr", ptSrc.Ptr, "uint", 0
        , "ptr", blendFunc.Ptr, "uint", 2)  ; ULW_ALPHA
}

_SplashFade(fromAlpha, toAlpha, durationMs) {
    global g_SplashHwnd
    if (!g_SplashHwnd)
        return

    if (durationMs <= 0) {
        _SplashUpdateLayeredWindow(toAlpha)
        return
    }

    steps := durationMs // 16  ; ~60fps
    if (steps < 1)
        steps := 1

    startTick := A_TickCount
    Loop steps {
        elapsed := A_TickCount - startTick
        progress := Min(elapsed / durationMs, 1.0)
        alpha := Integer(fromAlpha + (toAlpha - fromAlpha) * progress)
        _SplashUpdateLayeredWindow(alpha)
        if (progress >= 1.0)
            break
        Sleep(16)
    }
    _SplashUpdateLayeredWindow(toAlpha)
}

; Load a GDI+ bitmap from an embedded PE resource
; resourceId: The resource ID (e.g., 10 for logo.png)
; Returns: GDI+ bitmap pointer, or 0 on failure
_LoadBitmapFromResource(resourceId) {
    ; Find the resource (RT_RCDATA = 10)
    hRes := DllCall("FindResource", "ptr", 0, "int", resourceId, "int", 10, "ptr")
    if (!hRes)
        return 0

    ; Get resource size and load it
    resSize := DllCall("SizeofResource", "ptr", 0, "ptr", hRes, "uint")
    hMem := DllCall("LoadResource", "ptr", 0, "ptr", hRes, "ptr")
    if (!hMem || !resSize)
        return 0

    ; Lock the resource to get a pointer to the data
    pData := DllCall("LockResource", "ptr", hMem, "ptr")
    if (!pData)
        return 0

    ; Allocate global memory and copy resource data (needed for IStream)
    hGlobal := DllCall("GlobalAlloc", "uint", 0x0002, "uptr", resSize, "ptr")  ; GMEM_MOVEABLE
    if (!hGlobal)
        return 0

    pGlobal := DllCall("GlobalLock", "ptr", hGlobal, "ptr")
    if (!pGlobal) {
        DllCall("GlobalFree", "ptr", hGlobal)
        return 0
    }

    DllCall("RtlMoveMemory", "ptr", pGlobal, "ptr", pData, "uptr", resSize)
    DllCall("GlobalUnlock", "ptr", hGlobal)

    ; Create IStream from the global memory
    pStream := 0
    hr := DllCall("ole32\CreateStreamOnHGlobal", "ptr", hGlobal, "int", 1, "ptr*", &pStream, "int")
    if (hr != 0 || !pStream) {
        DllCall("GlobalFree", "ptr", hGlobal)
        return 0
    }

    ; Create GDI+ bitmap from IStream
    pBitmap := 0
    DllCall("gdiplus\GdipCreateBitmapFromStream", "ptr", pStream, "ptr*", &pBitmap)

    ; Release IStream (it owns the HGLOBAL now due to fDeleteOnRelease=1)
    ObjRelease(pStream)

    return pBitmap
}

; ============================================================
; TRAY MENU (ON-DEMAND UPDATES)
; ============================================================

TrayIconClick(wParam, lParam, msg, hwnd) {
    ; 0x205 = WM_RBUTTONUP (right-click release)
    if (lParam = 0x205) {
        UpdateTrayMenu()
        A_TrayMenu.Show()  ; Must explicitly show the menu
        return 1  ; Prevent default handling (we showed it ourselves)
    }
    return 0  ; Let default handling continue for other events
}

SetupLauncherTray() {
    ; Set custom icon - embedded in exe for compiled, file for dev mode
    if (A_IsCompiled) {
        ; Icon is embedded in exe via /icon compile flag - use icon index 1
        TraySetIcon(A_ScriptFullPath, 1)
    } else {
        iconPath := A_ScriptDir "\..\img\icon.ico"
        if FileExist(iconPath)
            TraySetIcon(iconPath)
    }
    A_IconTip := "Alt-Tabby"
    UpdateTrayMenu()
}

UpdateTrayMenu() {
    global g_StorePID, g_GuiPID, g_ViewerPID, cfg, gConfigIniPath

    ; Reload SetupRunAsAdmin from disk in case elevated instance changed it
    if (FileExist(gConfigIniPath)) {
        iniVal := IniRead(gConfigIniPath, "Setup", "RunAsAdmin", "false")
        cfg.SetupRunAsAdmin := (iniVal = "true" || iniVal = "1")
    }

    tray := A_TrayMenu
    tray.Delete()

    ; Header with version (and admin status if elevated)
    version := GetAppVersion()
    header := "Alt-Tabby v" version (A_IsAdmin ? " (Admin)" : "")
    tray.Add(header, (*) => 0)
    tray.Disable(header)
    tray.Add()

    ; Store status
    storeRunning := g_StorePID && ProcessExist(g_StorePID)
    if (storeRunning) {
        tray.Add("Store: Restart", (*) => RestartStore())
    } else {
        tray.Add("Store: Launch", (*) => LaunchStore())
    }

    ; GUI status
    guiRunning := g_GuiPID && ProcessExist(g_GuiPID)
    if (guiRunning) {
        tray.Add("GUI: Restart", (*) => RestartGui())
    } else {
        tray.Add("GUI: Launch", (*) => LaunchGui())
    }

    ; Viewer status (optional, launch from menu)
    viewerRunning := g_ViewerPID && ProcessExist(g_ViewerPID)
    if (viewerRunning) {
        tray.Add("Viewer: Restart", (*) => RestartViewer())
    } else {
        tray.Add("Viewer: Launch", (*) => LaunchViewer())
    }

    tray.Add()

    ; Restart option (only if something is running)
    if (storeRunning || guiRunning || viewerRunning) {
        tray.Add("Restart All", (*) => RestartAll())
        tray.Add()
    }

    ; Editors
    tray.Add("Edit Config...", (*) => LaunchConfigEditor())
    tray.Add("Edit Blacklist...", (*) => LaunchBlacklistEditor())
    tray.Add()

    ; Shortcuts (with checkmarks for current state)
    tray.Add("Add to Start Menu", (*) => ToggleStartMenuShortcut())
    if (_Shortcut_StartMenuExists())
        tray.Check("Add to Start Menu")

    tray.Add("Run at Startup", (*) => ToggleStartupShortcut())
    if (_Shortcut_StartupExists())
        tray.Check("Run at Startup")

    tray.Add()

    ; Admin mode toggle
    tray.Add("Run as Administrator", (*) => ToggleAdminMode())
    if (cfg.SetupRunAsAdmin && AdminTaskExists())
        tray.Check("Run as Administrator")

    tray.Add()

    ; Updates section
    tray.Add("Check for Updates Now", (*) => CheckForUpdates(true))
    tray.Add("Auto-check on Startup", (*) => ToggleAutoUpdate())
    if (cfg.SetupAutoUpdateCheck)
        tray.Check("Auto-check on Startup")

    tray.Add()

    tray.Add("Exit", (*) => ExitAll())
}

RestartStore() {
    global g_StorePID
    if (g_StorePID && ProcessExist(g_StorePID))
        ProcessClose(g_StorePID)
    g_StorePID := 0
    Sleep(300)
    LaunchStore()
}

RestartGui() {
    global g_GuiPID
    if (g_GuiPID && ProcessExist(g_GuiPID))
        ProcessClose(g_GuiPID)
    g_GuiPID := 0
    Sleep(300)
    LaunchGui()
}

RestartViewer() {
    global g_ViewerPID
    if (g_ViewerPID && ProcessExist(g_ViewerPID))
        ProcessClose(g_ViewerPID)
    g_ViewerPID := 0
    Sleep(300)
    LaunchViewer()
}

RestartAll() {
    global g_StorePID, g_GuiPID, g_ViewerPID

    ; Kill existing processes
    if (g_StorePID && ProcessExist(g_StorePID))
        ProcessClose(g_StorePID)
    if (g_GuiPID && ProcessExist(g_GuiPID))
        ProcessClose(g_GuiPID)
    if (g_ViewerPID && ProcessExist(g_ViewerPID))
        ProcessClose(g_ViewerPID)

    g_StorePID := 0
    g_GuiPID := 0
    g_ViewerPID := 0

    Sleep(500)

    ; Relaunch core processes
    LaunchStore()
    Sleep(300)
    LaunchGui()
}

ExitAll() {
    global g_StorePID, g_GuiPID, g_ViewerPID

    ; Kill all subprocesses
    if (g_StorePID && ProcessExist(g_StorePID))
        ProcessClose(g_StorePID)
    if (g_GuiPID && ProcessExist(g_GuiPID))
        ProcessClose(g_GuiPID)
    if (g_ViewerPID && ProcessExist(g_ViewerPID))
        ProcessClose(g_ViewerPID)

    ExitApp()
}

LaunchConfigEditor() {
    ; Run config editor with auto-restart enabled
    ; Returns true if changes were saved
    if (ConfigEditor_Run(true)) {
        ; Restart store and GUI to apply changes
        RestartStore()
        Sleep(300)
        RestartGui()
    }
}

LaunchBlacklistEditor() {
    ; Run blacklist editor
    ; IPC reload is sent automatically by the editor
    BlacklistEditor_Run()
}

; ============================================================
; SHORTCUT MANAGEMENT (Start Menu / Startup)
; ============================================================
; Note: _Shortcut_GetStartMenuPath, _Shortcut_GetStartupPath,
; _Shortcut_StartMenuExists, _Shortcut_StartupExists, and
; _Shortcut_GetIconPath are defined in setup_utils.ahk

; Create a shortcut file using WScript.Shell COM
_Shortcut_Create(lnkPath, targetPath, iconPath := "", description := "") {
    try {
        ; Get parent directory using SplitPath
        SplitPath(targetPath, , &targetDir)

        shell := ComObject("WScript.Shell")
        shortcut := shell.CreateShortcut(lnkPath)
        shortcut.TargetPath := targetPath
        shortcut.WorkingDirectory := targetDir
        if (iconPath && FileExist(iconPath))
            shortcut.IconLocation := iconPath
        if (description)
            shortcut.Description := description
        shortcut.Save()
        return true
    } catch as e {
        MsgBox("Failed to create shortcut:`n" e.Message, "Alt-Tabby", "Icon!")
        return false
    }
}

; Toggle Start Menu shortcut
ToggleStartMenuShortcut() {
    global cfg
    lnkPath := _Shortcut_GetStartMenuPath()
    if (FileExist(lnkPath)) {
        try {
            FileDelete(lnkPath)
            ToolTip("Removed from Start Menu")
        } catch as e {
            MsgBox("Failed to remove shortcut:`n" e.Message, "Alt-Tabby", "Icon!")
        }
    } else {
        ; Use admin-aware shortcut creation
        if (_CreateShortcutForCurrentMode(lnkPath)) {
            ToolTip("Added to Start Menu")
        }
    }
    SetTimer(() => ToolTip(), -1500)
}

; Toggle Startup shortcut
ToggleStartupShortcut() {
    global cfg
    lnkPath := _Shortcut_GetStartupPath()
    if (FileExist(lnkPath)) {
        try {
            FileDelete(lnkPath)
            ToolTip("Removed from Startup")
        } catch as e {
            MsgBox("Failed to remove shortcut:`n" e.Message, "Alt-Tabby", "Icon!")
        }
    } else {
        ; Use admin-aware shortcut creation
        if (_CreateShortcutForCurrentMode(lnkPath)) {
            ToolTip("Added to Startup")
        }
    }
    SetTimer(() => ToolTip(), -1500)
}

; ============================================================
; FIRST-RUN WIZARD
; ============================================================

ShowFirstRunWizard() {
    global g_WizardGui, cfg

    g_WizardGui := Gui("+AlwaysOnTop", "Welcome to Alt-Tabby")
    g_WizardGui.SetFont("s10", "Segoe UI")

    g_WizardGui.AddText("w400", "Let's set up a few things to get you started:")
    g_WizardGui.AddText("w400 y+5", "")

    g_WizardGui.AddCheckbox("vStartMenu w400", "Add to Start Menu")
    g_WizardGui.AddCheckbox("vStartup w400 Checked", "Run at Startup (recommended)")
    g_WizardGui.AddCheckbox("vInstall w400", "Install to Program Files")
    g_WizardGui.AddCheckbox("vAdmin w400", "Run as Administrator (for elevated windows)")
    g_WizardGui.AddCheckbox("vAutoUpdate w400 Checked", "Check for updates automatically")

    g_WizardGui.AddText("w400 y+15 cGray", "Note: 'Install to Program Files' and 'Run as Administrator'")
    g_WizardGui.AddText("w400 cGray", "require a one-time UAC elevation.")

    g_WizardGui.AddButton("w100 y+20", "Skip").OnEvent("Click", WizardSkip)
    g_WizardGui.AddButton("w120 x+10 Default", "Apply && Start").OnEvent("Click", WizardApply)

    g_WizardGui.OnEvent("Close", WizardSkip)
    g_WizardGui.Show()
    WinWaitClose(g_WizardGui)
}

WizardSkip(*) {
    global g_WizardGui, cfg, gConfigIniPath

    ; Mark first-run as completed even if skipped
    cfg.SetupFirstRunCompleted := true
    _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "FirstRunCompleted", true, false, "bool")

    g_WizardGui.Destroy()
}

WizardApply(*) {
    global g_WizardGui, cfg, gConfigIniPath

    ; Get checkbox states
    startMenu := g_WizardGui["StartMenu"].Value
    startup := g_WizardGui["Startup"].Value
    install := g_WizardGui["Install"].Value
    admin := g_WizardGui["Admin"].Value
    autoUpdate := g_WizardGui["AutoUpdate"].Value

    ; Check if selected options require admin
    needsAdmin := install || admin
    if (needsAdmin && !A_IsAdmin) {
        ; Save wizard choices to temp file, re-launch elevated with --wizard-continue flag
        choices := JXON_Dump(Map(
            "startMenu", startMenu,
            "startup", startup,
            "install", install,
            "admin", admin,
            "autoUpdate", autoUpdate
        ))
        choicesFile := A_Temp "\alttabby_wizard.json"
        try FileDelete(choicesFile)
        FileAppend(choices, choicesFile, "UTF-8")

        ; Self-elevate and continue wizard
        ; User may cancel UAC - handle gracefully
        try {
            if A_IsCompiled
                Run('*RunAs "' A_ScriptFullPath '" --wizard-continue')
            else
                Run('*RunAs "' A_AhkPath '" "' A_ScriptFullPath '" --wizard-continue')

            g_WizardGui.Destroy()
            ExitApp()  ; Exit non-elevated instance
        } catch as e {
            ; UAC was cancelled or failed - clean up temp file and notify user
            try FileDelete(choicesFile)
            MsgBox("Administrator privileges are required for the selected options.`n`nError: " e.Message "`n`nYou can still use Alt-Tabby without these features, or try again later from the tray menu.", "Alt-Tabby", "Icon!")
            ; Don't exit - fall through to apply non-admin options only
            install := false
            admin := false
        }
    }

    ; Apply choices (without admin options if UAC was cancelled)
    _WizardApplyChoices(startMenu, startup, install, admin, autoUpdate)
    g_WizardGui.Destroy()
}

; Called when --wizard-continue flag is passed (after elevation)
WizardContinue() {
    global cfg, gConfigIniPath

    choicesFile := A_Temp "\alttabby_wizard.json"
    if (!FileExist(choicesFile))
        return false

    ; Read saved choices
    try {
        choicesJson := FileRead(choicesFile, "UTF-8")
        choices := JXON_Load(choicesJson)
        FileDelete(choicesFile)
    } catch {
        return false
    }

    ; Apply the choices (we're elevated now)
    _WizardApplyChoices(
        choices["startMenu"],
        choices["startup"],
        choices["install"],
        choices["admin"],
        choices["autoUpdate"]
    )

    return true
}

; Internal: Apply wizard choices (called from both wizard and continuation)
_WizardApplyChoices(startMenu, startup, install, admin, autoUpdate) {
    global cfg, gConfigIniPath

    ; Determine exe path
    exePath := A_IsCompiled ? A_ScriptFullPath : A_ScriptFullPath

    ; Step 1: Install to Program Files (if selected)
    if (install) {
        newPath := InstallToProgramFiles()
        if (newPath != "") {
            exePath := newPath
            ; Update config path to point to new location so subsequent writes go there
            newDir := ""
            SplitPath(newPath, , &newDir)
            gConfigIniPath := newDir "\config.ini"
        }
    }

    ; Step 2: Create admin task (if selected) - needs final exe path
    if (admin) {
        if (CreateAdminTask(exePath)) {
            cfg.SetupRunAsAdmin := true
            _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", true, false, "bool")
        }
    }

    ; Step 3: Save config
    cfg.SetupExePath := exePath
    cfg.SetupAutoUpdateCheck := autoUpdate
    cfg.SetupFirstRunCompleted := true
    _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "ExePath", exePath, "", "string")
    _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "AutoUpdateCheck", autoUpdate, true, "bool")
    _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "FirstRunCompleted", true, false, "bool")

    ; Step 4: Create shortcuts AFTER admin mode is set (so they point correctly)
    if (startMenu)
        _CreateShortcutForCurrentMode(_Shortcut_GetStartMenuPath())
    if (startup)
        _CreateShortcutForCurrentMode(_Shortcut_GetStartupPath())
}

; ============================================================
; PROGRAM FILES INSTALLATION
; ============================================================

InstallToProgramFiles() {
    global cfg

    ; Target: C:\Program Files\Alt-Tabby\
    installDir := "C:\Program Files\Alt-Tabby"
    srcExe := A_IsCompiled ? A_ScriptFullPath : ""
    srcDir := A_IsCompiled ? A_ScriptDir : ""

    if (!A_IsCompiled) {
        MsgBox("Program Files installation only works with compiled exe.", "Alt-Tabby", "Icon!")
        return ""
    }

    ; Check if we need admin
    if (!A_IsAdmin) {
        MsgBox("Administrator privileges required to install to Program Files.", "Alt-Tabby", "Icon!")
        return ""
    }

    ; Check if already in Program Files
    if (InStr(A_ScriptDir, "C:\Program Files\Alt-Tabby")) {
        return A_ScriptFullPath  ; Already there
    }

    try {
        ; Create directory
        if (!DirExist(installDir))
            DirCreate(installDir)

        ; Copy exe
        FileCopy(srcExe, installDir "\AltTabby.exe", true)

        ; Copy img folder if exists
        if (DirExist(srcDir "\img"))
            DirCopy(srcDir "\img", installDir "\img", true)

        ; Copy config if exists (so user keeps their settings)
        if (FileExist(srcDir "\config.ini"))
            FileCopy(srcDir "\config.ini", installDir "\config.ini", true)

        ; Copy blacklist if exists
        if (FileExist(srcDir "\blacklist.txt"))
            FileCopy(srcDir "\blacklist.txt", installDir "\blacklist.txt", true)

        return installDir "\AltTabby.exe"
    } catch as e {
        MsgBox("Failed to install to Program Files:`n" e.Message, "Alt-Tabby", "IconX")
        return ""
    }
}

; ============================================================
; ADMIN-AWARE SHORTCUT MANAGEMENT
; ============================================================
; Note: CreateAdminTask, DeleteAdminTask, AdminTaskExists, and
; _Shortcut_GetEffectiveExePath are defined in setup_utils.ahk

; Create a shortcut that always points to the exe
; The exe will self-redirect to the scheduled task if admin mode is enabled
_CreateShortcutForCurrentMode(lnkPath) {
    global cfg

    exePath := _Shortcut_GetEffectiveExePath()
    iconPath := _Shortcut_GetIconPath()

    try {
        shell := ComObject("WScript.Shell")
        shortcut := shell.CreateShortcut(lnkPath)

        ; Always point to our exe - it will self-redirect to scheduled task if needed
        if (A_IsCompiled) {
            shortcut.TargetPath := exePath
            shortcut.Description := cfg.SetupRunAsAdmin
                ? "Alt-Tabby Window Switcher (Admin)"
                : "Alt-Tabby Window Switcher"
        } else {
            ; Dev mode: AutoHotkey.exe with script as argument
            shortcut.TargetPath := A_AhkPath
            shortcut.Arguments := '"' A_ScriptFullPath '"'
            shortcut.Description := "Alt-Tabby Window Switcher (Dev)"
        }

        ; Set working directory
        SplitPath(exePath, , &workDir)
        shortcut.WorkingDirectory := workDir

        ; Set icon
        if (iconPath && FileExist(iconPath))
            shortcut.IconLocation := iconPath

        shortcut.Save()
        return true
    } catch as e {
        MsgBox("Failed to create shortcut:`n" e.Message, "Alt-Tabby", "Icon!")
        return false
    }
}

; Recreate existing shortcuts when admin mode changes
RecreateShortcuts() {
    ; If Start Menu shortcut exists, recreate it
    if (_Shortcut_StartMenuExists()) {
        try FileDelete(_Shortcut_GetStartMenuPath())
        _CreateShortcutForCurrentMode(_Shortcut_GetStartMenuPath())
    }

    ; If Startup shortcut exists, recreate it
    if (_Shortcut_StartupExists()) {
        try FileDelete(_Shortcut_GetStartupPath())
        _CreateShortcutForCurrentMode(_Shortcut_GetStartupPath())
    }
}

; ============================================================
; TRAY MENU TOGGLES
; Note: CheckForUpdates is defined in setup_utils.ahk
; ============================================================

ToggleAdminMode() {
    global cfg, gConfigIniPath

    if (cfg.SetupRunAsAdmin) {
        ; Disable admin mode - doesn't require elevation
        DeleteAdminTask()
        cfg.SetupRunAsAdmin := false
        _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", false, false, "bool")
        RecreateShortcuts()  ; Update shortcuts (still point to exe, but description changes)

        ; Offer restart to apply change immediately
        result := MsgBox("Admin mode disabled.`n`nRestart Alt-Tabby to run without elevation?", "Alt-Tabby", "YesNo Icon?")
        if (result = "Yes") {
            ; Restart non-elevated by running the exe directly
            if A_IsCompiled
                Run('"' A_ScriptFullPath '"')
            else
                Run('"' A_AhkPath '" "' A_ScriptFullPath '"')
            ExitAll()
        } else {
            ToolTip("Admin mode disabled - changes apply on next launch")
            SetTimer(() => ToolTip(), -2000)
        }
    } else {
        ; Enable admin mode - requires elevation to create scheduled task
        if (!A_IsAdmin) {
            result := MsgBox("Creating the admin task requires elevation.`n`nA UAC prompt will appear.", "Alt-Tabby", "OKCancel Icon!")
            if (result = "Cancel")
                return

            ; Self-elevate with --enable-admin-task flag
            try {
                if A_IsCompiled
                    Run('*RunAs "' A_ScriptFullPath '" --enable-admin-task')
                else
                    Run('*RunAs "' A_AhkPath '" "' A_ScriptFullPath '" --enable-admin-task')
                ; Don't exit - the elevated instance will create the task and exit
                ; We'll see the result on next tray menu open
                ToolTip("Creating admin task...")
                SetTimer(() => ToolTip(), -2000)
            } catch {
                MsgBox("UAC was cancelled. Admin mode was not enabled.", "Alt-Tabby", "Icon!")
            }
            return
        }

        ; We're already admin - create task directly
        exePath := _Shortcut_GetEffectiveExePath()
        if (CreateAdminTask(exePath)) {
            cfg.SetupRunAsAdmin := true
            _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "RunAsAdmin", true, false, "bool")
            RecreateShortcuts()  ; Update to point to schtasks
            ToolTip("Admin mode enabled")
            SetTimer(() => ToolTip(), -1500)
        } else {
            MsgBox("Failed to create scheduled task.", "Alt-Tabby", "Iconx")
        }
    }
}

ToggleAutoUpdate() {
    global cfg, gConfigIniPath
    cfg.SetupAutoUpdateCheck := !cfg.SetupAutoUpdateCheck
    _CL_WriteIniPreserveFormat(gConfigIniPath, "Setup", "AutoUpdateCheck", cfg.SetupAutoUpdateCheck, true, "bool")
    ToolTip(cfg.SetupAutoUpdateCheck ? "Auto-update enabled" : "Auto-update disabled")
    SetTimer(() => ToolTip(), -1500)
}
