you are helping me with an AHKv2 based alt tab replacement.

we have a modular system with components in different .ahk files.

Here is out oldgui.ahk
-------
; gui.ahk — list overlay with icons and rich columns (fast, non-blocking, DPI-safe)
#Requires AutoHotkey v2.0

; ========================= GLOBALS =========================
global gGui := 0, gLV := 0
global OVERLAY_ROWS := 10

; icon infra
global gIL := 0                 ; HIMAGELIST handle
; cache maps hwnd -> { idx: <1-based icon index or 0>, pid: <UInt>, class: <Str> }
global gIconCache := Map()
global gIconQueue := []         ; pending hwnds to resolve
global gIconPumpOn := false

; current viewport snapshot for safe refresh
global gListSnap := [], gSelSnap := 1

; dynamic column plan (computed at overlay creation)
; gColKeys is an array of symbols in display order:
;   "#", "Title", ["Class"], ["PID"], ["HWND"], ["Z"], ["WS"], "State"
global gColKeys := []

__GUI_InitDefaults()   ; ensure defaults are set at load time

; expects from config.ahk (all optional, defaults used if missing):
;   OverlayFont
;   GUI_ShowPID, GUI_ShowHWND, GUI_ShowWinNum, GUI_ShowKomorebi, GUI_StateShort, GUI_HWND_Hex
;   UseIcons, IconBatchPerTick, IconTimerIntervalMs, IconSizePx
;   OverlayOpacity (0..255), BackdropMode ("none"|"auto"|"mica"|"acrylic"|"tabbed"), CornerPref ("round"|"small"|"square")
;   LV_ColorBG (e.g. "#101215"), LV_ColorText ("#F0F0F0"), LV_ColorTextBG ("#101215")


; Fallback defaults if not set in config (block style for v2 compatibility)
__GUI_InitDefaults() {
    global UseIcons, IconBatchPerTick, IconTimerIntervalMs, IconSizePx
    global GUI_ShowPID, GUI_ShowHWND, GUI_ShowWinNum, GUI_ShowKomorebi, GUI_StateShort, GUI_HWND_Hex
    global OverlayOpacity, BackdropMode, CornerPref
    global LV_ColorBG, LV_ColorText, LV_ColorTextBG
    global LV_ColorSelBG, LV_ColorSelText, LV_TransparentBG, LV_UseCustomDraw
    global LV_DisableTheme, OverlayInsetPx

    ; ---- icon / pump ----
    if !IsSet(UseIcons) {
        UseIcons := true
    }
    if !IsSet(IconBatchPerTick) {
        IconBatchPerTick := 3
    }
    if !IsSet(IconTimerIntervalMs) {
        IconTimerIntervalMs := 15
    }
    if !IsSet(IconSizePx) {
        IconSizePx := 64
    }

    ; ---- column toggles ----
    if !IsSet(GUI_ShowPID) {
        GUI_ShowPID := false
    }
    if !IsSet(GUI_ShowHWND) {
        GUI_ShowHWND := true
    }
    if !IsSet(GUI_ShowWinNum) {
        GUI_ShowWinNum := true
    }
    if !IsSet(GUI_ShowKomorebi) {
        GUI_ShowKomorebi := false
    }
    if !IsSet(GUI_StateShort) {
        GUI_StateShort := true
    }
    if !IsSet(GUI_HWND_Hex) {
        GUI_HWND_Hex := true
    }

    ; ---- visuals ----
    if !IsSet(OverlayOpacity) {
        OverlayOpacity := 255
    }
    if !IsSet(BackdropMode) {
        BackdropMode := "auto"    ; "none"|"auto"|"mica"|"acrylic"|"tabbed"
    }
    if !IsSet(CornerPref) {
        CornerPref := "round"     ; "round"|"small"|"square"
    }
    if !IsSet(OverlayInsetPx) {
        OverlayInsetPx := 40      ; padding ring for backdrop look
    }

    ; ---- listview base colors ----
    if !IsSet(LV_ColorBG) {
        LV_ColorBG := "#14181C"
    }
    if !IsSet(LV_ColorText) {
        LV_ColorText := "#F5F7FA"
    }
    if !IsSet(LV_ColorTextBG) {
        LV_ColorTextBG := "#14181C"
    }

    ; ---- selection + draw behavior ----
    if !IsSet(LV_ColorSelBG) {
        LV_ColorSelBG := "#2B5CAD"
    }
    if !IsSet(LV_ColorSelText) {
        LV_ColorSelText := "#FFFFFF"
    }
    if !IsSet(LV_TransparentBG) {
        LV_TransparentBG := false     ; true → attempt control-level transparency for grid bg
    }
    if !IsSet(LV_UseCustomDraw) {
        LV_UseCustomDraw := true      ; required for row bg + selection color
    }
    if !IsSet(LV_DisableTheme) {
        LV_DisableTheme := true       ; disable Explorer theme so custom colors win
    }
}



; ===================== STATE LABEL SHORTENING =====================
_StateShort(s) {
    ; v2-safe: explicit braces and else-if blocks for broad compatibility
    if !(IsSet(GUI_StateShort) && GUI_StateShort) {
        return s
    }

    sw := StrLower(Trim(s))

    if (sw = "workspaceshowing") {
        return "WS-Shown"
    } else if (sw = "workspaceminimized") {
        return "WS-Min"
    } else if (sw = "workspacehidden") {
        return "WS-Hidden"
    } else if (sw = "otherworkspace") {
        return "Other-WS"
    } else {
        return s
    }
}

; Keep this near other “custom draw / message” globals
global __BGBridge_On := false

; Keep this near other “custom draw / message” globals
global __BGBridge_On := false

_InstallListViewBgBridge() {
    global __BGBridge_On
    if (__BGBridge_On)
        return
    ; Intercept erase to avoid solid fills and let DWM material show.
    OnMessage(0x0014, __LV_OnEraseBk)     ; WM_ERASEBKGND
    ; IMPORTANT for transparent ListView: parent must respond to WM_PRINTCLIENT.
    OnMessage(0x0318, __LV_OnPrintClient) ; WM_PRINTCLIENT
    __BGBridge_On := true
}

; Allow DWM to paint the system backdrop by preventing default solid background fills.
; Swallow erase for both the ListView and the top-level GUI.
__LV_OnEraseBk(wParam, lParam, msg, hwnd) {
    global gLV, gGui
    if (IsObject(gLV) && HasProp(gLV, "Hwnd") && hwnd = gLV.Hwnd)
        return 1   ; handled - LV stays “transparent”; parent/backdrop shows
    if (IsObject(gGui) && HasProp(gGui, "Hwnd") && hwnd = gGui.Hwnd)
        return 1   ; handled - no grey fill; DWM material can render
    return 0
}

; NEW: Parent background bridge for transparent ListView.
; ListView with CLR_NONE / LVS_EX_TRANSPARENTBKGND sends WM_PRINTCLIENT to the *parent*
; asking it to paint the background into the provided HDC. We "ack" without painting,
; which leaves the existing DWM-drawn backdrop visible.
__LV_OnPrintClient(wParam, lParam, msg, hwnd) {
    global gGui, gLV
    ; Only handle if it targets our GUI (parent) or the LV itself.
    if (IsObject(gGui) && HasProp(gGui, "Hwnd") && hwnd = gGui.Hwnd)
        return 1  ; claim handled; do not overpaint backdrop
    if (IsObject(gLV) && HasProp(gLV, "Hwnd") && hwnd = gLV.Hwnd)
        return 1
    return 0
}





_DBG(msg) {
    global DebugLogPath, DebugGUI
    if !(IsSet(DebugGUI) && DebugGUI)
        return
    path := (IsSet(DebugLogPath) && DebugLogPath) ? DebugLogPath : (A_ScriptDir "\tabby_debug.log")
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss")
    ; ensure directory exists (no-op if it already exists)
    SplitPath(path, , &dir)
    try DirCreate(dir)
    ; always append
    FileAppend(ts " | " msg "rn", path, "UTF-8")
}



_DWM_SetAttrInt(hWnd, attrId, value) {
    buf := Buffer(4, 0)
    NumPut("Int", value, buf, 0)
    hr := DllCall("dwmapi\DwmSetWindowAttribute"
        , "ptr", hWnd
        , "int", attrId
        , "ptr", buf.Ptr
        , "int", 4
        , "int")  ; HRESULT
    _DBG(Format("DWM attr{} val={} hr={}", attrId, value, hr))
    return hr
}



; ===================== KOMOREBI WORKSPACE LOOKUP =====================
_GetWorkspaceForHwnd(hwnd) {
    ws := ""
    try {
        if Komorebi_SubTryMap(hwnd, &ws) && (ws != "")
            return ws
    } catch {
    }
    return ""
}

; ===================== COLUMN PLAN =====================
_BuildColumnPlan() {
    global gColKeys
    gColKeys := ["#", "Title"]  ; always
    gColKeys.Push("Class")
    if (IsSet(GUI_ShowPID) && GUI_ShowPID)
        gColKeys.Push("PID")
    if (IsSet(GUI_ShowHWND) && GUI_ShowHWND)
        gColKeys.Push("HWND")
    if (IsSet(GUI_ShowWinNum) && GUI_ShowWinNum)
        gColKeys.Push("Z")
    if (IsSet(GUI_ShowKomorebi) && GUI_ShowKomorebi)
        gColKeys.Push("WS")
    gColKeys.Push("State")
}

_HeadersFromPlan() {
    global gColKeys
    headers := []
    for _, k in gColKeys {
        if (k = "#")
            headers.Push("#")
        else if (k = "Title")
            headers.Push("Title")
        else if (k = "Class")
            headers.Push("Class")
        else if (k = "PID")
            headers.Push("PID")
        else if (k = "HWND")
            headers.Push("HWND")
        else if (k = "Z")
            headers.Push("Win#")
        else if (k = "WS")
            headers.Push("Workspace")
        else if (k = "State")
            headers.Push("State")
    }
    return headers
}

_RowFromItem(item, idx, total, optIcon := "") {
    global gColKeys, GUI_HWND_Hex
    cells := []
    for _, k in gColKeys {
        if (k = "#") {
            numText := "[" idx "/" total "]"
            if (optIcon != "")
                cells.Push({ v: numText, opt: optIcon })
            else
                cells.Push({ v: numText, opt: "" })
        } else if (k = "Title") {
            title := item.Title
            if (StrLen(title) > 140)
                title := SubStr(title, 1, 137) . "..."
            cells.Push({ v: title, opt: "" })
        } else if (k = "Class") {
            cells.Push({ v: item.Class, opt: "" })
        } else if (k = "PID") {
            cells.Push({ v: item.Pid, opt: "" })
        } else if (k = "HWND") {
            v := ""
            if (IsSet(GUI_HWND_Hex) && GUI_HWND_Hex)
                v := "0x" . Format("{:X}", item.Hwnd)
            else
                v := item.Hwnd
            cells.Push({ v: v, opt: "" })
        } else if (k = "Z") {
            cells.Push({ v: item.ZOrder, opt: "" })
        } else if (k = "WS") {
            ws := _GetWorkspaceForHwnd(item.Hwnd)
            cells.Push({ v: ws, opt: "" })
        } else if (k = "State") {
            cells.Push({ v: _StateShort(item.State), opt: "" })
        }
    }
    return cells
}

; ===================== GUI LIFECYCLE =====================
; ===== REPLACEMENT: gui.ahk :: Overlay_ShowList =====
; ===== REPLACEMENT: gui.ahk :: Overlay_ShowList =====
Overlay_ShowList(list, selIndex) {
    global gGui, gLV, OverlayFont, LV_ColorBG, LV_ColorText, LV_ColorTextBG
    global LV_DisableTheme, LV_TransparentBG, LV_UseCustomDraw, OverlayInsetPx
    global BackdropMode

    ; If already alive, just refresh.
    if (IsObject(gGui) && HasProp(gGui, "Hwnd") && gGui.Hwnd) {
        Overlay_Refresh(list, selIndex)
        return
    }

    _BuildColumnPlan()
    headers := _HeadersFromPlan()

    ; Borderless top-level GUI
    gGui := Gui("+AlwaysOnTop -Caption +Border", "Switch")
    gGui.Opt("+OwnDialogs")

    gGui.MarginX := 0
    gGui.MarginY := 0

    if (IsSet(OverlayFont) && OverlayFont) {
        try gGui.SetFont("s12", OverlayFont)
    }
    hGui := gGui.Hwnd
    _TryEnableDarkTitleBar(hGui)

    ; ----------------- geometry plan -----------------
    viewW := Floor(A_ScreenWidth * 0.85)
    if (viewW < 700)  viewW := 700
    if (viewW > 1400) viewW := 1400

    pad := IsSet(OverlayInsetPx) ? OverlayInsetPx : 40
    if (pad < 0) pad := 0

    ; Build LV options string w/o Format()
    lvOpt := ""
    try lvOpt := "x" pad " y" pad " w" (viewW - pad*2) " r" OVERLAY_ROWS " -Hdr AltSubmit ReadOnly"

    ; Create ListView (fallback if needed)
    gLV := 0
    try gLV := gGui.AddListView(lvOpt, headers)
    if !(IsObject(gLV) && HasProp(gLV, "Hwnd") && gLV.Hwnd) {
        safeOpt := "x" pad " y" pad " w" (viewW - pad*2)
        try gLV := gGui.AddListView(safeOpt, headers)
        if !(IsObject(gLV) && HasProp(gLV, "Hwnd") && gLV.Hwnd)
            return
    }

    ; If a backdrop is requested, do NOT disable the Explorer theme on the LV.
    ; Transparent background works more reliably with the themed listview.
    if (IsSet(BackdropMode) && (BackdropMode != "none")) {
        try DllCall("uxtheme\SetWindowTheme", "ptr", gLV.Hwnd, "wstr", "Explorer", "wstr", "")
    } else if (LV_DisableTheme) {
        try DllCall("uxtheme\SetWindowTheme", "ptr", gLV.Hwnd, "wstr", "", "wstr", "")
    }

    _LV_SetStyles(gLV, viewW - pad*2, headers)

    ; Enable transparent background behavior on the listview.
    LVS_EX_TRANSPARENTBKGND := 0x00400000
    DllCall("user32\SendMessage"
        , "ptr", gLV.Hwnd
        , "uint", 0x1036              ; LVM_SETEXTENDEDLISTVIEWSTYLE
        , "uptr", LVS_EX_TRANSPARENTBKGND
        , "ptr", LVS_EX_TRANSPARENTBKGND)

    _Icon_EnsureImageList()
    _LV_EnableTrueTransparency(gLV.Hwnd)

    _InstallListViewBgBridge() ; now also installs WM_PRINTCLIENT handler
    _SetListViewColors(gLV.Hwnd, LV_ColorBG, LV_ColorText, LV_ColorTextBG)
    if (LV_UseCustomDraw)
        _LV_InstallCustomColors(gLV.Hwnd)

    ; First population pass
    Overlay_Refresh(list, selIndex)

    ; ------------- layout pass -------------
    gGui.Show("Hide AutoSize")

    lx := 0, ly := 0, lw := 0, lh := 0
    try gLV.GetPos(&lx, &ly, &lw, &lh)
    wantW := lw + pad * 2
    wantH := lh + pad * 2
    gGui.Move(, , wantW, wantH)

    gx := 0, gy := 0, gw := 0, gh := 0
    try gGui.GetPos(&gx, &gy, &gw, &gh)
    try gLV.Move(pad, pad, gw - pad * 2, gh - pad * 2)

    _CenterOnWorkArea(gGui, gLV)

    ; Window must be visible before applying backdrop.
    try gLV.Focus()
    gGui.Show("NA")

    _ApplyBackdropAndCorners(hGui)
    _ApplyOpacity(hGui)
    _LV_FillToRight(gLV)

    _PostShowInsetFix(gGui, gLV, pad)

    _InstallDwmReapplyHooks()

    ; Final: ensure no WS_EX_LAYERED (layered windows can break system backdrops)
    _ForceNoLayered(hGui)

    ; Dump env for debugging once.
    _Debug_DumpBackdropEnv(hGui, gLV.Hwnd)
}



; Re-assert system backdrop when composition or theme toggles, or when transparency effects change.
global __DWMHooksOn := false

_InstallDwmReapplyHooks() {
    global __DWMHooksOn
    if (__DWMHooksOn)
        return
    OnMessage(0x031A, __OnDwmOrThemeChanged)   ; WM_THEMECHANGED
    OnMessage(0x031E, __OnDwmOrThemeChanged)   ; WM_DWMCOMPOSITIONCHANGED
    __DWMHooksOn := true
}

__OnDwmOrThemeChanged(wParam, lParam, msg, hwnd) {
    global gGui
    try {
        if (IsObject(gGui) && HasProp(gGui, "Hwnd") && gGui.Hwnd)
            _ApplyBackdropAndCorners(gGui.Hwnd)
    }
    return 0
}



Overlay_Refresh(list, selIndex) {
    global gGui, gLV, OVERLAY_ROWS, gIconQueue, UseIcons, gListSnap, gSelSnap

    if !(IsObject(gGui) && HasProp(gGui, "Hwnd") && gGui.Hwnd) {
        return
    }
    if !(IsObject(gLV) && HasProp(gLV, "Hwnd") && gLV.Hwnd) {
        return
    }

    total := list.Length
    gLV.Opt("-Redraw")
    gLV.Delete()

    if (total = 0) {
        gLV.Opt("+Redraw")
        return
    }

    gListSnap := list
    gSelSnap  := selIndex

    start := selIndex
    pending := []

    i := 0
    while (i < OVERLAY_ROWS) {
        i := i + 1
        idx := _WrapIndex(start + i - 1, total)
        item := list[idx]

        opt := ""
        if (UseIcons) {
            iIdx := _Icon_GetIndexFor(item.Hwnd, item.Pid, item.Class)
            if (iIdx > 0) {
                opt := "Icon" . iIdx
            } else if (iIdx = 0) {
                opt := "Icon0"
            } else {
                if WinExist("ahk_id " . item.Hwnd) {
                    pending.Push(item.Hwnd)
                }
                opt := "Icon0"
            }
        }

        row := _RowFromItem(item, idx, total, opt)
        args := []
        for _, cell in row {
            args.Push(cell.v)
        }
        gLV.Add(row[1].opt, args*)
    }

    ; ensure last column expands to the right edge (no horizontal scrollbar, no dead space)
    _LV_FillToRight(gLV)

    gLV.Modify(1, "Select Vis Focus")
    gLV.Opt("+Redraw")

    if (UseIcons && pending.Length) {
        for _, h in pending {
            gIconQueue.Push(h)
        }
        _Icon_StartPump()
    }
}


Overlay_UpdateSelection(list, selIndex) {
    Overlay_Refresh(list, selIndex)
}

Overlay_Hide() {
    global gGui, gLV, gIL, gColKeys
    try {
        if (IsObject(gLV) && HasProp(gLV, "Hwnd") && gLV.Hwnd) {
            gLV.SetImageList(0, 1)
        }
        if (IsObject(gGui) && HasProp(gGui, "Hwnd") && gGui.Hwnd)
            gGui.Destroy()
    }
    gGui := 0, gLV := 0
    gColKeys := []
}

; ===================== LV HELPERS =====================
_LV_SetStyles(lvCtrl, viewW, headers) {
    lv := lvCtrl
    if !lv
        return

    w := viewW ? viewW : 1000
    inner := w - 24

    fixed := Map()
    fixed["#"]    := 110
    fixed["PID"]  := 90
    fixed["HWND"] := 120
    fixed["Z"]    := 70
    fixed["WS"]   := 120
    fixed["State"]:= 110

    classPx := Floor(inner * 0.24)
    if (classPx > 280)
        classPx := 280

    extrasWidth := 0
    colIdx := 0
    tIdx := 0

    for _, name in headers {
        colIdx += 1
        if (name = "#") {
            lv.ModifyCol(colIdx, fixed["#"])
            extrasWidth += fixed["#"]
        } else if (name = "Title") {
            tIdx := colIdx
        } else if (name = "Class") {
            lv.ModifyCol(colIdx, classPx)
            extrasWidth += classPx
        } else if fixed.Has(name) {
            lv.ModifyCol(colIdx, fixed[name])
            extrasWidth += fixed[name]
        }
    }

    titleW := inner - extrasWidth
    if (titleW < 250)
        titleW := 250
    if (tIdx > 0)
        lv.ModifyCol(tIdx, titleW)

    ; Double-buffer + FULLROWSELECT + TRANSPARENTBKGND
    LVS_EX_DOUBLEBUFFER      := 0x00010000
    LVS_EX_FULLROWSELECT     := 0x00000020
    LVS_EX_TRANSPARENTBKGND  := 0x00400000  ; comctl32 v6.10+
    exMask := LVS_EX_DOUBLEBUFFER | LVS_EX_FULLROWSELECT | LVS_EX_TRANSPARENTBKGND
    DllCall("user32\SendMessage"
        , "ptr", lv.Hwnd
        , "uint", 0x1036              ; LVM_SETEXTENDEDLISTVIEWSTYLE
        , "uptr", exMask
        , "ptr", exMask)

    _LV_FillToRight(lv)
}





_LV_EnableTrueTransparency(hLV) {
    ; Make the control fully rely on its parent for background.
    CLR_NONE := 0xFFFFFFFF
    LVM_SETBKCOLOR     := 0x1001
    LVM_SETTEXTBKCOLOR := 0x1025
    DllCall("user32\SendMessage","ptr",hLV,"uint",LVM_SETBKCOLOR,    "uptr",0,"int",CLR_NONE)
    DllCall("user32\SendMessage","ptr",hLV,"uint",LVM_SETTEXTBKCOLOR,"uptr",0,"int",CLR_NONE)
}




_LV_FillToRight(lvCtrl) {
    try {
        cols := lvCtrl.GetCount("Col")
        if (cols >= 1) {
            lvCtrl.ModifyCol(cols, "AutoHdr")   ; LVSCW_AUTOSIZE_USEHEADER (-2)
        }
    }
}



_LV_SetTransparentBkgnd(hLV) {
    ; LVM_SETBKCOLOR with CLR_NONE makes the control background “transparent”
    LVM_SETBKCOLOR := 0x1001
    CLR_NONE := 0xFFFFFFFF
    DllCall("user32\SendMessage", "ptr", hLV, "uint", LVM_SETBKCOLOR, "uptr", 0, "int", CLR_NONE)
}

; ======== Custom-draw colors for every column & selection ========
; ===== Custom Draw state =====
global __LVCD_installed := false
global __LVCD_hLV := 0
global __LVCD_cols := Map()
global __LVCD_br_sel := 0

_LV_InstallCustomColors(hLV) {
    global LV_ColorText, LV_ColorSelBG, LV_ColorSelText
    global __LVCD_installed, __LVCD_hLV, __LVCD_cols, __LVCD_br_sel

    __LVCD_hLV := hLV
    __LVCD_cols := Map()
    __LVCD_cols["tx"]     := _RgbToBgr(LV_ColorText)
    __LVCD_cols["selbg"]  := _RgbToBgr(LV_ColorSelBG)
    __LVCD_cols["seltx"]  := _RgbToBgr(LV_ColorSelText)

    ; Brush only for selection (non-selected rows are transparent).
    if (!__LVCD_br_sel)
        __LVCD_br_sel := DllCall("gdi32\CreateSolidBrush", "uint", __LVCD_cols["selbg"], "ptr")

    if (!__LVCD_installed) {
        OnMessage(0x004E, __LV_OnNotify)   ; WM_NOTIFY
        __LVCD_installed := true
    }
}

__CD_Offsets() {
    static ready := false, m := 0
    if (ready)
        return m
    if (A_PtrSize = 8) {
        m := Map()
        m["hwndFrom"]   := 0
        m["code"]       := 16
        m["dwStage"]    := 24
        m["hdc"]        := 32
        m["rc"]         := 40
        m["uItemState"] := 64
        m["clrText"]    := 80
        m["clrTextBk"]  := 84
        m["iSubItem"]   := 88
    } else {
        m := Map()
        m["hwndFrom"]   := 0
        m["code"]       := 8
        m["dwStage"]    := 12
        m["hdc"]        := 16
        m["rc"]         := 20
        m["uItemState"] := 40
        m["clrText"]    := 48
        m["clrTextBk"]  := 52
        m["iSubItem"]   := 56
    }
    ready := true
    return m
}

__LV_OnNotify(wParam, lParam, msg, hwnd) {
    global __LVCD_hLV, __LVCD_cols, __LVCD_br_sel
    NM_CUSTOMDRAW := -12
    CDDS_PREPAINT := 0x00000001
    CDDS_ITEMPREPAINT := 0x00010001
    CDDS_SUBITEM := 0x00020000
    CDDS_SUBITEMPREPAINT := CDDS_ITEMPREPAINT | CDDS_SUBITEM
    CDRF_DODEFAULT := 0x00000000
    CDRF_NOTIFYITEMDRAW := 0x00000020
    CDRF_NOTIFYSUBITEMDRAW := 0x00000020
    CDIS_SELECTED := 0x0001
    CLR_NONE := 0xFFFFFFFF

    ofs := __CD_Offsets()
    if (NumGet(lParam + ofs["code"], 0, "UInt") != NM_CUSTOMDRAW)
        return 0
    if (NumGet(lParam + ofs["hwndFrom"], 0, "Ptr") != __LVCD_hLV)
        return 0

    stage := NumGet(lParam + ofs["dwStage"], 0, "UInt")
    if (stage = CDDS_PREPAINT)
        return CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYSUBITEMDRAW
    if (stage = CDDS_ITEMPREPAINT)
        return CDRF_NOTIFYSUBITEMDRAW

    if (stage = CDDS_SUBITEMPREPAINT) {
        uState := NumGet(lParam + ofs["uItemState"], 0, "UInt")
        isSel  := (uState & CDIS_SELECTED) != 0

        ; Always draw text with transparent background so parent/backdrop shows.
        NumPut("UInt", isSel ? __LVCD_cols["seltx"] : __LVCD_cols["tx"], lParam + ofs["clrText"])
        NumPut("UInt", CLR_NONE,                                             lParam + ofs["clrTextBk"])

        if (isSel) {
            ; Fill the selection cell only.
            hdc := NumGet(lParam + ofs["hdc"], 0, "Ptr")
            prc := lParam + ofs["rc"]
            DllCall("user32\FillRect", "ptr", hdc, "ptr", prc, "ptr", __LVCD_br_sel, "int")
        }

        ; Let ListView draw text/icon; do NOT let it paint default grey selection.
        if (isSel)
            NumPut("UInt", uState & ~0x0001, lParam + ofs["uItemState"]) ; clear CDIS_SELECTED

        return CDRF_DODEFAULT
    }
    return CDRF_DODEFAULT
}



_WrapIndex(idx, len) {
    if (len <= 0)
        return 1
    n := Mod(idx - 1, len)
    if (n < 0)
        n := n + len
    return n + 1
}

; =================== ICONS (non-blocking) ===================
_Icon_IsImageListAlive() {
    global gIL
    if (!gIL)
        return false
    cnt := DllCall("Comctl32\ImageList_GetImageCount", "ptr", gIL, "int")
    return (cnt >= 0)
}

_Icon_EnsureImageList() {
    global gIL, gLV, IconSizePx, gIconCache
    if (gIL && !_Icon_IsImageListAlive()) {
        gIL := 0
        gIconCache := Map()
    }
    if (!gIL) {
        ILC_COLOR32 := 0x20
        ILC_MASK    := 0x01
        gIL := DllCall("Comctl32\ImageList_Create"
            , "int", IconSizePx, "int", IconSizePx
            , "uint", ILC_COLOR32|ILC_MASK
            , "int", 32, "int", 32, "ptr")
        ; === CRITICAL: make the imagelist background transparent ===
        CLR_NONE := 0xFFFFFFFF
        DllCall("Comctl32\ImageList_SetBkColor", "ptr", gIL, "int", CLR_NONE)
    }
    if (IsObject(gLV) && HasProp(gLV, "Hwnd") && gLV.Hwnd)
        gLV.SetImageList(gIL, 1)  ; LVSIL_SMALL
}


_Icon_GetIndexFor(hwnd, pid, cls) {
    global gIconCache
    if !gIconCache.Has(hwnd)
        return -1
    meta := gIconCache[hwnd]
    if (Type(meta) != "Object")
        return meta
    if (HasProp(meta, "pid") && HasProp(meta, "class") && meta.pid = pid && meta.class = cls)
        return meta.idx
    gIconCache.Delete(hwnd)
    return -1
}

_Icon_StartPump() {
    global gIconPumpOn, IconTimerIntervalMs
    if (gIconPumpOn)
        return
    gIconPumpOn := true
    SetTimer(_Icon_Pump, IconTimerIntervalMs)
}

_Icon_Pump() {
    global gIconPumpOn, gIconQueue, IconBatchPerTick, gIconCache, gIL, gGui, gLV, gListSnap, gSelSnap

    if !(IsObject(gGui) && HasProp(gGui, "Hwnd") && gGui.Hwnd) {
        gIconQueue := []
        gIconPumpOn := false
        SetTimer(_Icon_Pump, 0)
        return
    }

    _Icon_EnsureImageList()
    changed := false
    count := 0

    while (gIconQueue.Length && count < IconBatchPerTick) {
        hwnd := gIconQueue.RemoveAt(1)
        if (gIconCache.Has(hwnd)) {
            count := count + 1
            continue
        }

        if !WinExist("ahk_id " . hwnd) {
            gIconCache[hwnd] := { idx: 0, pid: 0, class: "" }
            count := count + 1
            continue
        }

        pid := 0, cls := ""
        for _, it in gListSnap {
            if (it.Hwnd = hwnd) {
                pid := it.Pid
                cls := it.Class
                break
            }
        }

        hIcon := _Icon_ResolveSmall(hwnd)
        if (hIcon) {
            idx := DllCall("Comctl32\ImageList_AddIcon", "ptr", gIL, "ptr", hIcon, "int")
            DllCall("user32\DestroyIcon", "ptr", hIcon)
            gIconCache[hwnd] := { idx: idx + 1, pid: pid, class: cls }
            changed := true
        } else {
            gIconCache[hwnd] := { idx: 0, pid: pid, class: cls }
        }
        count := count + 1
    }

    if (gIconQueue.Length = 0) {
        gIconPumpOn := false
        SetTimer(_Icon_Pump, 0)
    }

    if (changed && IsObject(gGui) && HasProp(gGui, "Hwnd") && gGui.Hwnd) {
        Overlay_Refresh(gListSnap, gSelSnap)
    }
}

_Icon_ResolveSmall(hWnd) {
    if !WinExist("ahk_id " . hWnd)
        return 0

    WM_GETICON := 0x7F
    ICON_SMALL2 := 2, ICON_SMALL := 0, ICON_BIG := 1

    try {
        h := SendMessage(WM_GETICON, ICON_SMALL2, 0, , "ahk_id " . hWnd)
        if (!h)
            h := SendMessage(WM_GETICON, ICON_SMALL, 0, , "ahk_id " . hWnd)
        if (!h)
            h := SendMessage(WM_GETICON, ICON_BIG,   0, , "ahk_id " . hWnd)
        if (h)
            return h
    } catch {
        return 0
    }

    h := DllCall("user32\GetClassLongPtrW", "ptr", hWnd, "int", -34, "ptr") ; GCLP_HICONSM
    if (!h)
        h := DllCall("user32\GetClassLongPtrW", "ptr", hWnd, "int", -14, "ptr") ; GCLP_HICON
    if (h)
        return h

    pidBuf := Buffer(4, 0)
    DllCall("user32\GetWindowThreadProcessId", "ptr", hWnd, "ptr", pidBuf.Ptr, "uint")
    pid := NumGet(pidBuf, 0, "UInt")
    exe := _Icon_GetProcessPath(pid)
    if (!exe)
        return 0

    hSmall := 0
    hLarge := 0
    DllCall("Shell32\ExtractIconExW", "wstr", exe, "int", 0, "ptr*", &hLarge, "ptr*", &hSmall, "uint", 1)
    if (hSmall) {
        if (hLarge)
            DllCall("user32\DestroyIcon", "ptr", hLarge)
        return hSmall
    }
    if (hLarge)
        return hLarge
    return 0
}

_Icon_GetProcessPath(pid) {
    PROCESS_QUERY_LIMITED_INFORMATION := 0x1000
    hProc := DllCall("kernel32\OpenProcess", "uint", PROCESS_QUERY_LIMITED_INFORMATION, "int", 0, "uint", pid, "ptr")
    if (!hProc)
        return ""
    bufSize := 32767
    buf := Buffer(bufSize * 2, 0)
    sizeVar := bufSize
    ok := DllCall("kernel32\QueryFullProcessImageNameW", "ptr", hProc, "uint", 0, "ptr", buf.Ptr, "uint*", sizeVar, "int")
    DllCall("kernel32\CloseHandle", "ptr", hProc)
    if (!ok)
        return ""
    return StrGet(buf.Ptr, "UTF-16")
}

; ===================== THEME / WINDOW FX =====================

_TryEnableDarkTitleBar(hWnd) {
    try {
        ; 20 = DWMWA_USE_IMMERSIVE_DARK_MODE (newer builds)
        hr20 := _DWM_SetAttrInt(hWnd, 20, 1)
        if (hr20 != 0) {
            ; 19 = DWMWA_USE_IMMERSIVE_DARK_MODE (older builds)
            hr19 := _DWM_SetAttrInt(hWnd, 19, 1)
        }
    } catch as e {
        _DBG("DarkTitle EXCEPTION: " e.Message)
    }
}



; ===== REPLACEMENT: gui.ahk :: _ApplyBackdropAndCorners =====
_ApplyBackdropAndCorners(hWnd) {
    s := (IsSet(BackdropMode) ? StrLower(Trim(BackdropMode)) : "auto")
    mode := 1  ; 1=None
    if (s = "auto")
        mode := 0      ; DWMSBT_AUTO
    else if (s = "mica" || s = "mainwindow")
        mode := 2      ; DWMSBT_MAINWINDOW
    else if (s = "acrylic" || s = "transient")
        mode := 3      ; DWMSBT_TRANSIENTWINDOW
    else if (s = "tabbed" || s = "micaalt" || s = "mica_alt")
        mode := 4      ; DWMSBT_TABBEDWINDOW

    _DBG(Format("Backdrop request '{}' -> mode {}", s, mode))
    try _DWM_SetAttrInt(hWnd, 38, mode)  ; DWMWA_SYSTEMBACKDROP_TYPE (Win11 22621+)

    ; Fallback for older 22H2 builds where SYSTEMBACKDROP_TYPE might be inert:
    ; DWMWA_MICA_EFFECT was used pre-22523; ignore errors on newer builds.
    try _DWM_SetAttrInt(hWnd, 1029, 1)   ; DWMWA_MICA_EFFECT (deprecated/old) 
    ; (Safe to attempt; ignored on newer builds.) :contentReference[oaicite:5]{index=5}

    ; Corners
    cp := 2  ; 2=Round, 1=DoNotRound, 3=Small
    if (IsSet(CornerPref)) {
        sw := StrLower(Trim(CornerPref))
        if (sw = "square" || sw = "donotround")
            cp := 1
        else if (sw = "small")
            cp := 3
    }
    try _DWM_SetAttrInt(hWnd, 33, cp)  ; DWMWA_WINDOW_CORNER_PREFERENCE

    ; Region rounding fallback ONLY when no backdrop is active
    if (mode = 1 && cp != 1 && hWnd && WinExist("ahk_id " . hWnd)) {
        _DBG("ApplyRoundRegion fallback start")
        __ApplyRoundRegionClip(hWnd)
        _DBG("ApplyRoundRegion fallback end")
    }
}


; ===== NEW: gui.ahk :: __ApplyRoundRegionClip =====
__ApplyRoundRegionClip(hWnd) {
    radius := (IsSet(CornerRadiusPx) ? CornerRadiusPx : 12)
    sw := StrLower(Trim(IsSet(CornerPref) ? CornerPref : "round"))
    if (sw = "square" || sw = "donotround" || radius <= 0)
        return
    if (!hWnd)
        return
    if !WinExist("ahk_id " . hWnd)
        return

    x := 0, y := 0, w := 0, h := 0
    try WinGetPos(&x, &y, &w, &h, "ahk_id " . hWnd)
    if (w <= 0 || h <= 0)
        return

    hrgn := DllCall("gdi32\CreateRoundRectRgn"
        , "int", 0, "int", 0
        , "int", w + 1, "int", h + 1
        , "int", radius * 2, "int", radius * 2
        , "ptr")
    if (hrgn)
        DllCall("user32\SetWindowRgn", "ptr", hWnd, "ptr", hrgn, "int", 1)
}



_PostShowInsetFix(guiObj, lvCtrl, pad) {
    if (pad <= 0)
        return
    gx := 0, gy := 0, gw := 0, gh := 0
    lx := 0, ly := 0, lw := 0, lh := 0
    try guiObj.GetPos(&gx, &gy, &gw, &gh)
    try lvCtrl.GetPos(&lx, &ly, &lw, &lh)
    ; If LV is hugging the edges, pull it back to ensure the overlay inset exists.
    needFix := (lx <= 0) || (ly <= 0) || (lw >= gw) || (lh >= gh)
    if (needFix) {
        try lvCtrl.Move(pad, pad, Max(10, gw - pad*2), Max(10, gh - pad*2))
    }
    ; One-tick deferred re-assert in case theme compositor raced our first apply.
    SetTimer(() => _ApplyBackdropAndCorners(guiObj.Hwnd), -1)
}




_ApplyOpacity(hWnd) {
    global OverlayOpacity, OverlayOpacityMode, BackdropMode
    if !IsSet(OverlayOpacity)
        return

    ; Skip layered opacity when a backdrop is requested and mode is "auto".
    sBackdrop := IsSet(BackdropMode) ? StrLower(BackdropMode) : "none"
    sOp := IsSet(OverlayOpacityMode) ? StrLower(OverlayOpacityMode) : "auto"
    if (sOp = "auto" && (sBackdrop = "mica" || sBackdrop = "acrylic" || sBackdrop = "tabbed" || sBackdrop = "auto")) {
        return  ; allow DWM backdrop to draw
    }

    alpha := OverlayOpacity
    if (alpha < 0)   alpha := 0
    if (alpha > 255) alpha := 255
    try WinSetTransparent(alpha, "ahk_id " . hWnd)
}


_RemoveLvBorder(hLV) {
    ; Remove WS_EX_CLIENTEDGE and WS_BORDER from ListView
    GWL_EXSTYLE := -20
    WS_EX_CLIENTEDGE := 0x00000200
    GWL_STYLE := -16
    WS_BORDER := 0x00800000

    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hLV, "int", GWL_EXSTYLE, "ptr")
    ex := ex & ~WS_EX_CLIENTEDGE
    DllCall("user32\SetWindowLongPtrW", "ptr", hLV, "int", GWL_EXSTYLE, "ptr", ex, "ptr")

    st := DllCall("user32\GetWindowLongPtrW", "ptr", hLV, "int", GWL_STYLE, "ptr")
    st := st & ~WS_BORDER
    DllCall("user32\SetWindowLongPtrW", "ptr", hLV, "int", GWL_STYLE, "ptr", st, "ptr")

    ; refresh frame
    SWP_NOSIZE := 0x0001, SWP_NOMOVE := 0x0002, SWP_NOZORDER := 0x0004, SWP_FRAMECHANGED := 0x0020
    flags := SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED
    DllCall("user32\SetWindowPos", "ptr", hLV, "ptr", 0, "int", 0, "int", 0, "int", 0, "int", 0, "uint", flags)
}

_SetListViewColors(hLV, bg, text, textBg) {
    ; We leave BK as CLR_NONE so the parent/backdrop is visible.
    CLR_NONE := 0xFFFFFFFF
    cTX := _RgbToBgr(text)

    LVM_SETBKCOLOR     := 0x1001
    LVM_SETTEXTCOLOR   := 0x1024
    LVM_SETTEXTBKCOLOR := 0x1025

    DllCall("user32\SendMessage","ptr",hLV,"uint",LVM_SETBKCOLOR,     "uptr",0,"int",CLR_NONE)
    DllCall("user32\SendMessage","ptr",hLV,"uint",LVM_SETTEXTCOLOR,   "uptr",0,"int",cTX)
    DllCall("user32\SendMessage","ptr",hLV,"uint",LVM_SETTEXTBKCOLOR, "uptr",0,"int",CLR_NONE)

    ; Force a repaint
    DllCall("user32\InvalidateRect", "ptr", hLV, "ptr", 0, "int", 1, "int")
}



; Remove WS_EX_LAYERED if present (layered windows and backdrops don’t mix well)
_ForceNoLayered(hWnd) {
    GWL_EXSTYLE     := -20
    WS_EX_LAYERED   := 0x00080000
    try {
        ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", GWL_EXSTYLE, "ptr")
        if (ex & WS_EX_LAYERED) {
            ex := ex & ~WS_EX_LAYERED
            DllCall("user32\SetWindowLongPtrW", "ptr", hWnd, "int", GWL_EXSTYLE, "ptr", ex, "ptr")
            ; refresh frame
            SWP_NOSIZE := 0x0001, SWP_NOMOVE := 0x0002, SWP_NOZORDER := 0x0004, SWP_FRAMECHANGED := 0x0020
            flags := SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED
            DllCall("user32\SetWindowPos", "ptr", hWnd, "ptr", 0, "int", 0, "int", 0, "int", 0, "int", 0, "uint", flags)
            _DBG("Removed WS_EX_LAYERED from overlay window.")
        }
    }
}

; Dump environment that commonly breaks Mica/Acrylic
_Debug_DumpBackdropEnv(hGui, hLV) {
    try {
        ; OS version/build
        ver := A_OSVersion
        _DBG("OS: " ver)
    }

    ; Is DWM composition enabled?
    try {
        enabled := 0
        hr := DllCall("dwmapi\DwmIsCompositionEnabled", "int*", &enabled, "int")
        _DBG(Format("DwmIsCompositionEnabled={} hr={}", enabled, hr))
    }

    ; Transparency effects toggle (1 = on, 0 = off)
    try {
        trans := RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", "EnableTransparency")
        if (trans = "")
            trans := "N/A"
        _DBG("EnableTransparency=" trans)
    }

    ; Window styles (check for WS_EX_LAYERED which can suppress backdrops)
    try {
        GWL_STYLE   := -16
        GWL_EXSTYLE := -20
        WS_EX_LAYERED := 0x00080000

        gui_ex := DllCall("user32\GetWindowLongPtrW", "ptr", hGui, "int", GWL_EXSTYLE, "ptr")
        gui_st := DllCall("user32\GetWindowLongPtrW", "ptr", hGui, "int", GWL_STYLE,   "ptr")
        _DBG(Format("GUI style=0x{:X} exstyle=0x{:X}", gui_st, gui_ex))
        if (gui_ex & WS_EX_LAYERED)
            _DBG("WARNING: GUI has WS_EX_LAYERED (may block Mica/Acrylic)")

        lv_ex := DllCall("user32\GetWindowLongPtrW", "ptr", hLV, "int", GWL_EXSTYLE, "ptr")
        _DBG(Format("LV exstyle=0x{:X}", lv_ex))
    }

    try _DBG("Handles: gui=" hGui " lv=" hLV)
}






_RgbToBgr(col) {
    ; Accept "#RRGGBB" or integer 0xRRGGBB
    if (Type(col) = "Integer") {
        val := col
    } else {
        s := Trim(col)
        if (SubStr(s, 1, 1) = "#") {
            hex := SubStr(s, 2)
            if (StrLen(hex) = 6) {
                r := ("0x" . SubStr(hex, 1, 2)) + 0
                g := ("0x" . SubStr(hex, 3, 2)) + 0
                b := ("0x" . SubStr(hex, 5, 2)) + 0
                val := (r << 16) | (g << 8) | b
            } else {
                val := 0x20242A
            }
        } else {
            val := s + 0
        }
    }
    r := (val >> 16) & 0xFF
    g := (val >> 8)  & 0xFF
    b := (val)       & 0xFF
    return (b << 16) | (g << 8) | r
}

; ===================== POSITIONING =====================
_CenterOnWorkArea(guiObj, lvCtrl) {
    ; --- figure active-center (fallback to primary) ---
    ax := 0, ay := 0, aw := 0, ah := 0
    try WinGetPos(&ax, &ay, &aw, &ah, "A")
    cx := ax + Floor(aw / 2)
    cy := ay + Floor(ah / 2)

    mon := 1
    cnt := MonitorGetCount()
    if (cnt < 1)
        cnt := 1

    i := 1
    while (i <= cnt) {
        l := 0, t := 0, r := 0, b := 0
        try MonitorGet(i, &l, &t, &r, &b)
        if (cx >= l && cx < r && cy >= t && cy < b) {
            mon := i
            break
        }
        i := i + 1
    }

    ; --- get a safe work area rect ---
    L := 0, T := 0, R := 0, B := 0
    _SafeWorkAreaRect(mon, &L, &T, &R, &B)  ; guarantees valid rect

    ; --- current GUI size ---
    gx := 0, gy := 0, gw := 0, gh := 0
    try guiObj.GetPos(&gx, &gy, &gw, &gh)
    if (gw <= 0 || gh <= 0) {
        gw := 600, gh := 380
    }

    ; --- center + clamp within [L..R] x [T..B] ---
    areaW := R - L
    areaH := B - T
    nx := L + Floor((areaW - gw) / 2)
    ny := T + Floor((areaH - gh) / 2)

    if (nx < L) nx := L
    if (ny < T) ny := T
    if (nx + gw > R) nx := R - gw
    if (ny + gh > B) ny := B - gh

    try guiObj.Move(nx, ny)
}


_SafeWorkAreaRect(mon, &L, &T, &R, &B) {
    ; Try work-area first
    ok := false
    try {
        if MonitorGetWorkArea(mon, &L, &T, &R, &B) {
            if (R > L && B > T)
                ok := true
        }
    }

    ; Fallback: full monitor bounds
    if (!ok) {
        L := 0, T := 0, R := 0, B := 0
        try {
            if MonitorGet(mon, &L, &T, &R, &B) {
                if (R > L && B > T)
                    ok := true
            }
        }
    }

    ; Final fallback: primary screen (0..A_ScreenWidth/Height)
    if (!ok) {
        L := 0, T := 0
        R := A_ScreenWidth
        B := A_ScreenHeight
    }
}


; =======================================================
; End of file

---------

Now, we have a newgui.ahk that I'm trying to wire this into. but anytime I ask you, you get very confused between the 2
so I have to guide you a bit more

so help me pull out the parts of the code in this prompt that interact with FUNCTIONS or VARIABLES / DATA STRUCTURES not in this code

For example, I notice oldgui.ahk has this function

_GetWorkspaceForHwnd(hwnd) {
    ws := ""
    try {
        if Komorebi_SubTryMap(hwnd, &ws) && (ws != "")
            return ws
    } catch {
    }
    return ""
}

So I can see the workspace name comes from Komorebi_SubTryMap(hwnd, &ws).
so thats how we need to use it in the new GUI. 

but where does the hwnd come from?
what other data is this brining in?
what is it signalling out, like how it signals an alt tab needs to be preformed?
what is the GUI name/ID so I can match in the new version

So please give a detailed report of all the wiring this oldgui code uses to TAKE INFORMATION END and SEND INFORMATION OUT to the rest of the application
Sounds good. as its relevant, heres my config.ahk
--------- ; ================== CONFIG (tweak freely) ================== ; ---- Debug toggles ---- global DebugKomorebi := false global DebugBlacklist := false global DebugLogReceived := false global DebugGUI := false global DebugLogPath := A_ScriptDir "\tabby_debug.log" global DebugMaxLinesPerSession := 200 ; optional global DebugMaxDurationMs := 200 ; optional global UseRxWatchdog := false ; if true, the gui will have a timer for assuming it missed alt release message global HoldMs := 150 ; overlay delay (ms) when holding Alt after first Tab global UseAltGrace := false ; true: global Tab+grace; false: only when Alt physically down global AltGraceMs := 80 ; grace window for Alt pressed just before Tab global DisableInProcesses := [ ; e.g. "valorant.exe", "eldenring.exe" ] global DisableInFullscreen := false ; bypass in fullscreen-looking windows global UseMRU := true ; true: build cycling list from MRU ring vs pure Z-order global SwitchCloakedMode := "ignore" ; "ignore" | "toast" ; "ignore": do nothing if target is in other Komorebi workspace ; "toast": show small tooltip explaining why no switch happened global UseAltTabEligibility := true ; filter windows like native Alt-Tab ; alt tab fighting global BlockBareAlt := true global UseAltComboHook := true global RefreshOnOverlay := true ; rebuild list when overlay first appears global RefreshOnAltUp := true ; rebuild list just before activation ; === NEW: overlay + icons === global UseIcons := true ; show app icons in the list global IconBatchPerTick := 3 ; how many icons to resolve per timer tick global IconTimerIntervalMs := 15 ; timer cadence for icon loading global IconSizePx := 64 ; small icon size ; === NEW: komorebi integration === global FocusCloakedViaKomorebi := true global KomorebicExe := "C:\Program Files\komorebi\bin\komorebic.exe" ; <— set to your actual path ; === Blacklists for enumeration (AHK wildcard, case-insensitive) === global BlacklistTitle := [ "komoborder*", "YasbBar", "NVIDIA GeForce Overlay", "DWM Notification Window", "MSCTFIME UI", "Default IME", "Task Switching", "Command Palette", "GDI+ Window (OneDrive.exe)", "Windows Input Experience", OverlayTitle ; avoid listing our own overlay ] global BlacklistClass := [ "komoborder*", "CEF-OSC-WIDGET", "Dwm", "MSCTFIME UI", "IME", "GDI+ Hook Window Class", "XamlExplorerHostIslandWindow", "WinUIDesktopWin32WindowClass", "Windows.UI.Core.CoreWindow", "AutoHotkeyGUI" ; avoid listing any AHK GUI (including ours) ] ; Class+Title pair blacklist (both must match). Wildcards * and ? are OK (case-insensitive). global BlacklistPair := [] ;; Class+Title (exact): BlacklistPair.Push({ Class: "GDI+ Hook Window Class", Title: "GDI+ Window (OneDrive.exe)" }) ; ================== EXIT HOTKEY ================== global QuitHotkey := "$*!F12" ; Alt+F12 ; =============== OLD GUI SETTINGS ================= global OverlayFont := "Segoe UI" global OverlayTitle := "Switch" ; window title for overlay (we also blacklist it) ; add these near the top with other tunables: ; Column visibility (affects overlay ListView) ; Always shown: "#", "Title", "Class", "State" ; Optional: global GUI_ShowPID := false ; show Process ID global GUI_ShowHWND := false ; show HWND (hex if GUI_HWND_Hex=true) global GUI_ShowWinNum := false ; show Z-order / enumeration number global GUI_ShowKomorebi := true ; show Komorebi workspace name, e.g., "Main", "Media", "Game" global GUI_ShowClass := false ; State shortening: WorkspaceShowing -> WS-Shown, etc. global GUI_StateShort := true ; HWND formatting global GUI_HWND_Hex := true ; ================== OLD THEME (overlay) ================== ; Backdrop/material global BackdropMode := "mica" ; "none" | "auto" | "mica" | "acrylic" | "tabbed" ; Opacity policy ; "auto" -> if BackdropMode is not "none", skip layered opacity so DWM material can render ; "force" -> apply layered opacity anyway (will suppress material) global OverlayOpacityMode := "auto" ;global OverlayOpacity := 200 ; 0..255 (ignored when Mode="auto" and BackdropMode != "none") ; Corners + region fallback global CornerPref := "round" ; "round" | "small" | "square" global CornerRadiusPx := 14 ; used by _ApplyRoundRegion fallback global OverlayInsetPx := 40 ; padding ring to reveal material around the LV ; ListView theming/toggles global LV_DisableTheme := true ; disable Explorer theme so custom colors take effect global LV_TransparentBG := false ; control-level transparency attempt (safe to leave false) global LV_UseCustomDraw := true ; custom colors for text + selection ; ListView colors (hex "#RRGGBB" or integer 0xRRGGBB) global LV_ColorBG := "#14181C" ; (parent is material; LV bg is set to CLR_NONE anyway) global LV_ColorText := "#F5F7FA" global LV_ColorTextBG := "#14181C" global LV_ColorSelBG := "#2B5CAD" global LV_ColorSelText := "#FFFFFF" ; =============== NEW GUI SETTINGS ================= ; ========================= CONFIG ========================= ; Background Window global AcrylicAlpha := 0x33 ; 0..255 (higher = more opaque) global AcrylicBaseRgb := 0x330000 ; 0xRRGGBB base tint for acrylic - um I think its BBGGRR actually global CornerRadiusPx := 18 global AlwaysOnTop := true ; Selection scroll behavior global ScrollKeepHighlightOnTop := true ; false = anchor at bottom when scrolling down; true = highlighted row stays at top ; ---- Size config ---- global ScreenWidthPct := 0.60 ; 0.30..0.95 typical. Window width = this % of primary work area ; ---- Dynamic visible rows (window auto-resizes between these) ---- global RowsVisibleMin := 1 global RowsVisibleMax := 5 ; Virtual list look global RowHeight := 56 ; px height of each virtual row global MarginX := 18 global MarginY := 18 global IconSize := 36 global IconLeftMargin := 8 global RowRadius := 12 ; selection pill rounding global SelARGB := 0x662B5CAD ; AARRGGBB semi-transparent blue-ish ; ---- Action keystrokes (true/false gates) ---- global AllowCloseKeystroke := true global AllowKillKeystroke := true global AllowBlacklistKeystroke := true ; ---- Show row action buttons on hover ---- global ShowCloseButton := true global ShowKillButton := true global ShowBlacklistButton := true ; ---- Font + color theming ---- ; NOTE: weight >= 600 => bold, otherwise regular (GDI+ supports bold/regular) ; ---- Action button geometry / font ---- global ActionBtnSizePx := 24 global ActionBtnGapPx := 6 global ActionBtnRadiusPx := 6 global ActionFontName := "Segoe UI Symbol" ; try "Segoe UI" if symbols don't render global ActionFontSize := 18 global ActionFontWeight := 700 ; ---- Close button styling ---- global CloseButtonBorderPx := 1 global CloseButtonBorderARGB := 0x88FFFFFF global CloseButtonBGARGB := 0xFF000000 global CloseButtonBGHoverARGB := 0xFF888888 global CloseButtonTextARGB := 0xFFFFFFFF global CloseButtonTextHoverARGB := 0xFFFF0000 global CloseButtonGlyph := "❌" ; fallback: "X" ; ---- Kill button styling ---- global KillButtonBorderPx := 1 global KillButtonBorderARGB := 0x88FFB4A5 global KillButtonBGARGB := 0xFF300000 global KillButtonBGHoverARGB := 0xFFD00000 global KillButtonTextARGB := 0xFFFFE8E8 global KillButtonTextHoverARGB := 0xFFFFFFFF global KillButtonGlyph := "☠️" ; fallback: "K" ; ---- Blacklist button styling ---- global BlacklistButtonBorderPx := 1 global BlacklistButtonBorderARGB := 0x88999999 global BlacklistButtonBGARGB := 0xFF000000 global BlacklistButtonBGHoverARGB := 0xFF888888 global BlacklistButtonTextARGB := 0xFFFFFFFF global BlacklistButtonTextHoverARGB := 0xFFFF0000 global BlacklistButtonGlyph := "⛔" ; fallback: "B" ; ---- Extra columns (0 = hidden) ---- global ColFixed2 := 70 ; fixed width for column 2 (right) global ColFixed3 := 50 ; fixed width for column 3 (right) global ColFixed4 := 0 global ColFixed5 := 0 global ColFixed6 := 0 ; Optional headers global ShowHeader := true global Col2Name := "HWND" ; optional ; show HWND (hex if GUI_HWND_Hex=true) global Col3Name := "PID" ; optional ; show Process ID global Col4Name := "WS" ; optional ; show Komorebi workspace name, e.g., "Main", "Media", "Game" global Col5Name := "NUM" ; optional ; show Z-order / enumeration number global Col6Name := "CLASS" ; optional ; show class ; ---- Header font (name/size/weight/color) ---- global HdrFontName := "Segoe UI" global HdrFontSize := 12 global HdrFontWeight := 600 ; >=600 => bold global HdrARGB := 0xFFD0D6DE ; header text color ; Main Font global MainFontName := "Segoe UI" global MainFontSize := 20 global MainFontWeight := 400 global MainFontNameHi := "Segoe UI" global MainFontSizeHi := 20 global MainFontWeightHi := 800 global MainARGB := 0xFFF0F0F0 ; main text color global MainARGBHi := MainARGB ; main text highlight ; Sub Font global SubFontName := "Segoe UI" global SubFontSize := 12 global SubFontWeight := 400 global SubFontNameHi := "Segoe UI" global SubFontSizeHi := 12 global SubFontWeightHi := 600 global SubARGB := 0xFFB5C0CE ; dim text global SubARGBHi := SubARGB ; Col Font global ColFontName := "Segoe UI" global ColFontSize := 12 global ColFontWeight := 400 global ColFontNameHi := "Segoe UI" global ColFontSizeHi := 12 global ColFontWeightHi := 600 global ColARGB := 0xFFF0F0F0 ; column text color (same on highlight) global ColARGBHi := ColARGB ; column text color highlight ; ---- Overlay scrollbar (virtual) ---- global ScrollBarEnabled := true ; show/hide overlay scrollbar global ScrollBarWidthPx := 6 ; thickness in px (DIPs) global ScrollBarMarginRightPx := 8 ; distance from right edge (DIPs) global ScrollBarThumbARGB := 0x88FFFFFF ; AARRGGBB for thumb (semi-white) global ScrollBarGutterEnabled := false ; draw a gutter/track behind thumb global ScrollBarGutterARGB := 0x30000000 ; AARRGGBB for gutter (semi-dark) ; Message shown when there are no items (uses Main font styling) global EmptyListText := "No Windows" ; ---- Footer / Scope switcher (POC) ---- global ShowFooter := true ; show the footer bar global FooterTextAlign := "center" ; "left" | "center" | "right" global FooterBorderPx := 0 global FooterBorderARGB := 0x33FFFFFF global FooterBGRadius := 0 global FooterBGARGB := 0x00000000 ; subtle translucent fill global FooterTextARGB := 0xFFFFFFFF global FooterFontName := "Segoe UI" global FooterFontSize := 16 global FooterFontWeight := 600 global FooterHeightPx := 10 ; DIP height of the footer bar global FooterGapTopPx := 10 ; space between list and footer global FooterPaddingX := 0 ; text padding inside the bar 
-------- 
You can see I've aleady moved our config from our new GUI into this as globals, under: 
; =============== NEW GUI SETTINGS ================= 
I've left the old GUI code for reference here. 
; =============== OLD GUI SETTINGS ================= 
We can ditch most of it. 

I think the only relevant stuff to keep is probably: 
; State shortening: WorkspaceShowing -> WS-Shown, etc. 
global GUI_StateShort := true ; HWND formatting 
global GUI_HWND_Hex := true 

Also in the old config, but not for direct use are these items global 
GUI_ShowPID := false ; show Process ID 
global GUI_ShowHWND := false ; show HWND (hex if GUI_HWND_Hex=true) 
global GUI_ShowWinNum := false ; show Z-order / enumeration number 
global GUI_ShowKomorebi := true ; show Komorebi workspace name, e.g., "Main", "Media", "Game" 
global GUI_ShowClass := false 

We can ditch these configs and keep these values all the time, but where these are gonna go is into our columns 
the HWND goes into Col2 
PID goes into Col3 
ShowKomorebi goes into Col4 
WinNum into Col5 
Class (which you current have in col1-sub) goes into column 6 
so these wont have toggles directly, they will just be controleld by the existing pixel width settings 
Col1 sub text, where you currently have class, will have StateShort 

I think the only other stuff we might need to bring over in addition to what you identified is the icon logic and icon cache

So as we move the real function from gui.ahk into our newgui.ahk we dont need to focus on functions that dont exist yet
so process kill, window close, all those can remain placeholders
we just want to focus on moving the existing behavior gui.ahk into our newgui.ahk and wiring it up to our for real app

Now this is a very long prompt, and you will struggle with outputting a combine yourself. 
I think its best that instead you give me function level ADD / REPLACE / REMOVE instructions
 so you are explaining what functions needed to be added/modified to newgui.ahk to wire all the function from gui.ahk, the working alt tab gui, into our newgui.ahk 
 such that after i will be able to just swap my include of gui.ahk to an include of newgui.ahk 
 

Just give me function level ADD / REPLACE / REMOVES, or block level if its outside a function.
Remember - AHKv2 Syntax, especially variable assignments and IF syntax 

So again, we are brining over what you identified, including but not limited to:
Overlay_ShowList(list, selIndex)
Overlay_UpdateSelection(list, selIndex)
Overlay_Hide()
ws := ""
try Komorebi_SubTryMap(item.Hwnd, &ws)
copy the GUI title/handle/name from old into new
ok, i did what you gave me and my newgui is this
--------
#Requires AutoHotkey v2.0
; -----------------------------------------------------------------------------
; overlay_list_on_acrylic_poc_scroll_icons.ahk
; - Base: borderless acrylic (no flash)
; - Overlay: layered window same size/pos (catches all clicks), renders a simple
;            “virtual list” with columns + real icon + selection + scroll wheel.
;   Hotkeys:
;   Up/Down, Tab/Shift+Tab : change selection (keeps selection in view)
;   Mouse wheel            : scroll by rows
;   Z / X                  : hide / show overlay (POC toggle)
;   Q                      : cycle footer text (POC)
;   C / K / B              : close / kill (confirm) / blacklist (confirm)
;   Esc                    : exit
; -----------------------------------------------------------------------------

; Reveal both base + overlay together right after first painted frame
global gRevealed := false

global gHoverRow := 0        ; 1-based item index that the mouse is over; 0 = none
global gHoverBtn := ""       ; "", "close", "kill", "blacklist"

; persistent Graphics bound to the backbuffer HDC
global gG := 0

; Footer state (POC text cycle with Q)
global gFooterModes := ["All Windows", "XXX Windows", "XXX Visible Windows"]
global gFooterModeIndex := 1
global gFooterText := gFooterModes[gFooterModeIndex]


; ===== Overlay wiring compatibility (from oldgui) =====
global gGui := 0                  ; your overlay’s top-level GUI/window handle holder
global gOverlayOn := false
global gListSnap := []            ; last list handed to overlay
global gSelSnap := 1              ; last 1-based selection index

; ----- icon cache/pump (GUI-independent) -----
global gIconCache := Map()        ; hwnd -> { hicon: Ptr | 0, pid: UInt, class: Str }
global gIconQueue := []           ; hwnds pending resolution
global gIconPumpOn := false

; Use your existing config entries:
; OverlayTitle := "Switch"
; GUI_StateShort := true
; GUI_HWND_Hex := true
; UseIcons, IconBatchPerTick, IconTimerIntervalMs


; ========================= DEBUG =========================
global DebugGUI := false
global DebugLogPath := A_ScriptDir "\tabby_debug.log"

_DBG(msg) {
    if !DebugGUI {
        return
    }
    path := (DebugLogPath && DebugLogPath != "") ? DebugLogPath : (A_ScriptDir "\tabby_debug.log")
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss")
    SplitPath(path, , &dir)
    try DirCreate(dir)
    FileAppend(ts " | " msg "rn", path, "UTF-8")
}

_DWM_SetAttrInt(hWnd, attrId, value) {
    buf := Buffer(4, 0)
    NumPut("Int", value, buf, 0)
    hr := DllCall("dwmapi\DwmSetWindowAttribute"
        , "ptr", hWnd
        , "int", attrId
        , "ptr", buf.Ptr
        , "int", 4
        , "int")
    _DBG(Format("DWM attr{} val={} hr={}", attrId, value, hr))
    return hr
}

_ConfirmTopmost(text, title := "Confirm") {
    global gOverlayH  ; or gBaseH – either is fine; the owner just needs to be your UI
    res := MsgBox(text, title, "YesNo Icon! Default2 0x1000")
    return (res = "Yes" || res = 6) ; string ("Yes") or numeric (6) for compatibility
}

_FooterBlockDip() {
    global ShowFooter, FooterHeightPx, FooterGapTopPx
    return ShowFooter ? (FooterGapTopPx + FooterHeightPx) : 0
}


_DebugDump(hGui) {
    try _DBG("OS: " A_OSVersion)
    try {
        enabled := 0
        hr := DllCall("dwmapi\DwmIsCompositionEnabled", "int*", &enabled, "int")
        _DBG(Format("DwmIsCompositionEnabled={} hr={}", enabled, hr))
    }
    try {
        trans := RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", "EnableTransparency")
        if (trans = "") {
            trans := "N/A"
        }
        _DBG("EnableTransparency=" trans)
    }
    try {
        GWL_STYLE := -16, GWL_EXSTYLE := -20
        ex := DllCall("user32\GetWindowLongPtrW", "ptr", hGui, "int", GWL_EXSTYLE, "ptr")
        st := DllCall("user32\GetWindowLongPtrW", "ptr", hGui, "int", GWL_STYLE,   "ptr")
        _DBG(Format("GUI style=0x{:X} exstyle=0x{:X}", st, ex))
    }
}

; ======= OLD to NEW API SHIM ========
Overlay_ShowList(list, selIndex) {
    global gGui, gOverlayOn, gListSnap, gSelSnap, UseIcons, OverlayTitle, AlwaysOnTop

    gListSnap := list
    gSelSnap  := selIndex

    ; 1) Ensure overlay exists (create if absent) and set title to "Switch"
    NewGUI__EnsureCreated()                  ; <-- implement if you don’t have it
    try WinSetTitle(OverlayTitle, "ahk_id " gGui)  ; keep stable title for blacklist
    if (IsSet(AlwaysOnTop) && AlwaysOnTop)
        try WinSetAlwaysOnTop(1, "ahk_id " gGui)

    ; 2) Rebuild initial view from list + selection
    NewGUI__RebuildFromList(gListSnap, gSelSnap)   ; <-- call your draw/measure code

    ; 3) Kick icon pump if enabled
    if (IsSet(UseIcons) && UseIcons) {
        NewGUI__QueueIconsForVisibleRows(gListSnap, gSelSnap) ; enqueue by hwnd
        _Icon_StartPump()
    }

    ; 4) Show
    NewGUI__Show()                          ; <-- your show (non-activating) call
    gOverlayOn := true
}

Overlay_UpdateSelection(list, selIndex) {
    global gListSnap, gSelSnap, UseIcons
    gListSnap := list
    gSelSnap  := selIndex

    NewGUI__UpdateSelection(gListSnap, gSelSnap)    ; redraw rows only

    if (IsSet(UseIcons) && UseIcons)
        NewGUI__QueueIconsForVisibleRows(gListSnap, gSelSnap)
}

Overlay_Hide() {
    global gGui, gOverlayOn
    gOverlayOn := false
    NewGUI__Hide()                                   ; your hide/destroy path
    ; Optional: _Icon_ClearCache() if you want to free HICONs aggressively
}

; Returns a plain object with what your painter needs for a row
NewGUI__BuildRowModel(item, idx, total) {
    ; Col 1 (main) = Title; Col1 sub = StateShort
    main := item.Title
    if (StrLen(main) > 140)
        main := SubStr(main, 1, 137) . "..."

    sub  := _StateShort(item.State)

    ; Fixed mapping you wanted:
    ; Col2: HWND (hex if GUI_HWND_Hex), Col3: PID, Col4: WS, Col5: ZOrder, Col6: Class
    hwndStr := (IsSet(GUI_HWND_Hex) && GUI_HWND_Hex)
        ? ("0x" . Format("{:X}", item.Hwnd))
        : (item.Hwnd . "")

    ws := _GetWorkspaceForHwnd(item.Hwnd)

    ; Icon handle (if available now); defer to pump otherwise.
    hico := _Icon_GetCached(item.Hwnd)

    return {
        Number: "[" idx "/" total "]",
        Title:  main,
        Sub:    sub,
        Col2:   hwndStr,
        Col3:   item.Pid,
        Col4:   ws,
        Col5:   item.ZOrder,
        Col6:   item.Class,
        HICON:  hico
    }
}

;========= ICONS =============
_Icon_GetCached(hwnd) {
    global gIconCache
    return (gIconCache.Has(hwnd) && gIconCache[hwnd].hicon) ? gIconCache[hwnd].hicon : 0
}

_Icon_StartPump() {
    global gIconPumpOn, IconTimerIntervalMs
    if (gIconPumpOn)
        return
    gIconPumpOn := true
    SetTimer(_Icon_Pump, IconTimerIntervalMs)
}

_Icon_Pump() {
    global gIconPumpOn, gIconQueue, IconBatchPerTick, gIconCache, gOverlayOn, gListSnap, gSelSnap

    if (!gOverlayOn) {
        gIconQueue := []
        gIconPumpOn := false
        SetTimer(_Icon_Pump, 0)
        return
    }

    ; resolve a few per tick
    count := 0
    changed := false
    while (gIconQueue.Length && count < IconBatchPerTick) {
        hwnd := gIconQueue.RemoveAt(1)
        if (gIconCache.Has(hwnd)) {
            count += 1
            continue
        }

        pid := 0, cls := ""
        for _, it in gListSnap {           ; fast linear scan OK for small page
            if (it.Hwnd = hwnd) {
                pid := it.Pid
                cls := it.Class
                break
            }
        }

        hico := _Icon_ResolveSmall(hwnd)
        if (!hico) {
            ; attempt from process exe if window didn’t return one
            if (pid) {
                exe := _Icon_GetProcessPath(pid)
                if (exe) {
                    hSmall := 0, hLarge := 0
                    DllCall("Shell32\ExtractIconExW","wstr",exe,"int",0,"ptr*", &hLarge,"ptr*", &hSmall,"uint",1)
                    if (hSmall) {
                        if (hLarge) DllCall("user32\DestroyIcon","ptr",hLarge)
                        hico := hSmall
                    } else if (hLarge) {
                        hico := hLarge
                    }
                }
            }
        }

        gIconCache[hwnd] := { hicon: (hico ? hico : 0), pid: pid, class: cls }
        changed := changed || (hico != 0)
        count += 1
    }

    if (!gIconQueue.Length) {
        gIconPumpOn := false
        SetTimer(_Icon_Pump, 0)
    }

    if (changed) {
        ; Ask your view to redraw only visible rows
        NewGUI__InvalidateVisibleRows(gListSnap, gSelSnap)
    }
}

_Icon_ResolveSmall(hWnd) {
    if !WinExist("ahk_id " . hWnd)
        return 0
    WM_GETICON := 0x7F
    ICON_SMALL2 := 2, ICON_SMALL := 0, ICON_BIG := 1
    try {
        h := SendMessage(WM_GETICON, ICON_SMALL2, 0, , "ahk_id " . hWnd)
        if (!h) h := SendMessage(WM_GETICON, ICON_SMALL, 0, , "ahk_id " . hWnd)
        if (!h) h := SendMessage(WM_GETICON, ICON_BIG,   0, , "ahk_id " . hWnd)
        if (h) {
            return h
        }
    }
    h := DllCall("user32\GetClassLongPtrW","ptr",hWnd,"int",-34,"ptr") ; GCLP_HICONSM
    if (!h) h := DllCall("user32\GetClassLongPtrW","ptr",hWnd,"int",-14,"ptr") ; GCLP_HICON
    return h ? h : 0
}

_Icon_GetProcessPath(pid) {
    PROCESS_QUERY_LIMITED_INFORMATION := 0x1000
    hProc := DllCall("kernel32\OpenProcess","uint",PROCESS_QUERY_LIMITED_INFORMATION,"int",0,"uint",pid,"ptr")
    if (!hProc) {
        return ""
    }
    buf := Buffer(32767 * 2, 0), sz := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW","ptr",hProc,"uint",0,"ptr",buf.Ptr,"uint*",sz,"int")
    DllCall("kernel32\CloseHandle","ptr",hProc)
    return ok ? StrGet(buf.Ptr, "UTF-16") : ""
}

_Icon_ClearCache() {
    global gIconCache
    for hwnd, meta in gIconCache {
        if (meta.hicon)
            DllCall("user32\DestroyIcon","ptr",meta.hicon)
    }
    gIconCache := Map()
}



; ========================= WINDOW HELPERS =========================
_TryEnableDarkTitleBar(hWnd) {
    try _DWM_SetAttrInt(hWnd, 20, 1)  ; DWMWA_USE_IMMERSIVE_DARK_MODE (new)
    try _DWM_SetAttrInt(hWnd, 19, 1)  ; DWMWA_USE_IMMERSIVE_DARK_MODE (old)
}

_SetCornerPreference(hWnd, pref := 2) {
    ; 1=DoNotRound, 2=Round, 3=Small
    try _DWM_SetAttrInt(hWnd, 33, pref)  ; DWMWA_WINDOW_CORNER_PREFERENCE
}


_LoadTestIcon() {
    global gIconImg
    ; Try explorer.exe (most reliable), fall back to shell32.dll
    gIconImg := __LoadGpIconFromFile(A_WinDir "\explorer.exe", 0)
    if (!gIconImg) {
        gIconImg := __LoadGpIconFromFile(A_WinDir "\System32\shell32.dll", 4)
    }
}

_StateShort(s) {
    if !(IsSet(GUI_StateShort) && GUI_StateShort)
        return s
    sw := StrLower(Trim(s))
    if (sw = "workspaceshowing")      {
        return "WS-Shown"
        }
    else if (sw = "workspaceminimized") {
        return "WS-Min"
    }
    else if (sw = "workspacehidden")   {

     return "WS-Hidden"
    }
    else if (sw = "otherworkspace")    {
     return "Other-WS"
    }
    return s
}

_GetWorkspaceForHwnd(hwnd) {
    ws := ""
    try {
        if Komorebi_SubTryMap(hwnd, &ws) && (ws != "")
            return ws
    } catch {
    }
    return ""
}

_WrapIndex(idx, len) {
    if (len <= 0) {
        return 1
    }
    n := Mod(idx - 1, len)
    if (n < 0) n += len
    return n + 1
}


_GetIconLeftMarginDip(scale) {
    global IconLeftMargin
    try {
        return Round(IconLeftMargin * scale)
    } catch {
        return 0
    }
}

; Keep hover state (row + which button) aligned with the current cursor
; even if rows move due to scroll/selection changes.
_RecalcHoverFromCurrentCursor() {
    global gOverlayH, gHoverRow, gHoverBtn
    if (!gOverlayH) {
        return false
    }
    ; Get cursor in screen coords
    pt := Buffer(8, 0)
    if !DllCall("user32\GetCursorPos", "ptr", pt) {
        return false
    }
    ; Convert to overlay client coords (physical px)
    if !DllCall("user32\ScreenToClient", "ptr", gOverlayH, "ptr", pt.Ptr) {
        return false
    }
    x := NumGet(pt, 0, "Int")
    y := NumGet(pt, 4, "Int")

    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)

    changed := (idx != gHoverRow || act != gHoverBtn)
    gHoverRow := idx
    gHoverBtn := act
    return changed
}


_HeaderBlockDip() {
    ; 32 == 4px top pad + 28px header line height
    global ShowHeader
    return ShowHeader ? 32 : 0
}

__FontStyleFromWeight(w) {
    ; GDI+ style: 0=Regular, 1=Bold
    try {
        return (w+0 >= 600) ? 1 : 0
    } catch {
        return 0
    }
}

_EnsureGraphics() {
    global gBackHdc, gG
    ; If there's no backbuffer DC, we can't make a Graphics
    if (!gBackHdc) {
        return 0
    }
    ; Always rebuild the GDI+ Graphics from the CURRENT backbuffer HDC.
    ; This avoids intermittently using a Graphics tied to an old/invalid surface.
    if (gG) {
        try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
        gG := 0
    }
    DllCall("gdiplus\GdipCreateFromHDC", "ptr", gBackHdc, "ptr*", &gG)
    if (!gG) {
        return 0
    }
    SmoothingModeAntiAlias := 4
    TextRenderingHintClearTypeGridFit := 5
    DllCall("gdiplus\GdipSetSmoothingMode", "ptr", gG, "int", SmoothingModeAntiAlias)
    DllCall("gdiplus\GdipSetTextRenderingHint", "ptr", gG, "int", TextRenderingHintClearTypeGridFit)
    return gG
}

__Wrap0(i, count) {
    ; returns 0..count-1 (handles negative i)
    if (count <= 0) {
        return 0
    }
    r := Mod(i, count)
    if (r < 0) {
        r := r + count
    }
    return r
}

__Wrap1(i, count) {
    ; returns 1..count (handles negative i)
    if (count <= 0) {
        return 0
    }
    r := Mod(i - 1, count)
    if (r < 0) {
        r := r + count
    }
    return r + 1
}


__GetWorkAreaFromHwndPhys(hWnd, &left, &top, &right, &bottom) {
    MONITOR_DEFAULTTONEAREST := 2
    hMon := DllCall("user32\MonitorFromWindow", "ptr", hWnd, "uint", MONITOR_DEFAULTTONEAREST, "ptr")
    if (!hMon) {
        left := top := right := bottom := 0
        return
    }
    ; MONITORINFO is 40 bytes: cbSize(4) + rcMonitor(16) + rcWork(16) + dwFlags(4)
    mi := Buffer(40, 0)
    NumPut("UInt", 40, mi, 0) ; cbSize
    if !DllCall("user32\GetMonitorInfoW", "ptr", hMon, "ptr", mi.Ptr, "int") {
        left := top := right := bottom := 0
        return
    }
    ; rcWork at offset 20
    left   := NumGet(mi, 20, "Int")
    top    := NumGet(mi, 24, "Int")
    right  := NumGet(mi, 28, "Int")
    bottom := NumGet(mi, 32, "Int")
}

_RandomSpacedText(minTotal := 5, maxTotal := 20, minRun := 4, maxRun := 8) {
    total := Round(Random(minTotal, maxTotal))
    out := ""
    run := 0
    nextBreak := Round(Random(minRun, maxRun))

    while (StrLen(out) < total) {
        if (run >= nextBreak) {
            if (StrLen(out) + 1 > total) {
                break
            }
            out .= " "
            run := 0
            nextBreak := Round(Random(minRun, maxRun))
        } else {
            ; a–z
            ch := Chr(Round(Random(97, 122)))
            out .= ch
            run += 1
        }
    }
    if (StrLen(out) > total) {
        out := SubStr(out, 1, total)
    }
    return RTrim(out)
}

__SetWindowPosPhys(hWnd, xPhys, yPhys, wPhys, hPhys) {
    SWP_NOZORDER      := 0x0004
    SWP_NOOWNERZORDER := 0x0200
    SWP_NOACTIVATE    := 0x0010
    flags := SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOACTIVATE
    return DllCall("user32\SetWindowPos"
        , "ptr", hWnd
        , "ptr", 0
        , "int", xPhys
        , "int", yPhys
        , "int", wPhys
        , "int", hPhys
        , "uint", flags
        , "int")
}

; Per-monitor scale from a RECT (all params are PHYSICAL px)
__GetMonitorScaleFromRect(left, top, right, bottom) {
    ; Build RECT
    rc := Buffer(16, 0)
    NumPut("Int", left,   rc, 0)
    NumPut("Int", top,    rc, 4)
    NumPut("Int", right,  rc, 8)
    NumPut("Int", bottom, rc, 12)

    ; Get HMONITOR for this rect
    MONITOR_DEFAULTTONEAREST := 2
    hMon := DllCall("user32\MonitorFromRect", "ptr", rc.Ptr, "uint", MONITOR_DEFAULTTONEAREST, "ptr")

    ; shcore!GetDpiForMonitor → effective DPI for that monitor
    dpiX := 0, dpiY := 0
    success := false
    try {
        hr := DllCall("shcore\GetDpiForMonitor", "ptr", hMon, "int", 0, "uint*", &dpiX, "uint*", &dpiY, "int") ; MDT_EFFECTIVE_DPI=0
        if (hr = 0 && dpiX > 0) {
            success := true
        }
    }
    if (success) {
        return dpiX / 96.0
    }
    ; Fallback: system DPI
    return __GetSystemScale()
}

; System DPI → scale (physical / 96)
__GetSystemScale() {
    dpi := 0
    try {
        dpi := DllCall("user32\GetDpiForSystem", "uint")
    }
    if (!dpi) {
        dpi := A_ScreenDPI
    }
    return dpi / 96.0
}

; GetWindowRect in PHYSICAL pixels (no DPI math needed here)
__GetWindowRectPhys(hWnd, &x, &y, &w, &h) {
    rc := Buffer(16, 0) ; RECT {left,top,right,bottom}
    ok := DllCall("user32\GetWindowRect", "ptr", hWnd, "ptr", rc.Ptr, "int")
    if (!ok) {
        x := y := w := h := 0
        return
    }
    left   := NumGet(rc, 0, "Int")
    top    := NumGet(rc, 4, "Int")
    right  := NumGet(rc, 8, "Int")
    bottom := NumGet(rc, 12, "Int")
    x := left
    y := top
    w := right - left
    h := bottom - top
}


_ComputeRowsToShow(count) {
    global RowsVisibleMin, RowsVisibleMax
    if (RowsVisibleMax < RowsVisibleMin) {
        ; guard: swap if user misconfigures
        tmp := RowsVisibleMin
        RowsVisibleMin := RowsVisibleMax
        RowsVisibleMax := tmp
    }
    if (count >= RowsVisibleMax)
        return RowsVisibleMax
    if (count > RowsVisibleMin)
        return count
    return RowsVisibleMin
}

_ResizeWindowToRows(rowsToShow) {
    global gBase, gBaseH, gOverlay, gOverlayH, CornerRadiusPx

    ; Compute centered x/y/w/h (DIPs) on the SAME monitor as the base window
    xDip := 0, yDip := 0, wDip := 0, hDip := 0
    _GetWindowRectForWindowMonitor(&xDip, &yDip, &wDip, &hDip, rowsToShow, gBaseH)

    ; Convert those DIPs to PHYSICAL px for exact positioning without DPI drift
    ; Use the work area of the base window's monitor to get its scale
    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(gBaseH, &waL, &waT, &waR, &waB)
    monScale := __GetMonitorScaleFromRect(waL, waT, waR, waB)

    xPhys := Round(xDip * monScale)
    yPhys := Round(yDip * monScale)
    wPhys := Round(wDip * monScale)
    hPhys := Round(hDip * monScale)

    ; Physically move/resize both windows in lockstep (no Show() coords → no DPI hops)
    __SetWindowPosPhys(gBaseH,   xPhys, yPhys, wPhys, hPhys)
    __SetWindowPosPhys(gOverlayH, xPhys, yPhys, wPhys, hPhys)

    ; Re-apply rounded region using DIP sizes so the region matches the visual
    _ApplyRoundRegion(gBaseH, CornerRadiusPx, wDip, hDip)

    ; Make sure composition commits before the next layered blit
    try DllCall("dwmapi\DwmFlush")
}

__GetScaleForWindow(hWnd) {
    dpi := 0
    try {
        dpi := DllCall("user32\GetDpiForWindow", "ptr", hWnd, "uint")
    }
    if (!dpi) {
        dpi := A_ScreenDPI ; fallback
    }
    return dpi / 96.0
}

_InitDpiAwareness() {
    ; Prefer Per-Monitor V2; fall back gracefully if unavailable.
    try {
        ; DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 = -4
        DllCall("user32\SetProcessDpiAwarenessContext", "ptr", -4, "ptr")
    } catch {
        try {
            ; PROCESS_PER_MONITOR_DPI_AWARE = 2
            DllCall("shcore\SetProcessDpiAwareness", "int", 2, "int")
        } catch {
            ; Last resort: system-DPI aware
            try DllCall("user32\SetProcessDPIAware")
        }
    }
}

_GetWindowRectFromConfig(&x, &y, &w, &h, rowsToShow := "") {
    global ScreenWidthPct, RowHeight, MarginY

    if (rowsToShow == "" || rowsToShow < 1) {
        global RowsVisibleMin
        rowsToShow := RowsVisibleMin
    }

    left := 0, top := 0, right := 0, bottom := 0
    MonitorGetWorkArea(0, &left, &top, &right, &bottom)
    waW_phys := right - left
    waH_phys := bottom - top

    monScale := __GetMonitorScaleFromRect(left, top, right, bottom)

    pct := ScreenWidthPct
    if (pct <= 0)
        pct := 0.10
    if (pct > 1.0)
        pct := pct / 100.0

    waW_dip := waW_phys / monScale
    waH_dip := waH_phys / monScale
    left_dip := left / monScale
    top_dip  := top  / monScale

    w := Round(waW_dip * pct)

    headerBlock := _HeaderBlockDip()
    footerBlock := _FooterBlockDip()
    h := MarginY + headerBlock + rowsToShow * RowHeight + footerBlock + MarginY

    x := Round(left_dip + (waW_dip - w) / 2)
    y := Round(top_dip  + (waH_dip - h) / 2)
}

_ApplyRoundRegion(hWnd, radiusPx, optW := 0, optH := 0) {
    if (!hWnd || radiusPx <= 0) {
        return
    }

    local wx := 0, wy := 0, ww := 0, wh := 0
    local cx := 0, cy := 0, cw := 0, ch := 0
    local hrgn := 0

    if (optW > 0 && optH > 0) {
        ww := optW
        wh := optH
    } else {
        try {
            WinGetClientPos(&cx, &cy, &cw, &ch, "ahk_id " hWnd)
            if (cw > 0 && ch > 0) {
                ww := cw
                wh := ch
            }
        }
        if (ww <= 0 || wh <= 0) {
            try WinGetPos(&wx, &wy, &ww, &wh, "ahk_id " hWnd)
        }
    }

    if (ww <= 0 || wh <= 0) {
        return
    }

    hrgn := DllCall("gdi32\CreateRoundRectRgn"
        , "int", 0, "int", 0
        , "int", ww + 1, "int", wh + 1
        , "int", radiusPx * 2, "int", radiusPx * 2
        , "ptr")
    if (hrgn) {
        DllCall("user32\SetWindowRgn", "ptr", hWnd, "ptr", hrgn, "int", 1)
    }
}

_ForceNoLayered(hWnd) {
    GWL_EXSTYLE   := -20
    WS_EX_LAYERED := 0x00080000
    try {
        ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", GWL_EXSTYLE, "ptr")
        if (ex & WS_EX_LAYERED) {
            ex := ex & ~WS_EX_LAYERED
            DllCall("user32\SetWindowLongPtrW", "ptr", hWnd, "int", GWL_EXSTYLE, "ptr", ex, "ptr")
            SWP_NOSIZE := 0x0001, SWP_NOMOVE := 0x0002, SWP_NOZORDER := 0x0004, SWP_FRAMECHANGED := 0x0020
            flags := SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED
            DllCall("user32\SetWindowPos", "ptr", hWnd, "ptr", 0, "int", 0, "int", 0, "int", 0, "int", 0, "uint", flags)
            _DBG("Removed WS_EX_LAYERED.")
        }
    }
}

; Prevent default white erase (stop flash)
global __BASE_HGUI := 0
__OnEraseBk(wParam, lParam, msg, hwnd) {
    global __BASE_HGUI
    if (__BASE_HGUI && hwnd = __BASE_HGUI) {
        return 1
    }
    return 0
}
_InstallEraseBkSwallow(hWnd) {
    global __BASE_HGUI
    __BASE_HGUI := hWnd
    OnMessage(0x0014, __OnEraseBk) ; WM_ERASEBKGND
}

; ---- Perf caches (drawing + scale) ----
global gCurScale := 1.0              ; current monitor scale for our window
global gResScale := 0.0              ; scale the GDI+ resources were built for
global gRes := Map()                 ; cached GDI+ resources: brushes, fonts, families, formats

; Persistent ARGB backbuffer (reused every paint)
global gBackHdc := 0, gBackHBM := 0, gBackPrev := 0, gBackW := 0, gBackH := 0

; Paint/resize throttles
global gLastRowsDesired := -1

; -------- Scale cache + DPI hook --------
_EnsureScaleCache() {
    global gCurScale, gBaseH
    s := __GetScaleForWindow(gBaseH)
    if (s <= 0) {
        s := 1.0
    }
    gCurScale := s
}

_OnDpiChanged(wParam, lParam, msg, hwnd) {
    global gResScale
    _EnsureScaleCache()
    ; Invalidate resource cache (rebuild next paint)
    gResScale := 0.0
    return 0
}

; -------- Backbuffer management (top-down 32bpp ARGB DIB) --------
_EnsureBackbuffer(wPhys, hPhys) {
    global gBackHdc, gBackHBM, gBackPrev, gBackW, gBackH, gG

    ; Create the memory DC once
    if (!gBackHdc) {
        gBackHdc := DllCall("gdi32\CreateCompatibleDC", "ptr", 0, "ptr")
        if (gG) {
            try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
            gG := 0
        }
    }

    ; Hidden/just-shown windows can briefly report 0x0; clamp to >=1
    wPhys := Max(1, wPhys)
    hPhys := Max(1, hPhys)

    ; No change → keep current surface
    if (wPhys = gBackW && hPhys = gBackH && gBackHBM) {
        return
    }

    ; Replace bitmap surface
    if (gBackHBM) {
        DllCall("gdi32\SelectObject", "ptr", gBackHdc, "ptr", gBackPrev, "ptr")
        DllCall("gdi32\DeleteObject", "ptr", gBackHBM)
        gBackHBM := 0
    }

    ; Build a new top-down 32bpp DIB section
    bi := Buffer(40, 0)
    NumPut("UInt", 40, bi, 0)          ; biSize
    NumPut("Int",  wPhys, bi, 4)       ; biWidth
    NumPut("Int", -hPhys, bi, 8)       ; biHeight (negative => top-down)
    NumPut("UShort", 1,  bi, 12)       ; biPlanes
    NumPut("UShort", 32, bi, 14)       ; biBitCount
    NumPut("UInt", 0,  bi, 16)         ; biCompression = BI_RGB

    pvBits := 0
    gBackHBM := DllCall("gdi32\CreateDIBSection"
        , "ptr", gBackHdc, "ptr", bi.Ptr, "uint", 0, "ptr*", &pvBits, "ptr", 0, "uint", 0, "ptr")
    gBackPrev := DllCall("gdi32\SelectObject", "ptr", gBackHdc, "ptr", gBackHBM, "ptr")

    ; Invalidate any Graphics tied to the old surface to avoid AV on next paint
    if (gG) {
        try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
        gG := 0
    }

    gBackW := wPhys
    gBackH := hPhys
}

; -------- GDI+ resource cache (fonts/brushes/formats) --------
_DisposeGdipResources() {
    global gRes, gResScale
    if !gRes.Count {
        gResScale := 0.0
        return
    }
    for k in ["brMain","brMainHi","brSub","brSubHi","brCol","brColHi","brHdr","brHit","brFooterText"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteBrush", "ptr", gRes[k])
    }
    for k in ["fMain","fMainHi","fSub","fSubHi","fCol","fColHi","fHdr","fAction","fFooter"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteFont", "ptr", gRes[k])
    }
    for k in ["ffMain","ffMainHi","ffSub","ffSubHi","ffCol","ffColHi","ffHdr","ffAction","ffFooter"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteFontFamily", "ptr", gRes[k])
    }
    for k in ["fmt","fmtCenter","fmtRight","fmtLeft","fmtLeftCol","fmtFooterLeft","fmtFooterCenter","fmtFooterRight"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteStringFormat", "ptr", gRes[k])
    }
    ; NEW: dispose any cached scaled icon
    if (gRes.Has("iconScaled") && gRes["iconScaled"]) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", gRes["iconScaled"])
    }
    gRes := Map()
    gResScale := 0.0
}


__PointInRect(px, py, x, y, w, h) {
    return (px >= x && px < x + w && py >= y && py < y + h)
}

__Gdip_StrokeRoundRect(g, argb, x, y, w, h, r, width := 1) {
    if (w <= 0 || h <= 0) {
        return
    }
    pPath := 0, pPen := 0
    r2 := r * 2.0
    DllCall("gdiplus\GdipCreatePath", "int", 0, "ptr*", &pPath)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y,           "float", r2, "float", r2, "float", 180.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + r,      "float", y,           "float", x + w - r, "float", y)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y,           "float", r2, "float", r2, "float", 270.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w,      "float", y + r,       "float", x + w, "float", y + h - r)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y + h - r2,  "float", r2, "float", r2, "float", 0.0,   "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w - r,  "float", y + h,       "float", x + r, "float", y + h)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y + h - r2,  "float", r2, "float", r2, "float", 90.0,  "float", 90.0)
    DllCall("gdiplus\GdipClosePathFigure", "ptr", pPath)
    DllCall("gdiplus\GdipCreatePen1", "int", argb, "float", width, "int", 2, "ptr*", &pPen) ; UnitPixel=2
    DllCall("gdiplus\GdipDrawPath", "ptr", g, "ptr", pPen, "ptr", pPath)
    if (pPen)  {
      DllCall("gdiplus\GdipDeletePen",  "ptr", pPen)
    }
    if (pPath) {
      DllCall("gdiplus\GdipDeletePath", "ptr", pPath)
    }
}

__Gdip_DrawCenteredTextRect(g, text, x, y, w, h, argb, font) {
    global gRes
    rf := Buffer(16, 0)
    NumPut("Float", x, rf, 0), NumPut("Float", y, rf, 4), NumPut("Float", w, rf, 8), NumPut("Float", h, rf, 12)
    br := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &br)
    DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", gRes["fmtCenter"], "ptr", br)
    if (br) {
      DllCall("gdiplus\GdipDeleteBrush", "ptr", br)
    }
}

__DrawActionButtons(g, wPhys, yRow, rowHPhys, scale, isHoveredRow := true) {
    global ShowCloseButton, ShowKillButton, ShowBlacklistButton
    global ActionBtnSizePx, ActionBtnGapPx, ActionBtnRadiusPx, MarginX
    global CloseButtonBGARGB, CloseButtonBGHoverARGB, CloseButtonBorderARGB, CloseButtonBorderPx
         , CloseButtonTextARGB, CloseButtonTextHoverARGB, CloseButtonGlyph
    global KillButtonBGARGB,  KillButtonBGHoverARGB,  KillButtonBorderARGB,  KillButtonBorderPx
         , KillButtonTextARGB, KillButtonTextHoverARGB, KillButtonGlyph
    global BlacklistButtonBGARGB, BlacklistButtonBGHoverARGB, BlacklistButtonBorderARGB, BlacklistButtonBorderPx
         , BlacklistButtonTextARGB, BlacklistButtonTextHoverARGB, BlacklistButtonGlyph
    global gHoverBtn, gRes

    size := Max(12, Round(ActionBtnSizePx * scale))
    gap  := Max(2,  Round(ActionBtnGapPx  * scale))
    rad  := Max(2,  Round(ActionBtnRadiusPx * scale))
    marR := Round(MarginX * scale)

    x := wPhys - marR - size
    y := yRow + (rowHPhys - size) // 2

    drawOne(name, glyph, bg, bgH, text, textH, border, borderPx) {
        local w := size, h := size, hovered := (gHoverBtn = name && isHoveredRow)
        local bgCol := hovered ? bgH : bg
        local txCol := hovered ? textH : text
        __Gdip_FillRoundRect(g, bgCol, x, y, w, h, rad)
        if (borderPx > 0) {
            __Gdip_StrokeRoundRect(g, border, x+0.5, y+0.5, w-1, h-1, rad, Max(1, Round(borderPx*scale)))
        }
        __Gdip_DrawCenteredTextRect(g, glyph, x, y, w, h, txCol, gRes["fAction"])
        x := x - (w + gap)
        return x
    }

    ; Order: Close (rightmost), then Kill, then Blacklist
    if (ShowCloseButton) {
        x := drawOne("close", CloseButtonGlyph, CloseButtonBGARGB, CloseButtonBGHoverARGB
            , CloseButtonTextARGB, CloseButtonTextHoverARGB, CloseButtonBorderARGB, CloseButtonBorderPx)
    }
    if (ShowKillButton) {
        x := drawOne("kill", KillButtonGlyph, KillButtonBGARGB, KillButtonBGHoverARGB
            , KillButtonTextARGB, KillButtonTextHoverARGB, KillButtonBorderARGB, KillButtonBorderPx)
    }
    if (ShowBlacklistButton) {
        x := drawOne("blacklist", BlacklistButtonGlyph, BlacklistButtonBGARGB, BlacklistButtonBGHoverARGB
            , BlacklistButtonTextARGB, BlacklistButtonTextHoverARGB, BlacklistButtonBorderARGB, BlacklistButtonBorderPx)
    }
}


_EnsureGdipResources(scale) {
    global gRes, gResScale
    if (Abs(gResScale - scale) < 0.001 && gRes.Count) {
        return
    }
    _DisposeGdipResources()
    __Gdip_Startup()

    ; ---- Brushes ----
    global MainARGB, MainARGBHi, SubARGB, SubARGBHi, ColARGB, ColARGBHi, HdrARGB, FooterTextARGB
    br := 0
    for _ in [ ["brMain",    MainARGB]
             , ["brMainHi",  MainARGBHi]
             , ["brSub",     SubARGB]
             , ["brSubHi",   SubARGBHi]
             , ["brCol",     ColARGB]
             , ["brColHi",   ColARGBHi]
             , ["brHdr",     HdrARGB]
             , ["brHit",     0x01000000]
             , ["brFooterText", FooterTextARGB] ] {
        DllCall("gdiplus\GdipCreateSolidFill", "int", _[2], "ptr*", &br)
        gRes[ _[1] ] := br, br := 0
    }

    ; ---- Fonts ----
    global MainFontName, MainFontSize, MainFontWeight
         , MainFontNameHi, MainFontSizeHi, MainFontWeightHi
         , SubFontName,  SubFontSize,  SubFontWeight
         , SubFontNameHi,SubFontSizeHi,SubFontWeightHi
         , ColFontName,  ColFontSize,  ColFontWeight
         , ColFontNameHi,ColFontSizeHi,ColFontWeightHi
         , HdrFontName,  HdrFontSize,  HdrFontWeight
         , ActionFontName, ActionFontSize, ActionFontWeight
         , FooterFontName, FooterFontSize, FooterFontWeight

    UnitPixel := 2
    mkFont(name, size, weight, keyFam, keyFont) {
        local fam := 0, f := 0, style := __FontStyleFromWeight(weight)
        DllCall("gdiplus\GdipCreateFontFamilyFromName", "wstr", name, "ptr", 0, "ptr*", &fam)
        DllCall("gdiplus\GdipCreateFont", "ptr", fam, "float", size*scale, "int", style, "int", UnitPixel, "ptr*", &f)
        gRes[keyFam]  := fam
        gRes[keyFont] := f
    }
    mkFont(MainFontName,    MainFontSize,    MainFontWeight,    "ffMain",   "fMain")
    mkFont(MainFontNameHi,  MainFontSizeHi,  MainFontWeightHi,  "ffMainHi", "fMainHi")
    mkFont(SubFontName,     SubFontSize,     SubFontWeight,     "ffSub",    "fSub")
    mkFont(SubFontNameHi,   SubFontSizeHi,   SubFontWeightHi,   "ffSubHi",  "fSubHi")
    mkFont(ColFontName,     ColFontSize,     ColFontWeight,     "ffCol",    "fCol")
    mkFont(ColFontNameHi,   ColFontSizeHi,   ColFontWeightHi,   "ffColHi",  "fColHi")
    mkFont(HdrFontName,     HdrFontSize,     HdrFontWeight,     "ffHdr",    "fHdr")
    mkFont(ActionFontName,  ActionFontSize,  ActionFontWeight,  "ffAction", "fAction")
    mkFont(FooterFontName,  FooterFontSize,  FooterFontWeight,  "ffFooter", "fFooter")

    ; ---- String formats (create independent instances; do NOT use GenericDefault) ----
    StringAlignmentNear := 0, StringAlignmentCenter := 1, StringAlignmentFar := 2
    StringFormatFlagsNoWrap := 0x00001000
    StringFormatFlagsNoClip := 0x00004000
    StringTrimmingEllipsisCharacter := 3
    flags := StringFormatFlagsNoWrap | StringFormatFlagsNoClip

    mkFmt(&out, align, valign) {
        out := 0
        ; independent instance
        DllCall("gdiplus\GdipCreateStringFormat", "int", 0, "ushort", 0, "ptr*", &out)
        DllCall("gdiplus\GdipSetStringFormatFlags",     "ptr", out, "int", flags)
        DllCall("gdiplus\GdipSetStringFormatTrimming",  "ptr", out, "int", StringTrimmingEllipsisCharacter)
        DllCall("gdiplus\GdipSetStringFormatAlign",     "ptr", out, "int", align)
        DllCall("gdiplus\GdipSetStringFormatLineAlign", "ptr", out, "int", valign)
    }

    ; General text formats
    fmt := 0, fmtC := 0, fmtR := 0, fmtLcol := 0
    mkFmt(&fmt,     StringAlignmentNear,   StringAlignmentNear)    ; left/top
    mkFmt(&fmtC,    StringAlignmentCenter, StringAlignmentNear)    ; center/top
    mkFmt(&fmtR,    StringAlignmentFar,    StringAlignmentNear)    ; right/top
    mkFmt(&fmtLcol, StringAlignmentNear,   StringAlignmentNear)    ; explicit left for Column 1

    gRes["fmt"]        := fmt
    gRes["fmtCenter"]  := fmtC
    gRes["fmtRight"]   := fmtR
    gRes["fmtLeft"]    := fmtLcol
    gRes["fmtLeftCol"] := fmtLcol   ; alias used by list/headers

    ; Footer formats (vertical center looks nicer)
    fL := 0, fC := 0, fR := 0
    mkFmt(&fL, StringAlignmentNear,   StringAlignmentCenter)   ; left/center
    mkFmt(&fC, StringAlignmentCenter, StringAlignmentCenter)   ; center/center
    mkFmt(&fR, StringAlignmentFar,    StringAlignmentCenter)   ; right/center
    gRes["fmtFooterLeft"]   := fL
    gRes["fmtFooterCenter"] := fC
    gRes["fmtFooterRight"]  := fR

    gResScale := scale
}


_EnsureScaledIcon(scale, ISize, pSrcIcon) {
    global gRes
    if (!pSrcIcon || ISize <= 0) {
        return 0
    }
    if (gRes.Has("iconScaled") && gRes["iconScaled"] && gRes.Has("iconScalePx") && gRes["iconScalePx"] = ISize) {
        return gRes["iconScaled"]
    }
    ; Dispose previous
    if (gRes.Has("iconScaled") && gRes["iconScaled"]) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", gRes["iconScaled"])
        gRes["iconScaled"] := 0
    }

    PixelFormat32bppPARGB := 0x26200A
    pDst := 0, g2 := 0
    DllCall("gdiplus\GdipCreateBitmapFromScan0", "int", ISize, "int", ISize, "int", 0, "int", PixelFormat32bppPARGB, "ptr", 0, "ptr*", &pDst)
    DllCall("gdiplus\GdipGetImageGraphicsContext", "ptr", pDst, "ptr*", &g2)
    ; Interpolation high-quality for visual parity with GDI+ scaling in DrawImageRectI
    InterpolationModeHighQualityBicubic := 7
    DllCall("gdiplus\GdipSetInterpolationMode", "ptr", g2, "int", InterpolationModeHighQualityBicubic)
    DllCall("gdiplus\GdipDrawImageRectI", "ptr", g2, "ptr", pSrcIcon, "int", 0, "int", 0, "int", ISize, "int", ISize)
    if (g2) {
        DllCall("gdiplus\GdipDeleteGraphics", "ptr", g2)
    }

    gRes["iconScaled"] := pDst
    gRes["iconScalePx"] := ISize
    return pDst
}


; -------- Paint directly into backbuffer using GDI+ over HDC --------
__Gdip_PaintOverlay(items, selIndex, wPhys, hPhys, scrollTop := "", pIcon := 0, scale := 1.0) {
    global RowHeight, MarginX, MarginY, IconSize, RowRadius, SelARGB
         , gScrollTop, gIconImg, ShowHeader, EmptyListText
         , ColFixed2, ColFixed3, ColFixed4, ColFixed5, ColFixed6
         , Col2Name, Col3Name, Col4Name, Col5Name, Col6Name
         , gHoverRow, MainARGB, ShowFooter, FooterHeightPx, FooterGapTopPx

    _EnsureGdipResources(scale)
    global gRes

    g := _EnsureGraphics()
    if (!g)
        return

    ; Clear + full-surface hit matte
    DllCall("gdiplus\GdipGraphicsClear", "ptr", g, "int", 0x00000000)
    DllCall("gdiplus\GdipFillRectangle", "ptr", g, "ptr", gRes["brHit"], "float", 0, "float", 0, "float", wPhys, "float", hPhys)

    if (scrollTop == "")
        scrollTop := gScrollTop
    if (!pIcon && IsSet(gIconImg) && gIconImg)
        pIcon := gIconImg

    fmtLeft := (gRes.Has("fmtLeft") && gRes["fmtLeft"]) ? gRes["fmtLeft"] : gRes["fmt"]

    ; ---- Metrics (PHYSICAL px) ----
    RowH    := Max(1, Round(RowHeight * scale))
    Mx      := Round(MarginX  * scale)
    My      := Round(MarginY  * scale)
    ISize   := Round(IconSize * scale)
    Rad     := Round(RowRadius * scale)
    gapText := Round(12 * scale)
    gapCols := Round(10 * scale)
    hdrY4   := Round(4  * scale)
    hdrH28  := Round(28 * scale)

    iconLeftDip := _GetIconLeftMarginDip(scale)

    y     := My
    leftX := Mx + iconLeftDip
    textX := leftX + ISize + gapText

    ; Right-side columns
    cols := []
    Col6W := Round(ColFixed6 * scale), Col5W := Round(ColFixed5 * scale)
    Col4W := Round(ColFixed4 * scale), Col3W := Round(ColFixed3 * scale)
    Col2W := Round(ColFixed2 * scale)

    rightX := wPhys - Mx
    if (Col6W > 0) { 
      x := rightX - Col6W, cols.Push({name:Col6Name, w:Col6W, key:"Col6", x:x}), rightX := x - gapCols
     }
    if (Col5W > 0) { 
      x := rightX - Col5W, cols.Push({name:Col5Name, w:Col5W, key:"Col5", x:x}), rightX := x - gapCols 
    }
    if (Col4W > 0) { 
      x := rightX - Col4W, cols.Push({name:Col4Name, w:Col4W, key:"Col4", x:x}), rightX := x - gapCols 
    }
    if (Col3W > 0) { 
      x := rightX - Col3W, cols.Push({name:Col3Name, w:Col3W, key:"PID",  x:x}), rightX := x - gapCols 
    }
    if (Col2W > 0) { 
      x := rightX - Col2W, cols.Push({name:Col2Name, w:Col2W, key:"HWND", x:x}), rightX := x - gapCols 
    }

    textW := (rightX - Round(16*scale)) - textX
    if (textW < 0)
        textW := 0

    ; ---- Optional header ----
    if (ShowHeader) {
        hdrY := y + hdrY4
        __Gdip_DrawText(g, "Title", textX, hdrY, textW, Round(20*scale), gRes["brHdr"], gRes["fHdr"], fmtLeft)
        for _, col in cols {
            __Gdip_DrawText(g, col.name, col.x, hdrY, col.w, Round(20*scale), gRes["brHdr"], gRes["fHdr"], gRes["fmt"])
        }
        y += hdrH28
    }

    contentTopY := y
    count := items.Length

    ; Compute available rows area (reserve space for footer if shown)
    footerH := ShowFooter ? Round(FooterHeightPx * scale) : 0
    footerGap := ShowFooter ? Round(FooterGapTopPx * scale) : 0
    availH := hPhys - My - contentTopY - footerH - footerGap
    if (availH < 0)
        availH := 0

    rowsCap := (availH > 0) ? Floor(availH / RowH) : 0
    rowsToDraw := (count <= rowsCap) ? count : rowsCap

    ; ---- Empty list ----
    if (count = 0) {
        rectX := Mx
        rectW := wPhys - 2*Mx
        rectH := RowH
        rectY := contentTopY + Max(0, (availH - rectH) // 2)
        __Gdip_DrawCenteredTextRect(g, EmptyListText, rectX, rectY, rectW, rectH, MainARGB, gRes["fMain"])
        ; still draw footer (below)
    } else if (rowsToDraw > 0) {
        start0 := __Wrap0(scrollTop, count)
        i := 0
        yRow := y

        while (i < rowsToDraw && (yRow + RowH <= contentTopY + availH)) {
            idx0 := __Wrap0(start0 + i, count)
            idx1 := idx0 + 1
            cur  := items[idx1]
            isSel := (idx1 = selIndex)

            if (isSel)
                __Gdip_FillRoundRect(g, SelARGB, Mx - Round(4*scale), yRow - Round(2*scale), wPhys - 2*Mx + Round(8*scale), RowH, Rad)

            ix := leftX
            iy := yRow + (RowH - ISize)//2
            if (pIcon) {
                DllCall("gdiplus\GdipDrawImageRectI", "ptr", g, "ptr", pIcon, "int", ix, "int", iy, "int", ISize, "int", ISize)
            } else {
                __Gdip_FillEllipse(g, __ARGB_FromIndex(idx1), ix, iy, ISize, ISize)
            }

            fMainUse  := isSel ? gRes["fMainHi"] : gRes["fMain"]
            fSubUse   := isSel ? gRes["fSubHi"]  : gRes["fSub"]
            fColUse   := isSel ? gRes["fColHi"]  : gRes["fCol"]
            brMainUse := isSel ? gRes["brMainHi"] : gRes["brMain"]
            brSubUse  := isSel ? gRes["brSubHi"]  : gRes["brSub"]
            brColUse  := isSel ? gRes["brColHi"]  : gRes["brCol"]

            title := cur.HasOwnProp("Title") ? cur.Title : ""
            __Gdip_DrawText(g, title, textX, yRow + Round(6*scale),  textW, Round(24*scale), brMainUse, fMainUse, fmtLeft)

            sub := cur.HasOwnProp("Class") ? "Class: " cur.Class : ""
            __Gdip_DrawText(g, sub,   textX, yRow + Round(28*scale), textW, Round(18*scale), brSubUse,  fSubUse,  fmtLeft)

            for _, col in cols {
                val := cur.HasOwnProp(col.key) ? cur.%col.key% : ""
                __Gdip_DrawText(g, val, col.x, yRow + Round(10*scale), col.w, Round(20*scale), brColUse, fColUse, gRes["fmt"])
            }

            if (idx1 = gHoverRow) {
                __DrawActionButtons(g, wPhys, yRow, RowH, scale, true)
            }

            yRow += RowH
            i += 1
        }
    }

    ; virtual scrollbar if needed
    if (count > rowsToDraw && rowsToDraw > 0) {
        __DrawVirtualScrollbar(g, wPhys, contentTopY, rowsToDraw, RowH, scrollTop, count, scale)
    }

    ; Footer (bottom anchored)
    if (ShowFooter) {
        _DrawFooter(g, wPhys, hPhys, scale)
    }
}

_DetectActionAtPoint(xPhys, yPhys, &action, &idx1) {
    global gItems, gScrollTop, gOverlayH, MarginY, RowHeight
    global ShowCloseButton, ShowKillButton, ShowBlacklistButton
    global ActionBtnSizePx, ActionBtnGapPx, MarginX

    action := "", idx1 := 0
    count := gItems.Length
    if (count <= 0) {
        return
    }

    scale := __GetScaleForWindow(gOverlayH)
    RowH := Max(1, Round(RowHeight * scale))
    My   := Round(MarginY  * scale)
    hdr  := Round(_HeaderBlockDip() * scale)
    topY := My + hdr

    if (yPhys < topY) {
        return
    }

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    local rel := yPhys - topY
    local rowVis := Floor(rel / RowH) + 1
    if (rowVis < 1 || rowVis > vis) {
        return
    }

    ; 1-based item index under cursor (wrap-aware viewport)
    local idx0 := __Wrap0(gScrollTop + (rowVis - 1), count)
    idx1 := idx0 + 1

    ; Build button rects (right aligned)
    size := Max(12, Round(ActionBtnSizePx * scale))
    gap  := Max(2,  Round(ActionBtnGapPx  * scale))
    marR := Round(MarginX * scale)

    ox := 0, oy := 0, ow := 0, oh := 0
    __GetWindowRectPhys(gOverlayH, &ox, &oy, &ow, &oh)

    x := ow - marR - size
    y := topY + (rowVis - 1) * RowH + (RowH - size) // 2

    ; Test in order: Close (rightmost), Kill, Blacklist
    if (ShowCloseButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "close"
        return
    }
    x := x - (size + gap)
    if (ShowKillButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "kill"
        return
    }
    x := x - (size + gap)
    if (ShowBlacklistButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "blacklist"
        return
    }
}

; ========================= ACRYLIC (ACCENT) =========================
ApplyAccentAcrylic(hWnd, alpha, baseRgb) {
    bb := (baseRgb >> 16) & 0xFF
    gg := (baseRgb >> 8)  & 0xFF
    rr := (baseRgb)       & 0xFF
    grad := (alpha << 24) | (bb << 16) | (gg << 8) | rr  ; 0xAABBGGRR

    ACCENT_ENABLE_ACRYLICBLURBEHIND := 4
    accent := Buffer(16, 0)
    NumPut("Int", ACCENT_ENABLE_ACRYLICBLURBEHIND, accent, 0)
    NumPut("Int", 0, accent, 4)
    NumPut("Int", grad, accent, 8)
    NumPut("Int", 0, accent, 12)

    WCA_ACCENT_POLICY := 19
    data := Buffer(A_PtrSize * 3, 0)
    NumPut("Int", WCA_ACCENT_POLICY, data, 0)
    NumPut("Ptr", accent.Ptr,        data, A_PtrSize)
    NumPut("Int", accent.Size,       data, A_PtrSize*2)

    ok := DllCall("user32\SetWindowCompositionAttribute", "ptr", hWnd, "ptr", data.Ptr, "int")
    _DBG("SetWindowCompositionAttribute(Acrylic) ok=" ok " alpha=" alpha " baseRgb=0x" Format("{:06X}", baseRgb))
    return ok
}

; ========================= STAGE + REVEAL (no flash) =========================
_StageAndRevealAcrylic(guiObj, x, y, wDip, hDip, alpha, baseRgb, cornerRadius, revealNow := true) {
    ; 1) Create/size hidden (width/height only, let AHK/DWM establish actual size)
    guiObj.Show("Hide w" wDip " h" hDip)
    hWnd := guiObj.Hwnd

    ; 2) Read actual PHYSICAL window size now
    curX := 0, curY := 0, curW := 0, curH := 0
    __GetWindowRectPhys(hWnd, &curX, &curY, &curW, &curH)

    ; 3) Get the work area of the monitor this window is on (PHYSICAL)
    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(hWnd, &waL, &waT, &waR, &waB)
    waW := waR - waL
    waH := waB - waT

    ; 4) Compute perfect physical center and move (still hidden → no flash)
    tgtX := waL + (waW - curW) // 2
    tgtY := waT + (waH - curH) // 2
    __SetWindowPosPhys(hWnd, tgtX, tgtY, curW, curH)

    ; 5) Cosmetics (after size is final)
    _TryEnableDarkTitleBar(hWnd)
    _SetCornerPreference(hWnd, 2)
    _ForceNoLayered(hWnd)
    _InstallEraseBkSwallow(hWnd)
    _ApplyRoundRegion(hWnd, cornerRadius, wDip, hDip)

    ; 6) Apply acrylic
    ApplyAccentAcrylic(hWnd, alpha, baseRgb)
    try DllCall("dwmapi\DwmFlush")

    ; 7) Reveal now or defer for a synchronized reveal with overlay
    if (revealNow) {
        guiObj.Show("NA")
        SetTimer(() => _ApplyRoundRegion(hWnd, cornerRadius), -1)
    }
}


; ========================= GDI+ HELPERS =========================
__Gdip_Startup() {
    ; Start GDI+ once; keep the token internally (and mirror to a global for shutdown).
    static token := 0
    if (token)
        return token

    si := Buffer(A_PtrSize=8 ? 24 : 16, 0)  ; GdiplusStartupInput
    NumPut("UInt", 1, si, 0)                ; version = 1

    status := DllCall("gdiplus\GdiplusStartup", "ptr*", &token, "ptr", si.Ptr, "ptr", 0, "int")
    if (status = 0 && token) {
        global gGdipToken
        gGdipToken := token   ; optional mirror for shutdown visibility
        return token
    }
    return 0
}

__Gdip_FillRoundRect(g, argb, x, y, w, h, r) {
    if (w <= 0 || h <= 0) {
        return
    }
    if (r <= 0) {
        pBr := 0
        DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
        DllCall("gdiplus\GdipFillRectangle", "ptr", g, "ptr", pBr, "float", x, "float", y, "float", w, "float", h)
        if (pBr) {
            DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
        }
        return
    }
    pPath := 0
    pBr   := 0
    r2    := r * 2.0
    DllCall("gdiplus\GdipCreatePath", "int", 0, "ptr*", &pPath)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y,           "float", r2, "float", r2, "float", 180.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + r,      "float", y,           "float", x + w - r, "float", y)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y,           "float", r2, "float", r2, "float", 270.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w,      "float", y + r,       "float", x + w, "float", y + h - r)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y + h - r2,  "float", r2, "float", r2, "float", 0.0,   "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w - r,  "float", y + h,       "float", x + r, "float", y + h)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y + h - r2,  "float", r2, "float", r2, "float", 90.0,  "float", 90.0)
    DllCall("gdiplus\GdipClosePathFigure", "ptr", pPath)
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
    DllCall("gdiplus\GdipFillPath", "ptr", g, "ptr", pBr, "ptr", pPath)
    if (pBr) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
    }
    if (pPath) {
        DllCall("gdiplus\GdipDeletePath",  "ptr", pPath)
    }
}

__Gdip_DrawText(g, text, x, y, w, h, br, font, fmt) {
    rf := Buffer(16, 0)
    NumPut("Float", x, rf, 0)
    NumPut("Float", y, rf, 4)
    NumPut("Float", w, rf, 8)
    NumPut("Float", h, rf, 12)
    DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", fmt, "ptr", br)
}

__Gdip_FillEllipse(g, argb, x, y, w, h) {
    pBr := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
    DllCall("gdiplus\GdipFillEllipse", "ptr", g, "ptr", pBr, "float", x, "float", y, "float", w, "float", h)
    if (pBr) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
    }
}

; ===== Icon loading (explorer.exe) → GDI+ image =====
__LoadGpIconFromFile(path, index := 0) {
    __Gdip_Startup()
    hIconLarge := 0
    got := DllCall("shell32\ExtractIconExW", "wstr", path, "int", index, "ptr*", &hIconLarge, "ptr", 0, "uint", 1, "uint")
    if (got = 0 || !hIconLarge) {
        return 0
    }
    pImg := 0
    DllCall("gdiplus\GdipCreateBitmapFromHICON", "ptr", hIconLarge, "ptr*", &pImg)
    DllCall("user32\DestroyIcon", "ptr", hIconLarge)
    return pImg  ; caller must GdipDisposeImage
}

__DrawVirtualScrollbar(g, wPhys, contentTopY, rowsDrawn, rowHPhys, scrollTop, count, scale) {
    global ScrollBarEnabled, ScrollBarWidthPx, ScrollBarMarginRightPx
         , ScrollBarThumbARGB, ScrollBarGutterEnabled, ScrollBarGutterARGB

    if (!ScrollBarEnabled) {
        return
    }
    if (count <= 0 || rowsDrawn <= 0 || rowHPhys <= 0) {
        return
    }

    ; viewport and track geometry (PHYSICAL px)
    trackH := rowsDrawn * rowHPhys
    if (trackH <= 0) {
        return
    }
    trackW := Max(2, Round(ScrollBarWidthPx * scale))
    marR   := Max(0, Round(ScrollBarMarginRightPx * scale))
    x      := wPhys - marR - trackW
    y      := contentTopY
    r      := trackW // 2  ; pill radius

    ; thumb size scales by visible/count (min height guard)
    visCount := rowsDrawn
    thumbH := Max(3, Floor(trackH * visCount / count))

    ; wrap-aware start (0..count-1)
    start0 := __Wrap0(scrollTop, count)
    startRatio := start0 / count
    y1 := y + Floor(startRatio * trackH)
    y2 := y1 + thumbH
    yEnd := y + trackH

    ; brushes
    brThumb := 0, brGutter := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", ScrollBarThumbARGB, "ptr*", &brThumb)

    if (ScrollBarGutterEnabled) {
        DllCall("gdiplus\GdipCreateSolidFill", "int", ScrollBarGutterARGB, "ptr*", &brGutter)
        __Gdip_FillRoundRect(g, ScrollBarGutterARGB, x, y, trackW, trackH, r)
    }

    ; draw thumb (1 or 2 segments if wrapping across end → top)
    if (y2 <= yEnd) {
        __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y1, trackW, thumbH, r)
    } else {
        ; segment 1: bottom tail
        h1 := yEnd - y1
        if (h1 > 0) {
            __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y1, trackW, h1, r)
        }
        ; segment 2: wrap to top
        h2 := y2 - yEnd
        if (h2 > 0) {
            __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y, trackW, h2, r)
        }
    }

    if (brThumb)  {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", brThumb)
    }
    if (brGutter) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", brGutter)
    }
}


__ARGB_FromIndex(i) {
    ; fallback colored circle (unused if icon loads)
    r := (37 * i)  & 0xFF
    g := (71 * i)  & 0xFF
    b := (113 * i) & 0xFF
    return (0xCC << 24) | (r << 16) | (g << 8) | b
}

; ========================= OVERLAY (layered) =========================
global gBase := 0, gOverlay := 0, gBaseH := 0, gOverlayH := 0
global gItems := [], gSel := 1
global gScrollTop := 0
global gIconImg := 0

_BuildSampleItems() {
    arr := []
    ; vary count a bit to simulate changing results
    count := Round(Random(4, 12))
    i := 1
    while (i <= count) {
        hwnd := Format("0x{:X}", 0x10000 + Round(Random(1000, 99999)))
        title := _RandomSpacedText(5, 20, 4, 8)
        arr.Push({
            Title: title,
            Class: "Class" i,
            HWND:  hwnd,
            PID:   "" Round(Random(500, 99999))
        })
        i += 1
    }
    return arr
}

_HideOverlay() {
    global gBase, gOverlay
    try gOverlay.Hide()
    try gBase.Hide()
}

_ShowOverlay() {
    global gBase, gBaseH, gOverlay, gOverlayH, gItems, gSel, gScrollTop

    ; simulate changed contents each time we show
    gItems := _BuildSampleItems()
    gSel := 1
    gScrollTop := 0

    ; Ensure the base is visible/sized so GetWindowRect returns valid dimensions
    try gBase.Show("NA")

    ; Force size/rows to match new item count before repaint (ensures non-zero backbuffer)
    rowsDesired := _ComputeRowsToShow(gItems.Length)
    _ResizeWindowToRows(rowsDesired)

    ; Now (re)paint and reveal overlay
    _Overlay_Repaint(gOverlayH, gItems, gSel)
    try gOverlay.Show("NA")
    try DllCall("dwmapi\DwmFlush")
}

_Overlay_Create(ownerHwnd) {
    ; Create overlay as hidden first to avoid any black flash before first paint
    ov := Gui("+AlwaysOnTop -Caption +ToolWindow +Owner" ownerHwnd)
    ov.Show("Hide")

    ; Match owner (base) window position/size in PHYSICAL pixels
    ox := 0, oy := 0, ow := 0, oh := 0
    __GetWindowRectPhys(ownerHwnd, &ox, &oy, &ow, &oh)
    __SetWindowPosPhys(ov.Hwnd, ox, oy, ow, oh)

    return ov
}

_GetWindowRectForWindowMonitor(&x, &y, &w, &h, rowsToShow, hWnd) {
    global ScreenWidthPct, RowHeight, MarginY

    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(hWnd, &waL, &waT, &waR, &waB)

    monScale := __GetMonitorScaleFromRect(waL, waT, waR, waB)

    waW_dip := (waR - waL) / monScale
    waH_dip := (waB - waT) / monScale
    left_dip := waL / monScale
    top_dip  := waT / monScale

    pct := ScreenWidthPct
    if (pct <= 0)
        pct := 0.10
    if (pct > 1.0)
        pct := pct / 100.0

    w := Round(waW_dip * pct)

    headerBlock := _HeaderBlockDip()
    footerBlock := _FooterBlockDip()
    h := MarginY + headerBlock + rowsToShow * RowHeight + footerBlock + MarginY

    x := Round(left_dip + (waW_dip - w) / 2)
    y := Round(top_dip  + (waH_dip - h) / 2)
}

_GetVisibleRowsFromOverlay() {
    global gOverlayH, MarginY, RowHeight

    ox := 0, oy := 0, owPhys := 0, ohPhys := 0
    __GetWindowRectPhys(gOverlayH, &ox, &oy, &owPhys, &ohPhys)

    scale := __GetScaleForWindow(gOverlayH)
    ohDip := ohPhys / scale

    headerTopDip := MarginY + _HeaderBlockDip()
    footerDip := _FooterBlockDip()
    usableDip := ohDip - headerTopDip - MarginY - footerDip

    if (usableDip < RowHeight)
        return 0
    return Floor(usableDip / RowHeight)
}

_DrawFooter(g, wPhys, hPhys, scale) {
    global ShowFooter, FooterHeightPx, FooterGapTopPx, FooterBGARGB, FooterBGRadius
         , FooterBorderPx, FooterBorderARGB, FooterPaddingX, FooterTextAlign
         , FooterTextARGB, MarginX, MarginY, gFooterText, gRes

    if (!ShowFooter)
        return

    fh := Max(1, Round(FooterHeightPx * scale))
    mx := Round(MarginX * scale)
    my := Round(MarginY * scale)

    x := mx
    y := hPhys - my - fh
    w := wPhys - 2*mx
    r := Max(0, Round(FooterBGRadius * scale))

    __Gdip_FillRoundRect(g, FooterBGARGB, x, y, w, fh, r)
    if (FooterBorderPx > 0)
        __Gdip_StrokeRoundRect(g, FooterBorderARGB, x+0.5, y+0.5, w-1, fh-1, r, Max(1, Round(FooterBorderPx*scale)))

    pad := Max(0, Round(FooterPaddingX * scale))
    tx := x + pad
    tw := w - 2*pad

    t := StrLower(Trim(FooterTextAlign))
    fmt := gRes.Has("fmtFooterCenter") ? gRes["fmtFooterCenter"] : (gRes.Has("fmtCenter") ? gRes["fmtCenter"] : 0)
    if (t = "left")
        fmt := gRes.Has("fmtFooterLeft")  ? gRes["fmtFooterLeft"]  : (gRes.Has("fmt") ? gRes["fmt"] : fmt)
    else if (t = "right")
        fmt := gRes.Has("fmtFooterRight") ? gRes["fmtFooterRight"] : (gRes.Has("fmtRight") ? gRes["fmtRight"] : fmt)

    rf := Buffer(16, 0)
    NumPut("Float", tx, rf, 0)
    NumPut("Float", y,  rf, 4)
    NumPut("Float", tw, rf, 8)
    NumPut("Float", fh, rf, 12)

    DllCall("gdiplus\GdipDrawString"
        , "ptr", g
        , "wstr", gFooterText
        , "int", -1
        , "ptr", gRes["fFooter"]
        , "ptr", rf.Ptr
        , "ptr", fmt
        , "ptr", gRes["brFooterText"])
}

_ScrollBy(step) {
    global gScrollTop, gItems, gOverlayH, gSel

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    count := gItems.Length
    if (count <= 0) {
        return
    }

    visEff := Min(vis, count)
    if (count <= visEff) {
        ; Everything fits; nothing to scroll.
        return
    }

    ; Wrap-aware scrolling for the circular viewport
    gScrollTop := __Wrap0(gScrollTop + step, count)

    ; Recompute hover from current cursor so action icons stay under the pointer
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_Overlay_Repaint(hOv, items, selIndex) {
    global gBaseH, gOverlay, gLastRowsDesired, gLastItemCount

    ; ----- Throttled dynamic height: only when rows-to-show actually changes -----
    count := items.Length
    rowsDesired := _ComputeRowsToShow(count)
    if (rowsDesired != gLastRowsDesired) {
        _ResizeWindowToRows(rowsDesired)
        gLastRowsDesired := rowsDesired
    }

    ; Base rect in PHYSICAL pixels
    phX := 0, phY := 0, phW := 0, phH := 0
    __GetWindowRectPhys(gBaseH, &phX, &phY, &phW, &phH)

    ; Ensure scale + backbuffer + resources
    _EnsureScaleCache()
    scale := gCurScale
    _EnsureBackbuffer(phW, phH)

    ; Paint directly into backbuffer
    __Gdip_PaintOverlay(items, selIndex, phW, phH, "", 0, scale)

    ; BLENDFUNCTION
    bf := Buffer(4, 0)
    NumPut("UChar", 0x00, bf, 0) ; AC_SRC_OVER
    NumPut("UChar", 0x00, bf, 1)
    NumPut("UChar", 255,  bf, 2) ; per-pixel alpha
    NumPut("UChar", 0x01, bf, 3) ; AC_SRC_ALPHA

    ; SIZE and POINT (PHYSICAL)
    sz := Buffer(8, 0), ptDst := Buffer(8, 0), ptSrc := Buffer(8, 0)
    NumPut("Int", phW, sz, 0), NumPut("Int", phH, sz, 4)
    NumPut("Int", phX, ptDst, 0), NumPut("Int", phY, ptDst, 4)

    ; Ensure WS_EX_LAYERED
    GWL_EXSTYLE := -20, WS_EX_LAYERED := 0x80000
    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hOv, "int", GWL_EXSTYLE, "ptr")
    if !(ex & WS_EX_LAYERED) {
        ex |= WS_EX_LAYERED
        DllCall("user32\SetWindowLongPtrW", "ptr", hOv, "int", GWL_EXSTYLE, "ptr", ex, "ptr")
    }

    ; Update layered directly from persistent backbuffer DC/bitmap
    ULW_ALPHA := 0x2
    hdcScreen := DllCall("user32\GetDC", "ptr", 0, "ptr")
    DllCall("user32\UpdateLayeredWindow"
        , "ptr", hOv
        , "ptr", hdcScreen
        , "ptr", ptDst.Ptr
        , "ptr", sz.Ptr
        , "ptr", gBackHdc
        , "ptr", ptSrc.Ptr
        , "int", 0
        , "ptr", bf.Ptr
        , "uint", ULW_ALPHA
        , "int")
    DllCall("user32\ReleaseDC", "ptr", 0, "ptr", hdcScreen)

    ; Synchronized first reveal
    _RevealBaseAndOverlayTogether()
}

; Keep selection visible after changing gSel
_EnsureVisible(totalCount) {
    global gSel, gScrollTop
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0 || totalCount <= 0) {
        return
    }
    visEff := Min(vis, totalCount)
    if (visEff <= 0) {
        return
    }
    if (gSel < gScrollTop + 1) {
        gScrollTop := gSel - 1
    } else if (gSel > gScrollTop + visEff) {
        gScrollTop := gSel - visEff
    }
    if (gScrollTop < 0)
        gScrollTop := 0
    maxTop := Max(0, totalCount - visEff)
    if (gScrollTop > maxTop)
        gScrollTop := maxTop
}

; Full-row click → select clicked row (not just icon)
_OnOverlayClick(x, y) {
    global gItems, gSel, gOverlayH, MarginY, RowHeight, gScrollTop, ScrollKeepHighlightOnTop

    ; First: did we click an action button?
    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)
    if (act != "") {
        _Action_Perform(act, idx)
        return
    }

    ; Otherwise: regular row selection behavior
    count := gItems.Length
    if (count = 0) {
        return
    }

    scale := __GetScaleForWindow(gOverlayH)
    yDip := Round(y / scale)

    rowsTopDip := MarginY + _HeaderBlockDip()
    if (yDip < rowsTopDip) {
        return
    }

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    rowsDrawn := Min(vis, count)

    idxVisible := ((yDip - rowsTopDip) // RowHeight) + 1
    if (idxVisible < 1) {
        idxVisible := 1
    }
    if (idxVisible > rowsDrawn) {
        return
    }

    top0 := gScrollTop
    idx0 := __Wrap0(top0 + (idxVisible - 1), count)
    gSel := idx0 + 1

    if (ScrollKeepHighlightOnTop) {
        gScrollTop := gSel - 1
    }

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}

_OnOverlayMouseMove(wParam, lParam, msg, hwnd) {
    global gOverlayH, gHoverRow, gHoverBtn, gItems, gSel
    if (hwnd != gOverlayH) {
        return 0
    }
    x := lParam & 0xFFFF
    y := (lParam >> 16) & 0xFFFF

    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)

    prevRow := gHoverRow
    prevBtn := gHoverBtn
    gHoverRow := idx
    gHoverBtn := act

    if (gHoverRow != prevRow || gHoverBtn != prevBtn) {
        _Overlay_Repaint(gOverlayH, gItems, gSel)
    }
    return 0
}

_MoveSelection(delta) {
    global gSel, gItems, gScrollTop, gOverlayH, gSel, ScrollKeepHighlightOnTop

    if (gItems.Length = 0 || delta = 0) {
        return
    }

    count := gItems.Length
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        vis := 1
    }
    if (vis > count) {
        vis := count
    }

    if (ScrollKeepHighlightOnTop) {
        ; ===================== TOP-ANCHOR MODE (true) =====================
        if (delta > 0) {
            gSel := __Wrap1(gSel + 1, count)
        } else {
            gSel := __Wrap1(gSel - 1, count)
        }
        gScrollTop := gSel - 1           ; let rendering wrap; no clamping
    } else {
        ; ===================== STICKY-EDGE MODE (false) =====================
        top0 := gScrollTop

        if (delta > 0) {
            ; move selection down (wrap 1..count)
            gSel := __Wrap1(gSel + 1, count)
            sel0 := gSel - 1
            pos := __Wrap0(sel0 - top0, count)
            ; If offscreen OR already at bottom, anchor selection to bottom row.
            if (pos >= vis || pos = vis - 1) {
                gScrollTop := sel0 - (vis - 1)
            }
        } else {
            ; move selection up (wrap 1..count)
            gSel := __Wrap1(gSel - 1, count)
            sel0 := gSel - 1
            pos := __Wrap0(sel0 - top0, count)
            ; If offscreen OR already at top, anchor selection to top row.
            if (pos >= vis || pos = 0) {
                gScrollTop := sel0
            }
        }
    }

    ; Recompute hover from current cursor so action icons stay under the pointer
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_RemoveItemAt(idx1) {
    global gItems, gSel, gScrollTop, gOverlayH
    if (idx1 < 1 || idx1 > gItems.Length) {
        return
    }
    gItems.RemoveAt(idx1)

    if (gItems.Length = 0) {
        gSel := 1
        gScrollTop := 0
    } else {
        if (gSel > gItems.Length) {
            gSel := gItems.Length
        }
        _EnsureVisible(gItems.Length)
    }

    ; Keep hover aligned with the cursor after the list compacts
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_Action_Perform(action, idx1 := 0) {
    global gItems, gSel
    if (idx1 = 0) {
        idx1 := gSel
    }
    if (idx1 < 1 || idx1 > gItems.Length) {
        return
    }
    cur := gItems[idx1]

    if (action = "close") {
        ; TODO: Real close: PostMessage(WM_CLOSE) to cur.HWND
        _RemoveItemAt(idx1)
        return
    }
    if (action = "kill") {
        pid := cur.HasOwnProp("PID") ? cur.PID : "?"
        ttl := cur.HasOwnProp("Title") ? cur.Title : "window"
        if _ConfirmTopmost("Are you sure you want to TERMINATE process " pid " for '" ttl "'?", "Confirm terminate") {
            ; TODO: ProcessClose(pid)
            _RemoveItemAt(idx1)
        }
        return
    }

    if (action = "blacklist") {
        ttl := cur.HasOwnProp("Title") ? cur.Title : "window"
        cls := cur.HasOwnProp("Class") ? cur.Class : "?"
        if _ConfirmTopmost("Blacklist '" ttl "' from class '" cls "'?", "Confirm blacklist") {
            ; TODO: add to config/store
            _RemoveItemAt(idx1)
        }
        return
    }

}

; Mouse wheel scroll (row-based)
_OnOverlayWheel(wParam, lParam) {
    global gOverlayH, ScrollKeepHighlightOnTop
    delta := (wParam >> 16) & 0xFFFF
    if (delta >= 0x8000) {
        delta -= 0x10000
    }
    step := (delta > 0) ? -1 : 1  ; up = -1, down = +1

    if (ScrollKeepHighlightOnTop) {
        _MoveSelection(step)
    } else {
        _ScrollBy(step)
    }
}

_RevealBaseAndOverlayTogether() {
    global gBase, gBaseH, gOverlay, CornerRadiusPx, gRevealed
    if (gRevealed) {
        return
    }
    ; Re-apply rounded region once on-screen, then show both windows
    try _ApplyRoundRegion(gBaseH, CornerRadiusPx)
    try gBase.Show("NA")
    try gOverlay.Show("NA")
    try DllCall("dwmapi\DwmFlush")
    gRevealed := true
}


; ========================= MAIN =========================
_InitDpiAwareness()

; Warm up GDI+ once (faster first paint)
__Gdip_Startup()

; Track DPI changes to rebuild cached resources lazily
OnMessage(0x02E0, _OnDpiChanged) ; WM_DPICHANGED
OnMessage(0x0200, (wParam, lParam, msg, hwnd) => (
    hwnd = gOverlayH ? ( _OnOverlayMouseMove(wParam, lParam, msg, hwnd), 0 ) : 0
)) ; WM_MOUSEMOVE


opts := "-Caption"
if (AlwaysOnTop)
    opts := "+AlwaysOnTop " . opts

; Build items FIRST so we can compute the correct initial height
gItems      := _BuildSampleItems()
rowsDesired := _ComputeRowsToShow(gItems.Length)

winX := 0, winY := 0, WinW := 0, WinH := 0
_GetWindowRectFromConfig(&winX, &winY, &WinW, &WinH, rowsDesired)

gBase := Gui(opts, "Acrylic Base")
_StageAndRevealAcrylic(gBase, winX, winY, WinW, WinH, AcrylicAlpha, AcrylicBaseRgb, CornerRadiusPx, false)
gBaseH := gBase.Hwnd
_DebugDump(gBaseH)

; Load a single test icon to use for every row (replaces the colored circle)
_LoadTestIcon()

gSel       := 1
gScrollTop := 0

gOverlay  := _Overlay_Create(gBaseH)
gOverlayH := gOverlay.Hwnd
_Overlay_Repaint(gOverlayH, gItems, gSel)

; mouse: click + wheel
OnMessage(0x0201, (wParam, lParam, msg, hwnd) => (
    hwnd = gOverlayH
        ? ( _OnOverlayClick(lParam & 0xFFFF, (lParam >> 16) & 0xFFFF), 0 )
        : 0
)) ; WM_LBUTTONDOWN

OnMessage(0x020A, (wParam, lParam, msg, hwnd) => (
    hwnd = gOverlayH
        ? ( _OnOverlayWheel(wParam, lParam), 0 )
        : 0
)) ; WM_MOUSEWHEEL


; ========================= HOTKEYS =========================
Up:: {
    _MoveSelection(-1)
}
Down:: {
    _MoveSelection(1)
}
Tab:: {
    _MoveSelection(1)
}
+Tab:: { ; Shift+Tab
    _MoveSelection(-1)
}

; C = Close (no confirmation)
c:: {
    global AllowCloseKeystroke
    if (AllowCloseKeystroke) {
        _Action_Perform("close")
    }
}

; K = Kill (confirm)
k:: {
    global AllowKillKeystroke
    if (AllowKillKeystroke) {
        _Action_Perform("kill")
    }
}

; B = Blacklist (confirm)
b:: {
    global AllowBlacklistKeystroke
    if (AllowBlacklistKeystroke) {
        _Action_Perform("blacklist")
    }
}

z:: {
    _HideOverlay()
}
x:: {
    _ShowOverlay()
}

; Q = cycle footer scope text (POC only)
q:: {
    global gFooterModes, gFooterModeIndex, gFooterText, gOverlayH, gItems, gSel
    gFooterModeIndex := (gFooterModeIndex >= gFooterModes.Length) ? 1 : (gFooterModeIndex + 1)
    gFooterText := gFooterModes[gFooterModeIndex]
    _Overlay_Repaint(gOverlayH, gItems, gSel)
}

Esc:: {
    global gIconImg
    if (gIconImg) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", gIconImg)
    }

    ExitApp
}
-------
but it doesnt work as a drop in. 
your last reply had a "REPLACE (lightly wire your existing NewGUI code)" section
but you tell me to do various things
i dont know how to do all that
I asked you to give me the exact functions to ADD / REPLACE / REMOVE
so for all of that that you said to do, and this current version of my newgui.ahk, give me the exact, FULL functions to add / REPLACE / remove
You are assisting me in building in AHKv2 based alt-tab replacement. The obbsessive focus of this program is speed. Nothing should stop alt-tab from triggering, everything needs to be non-blocking and instant.

Here are the current componets.
Contents of altlogic.ahk
--------------
﻿; altlogic.ahk — Lightning-fast Alt+Tab with overlay, MRU, blacklist debugger (press B while overlay is up)
; altlogic.ahk — Lightning-fast Alt+Tab (receiver mode via IPC)
ALTAB_Init() {
  global QuitHotkey

  if !IsSet(RefreshOnOverlay)
    global RefreshOnOverlay := true
  if !IsSet(RefreshOnAltUp)
    global RefreshOnAltUp := true

  ; --- RX logging toggles ---
  if !IsSet(DebugLogReceived)
    global DebugLogReceived := false
  if !IsSet(DebugRxLogPath)
    global DebugRxLogPath := (IsSet(DebugLogPath) ? DebugLogPath : A_ScriptDir "\tabby_debug.log")

  ; --- RX/session bookkeeping ---
  global AL_rxAltHeld       := false   ; logical “Alt is held” from micro
  global AL_rxEventCount    := 0
  global AL_lastRxTick      := 0

  ; --- NEW: event queue & processing flags ---
  global AL_evtQ            := []      ; queue of step dirs (+1 / -1)
  global AL_altUpPending    := false
  global AL_processingQ     := false

  ; optional watchdog to self-heal ultra-edge cases
  if !IsSet(UseRxWatchdog)
    global UseRxWatchdog := true
  if !IsSet(RxWatchdogMs)
    global RxWatchdogMs := 120

  Hotkey(QuitHotkey, ALTAB_Quit)
  Hotkey("#^Esc", ALTAB_Quit)
  A_TrayMenu.Add("Exit", ALTAB_Quit)

  ; === IPC receiver init (targeted IPC) ===
  TABBY_IPC_InitReceiver(ALTAB_IPC_Handler)

  ; Debug helpers
  HotIf(IsBLHotkeyActive)
  Hotkey("*b", ALTAB_Debug_Blacklist)
  Hotkey("*B", ALTAB_Debug_Blacklist)
  HotIf()

  Hotkey("#^F10", ALTAB_Toggle_NoGUI)
  Hotkey("#^F11", ALTAB_Toggle_NoBlocking)
  Hotkey("#^F9",  ALTAB_Debug_ToggleRxLog)

  MRU_Init()

  if (UseRxWatchdog)
    SetTimer(ALTAB_RxWatchdog_Tick, RxWatchdogMs)
}



; ---- New: IPC event handler (called by TABBY_IPC_Listen) ----
; ---- IPC event handler (called by TABBY_IPC_Listen) ----
ALTAB_IPC_Handler(ev, flags, lParam) {
  global AL_rxEventCount, AL_lastRxTick, AL_evtQ, AL_altUpPending, AL_rxAltHeld, AL_processingQ

  AL_rxEventCount += 1
  AL_lastRxTick := A_TickCount
  __RX_Log(Format("RX #{1} ev={2} flags={3} lParam={4} tick={5} sess={6} presses={7}"
    , AL_rxEventCount, ev, flags, lParam, A_TickCount, AL_session, AL_pressCount))

  if (ev = 1) {                       ; TAB_STEP
    AL_evtQ.Push((flags & 0x01) ? -1 : +1)
    AL_rxAltHeld := true
  } else if (ev = 2) {                ; ALT_UP
    AL_altUpPending := true
    AL_rxAltHeld := false
  }

  ; Drain in a single tick after we return (prevents re-entrancy races).
  SetTimer(ALTAB_ProcessQueue, -1)
}


ALTAB_ProcessQueue() {
  global AL_processingQ, AL_evtQ, AL_altUpPending
  global AL_session, AL_tabHeld, AL_firstTick, AL_pressCount, AL_list, AL_len
  global AL_sel, AL_base, HoldMs

  if (AL_processingQ)
    return
  AL_processingQ := true

  try {
    loop {
      ; 3a) Apply any queued steps first
      while (AL_evtQ.Length) {
        ; session start on first step
        if !AL_session {
          AL_list := ALTAB_BuildList()
          AL_len  := AL_list.Length
          if (AL_len = 0) {
            __RX_Log("session start aborted: empty list")
            AL_evtQ := []
            AL_altUpPending := false
            return
          }
          curr := WinGetID("A")
          AL_base := ALTAB_IndexOf(AL_list, curr)
          if (AL_base = 0)
            AL_base := 1
          AL_sel := AL_base

          AL_session    := true
          AL_pressCount := 0
          AL_firstTick  := A_TickCount
          SetTimer(ALTAB_ShowOverlayIfEligible, -HoldMs)
          __RX_Log(Format("session start: base={1} len={2} hold={3}ms", AL_base, AL_len, HoldMs))
        }

        dir := AL_evtQ.RemoveAt(1)
        AL_pressCount += 1
        AL_sel := ALTAB_Wrap(AL_sel + dir, AL_len)
        __RX_Log(Format("step dir={1} sel={2}/{3} presses={4}", dir, AL_sel, AL_len, AL_pressCount))

        if (AL_pressCount >= 2) {
          ALTAB_ShowOverlayNow()
          SetTimer(ALTAB_ShowOverlayIfEligible, 0)
          __RX_Log("overlay forced now (>=2 presses)")
        }
        ALTAB_UpdateOverlay()
      }

      ; 3b) If ALT_UP is pending, finalize now (after applying all steps)
      if (AL_altUpPending) {
        AL_altUpPending := false

        SetTimer(ALTAB_ShowOverlayIfEligible, 0)
        Overlay_Hide()
        AL_overlayUp := false

        len := (IsSet(AL_list) && IsObject(AL_list)) ? AL_list.Length : 0
        __RX_Log(Format("ALT_UP: sess={1} presses={2} list={3}", AL_session, AL_pressCount, len))

        if (AL_session && AL_pressCount >= 1 && len >= 1) {
          if (IsSet(RefreshOnAltUp) && RefreshOnAltUp) {
            currentSel := AL_list[AL_sel].Hwnd
            fresh := ALTAB_BuildList()
            if (fresh.Length) {
              AL_list := fresh
              idx := ALTAB_IndexOf(AL_list, currentSel)
              if (idx)
                AL_sel := idx
              else if (AL_sel > AL_list.Length)
                AL_sel := 1
            }
          }
          target := AL_list[AL_sel]
          ok := ActivateHwnd(target.Hwnd, target.State)
          __RX_Log(Format("activate hwnd={1} state={2} ok={3}", target.Hwnd, target.State, ok))
          if (ok)
            MRU_MoveToFront(target.Hwnd)
        }

        ALTAB_ResetSessionState()
        __RX_Log("session reset")
        ; after ALT_UP we’re done; break outer loop
        break
      } else {
        ; nothing more pending
        break
      }
    }
  } finally {
    AL_processingQ := false
  }
}


; dir: +1 forward, -1 backward
ALTAB_IPC_TabStep(dir) {
  global AL_session, AL_tabHeld, AL_firstTick, AL_pressCount, AL_list, AL_len
  global AL_sel, AL_base, HoldMs, AL_rxAltHeld

  if (AL_tabHeld)
    return
  AL_tabHeld := true
  AL_rxAltHeld := true

  if !AL_session {
    AL_list := ALTAB_BuildList()
    AL_len  := AL_list.Length
    if (AL_len = 0) {
      AL_tabHeld := false
      __RX_Log("RX step: list=0 → noop")
      return
    }
    curr    := WinGetID("A")
    AL_base := ALTAB_IndexOf(AL_list, curr)
    if (AL_base = 0)
      AL_base := 1
    AL_sel := AL_base

    AL_session    := true
    AL_pressCount := 0
    AL_firstTick  := A_TickCount
    SetTimer(ALTAB_ShowOverlayIfEligible, -HoldMs)
    __RX_Log(Format("session start: base={1} len={2} hold={3}ms", AL_base, AL_len, HoldMs))
  }

  AL_pressCount += 1
  AL_sel := ALTAB_Wrap(AL_sel + dir, AL_len)
  __RX_Log(Format("step dir={1} sel={2}/{3} presses={4}", dir, AL_sel, AL_len, AL_pressCount))

  if (AL_pressCount >= 2) {
    ALTAB_ShowOverlayNow()
    SetTimer(ALTAB_ShowOverlayIfEligible, 0)
    __RX_Log("overlay forced now (>=2 presses)")
  }
  ALTAB_UpdateOverlay()
  AL_tabHeld := false
}




ALTAB_IPC_AltUp() {
  global AL_session, AL_pressCount, AL_list, AL_sel, AL_overlayUp
  global RefreshOnAltUp, AL_rxAltHeld

  AL_rxAltHeld := false
  SetTimer(ALTAB_ShowOverlayIfEligible, 0)
  Overlay_Hide()
  AL_overlayUp := false

  len := (IsSet(AL_list) && IsObject(AL_list)) ? AL_list.Length : 0
  __RX_Log(Format("ALT_UP: sess={1} presses={2} list={3}", AL_session, AL_pressCount, len))

  if (AL_session && AL_pressCount >= 1 && len >= 1) {
    if (RefreshOnAltUp) {
      currentSel := AL_list[AL_sel].Hwnd
      fresh := ALTAB_BuildList()
      if (fresh.Length) {
        AL_list := fresh
        idx := ALTAB_IndexOf(AL_list, currentSel)
        if (idx)
          AL_sel := idx
        else if (AL_sel > AL_list.Length)
          AL_sel := 1
      }
    }
    target := AL_list[AL_sel]
    ok := ActivateHwnd(target.Hwnd, target.State)
    __RX_Log(Format("activate hwnd={1} state={2} ok={3}", target.Hwnd, target.State, ok))
    if (ok)
      MRU_MoveToFront(target.Hwnd)
  }

  ALTAB_ResetSessionState()
  __RX_Log("session reset")
}






; ---- Context predicate for blacklist helper ----
IsBLHotkeyActive(*) {
  global AL_session, AL_overlayUp
  return AL_session && AL_overlayUp && GetKeyState("Alt","P")
}

; ---- State ----
global AL_session     := false
global AL_tabHeld     := false
global AL_firstTick   := 0
global AL_pressCount  := 0
global AL_list        := []
global AL_len         := 0
global AL_sel         := 0
global AL_base        := 0
global AL_overlayUp   := false


; ---- Event helpers ----
ALTAB_Quit(*) {
  Overlay_Hide()
  Komorebi_SubStop()
  ExitApp()
}


; ---- Core Alt+Tab logic ----


ALTAB_Wrap(idx, len) {
  if (idx < 1)
    return len
  if (idx > len)
    return 1
  return idx
}
ALTAB_IndexOf(arr, hwnd) {
  for idx, it in arr
    if (it.Hwnd = hwnd)
      return idx
  return 0
}

; ---- Alt release = perform switch (if any) ----

ALTAB_ResetSessionState() {
  global AL_session, AL_pressCount, AL_tabHeld, AL_list, AL_len, AL_sel, AL_base
  global AL_pendingTabTick, AL_rxAltHeld
  global AL_evtQ, AL_altUpPending

  ; cancel any overlay delay timer
  SetTimer(ALTAB_ShowOverlayIfEligible, 0)

  AL_session    := false
  AL_pressCount := 0
  AL_tabHeld    := false
  AL_list       := []
  AL_len        := 0
  AL_sel        := 0
  AL_base       := 0
  AL_pendingTabTick := -1

  ; clear RX logical state & queue
  AL_rxAltHeld    := false
  AL_evtQ         := []
  AL_altUpPending := false
}



; ---- RX debug logging (non-blocking guard) ----
ALTAB_Debug_ToggleRxLog(*) {
  global DebugLogReceived
  DebugLogReceived := !DebugLogReceived
  ToolTip "DebugLogReceived = " (DebugLogReceived ? "ON" : "OFF")
  SetTimer(() => ToolTip(), -800)
  __RX_Log("=== toggled DebugLogReceived → " . (DebugLogReceived ? "ON" : "OFF") . " ===")
}
__RX_Log(msg) {
  if !(IsSet(DebugLogReceived) && DebugLogReceived)
    return
  global DebugRxLogPath
  ts := A_YYYY . "-" . A_MM . "-" . A_DD . " " . A_Hour . ":" . A_Min . ":" . A_Sec . "." . SubStr(A_MSec "000", 1, 3)
  try FileAppend(ts . "  [RX] " . msg . "rn", DebugRxLogPath, "UTF-8")
}



; ---- Overlay ----
; ---- Overlay ----
ALTAB_ShowOverlayIfEligible() {
  global AL_session, AL_firstTick, HoldMs, AL_rxAltHeld
  if !AL_session
    return
  if !AL_rxAltHeld
    return
  if (A_TickCount - AL_firstTick) < HoldMs
    return
  __RX_Log("overlay eligible → show now")
  ALTAB_ShowOverlayNow()
}



ALTAB_RxWatchdog_Tick() {
  global UseRxWatchdog, AL_session, AL_rxAltHeld, AL_lastRxTick
  if !UseRxWatchdog
    return
  if !(AL_session && AL_rxAltHeld)
    return
  ; if no RX activity for a bit and Alt is physically up, infer ALT_UP
  if ((A_TickCount - AL_lastRxTick) > 80 && !GetKeyState("Alt","P")) {
    __RX_Log("watchdog: inferred ALT_UP → self-heal")
    ; queue an alt-up and process
    global AL_altUpPending := true
    SetTimer(ALTAB_ProcessQueue, -1)
  }
}




ALTAB_Toggle_NoGUI(*) {
  global OverlayEnabled
  if !IsSet(OverlayEnabled)
    OverlayEnabled := true
  OverlayEnabled := !OverlayEnabled
  ToolTip "OverlayEnabled = " (OverlayEnabled ? "ON" : "OFF")
  SetTimer(() => ToolTip(), -800)
}

ALTAB_Toggle_NoBlocking(*) {
  global NoBlocking
  if (!IsSet(NoBlocking))
    NoBlocking := false
  NoBlocking := !NoBlocking
  ToolTip "NoBlocking = " (NoBlocking ? "ON" : "OFF")
  SetTimer(() => ToolTip(), -800)
}

ALTAB_ShowOverlayNow() {
  global AL_list, AL_sel, AL_overlayUp, RefreshOnOverlay

  local overlayEnabled := IsSet(OverlayEnabled) ? !!OverlayEnabled : true
  if !overlayEnabled
    return
  if (AL_list.Length = 0)
    return

  if (RefreshOnOverlay) {
    prev := (AL_sel >= 1 && AL_sel <= AL_list.Length) ? AL_list[AL_sel].Hwnd : 0
    fresh := ALTAB_BuildList()
    if (fresh.Length) {
      AL_list := fresh
      if (prev) {
        idx := ALTAB_IndexOf(AL_list, prev)
        if (idx)
          AL_sel := idx
        else if (AL_sel > AL_list.Length)
          AL_sel := 1
      } else if (AL_sel > AL_list.Length) {
        AL_sel := 1
      }
    }
  }

  Overlay_ShowList(AL_list, AL_sel)
  AL_overlayUp := true
}

ALTAB_UpdateOverlay() {
  global AL_list, AL_sel
  if (AL_list.Length = 0)
    return
  Overlay_UpdateSelection(AL_list, AL_sel)
}

; ---- MRU + Z-order ----
ALTAB_BuildList() {
  global UseMRU
  arr := WinList_EnumerateAll()  ; filtered, Z-order list
  if (!UseMRU)
    return arr

  local hmap := Map(), ordered := [], mru := MRU_GetList()
  for _, item in arr
    hmap[item.Hwnd] := item
  if IsObject(mru) {
    for _, h in mru
      if hmap.Has(h) {
        ordered.Push(hmap[h])
        hmap.Delete(h)
      }
  }
  for hwnd, item in hmap
    ordered.Push(item)
  return ordered
}

; ---- Debug: Alt+B to show blacklist snippet for selected window ----
ALTAB_Debug_Blacklist(*) {
  global AL_session, AL_overlayUp, AL_list, AL_sel
  if !(AL_session && AL_overlayUp && AL_list.Length && AL_sel >= 1 && AL_sel <= AL_list.Length)
    return
  item := AL_list[AL_sel]
  ShowBlacklistSuggestion(item)
}
--------------
Contents of config.ahk
--------------
﻿; ================== CONFIG (tweak freely) ==================
; ---- Debug toggles ----
global DebugKomorebi := false
global DebugBlacklist := false
global DebugLogReceived := false
global DebugGUI := false
global DebugLogPath   := A_ScriptDir "\tabby_debug.log"
global DebugMaxLinesPerSession := 200    ; optional
global DebugMaxDurationMs := 200         ; optional

global UseRxWatchdog    := false     ; if true, the gui will have a timer for assuming it missed alt release message
global HoldMs           := 150       ; overlay delay (ms) when holding Alt after first Tab
global UseAltGrace      := false     ; true: global Tab+grace; false: only when Alt physically down
global AltGraceMs       := 80        ; grace window for Alt pressed just before Tab
global DisableInProcesses := [       ; e.g. "valorant.exe", "eldenring.exe"
]
global DisableInFullscreen := false  ; bypass in fullscreen-looking windows
global UseMRU            := true   ; true: build cycling list from MRU ring vs pure Z-order
global SwitchCloakedMode := "ignore"  ; "ignore" | "toast"
; "ignore": do nothing if target is in other Komorebi workspace
; "toast":  show small tooltip explaining why no switch happened
global UseAltTabEligibility := true   ; filter windows like native Alt-Tab
global OverlayTitle      := "Switch"    ; window title for overlay (we also blacklist it)

; alt tab fighting
global BlockBareAlt := true
global UseAltComboHook := true
global RefreshOnOverlay := true ; rebuild list when overlay first appears
global RefreshOnAltUp := true   ; rebuild list just before activation

; === NEW: overlay + icons ===
global UseIcons            := true           ; show app icons in the list
global IconBatchPerTick    := 3              ; how many icons to resolve per timer tick
global IconTimerIntervalMs := 15             ; timer cadence for icon loading
global IconSizePx          := 64             ; small icon size

; === NEW: komorebi integration ===
global FocusCloakedViaKomorebi := true
global KomorebicExe := "C:\Program Files\komorebi\bin\komorebic.exe"  ; <— set to your actual path

; === Blacklists for enumeration (AHK wildcard, case-insensitive) ===
global BlacklistTitle := [
  "komoborder*",
  "YasbBar",
  "NVIDIA GeForce Overlay",
  "DWM Notification Window",
  "MSCTFIME UI",
  "Default IME",
  "Task Switching",
  "Command Palette",
  "GDI+ Window (OneDrive.exe)",
  "Windows Input Experience",
  OverlayTitle            ; avoid listing our own overlay
]
global BlacklistClass := [
  "komoborder*",
  "CEF-OSC-WIDGET",
  "Dwm",
  "MSCTFIME UI",
  "IME",
  "GDI+ Hook Window Class",
  "XamlExplorerHostIslandWindow",
  "WinUIDesktopWin32WindowClass",
  "Windows.UI.Core.CoreWindow",
  "AutoHotkeyGUI"         ; avoid listing any AHK GUI (including ours)
]
; Class+Title pair blacklist (both must match). Wildcards * and ? are OK (case-insensitive).
global BlacklistPair := []

;; Class+Title (exact):
BlacklistPair.Push({ Class: "GDI+ Hook Window Class", Title: "GDI+ Window (OneDrive.exe)" })

; ================== EXIT HOTKEY ==================
global QuitHotkey := "$*!F12"  ; Alt+F12

; =============== OLD GUI SETTINGS =================
global OverlayFont       := "Segoe UI"
global OverlayTitle      := "Switch"    ; window title for overlay (we also blacklist it)
; add these near the top with other tunables:

; Column visibility (affects overlay ListView)
; Always shown: "#", "Title", "Class", "State"
; Optional:
global GUI_ShowPID      := false       ; show Process ID
global GUI_ShowHWND     := false      ; show HWND (hex if GUI_HWND_Hex=true)
global GUI_ShowWinNum   := false      ; show Z-order / enumeration number
global GUI_ShowKomorebi := true       ; show Komorebi workspace name, e.g., "Main", "Media", "Game"
global GUI_ShowClass    := false 

; State shortening: WorkspaceShowing -> WS-Shown, etc.
global GUI_StateShort   := true

; HWND formatting
global GUI_HWND_Hex     := true


; ================== OLD THEME (overlay) ==================
; Backdrop/material
global BackdropMode        := "mica"   ; "none" | "auto" | "mica" | "acrylic" | "tabbed"

; Opacity policy
; "auto"  -> if BackdropMode is not "none", skip layered opacity so DWM material can render
; "force" -> apply layered opacity anyway (will suppress material)
global OverlayOpacityMode  := "auto"
;global OverlayOpacity      := 200      ; 0..255 (ignored when Mode="auto" and BackdropMode != "none")

; Corners + region fallback
global CornerPref          := "round"  ; "round" | "small" | "square"
global CornerRadiusPx      := 14       ; used by _ApplyRoundRegion fallback
global OverlayInsetPx      := 40       ; padding ring to reveal material around the LV

; ListView theming/toggles
global LV_DisableTheme     := true     ; disable Explorer theme so custom colors take effect
global LV_TransparentBG    := false    ; control-level transparency attempt (safe to leave false)
global LV_UseCustomDraw    := true     ; custom colors for text + selection

; ListView colors (hex "#RRGGBB" or integer 0xRRGGBB)
global LV_ColorBG          := "#14181C"  ; (parent is material; LV bg is set to CLR_NONE anyway)
global LV_ColorText        := "#F5F7FA"
global LV_ColorTextBG      := "#14181C"
global LV_ColorSelBG       := "#2B5CAD"
global LV_ColorSelText     := "#FFFFFF"

; =============== NEW GUI SETTINGS =================

; ========================= CONFIG =========================

; Background Window
global AcrylicAlpha    := 0x33           ; 0..255 (higher = more opaque)
global AcrylicBaseRgb  := 0x330000       ; 0xRRGGBB base tint for acrylic - um I think its BBGGRR actually
global CornerRadiusPx  := 18
global AlwaysOnTop := true

; Selection scroll behavior
global ScrollKeepHighlightOnTop := true  ; false = anchor at bottom when scrolling down; true = highlighted row stays at top

; ---- Size config ----
global ScreenWidthPct := 0.60   ; 0.30..0.95 typical. Window width = this % of primary work area

; ---- Dynamic visible rows (window auto-resizes between these) ----
global RowsVisibleMin := 1
global RowsVisibleMax := 5

; Virtual list look
global RowHeight   := 56     ; px height of each virtual row
global MarginX     := 18
global MarginY     := 18
global IconSize    := 36
global IconLeftMargin := 8
global RowRadius   := 12    ; selection pill rounding
global SelARGB     := 0x662B5CAD ; AARRGGBB semi-transparent blue-ish

; ---- Action keystrokes (true/false gates) ----
global AllowCloseKeystroke     := true
global AllowKillKeystroke      := true
global AllowBlacklistKeystroke := true

; ---- Show row action buttons on hover ----
global ShowCloseButton      := true
global ShowKillButton       := true
global ShowBlacklistButton  := true

; ---- Font + color theming ----
; NOTE: weight >= 600 => bold, otherwise regular (GDI+ supports bold/regular)


; ---- Action button geometry / font ----
global ActionBtnSizePx   := 24
global ActionBtnGapPx    := 6
global ActionBtnRadiusPx := 6
global ActionFontName    := "Segoe UI Symbol"  ; try "Segoe UI" if symbols don't render
global ActionFontSize    := 18
global ActionFontWeight  := 700

; ---- Close button styling ----
global CloseButtonBorderPx      := 1
global CloseButtonBorderARGB    := 0x88FFFFFF
global CloseButtonBGARGB        := 0xFF000000
global CloseButtonBGHoverARGB   := 0xFF888888
global CloseButtonTextARGB      := 0xFFFFFFFF
global CloseButtonTextHoverARGB := 0xFFFF0000
global CloseButtonGlyph         := "❌"  ; fallback: "X"

; ---- Kill button styling ----
global KillButtonBorderPx       := 1
global KillButtonBorderARGB     := 0x88FFB4A5
global KillButtonBGARGB         := 0xFF300000
global KillButtonBGHoverARGB    := 0xFFD00000
global KillButtonTextARGB       := 0xFFFFE8E8
global KillButtonTextHoverARGB  := 0xFFFFFFFF
global KillButtonGlyph          := "☠️"  ; fallback: "K"

; ---- Blacklist button styling ----
global BlacklistButtonBorderPx      := 1
global BlacklistButtonBorderARGB    := 0x88999999
global BlacklistButtonBGARGB        := 0xFF000000
global BlacklistButtonBGHoverARGB   := 0xFF888888
global BlacklistButtonTextARGB      := 0xFFFFFFFF
global BlacklistButtonTextHoverARGB := 0xFFFF0000
global BlacklistButtonGlyph         := "⛔"  ; fallback: "B"


; ---- Extra columns (0 = hidden) ----
global ColFixed2   := 70   ; fixed width for column 2 (right)
global ColFixed3   := 50   ; fixed width for column 3 (right)
global ColFixed4 := 0
global ColFixed5 := 0
global ColFixed6 := 0

; Optional headers
global ShowHeader := true
global Col2Name := "HWND" ; optional ; show HWND (hex if GUI_HWND_Hex=true)
global Col3Name := "PID" ; optional ; show Process ID
global Col4Name := "WS"    ; optional ; show Komorebi workspace name, e.g., "Main", "Media", "Game"
global Col5Name := "NUM"    ; optional ; show Z-order / enumeration number
global Col6Name := "CLASS"    ; optional ; show class

; ---- Header font (name/size/weight/color) ----
global HdrFontName   := "Segoe UI"
global HdrFontSize   := 12
global HdrFontWeight := 600             ; >=600 => bold
global HdrARGB       := 0xFFD0D6DE      ; header text color

; Main Font
global MainFontName := "Segoe UI"
global MainFontSize := 20
global MainFontWeight := 400
global MainFontNameHi := "Segoe UI"
global MainFontSizeHi := 20
global MainFontWeightHi := 800
global MainARGB := 0xFFF0F0F0  ; main text color 
global MainARGBHi := MainARGB  ; main text highlight

; Sub Font
global SubFontName := "Segoe UI"
global SubFontSize := 12
global SubFontWeight := 400
global SubFontNameHi := "Segoe UI"
global SubFontSizeHi := 12
global SubFontWeightHi := 600
global SubARGB     := 0xFFB5C0CE ; dim text
global SubARGBHi  := SubARGB

; Col Font
global ColFontName := "Segoe UI"
global ColFontSize := 12
global ColFontWeight := 400
global ColFontNameHi := "Segoe UI"
global ColFontSizeHi := 12
global ColFontWeightHi := 600
global ColARGB := 0xFFF0F0F0     ; column text color (same on highlight)
global ColARGBHi  := ColARGB ; column text color highlight

; ---- Overlay scrollbar (virtual) ----
global ScrollBarEnabled         := true         ; show/hide overlay scrollbar
global ScrollBarWidthPx         := 6            ; thickness in px (DIPs)
global ScrollBarMarginRightPx   := 8            ; distance from right edge (DIPs)
global ScrollBarThumbARGB       := 0x88FFFFFF   ; AARRGGBB for thumb (semi-white)
global ScrollBarGutterEnabled   := false        ; draw a gutter/track behind thumb
global ScrollBarGutterARGB      := 0x30000000   ; AARRGGBB for gutter (semi-dark)

; Message shown when there are no items (uses Main font styling)
global EmptyListText := "No Windows"

; ---- Footer / Scope switcher (POC) ----
global ShowFooter          := true          ; show the footer bar
global FooterTextAlign     := "center"      ; "left" | "center" | "right"
global FooterBorderPx      := 0
global FooterBorderARGB    := 0x33FFFFFF
global FooterBGRadius      := 0
global FooterBGARGB        := 0x00000000    ; subtle translucent fill
global FooterTextARGB      := 0xFFFFFFFF
global FooterFontName      := "Segoe UI"
global FooterFontSize      := 16
global FooterFontWeight    := 600
global FooterHeightPx      := 10            ; DIP height of the footer bar
global FooterGapTopPx      := 10             ; space between list and footer
global FooterPaddingX      := 0           ; text padding inside the bar
--------------
Contents of helpers.ahk
--------------
﻿; ================== helpers.ahk ==================
; Utility helpers: dark mode, wildcard matching (with strong normalization),
; game bypass, activation (Komorebi-aware call-out), blacklist snippet tools, and debug logging.

; ---------- Debug toggles (optionally override in config.ahk) ----------
if !IsSet(DebugBlacklist)
    global DebugBlacklist := false
if !IsSet(DebugKomorebi)
    global DebugKomorebi := false
if !IsSet(DebugLogPath)
    global DebugLogPath := A_ScriptDir "\tabby_debug.log"

; ---------- Logging ----------
_Log(msg) {
    global DebugBlacklist, DebugKomorebi, DebugLogPath
    if !(DebugBlacklist || DebugKomorebi)
        return
    ts := A_YYYY . "-" . A_MM . "-" . A_DD . " " . A_Hour . ":" . A_Min . ":" . A_Sec . "." . SubStr(A_MSec "000", 1, 3)
    try FileAppend(ts . "  " . msg . "rn", DebugLogPath, "UTF-8")
}

_LogCodepoints(label, s) {
    if !IsSet(s)
        s := ""
    cp := ""
    Loop StrLen(s) {
        ch := SubStr(s, A_Index, 1)
        cp .= Format("{:04X} ", Ord(ch))  ; safe here; not embedded in a larger format string
    }
    _Log(label . " (len=" . StrLen(s) . "): " . cp)
}


; ---------- Theme helpers (safe) ----------
_ColorToCOLORREF(c) {
    if IsNumber(c)
        return Integer(c) & 0xFFFFFF
    s := Trim(c)
    if (SubStr(s,1,1) = "#") {
        rr := Integer("0x" . SubStr(s,2,2))
        gg := Integer("0x" . SubStr(s,4,2))
        bb := Integer("0x" . SubStr(s,6,2))
        return (bb<<16) | (gg<<8) | rr
    }
    if (StrLen(s)=6) {
        rr := Integer("0x" . SubStr(s,1,2))
        gg := Integer("0x" . SubStr(s,3,2))
        bb := Integer("0x" . SubStr(s,5,2))
        return (bb<<16) | (gg<<8) | rr
    }
    return 0x202020
}


; ---------- Rounded corners by region (works with -Caption) ----------


; ---------- Window theme application (pre- and post-show) ----------



; ---------- Strong normalization for matching ----------
; - Map plus-like Unicode to ASCII '+'
; - Collapse CR/LF/TAB/NBSP to spaces
; - Remove spaces around '+'
; - Collapse multiple spaces
; - Trim
NormalizeMatchText(s) {
  if !IsSet(s) || (s = "")
    return ""
  ; FULLWIDTH PLUS (FF0B), SMALL PLUS (FE62), SUPERSCRIPT PLUS (207A)
  s := RegExReplace(s, "[\x{FF0B}\x{FE62}\x{207A}]", "+")
  s := RegExReplace(s, "[\r\n\t\xA0]+", " ")
  s := RegExReplace(s, "\s*\+\s*", "+")
  s := RegExReplace(s, " {2,}", " ")
  return Trim(s)
}

; ---------- Wildcards (AHK → regex) with normalization ----------
WildMatch(s, pat) {
  s   := NormalizeMatchText(s)
  pat := NormalizeMatchText(pat)
  ; Escape regex specials, then apply AHK wildcards
  pat := RegExReplace(pat, "([\\.^$+(){}\[\]|])", "\\$1")
  pat := StrReplace(pat, "?", ".")
  pat := StrReplace(pat, "*", ".*")
  return RegExMatch(s, "i)^(?:" . pat . ")$")
}

MatchAny(value, patterns) {
  if !IsSet(patterns) || patterns.Length = 0
    return false
  for _, p in patterns
    if (WildMatch(value, p))
      return true
  return false
}

; pairs = [ {Title:"...", Class:"..."}, ... ]
; Either key may be omitted in a pair. BOTH present keys must match.
MatchPairs(ttl, cls, pairs) {
  if !IsSet(pairs) || pairs.Length = 0
    return false
  for _, r in pairs {
    hasT := HasProp(r, "Title")
    hasC := HasProp(r, "Class")
    tOk := (!hasT) || WildMatch(ttl, r.Title)
    cOk := (!hasC) || WildMatch(cls, r.Class)
    if (tOk && cOk)
      return true
  }
  return false
}

; ---------- Fullscreen heuristic & game bypass ----------
IsFullscreenApprox(win := "A") {
  ; Guard against transient “no active window” / shell handoff states.
  local x := 0, y := 0, w := 0, h := 0
  try {
    if !WinExist(win)
      return false
    WinGetPos &x, &y, &w, &h, win
  } catch {
    ; If we can’t query, treat as not fullscreen (never block Alt+Tab).
    return false
  }
  return (w >= A_ScreenWidth*0.99 && h >= A_ScreenHeight*0.99 && x <= 5 && y <= 5)
}

ShouldBypassForGame() {
  global DisableInProcesses, DisableInFullscreen

  ; Fetch active exe name safely; on failure, just skip process match.
  exename := ""
  try {
    if WinExist("A")
      exename := WinGetProcessName("A")
  } catch as e {
    _Log("ShouldBypassForGame: WinGetProcessName failed: " . e.Message)
    ; Optional: surface when you’re already debugging blacklist/enum.
    if (IsSet(DebugBlacklist) && DebugBlacklist)
      _SoftToast("Bypass check skipped (no active window)")
  }

  if (exename != "") {
    lex := StrLower(exename)
    for _, nm in DisableInProcesses
      if (StrLower(nm) = lex)
        return true
  }

  if (DisableInFullscreen && IsFullscreenApprox("A"))
    return true

  return false
}


; ---------- Activation (Komorebi-aware) ----------
; NOTE: Komorebi_FocusHwnd() is implemented in komorebi.ahk. This function just calls it.
; ---------- Activation (Komorebi-aware) ----------
; ---------- Activation (Komorebi-aware) ----------
; --- helpers.ahk ---
; --- helpers.ahk ---
ActivateHwnd(hwnd, state := "") {
  try _KLog("ActivateHwnd: hwnd=" . hwnd . " state=" . state)
  if !hwnd
    return false

  if (state = "OtherWorkspace") {
    if (IsSet(NoBlocking) && NoBlocking) {
      _KLog("ActivateHwnd: skipped (NoBlocking) for OtherWorkspace")
      return false
    }
    SetTimer(() => __ALTAB_FocusOtherWorkspaceAsync(hwnd), -1) ; run once, ASAP
    return false
  }

  if !WinExist("ahk_id " hwnd)
    return false

  stateMM := WinGetMinMax("ahk_id " hwnd)
  if (stateMM = -1)
    DllCall("user32\ShowWindow", "ptr", hwnd, "int", 9)  ; SW_RESTORE

  WinActivate "ahk_id " hwnd
  Sleep 0
  return WinActive("ahk_id " hwnd)
}


__ALTAB_FocusOtherWorkspaceAsync(hwnd) {
  ; This runs off-thread (timer), so any slower CLI calls can’t stall Alt-Tab.
  try {
    ok := Komorebi_FocusHwnd(hwnd)   ; may call RunWait internally
    _KLog("Async focus result=" . (ok ? "ok" : "fail"))
  } catch as e {
    _KLog("Async focus error: " . e.Message)
  }
}



; ---------- (NEW) tiny optional toast for debug-only surfacing ----------
_SoftToast(msg, ms := 900) {
  try {
    ToolTip msg
    SetTimer(() => ToolTip(), -Abs(ms))
  }
}



; Keep this here so komorebi.ahk can use it for CLI attempts.
RunTry(cmdLine) {
  try {
    return RunWait(cmdLine, , "Hide")
  } catch {
    return 1
  }
}

; ---------- Blacklist snippet builder (Alt+B) ----------
EscapeAhkStr(s) {
  q := Chr(34)                 ; double-quote
  return StrReplace(s, q, q q) ; double the quotes
}

BuildBlacklistSnippet(item) {
  ; Raw
  rawT := item.Title, rawC := item.Class
  ; Exact (escaped)
  t := EscapeAhkStr(rawT)
  c := EscapeAhkStr(rawC)
  ; Tolerant (normalize spaces around '+'), then escape
  tTol := EscapeAhkStr(RegExReplace(rawT, "\s*\+\s*", "+"))
  cTol := EscapeAhkStr(RegExReplace(rawC, "\s*\+\s*", "+"))

  ; CHAT GPT HEY YOU. OR ANY AI
  ; YOU ARE VERY BAD AT THESE PARSING STRINGS IN AHKv2
  ; MAKE SURE YOU ARENT CHANGING THEM UNLESS YOU ABSOLUTELY NEED TO
  ; DON'T REMOVE OR CHANGE THIS WARNING
  txt := ';; --- Copy any of these into config.ahk ---rn'
  txt .= ';; Title-only (exact):rn'
  txt .= 'BlacklistTitle.Push("' . t . '")rnrn'
  txt .= ';; Class-only (exact):rn'
  txt .= 'BlacklistClass.Push("' . c . '")rnrn'
  txt .= ';; Class+Title (exact):rn'
  txt .= 'BlacklistPair.Push({ Class: "' . c . '", Title: "' . t . '" })rnrn'
  txt .= ';; Class+Title (tolerant of spaces around +):rn'
  txt .= 'BlacklistPair.Push({ Class: "' . cTol . '", Title: "' . tTol . '" })rn'
  return txt
}

ShowBlacklistSuggestion(item) {
  txt := BuildBlacklistSnippet(item)
  A_Clipboard := txt
  MsgBox txt, "Blacklist snippet (copied to clipboard)", "64"
}

; ---------- Debug helpers to trace blacklist decisions ----------
_DebugDumpBlacklistDecision(ttl, cls) {
    ; Only spam logs for likely offenders; tweak as needed.
    if !(InStr(ttl, "OneDrive") || InStr(cls, "OneDrive") || InStr(ttl, "GDI") || InStr(cls, "GDI"))
        return
    _Log("----- BLACKLIST TRACE -----")
    _Log("RAW Title: " . ttl)
    _Log("RAW Class: " . cls)
    _LogCodepoints("Title codepoints", ttl)
    _LogCodepoints("Class codepoints", cls)

    nt := NormalizeMatchText(ttl), nc := NormalizeMatchText(cls)
    _Log("NORM Title: " . nt)
    _Log("NORM Class: " . nc)

    global BlacklistTitle, BlacklistClass, BlacklistPair

    ; Title rules
    if IsSet(BlacklistTitle) {
        for i, p in BlacklistTitle {
            res := WildMatch(ttl, p) ? "MATCH" : "no"
            _Log("TitleRule[" . i . "]: '" . p . "' -> " . res)
        }
    }

    ; Class rules
    if IsSet(BlacklistClass) {
        for i, p in BlacklistClass {
            res := WildMatch(cls, p) ? "MATCH" : "no"
            _Log("ClassRule[" . i . "]: '" . p . "' -> " . res)
        }
    }

    ; Pair rules
    if IsSet(BlacklistPair) && BlacklistPair.Length {
        for i, r in BlacklistPair {
            hasT := HasProp(r, "Title")
            hasC := HasProp(r, "Class")
            tRes := hasT ? (WildMatch(ttl, r.Title) ? "T=match" : "T=no") : "T=skip"
            cRes := hasC ? (WildMatch(cls, r.Class) ? "C=match" : "C=no")  : "C=skip"
            msg := "Pair[" . i . "]: " . tRes . " " . Chr(59) . " " . cRes
            _Log(msg)
        }
    }

    _Log("---------------------------")
}
--------------
Contents of interceptor.ahk
--------------
﻿; ================== Alt+Tab Intercept MICRO (no GUI) — Alt pass-through, Tab deferred ==================
#Requires AutoHotkey v2.0
#SingleInstance Force
#UseHook true
InstallKeybdHook(true)

; Use an inert mask key so Alt taps don't focus menus, without blocking Alt itself.
; Official v2 docs: A_MenuMaskKey
A_MenuMaskKey := "vkE8"

#Include config.ahk
#Include ipc_targeted.ahk   ; targeted IPC

; ================== CONFIG (local defaults if not in config.ahk) ==================
if !IsSet(HoldMs)               ; (unused here; kept for compatibility with the rest of your app)
    HoldMs := 350
; New: tiny non-blocking Tab decision window + “recent Alt” leeway
if !IsSet(DecisionMs)
    DecisionMs := 24            ; try 16–24ms
if !IsSet(LastAltLeewayMs)
    LastAltLeewayMs := 60       ; accept Alt pressed within this window
if !IsSet(DisableInProcesses)
    DisableInProcesses := []
if !IsSet(DisableInFullscreen)
    DisableInFullscreen := true

; (Back-compat only; no longer used)
if !IsSet(UseAltGrace)
    UseAltGrace := true
if !IsSet(AltGraceMs)
    AltGraceMs := 80

; ================== STATE ==================
sessionActive := false
tabHeld       := false
pressCount    := 0
lastAltDown   := -999999

; Deferred-Tab decision state
tabPending          := false
tabUpSeen           := false
pendingShift        := false
pendingDecideArmed  := false

; ================== START ==================
TABBY_IPC_InitMicro()   ; discover receiver hwnd via HELLO/ACK (non-blocking)

; ================== QUIT ====================
Quit(*) => ExitApp()
Hotkey("$*!F12", Quit)
A_TrayMenu.Add("Exit", Quit)

; ================== ALT TRACKING (pass-through; just timestamp + mask nudge) =====
; We don't block Alt at all, so Alt+F at 10ms works. We only prevent the “Alt tap → menu” side-effect.
Hotkey("~*Alt",    Alt_Down)
Hotkey("~*Alt Up", Alt_Up)

Alt_Down(*) {
    global lastAltDown
    lastAltDown := A_TickCount
    ; Paranoia: nudge the mask at Alt down (A_MenuMaskKey already handles masking)
    try Send "{Blind}{vkE8}"
}

Alt_Up(*) {
    global sessionActive, pressCount, tabHeld
    ; No synthetic Alt sends—Alt was never blocked.
    if (sessionActive && pressCount >= 1) {
        TABBY_IPC_SendAltUp()   ; targeted + redundant pings, async
    }
    sessionActive := false
    pressCount    := 0
    tabHeld       := false
}

; ================== HOOKS ===================
Hotkey("$*Tab",    Tab_Down_Global)
Hotkey("$*Tab Up", Tab_Up)

; ================== HELPERS =================
ShouldBypassForGame() {
    global DisableInProcesses, DisableInFullscreen
    exename := ""
    try exename := WinGetProcessName("A")
    if (exename) {
        lex := StrLower(exename)
        for _, nm in DisableInProcesses
            if (StrLower(nm) = lex)
                return true
    }
    return DisableInFullscreen && IsFullscreenApprox("A")
}
IsFullscreenApprox(win := "A") {
    local x:=0,y:=0,w:=0,h:=0
    try WinGetPos &x,&y,&w,&h, win
    return (w >= A_ScreenWidth*0.99 && h >= A_ScreenHeight*0.99 && x <= 5 && y <= 5)
}

; ================== CORE: TAB (deferred decision; never delays Alt) ==================
Tab_Down_Global(*) {
    global tabPending, pendingShift, tabUpSeen, pendingDecideArmed, DecisionMs

    if ShouldBypassForGame() {
        Send(GetKeyState("Shift","P") ? "+{Tab}" : "{Tab}")
        return
    }
    ; Already pending or currently held by an Alt+Tab step?
    if (tabPending)
        return

    ; Swallow Tab briefly and decide soon whether this is Alt+Tab or a plain Tab.
    tabPending         := true
    pendingShift       := GetKeyState("Shift","P")
    tabUpSeen          := false
    pendingDecideArmed := true
    SetTimer(Tab_Decide, -DecisionMs)
}

Tab_Up(*) {
    global tabHeld, tabPending, tabUpSeen
    if (tabHeld) {
        ; We committed this keystroke as an Alt+Tab step—release “held” state.
        tabHeld := false
        return
    }
    ; If we're still deciding, remember that physical Tab already went up.
    if (tabPending)
        tabUpSeen := true
}

Tab_Decide() {
    global tabPending, tabUpSeen, pendingShift, pendingDecideArmed
    global lastAltDown, LastAltLeewayMs
    global sessionActive, pressCount, tabHeld

    if (!pendingDecideArmed)
        return
    pendingDecideArmed := false

    isAltNow  := GetKeyState("Alt","P")
    altRecent := (A_TickCount - lastAltDown) <= LastAltLeewayMs

    if (isAltNow || altRecent) {
        ; Commit as Alt+Tab step (send to your receiver via IPC)
        tabPending := false

        if (!sessionActive) {
            sessionActive := true
            pressCount    := 0
        }
        pressCount += 1

        shiftFlag := pendingShift ? 1 : 0
        TABBY_IPC_SendStep(shiftFlag)   ; targeted async send

        ; Maintain a simple “held Tab” flag until the physical key-up arrives (if it hasn't already).
        tabHeld := !tabUpSeen
    } else {
        ; Not Alt+Tab → replay a normal Tab immediately (respect Shift).
        tabPending := false
        Send(pendingShift ? "+{Tab}" : "{Tab}")
    }
}
--------------
Contents of ipc_targeted.ahk
--------------
﻿; ================== ipc_targeted.ahk (AHKv2) ==================
#Requires AutoHotkey v2.0

; ---- Public API ------------------------------------------------
; Micro (interceptor) side:
;   TABBY_IPC_InitMicro()
;   TABBY_IPC_Post(ev, flags := 0, lParam := 0)   ; ev: 1=TAB_STEP, 2=ALT_UP (kept for compatibility)
;   TABBY_IPC_SendStep(shiftFlag := 0)
;   TABBY_IPC_SendAltUp()

; Receiver (switcher) side:
;   TABBY_IPC_InitReceiver(handlerFn)             ; handlerFn(ev, flags, lParam)

; ---------------------------------------------------------------

; ---- Globals ----
global __TAB_msg_STEP := 0
global __TAB_msg_ALTUP := 0
global __TAB_msg_HELLO := 0
global __TAB_msg_HELLO_ACK := 0

global __TAB_role := ""                 ; "micro" | "receiver"
global __TAB_handler := 0               ; receiver’s delegate
global __TAB_target := 0                ; micro->receiver target hwnd
global __TAB_peerMicro := 0             ; receiver caches last micro hwnd
global __TAB_lastHelloTick := 0
global __TAB_helloTimerOn := false
global __TAB_pendingRetry := false

; redundant ALT_UP re-post guard
global __TAB_lastAltUpTick := 0

; ---- Constants ----
__TAB_HWND_BROADCAST() => 0xFFFF
__TAB_MSGFLT_ADD()     => 1

; ---- Utilities ----
__TAB_Reg(msgName) {
  return DllCall("user32\RegisterWindowMessageW", "str", msgName, "uint")
}

__TAB_AllowMsgForThisWindow(msgId) {
  ; Allows message from lower IL senders if needed (safe no-op if same IL).
  try DllCall("user32\ChangeWindowMessageFilterEx"
    , "ptr", A_ScriptHwnd
    , "uint", msgId
    , "uint", __TAB_MSGFLT_ADD()
    , "ptr", 0
    , "int")
}

__TAB_SendNotify(hWnd, msg, wParam := 0, lParam := 0) {
  ; Async, non-blocking across threads/processes
  return DllCall("user32\SendNotifyMessageW"
    , "ptr", hWnd
    , "uint", msg
    , "uptr", wParam
    , "ptr", lParam
    , "int")
}

__TAB_SendHello_Broadcast(*) {
  global __TAB_msg_HELLO, __TAB_helloTimerOn, __TAB_lastHelloTick
  __TAB_lastHelloTick := A_TickCount
  __TAB_SendNotify(__TAB_HWND_BROADCAST(), __TAB_msg_HELLO, A_ScriptHwnd, 0)
}

__TAB_StartHelloTimer() {
  global __TAB_helloTimerOn
  if (__TAB_helloTimerOn)
    return
  __TAB_helloTimerOn := true
  ; quick bursts for first second, then back off
  ; 0ms, 120ms, 250ms, 500ms, stop when __TAB_target learned
  seq := [0, 120, 250, 500]
  i := 1
  for delay in seq {
    SetTimer(() => (__TAB_target ? 0 : __TAB_SendHello_Broadcast()), -delay)
  }
  ; safety: after 2s, try once more if still no target
  SetTimer(() => (__TAB_target ? 0 : __TAB_SendHello_Broadcast()), -2000)
}

__TAB_OnMsg(wParam, lParam, msg, hwnd) {
  global __TAB_role, __TAB_handler, __TAB_msg_STEP, __TAB_msg_ALTUP, __TAB_msg_HELLO, __TAB_msg_HELLO_ACK
  global __TAB_peerMicro, __TAB_target

  if (msg = __TAB_msg_HELLO) {
    ; someone is announcing; if we’re receiver, cache its hwnd and ACK with our hwnd
    if (__TAB_role = "receiver") {
      __TAB_peerMicro := wParam
      __TAB_SendNotify(wParam, __TAB_msg_HELLO_ACK, A_ScriptHwnd, 0)
    }
    return
  }

  if (msg = __TAB_msg_HELLO_ACK) {
    ; micro learns receiver’s hwnd
    __TAB_target := wParam
    return
  }

  ; Delivery to receiver:
  if (__TAB_role = "receiver") {
    if !IsSet(__TAB_handler) || !__TAB_handler
      return
    if (msg = __TAB_msg_STEP) {
      (__TAB_handler).Call(1, wParam, lParam)   ; ev=1 (TAB_STEP)
      return
    }
    if (msg = __TAB_msg_ALTUP) {
      (__TAB_handler).Call(2, wParam, lParam)   ; ev=2 (ALT_UP)
      return
    }
  }
}

__TAB_InitCommon() {
  global __TAB_msg_STEP, __TAB_msg_ALTUP, __TAB_msg_HELLO, __TAB_msg_HELLO_ACK
  ; Use GUID-like names to avoid collisions
  __TAB_msg_STEP      := __TAB_Reg("TABBY_STEP_5b1b1e9b-ec5e-4aa0-8893-1f4d2a1c1a00")
  __TAB_msg_ALTUP     := __TAB_Reg("TABBY_ALTUP_9b40a4d1-1c0f-4dc5-8b7e-0bdb6c8a5f01")
  __TAB_msg_HELLO     := __TAB_Reg("TABBY_HELLO_a1157f6c-2a6f-4e3d-afe1-3bcd29c3c102")
  __TAB_msg_HELLO_ACK := __TAB_Reg("TABBY_HELLO_ACK_3a3d3e6c-8b9a-4e2b-945f-10c7f4b2d203")

  OnMessage(__TAB_msg_HELLO,     __TAB_OnMsg)
  OnMessage(__TAB_msg_HELLO_ACK, __TAB_OnMsg)
  OnMessage(__TAB_msg_STEP,      __TAB_OnMsg)
  OnMessage(__TAB_msg_ALTUP,     __TAB_OnMsg)

  ; Allow through UIPI if needed (harmless otherwise)
  __TAB_AllowMsgForThisWindow(__TAB_msg_HELLO)
  __TAB_AllowMsgForThisWindow(__TAB_msg_HELLO_ACK)
  __TAB_AllowMsgForThisWindow(__TAB_msg_STEP)
  __TAB_AllowMsgForThisWindow(__TAB_msg_ALTUP)
}

; ---- Public: Receiver init ----
TABBY_IPC_InitReceiver(handlerFn) {
  global __TAB_role, __TAB_handler
  __TAB_InitCommon()
  __TAB_role   := "receiver"
  __TAB_handler := handlerFn
  ; On first HELLO from micro we’ll reply with ACK; nothing more to do now.
}

; ---- Public: Micro init ----
TABBY_IPC_InitMicro() {
  global __TAB_role
  __TAB_InitCommon()
  __TAB_role := "micro"
  __TAB_StartHelloTimer()
}

; ---- Micro send helpers ----
__TAB_EvToMsg(ev) {
  global __TAB_msg_STEP, __TAB_msg_ALTUP
  return (ev = 1) ? __TAB_msg_STEP
       : (ev = 2) ? __TAB_msg_ALTUP
       : 0
}

__TAB_TargetEnsure() {
  global __TAB_target
  if (__TAB_target)
    return true
  __TAB_StartHelloTimer()
  return false
}

__TAB_Send(ev, flags := 0, lParam := 0) {
  global __TAB_target
  msg := __TAB_EvToMsg(ev)
  if (!msg)
    return
  if (!__TAB_TargetEnsure()) {
    ; If target is not known yet, schedule a quick retry (non-blocking) and bail.
    SetTimer(() => __TAB_Send(ev, flags, lParam), -8)
    return
  }
  __TAB_SendNotify(__TAB_target, msg, flags, lParam)
}

; Backward-compatible entry
TABBY_IPC_Post(ev, flags := 0, lParam := 0) => __TAB_Send(ev, flags, lParam)

TABBY_IPC_SendStep(shiftFlag := 0) {
  __TAB_Send(1, shiftFlag & 1, 0)
}

TABBY_IPC_SendAltUp() {
  global __TAB_lastAltUpTick
  __TAB_lastAltUpTick := A_TickCount
  __TAB_Send(2, 0, 0)
  ; tiny redundant pings to survive edge races (still async/non-blocking)
  SetTimer(TABBY_IPC_SendAltUp__retry5,  -5)
  SetTimer(TABBY_IPC_SendAltUp__retry25, -25)
}
TABBY_IPC_SendAltUp__retry5(*)  => __TAB_Send(2, 0, 0)
TABBY_IPC_SendAltUp__retry25(*) => __TAB_Send(2, 0, 0)
--------------
Contents of komorebi.ahk
--------------
﻿; ================== komorebi.ahk ==================
; Single source for Komorebi helpers.
; Depends on: _Log(msg) and RunTry(cmdLine) from helpers.ahk
; Ensure helpers.ahk is #included before this file.

if !IsSet(DebugKomorebi)
    global DebugKomorebi := false

; --- Tiny state TTL cache (avoid re-spawning komorebic state repeatedly)
global KState_Text := ""
global KState_Stamp := 0
global KState_TTL := 180   ; ms

; --- LRU cache for hwnd -> (mIdx, wsIdx, wsName)
global KLRU_Map := Map()    ; hwnd -> {mIdx:Int, wsIdx:Int, wsName:Str}
global KLRU_Order := []     ; keeps recency order of hwnds
global KLRU_Cap := 256


; --- Internal logging wrapper (routes to _Log when DebugKomorebi = true)
_KLog(msg) {
    global DebugKomorebi
    if (DebugKomorebi)
        _Log("[komorebi] " . msg)
}

; --- Quote helper for command lines
_KQuote(s) {
    if !IsSet(s)
        return '""'
    if InStr(s, '"')
        return '"' . StrReplace(s, '"', '""') . '"'
    if InStr(s, ' ')
        return '"' . s . '"'
    return s
}

; --- Run a CLI and capture its stdout to a temp file, then read it back
_KRunCaptureToText(cmd, &outText) {
    tmp := A_Temp . "\komorebi_cap_" . A_TickCount . "_" . Random(1000,9999) . ".tmp"
    ; Run via cmd so we can use redirection
    full := 'cmd.exe /c ' . cmd . ' > ' . _KQuote(tmp) . ' 2>&1'
    code := RunTry(full)
    outText := ""
    try {
        if FileExist(tmp)
            outText := FileRead(tmp, "UTF-8")
    }
    try FileDelete(tmp)
    return code
}

_KLRU_Touch(hwnd) {
    global KLRU_Order
    ; remove any existing
    for i, h in KLRU_Order
        if (h = hwnd) {
            KLRU_Order.RemoveAt(i)
            break
        }
    KLRU_Order.InsertAt(1, hwnd)
}

_KLRU_Put(hwnd, mIdx, wsIdx, wsName) {
    global KLRU_Map, KLRU_Order, KLRU_Cap
    KLRU_Map[hwnd] := { mIdx: mIdx, wsIdx: wsIdx, wsName: wsName }
    _KLRU_Touch(hwnd)
    ; evict if needed
    while (KLRU_Order.Length > KLRU_Cap) {
        old := KLRU_Order.RemoveAt(KLRU_Order.Length)
        if (KLRU_Map.Has(old))
            KLRU_Map.Delete(old)
    }
}

_KLRU_Get(hwnd, &mIdx, &wsIdx, &wsName) {
    global KLRU_Map
    if !KLRU_Map.Has(hwnd) {
        mIdx := -1, wsIdx := -1, wsName := ""
        return false
    }
    v := KLRU_Map[hwnd]
    mIdx := v.mIdx, wsIdx := v.wsIdx, wsName := v.wsName
    _KLRU_Touch(hwnd)
    return true
}


Komorebi_IsAvailable() {
    global KomorebicExe
    return (IsSet(KomorebicExe) && KomorebicExe != "" && FileExist(KomorebicExe))
}

; --- For startup sanity checks
Komorebi_DebugPing() {
    global KomorebicExe
    _KLog("DebugPing: starting…")
    _KLog("DebugPing: KomorebicExe='" . KomorebicExe . "'")
    _KLog("IsAvailable=" . (Komorebi_IsAvailable() ? "true" : "false"))

    if Komorebi_IsAvailable() {
        exeQ := _KQuote(KomorebicExe)
        verTxt := ""
        code := _KRunCaptureToText(exeQ . " --version", &verTxt)
        _KLog("DebugPing: '--version' exit=" . code)
        if (StrLen(Trim(verTxt)) > 0)
            _KLog("DebugPing: version='" . Trim(verTxt) . "'")
    }
}

; --- Get the raw JSON state from komorebi
_Komorebi_GetStateText() {
    global KomorebicExe, KState_Text, KState_Stamp, KState_TTL
    if !Komorebi_IsAvailable()
        return ""

    ; TTL reuse
    now := A_TickCount
    if (KState_Text != "" && (now - KState_Stamp) < KState_TTL)
        return KState_Text

    exeQ := _KQuote(KomorebicExe)
    txt := ""
    code := _KRunCaptureToText(exeQ . " state", &txt)
    _KLog("GetState: exit=" . code . " bytes=" . StrLen(txt))

    if (code = 0 && StrLen(txt))
        KState_Text := txt, KState_Stamp := now
    else
        KState_Text := "", KState_Stamp := 0

    return txt
}


; --- Find the workspace *name* that contains a specific hwnd by scanning the JSON text.
;     Strategy: find the first occurrence of "hwnd": <hwnd>, then walk backward to the
;     nearest preceding "name": "<...>" that also has "containers" before the hwnd.
_Komorebi_FindWorkspaceNameByHwnd(stateText, hwnd) {
    if (stateText = "" || !hwnd)
        return ""

    m := 0
    pos := RegExMatch(stateText, '"hwnd"\s*:\s*' . hwnd . '\b', &m, 1)
    if (pos = 0) {
        _KLog("FindWorkspace: hwnd not found in state")
        return ""
    }

    back := SubStr(stateText, 1, pos)
    names := []
    searchPos := 1
    mm := 0
    while (p := RegExMatch(back, '"name"\s*:\s*"([^"]+)"', &mm, searchPos)) {
        names.Push({ pos: p, name: mm[1], len: StrLen(mm[0]) })
        searchPos := p + StrLen(mm[0])
    }
    if (names.Length = 0) {
        _KLog("FindWorkspace: no name entries before hwnd")
        return ""
    }

    i := names.Length
    loop {
        if (i <= 0)
            break
        cand := names[i]
        block := SubStr(stateText, cand.pos, pos - cand.pos)
        if InStr(block, '"containers"') {
            ws := cand.name
            _KLog("FindWorkspace: hwnd=" . hwnd . " => workspace='" . ws . "'")
            return ws
        }
        i -= 1
    }

    _KLog("FindWorkspace: could not resolve workspace name for hwnd=" . hwnd)
    return ""
}

; --- DWMWA_CLOAKED check
_Komorebi_IsCloaked(hwnd) {
    buf := Buffer(4, 0)
    ; DWMWA_CLOAKED = 14
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hwnd, "uint", 14, "ptr", buf.Ptr, "uint", 4, "int")
    if (hr != 0)
        return false
    return (NumGet(buf, 0, "UInt") != 0)
}

_Komorebi_WaitUncloak(hwnd, waitMs := 300) {
    deadline := A_TickCount + Abs(waitMs)
    loop {
        if !_Komorebi_IsCloaked(hwnd)
            return true
        if (A_TickCount >= deadline)
            break
        Sleep 12
    }
    return !_Komorebi_IsCloaked(hwnd)
}

; === NEW ===
; Robustly find (monitorIndex, workspaceIndex) for the workspace containing the given hwnd.
; Also returns the workspace name (wsName). Returns true on success, false otherwise.
_Komorebi_FindMonitorWorkspaceIndexByHwnd(stateText, hwnd, &mIdx, &wsIdx, &wsName) {
    mIdx := -1, wsIdx := -1, wsName := ""
    if (stateText = "" || !hwnd)
        return false

    ; Absolute position of the target hwnd in the full JSON
    mh := 0
    hx := RegExMatch(stateText, '"hwnd"\s*:\s*' . hwnd . '\b', &mh, 1)
    if (hx = 0) {
        _KLog("IdxFinder: hwnd not found in state")
        return false
    }

    ; Find each monitor's *workspaces* object by anchoring on:
    ;   "workspaces": { ... } , "last_focused_workspace"
    ; The capture group 1 is the *content* of the workspaces object.
    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"last_focused_workspace"'
    posMon := 1
    mm := 0
    curMon := 0
    wsContent := "", wsContentAbsStart := 0
    foundMon := false

    while (p := RegExMatch(stateText, patMon, &mm, posMon)) {
        ; mm.Pos(0) .. mm.Pos(0)+mm.Len(0)-1 is the entire "workspaces":{...},"last_focused_workspace"
        blockStart := mm.Pos(0)
        blockEnd   := mm.Pos(0) + mm.Len(0) - 1

        if (blockStart <= hx && hx <= blockEnd) {
            wsContent := mm[1]
            wsContentAbsStart := mm.Pos(1)  ; absolute start of the captured content
            mIdx := curMon
            foundMon := true
            break
        }

        posMon := mm.Pos(0) + mm.Len(0)
        curMon += 1
    }

    if !foundMon {
        _KLog("IdxFinder: containing workspaces block not found around hwnd")
        return false
    }

    ; Inside the selected monitor's workspaces content, find the last "name" *before* hx
    ; That "name" corresponds to the workspace owning the hwnd.
    patName := 's)"name"\s*:\s*"([^"]+)"'
    posN := 1
    mn := 0
    idx := 0
    lastIdx := -1
    lastName := ""
    lastAbs := 0

    while (q := RegExMatch(wsContent, patName, &mn, posN)) {
        absPos := wsContentAbsStart + q - 1
        if (absPos < hx) {
            lastIdx := idx
            lastName := mn[1]
            lastAbs := absPos
        } else {
            break
        }
        posN := mn.Pos(0) + mn.Len(0)
        idx += 1
    }

    if (lastIdx < 0) {
        _KLog("IdxFinder: no workspace name found before hwnd inside selected monitor")
        return false
    }

    wsIdx  := lastIdx
    wsName := lastName
    _KLog("IdxFinder: resolved mIdx=" . mIdx . " wsIdx=" . wsIdx . " wsName='" . wsName . "'")
    return true
}


; Run komorebic with args, hidden; return exit code
Kom_RunWait(args) {
    global KomorebicExe
    return RunWait('"' KomorebicExe '" ' . args, , "Hide")
}


; --- Main entry used by helpers.ActivateHwnd for OtherWorkspace
;     1) Read state
;     2) Resolve monitor/workspace index that contains hwnd (and log name)
;     3) komorebic focus-monitor <mIdx>, then focus-workspace <wsIdx>
;     4) Wait for uncloaked; return true/false
Komorebi_FocusHwnd(hwnd) {
    global KomorebicExe
    if !Komorebi_IsAvailable() {
        _KLog("Komorebi_FocusHwnd: komorebic.exe not found or path not set")
        return false
    }

    cloakedStart := _Komorebi_IsCloaked(hwnd)
    _KLog("Komorebi_FocusHwnd: hwnd=" . hwnd . " cloakedStart=" . (cloakedStart ? "true" : "false"))

    ; ---------- FAST PATH: subscription map ----------
    wsFast := ""
    if Komorebi_SubTryMap(hwnd, &wsFast) && (wsFast != "") {
        _KLog("Komorebi_FocusHwnd: submap -> " . wsFast)
        if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsFast)) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 180) {
                _KLog("Komorebi_FocusHwnd: success (submap)")
                return true
            }
        }
        _KLog("Komorebi_FocusHwnd: submap focus attempt fell through")
    }

    ; ---------- FAST PATH 2: LRU (no state parse) ----------
    mIdx := -1, wsIdx := -1, wsNameLRU := ""
    if _KLRU_Get(hwnd, &mIdx, &wsIdx, &wsNameLRU) {
        if (mIdx >= 0 && wsIdx >= 0) {
            if (Kom_RunWait('focus-monitor ' . mIdx) = 0 && Kom_RunWait('focus-workspace ' . wsIdx) = 0) {
                Kom_RunWait('focus-window --hwnd ' . hwnd)
                if _Komorebi_WaitUncloak(hwnd, 180) {
                    _KLog("Komorebi_FocusHwnd: success (lru idx)")
                    return true
                }
            }
        }
        if (wsNameLRU != "") {
            if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsNameLRU)) = 0) {
                Kom_RunWait('focus-window --hwnd ' . hwnd)
                if _Komorebi_WaitUncloak(hwnd, 180) {
                    _KLog("Komorebi_FocusHwnd: success (lru name)")
                    return true
                }
            }
        }
        _KLog("Komorebi_FocusHwnd: LRU fell through")
    }

    ; ---------- Normal path: read (TTL-cached) state once ----------
    stateTxt := _Komorebi_GetStateText()
    if (stateTxt = "") {
        _KLog("Komorebi_FocusHwnd: state text empty, abort")
        return false
    }

    wsNameLog := _Komorebi_FindWorkspaceNameByHwnd(stateTxt, hwnd)
    if (wsNameLog != "")
        _KLog("Komorebi_FocusHwnd: workspace='" . wsNameLog . "'")

    mIdx := -1, wsIdx := -1, wsName := ""
    if _Komorebi_FindMonitorWorkspaceIndexByHwnd(stateTxt, hwnd, &mIdx, &wsIdx, &wsName) {
        if (Kom_RunWait('focus-monitor ' . mIdx) = 0 && Kom_RunWait('focus-workspace ' . wsIdx) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 220) {
                _KLog("Komorebi_FocusHwnd: success (index path)")
                _KLRU_Put(hwnd, mIdx, wsIdx, (wsName != "" ? wsName : wsNameLog))
                return true
            } else {
                _KLog("Komorebi_FocusHwnd: cloaked after index path")
            }
        } else {
            _KLog("Komorebi_FocusHwnd: focus-monitor/workspace failed (index path)")
        }
    } else {
        _KLog("Komorebi_FocusHwnd: failed to resolve indexes; trying name fallback")
    }

    ; ----- Fallback: by name ----------
    if (wsNameLog != "") {
        if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsNameLog)) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 220) {
                _KLog("Komorebi_FocusHwnd: success (fallback)")
                _KLRU_Put(hwnd, -1, -1, wsNameLog)
                return true
            }
        } else {
            _KLog("Komorebi_FocusHwnd: focus-named-workspace failed (fallback)")
        }
    }

    return false
}




--------------
Contents of komorebi_sub.ahk
--------------
﻿; ================== komorebi_sub.ahk ==================
; Fast komorebi subscription bridge using a Named Pipe (no PowerShell, no files).
; - AHK hosts \\.\pipe\<name> (overlapped, non-blocking)
; - Launches one hidden: komorebic.exe subscribe-pipe <name>
; - Timer peeks & reads only when bytes are available (never blocks UI)
; - Maintains fast cache: hwnd -> workspace_name, plus last "state" JSON
; - Auto-reconnect & backoff

#Requires AutoHotkey v2.0

; -------- CONFIG --------
global KomorebicExe            := IsSet(KomorebicExe) ? KomorebicExe : "C:\Program Files\komorebi\bin\komorebic.exe"
global KSub_PollMs             := 50           ; timer cadence (lower = snappier)
global KSub_MaxBytesPerTick    := 65536        ; cap bytes processed per tick
global KSub_IdleRecycleMs      := 120000       ; recycle if no events this long (ms)
global KSub_MaxRestartBackoff  := 5000         ; ms

; -------- STATE --------
global KSub_PipeName := "tabby_" A_TickCount "_" Random(1000,9999)
global KSub_hPipe    := 0
global KSub_hEvent   := 0
global KSub_Over     := 0                       ; OVERLAPPED struct buffer
global KSub_Connected := false

global KSub_ClientPid := 0                      ; komorebic subscribe-pipe pid
global KSub_LastEvent := 0
global KSub_BackoffMs := 0
global KSub_LastStart := 0

global KSub_Buf := ""                           ; partial line buffer
global KSub_Map := Map()                        ; hwnd -> workspace_name
global KSub_StateText := ""                     ; last "state" JSON

; -------- Logging (safe if _Log missing) --------
KSub_Log(msg) {
    if (IsSet(DebugKomorebi) && DebugKomorebi) {
        try {
            _Log("[komorebi] " . msg)
        } catch as e {
            ; ignore logging errors
        }
    }
}

; -------- Public API --------
Komorebi_SubEnsure() {
    if (KSub_hPipe && KSub_Connected)
        return true
    return Komorebi_SubStart()
}

Komorebi_SubStart() {
    global KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    global KSub_ClientPid, KSub_LastEvent, KSub_BackoffMs, KSub_LastStart, KSub_PipeName

    Komorebi_SubStop()  ; clean slate

    ; Validate komorebic path
    if !(IsSet(KomorebicExe) && KomorebicExe != "" && FileExist(KomorebicExe)) {
        KSub_Log("SubStart: komorebic.exe not found; will retry")
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Backoff if crash-looping
    now := A_TickCount
    if (KSub_LastStart && now - KSub_LastStart < 3000) {
        KSub_BackoffMs := Min(KSub_MaxRestartBackoff, Max(500, KSub_BackoffMs * 2))
        Sleep KSub_BackoffMs
    } else {
        KSub_BackoffMs := 0
    }
    KSub_LastStart := A_TickCount

    ; Create overlapped Named Pipe server (message mode)
    PIPE_ACCESS_INBOUND   := 0x00000001
    FILE_FLAG_OVERLAPPED  := 0x40000000
    PIPE_TYPE_MESSAGE     := 0x00000004
    PIPE_READMODE_MESSAGE := 0x00000002
    PIPE_WAIT             := 0x00000000

    name := "\\.\pipe\" . KSub_PipeName
    KSub_hPipe := DllCall("CreateNamedPipeW"
        , "str", name
        , "uint", PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED
        , "uint", PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT
        , "uint", 1                 ; max instances
        , "uint", 65536             ; out buffer (unused for inbound)
        , "uint", 65536             ; in buffer
        , "uint", 0                 ; default timeout
        , "ptr", 0                  ; security attrs
        , "ptr")
    if (KSub_hPipe = 0 || KSub_hPipe = -1) {
        KSub_Log("SubStart: CreateNamedPipe failed")
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Create event for OVERLAPPED connect
    KSub_hEvent := DllCall("CreateEventW", "ptr", 0, "int", 1, "int", 0, "ptr", 0, "ptr")
    if (!KSub_hEvent) {
        KSub_Log("SubStart: CreateEvent failed")
        Komorebi_SubStop()
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Allocate OVERLAPPED and set hEvent (x64 offset 24, x86 offset 16)
    KSub_Over := Buffer(A_PtrSize=8 ? 32 : 20, 0)
    NumPut("ptr", KSub_hEvent, KSub_Over, (A_PtrSize=8) ? 24 : 16)

    ; Begin async connect
    ok := DllCall("ConnectNamedPipe", "ptr", KSub_hPipe, "ptr", KSub_Over.Ptr, "int")
    if (!ok) {
        gle := DllCall("GetLastError", "uint")
        if (gle = 997) { ; ERROR_IO_PENDING
            KSub_Connected := false
        } else if (gle = 535) { ; ERROR_PIPE_CONNECTED
            KSub_Connected := true
        } else {
            KSub_Log("SubStart: ConnectNamedPipe err=" . gle)
            Komorebi_SubStop()
            SetTimer(Komorebi_SubPoll, KSub_PollMs)
            return false
        }
    } else {
        KSub_Connected := true
    }

    ; Launch hidden komorebic subscriber (client)
    try {
        KSub_ClientPid := Run('"' KomorebicExe '" subscribe-pipe ' KSub_PipeName, , "Hide")
        KSub_Log("SubStart: spawned client pid=" . KSub_ClientPid . " pipe=" . KSub_PipeName)
    } catch as e {
        KSub_Log("SubStart: failed to start subscribe-pipe: " . e.Message)
        ; keep server alive; we may connect later
    }

    KSub_LastEvent := A_TickCount
    SetTimer(Komorebi_SubPoll, KSub_PollMs)
    return true
}

Komorebi_SubStop() {
    global KSub_ClientPid, KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    SetTimer(Komorebi_SubPoll, 0)

    if (KSub_ClientPid) {
        try {
            ProcessClose(KSub_ClientPid)
        } catch as e {
            ; ignore
        }
        KSub_ClientPid := 0
    }

    if (KSub_hPipe) {
        try {
            DllCall("DisconnectNamedPipe", "ptr", KSub_hPipe)
        } catch as e {
        }
        try {
            DllCall("CloseHandle", "ptr", KSub_hPipe)
        } catch as e {
        }
        KSub_hPipe := 0
    }
    if (KSub_hEvent) {
        try {
            DllCall("CloseHandle", "ptr", KSub_hEvent)
        } catch as e {
        }
        KSub_hEvent := 0
    }
    KSub_Over := 0
    KSub_Connected := false
    KSub_Log("SubStop: done")
}

; ---- Fast map lookup used by your Komorebi_FocusHwnd fast path ----
Komorebi_SubTryMap(hwnd, &ws) {
    global KSub_Map, KSub_StateText
    if (KSub_Map.Has(hwnd)) {
        ws := KSub_Map[hwnd]
        return (ws != "")
    }
    if (KSub_StateText != "") {
        try {
            w := _Komorebi_FindWorkspaceNameByHwnd(KSub_StateText, hwnd)
            if (w != "") {
                KSub_Map[hwnd] := w
                ws := w
                return true
            }
        } catch as e {
            ; ignore
        }
    }
    ws := ""
    return false
}

; -------- Timer: connect progress, read available bytes (non-blocking) --------
Komorebi_SubPoll() {
    global KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    global KSub_ClientPid, KSub_LastEvent, KSub_IdleRecycleMs, KSub_MaxBytesPerTick

    if (!KSub_hPipe) {
        Komorebi_SubStart()
        return
    }

    ; If not connected yet, check the event
    if (!KSub_Connected) {
        res := DllCall("kernel32\WaitForSingleObject", "ptr", KSub_hEvent, "uint", 0, "uint")
        if (res = 0) { ; WAIT_OBJECT_0
            KSub_Connected := true
            KSub_Log("SubPoll: pipe connected")
        }
        return
    }

    ; Read loop (bounded by bytes per tick)
    bytesProcessed := 0
    loop {
        avail := 0, bytesLeft := 0
        ok := DllCall("PeekNamedPipe"
            , "ptr", KSub_hPipe
            , "ptr", 0, "uint", 0
            , "uint*", 0
            , "uint*", &avail
            , "uint*", &bytesLeft
            , "int")
        if (!ok) {
            gle := DllCall("GetLastError", "uint")
            if (gle = 109) { ; ERROR_BROKEN_PIPE
                KSub_Log("SubPoll: client disconnected (broken pipe) -> restarting")
                Komorebi_SubStart()
                return
            }
            return
        }

        if (avail = 0)
            break

        toRead := Min(avail, KSub_MaxBytesPerTick - bytesProcessed)
        if (toRead <= 0)
            break

        buf := Buffer(toRead)
        read := 0
        ok2 := DllCall("ReadFile"
            , "ptr", KSub_hPipe
            , "ptr", buf.Ptr
            , "uint", toRead
            , "uint*", &read
            , "ptr", 0
            , "int")
        if (!ok2) {
            gle := DllCall("GetLastError", "uint")
            if (gle = 109) {
                KSub_Log("SubPoll: client disconnected during read -> restarting")
                Komorebi_SubStart()
                return
            }
            return
        }

        if (read > 0) {
            chunk := StrGet(buf.Ptr, read, "UTF-8")
            KSub_LastEvent := A_TickCount
            KSub_ProcessChunk(chunk)
            bytesProcessed += read
            if (bytesProcessed >= KSub_MaxBytesPerTick)
                break
        } else {
            break
        }
    }

    ; Recycle if idle for a long time (handles komorebi restarts)
    idle := A_TickCount - KSub_LastEvent
    if (idle > KSub_IdleRecycleMs) {
        KSub_Log("SubPoll: idle " . idle . "ms -> recycling subscriber")
        Komorebi_SubStart()
    }
}

KSub_ProcessChunk(chunk) {
    global KSub_Buf
    KSub_Buf .= chunk
    while true {
        pos := InStr(KSub_Buf, "n")
        if (!pos)
            break
        line := RTrim(SubStr(KSub_Buf, 1, pos - 1), "r")
        KSub_Buf := SubStr(KSub_Buf, pos + 1)
        if (line != "")
            Komorebi_SubOnLine(line)
    }
}

; -------- Parse each JSON line --------
Komorebi_SubOnLine(line) {
    global KSub_Map, KSub_StateText

    hwnd := 0, ws := ""

    m := 0
    if RegExMatch(line, '"hwnd"\s*:\s*(\d+)', &m)
        hwnd := Integer(m[1])

    n := 0
    if RegExMatch(line, '"workspace_name"\s*:\s*"([^"]+)"', &n)
        ws := n[1]
    else if RegExMatch(line, '"workspace"\s*:\s*"([^"]+)"', &n)
        ws := n[1]
    else if InStr(line, '"workspace"') && RegExMatch(line, '"name"\s*:\s*"([^"]+)"', &n)
        ws := n[1]

    if (hwnd && ws != "") {
        KSub_Map[hwnd] := ws
        return
    }

    ; Full state update present on this line?
    if InStr(line, '"state"') {
        st := _KSub_ExtractStateJson(line)
        if (st != "" && st != "{}") {
            KSub_StateText := st
            if (hwnd) {
                try {
                    w := _Komorebi_FindWorkspaceNameByHwnd(st, hwnd) ; from your komorebi.ahk
                    if (w != "")
                        KSub_Map[hwnd] := w
                } catch as e {
                    ; ignore
                }
            }
        }
    }
}

; Extract the JSON object that follows the "state": key on this line
_KSub_ExtractStateJson(line) {
    posState := InStr(line, '"state"')
    if (!posState)
        return ""
    posColon := InStr(line, ":", false, posState)
    if (!posColon)
        return ""
    i := posColon + 1
    while (i <= StrLen(line) && SubStr(line, i, 1) ~= "\s")
        i += 1
    if (i > StrLen(line) || SubStr(line, i, 1) != "{")
        return ""
    depth := 0, start := i, j := i
    while (j <= StrLen(line)) {
        ch := SubStr(line, j, 1)
        if (ch = "{") {
            depth += 1
        } else if (ch = "}") {
            depth -= 1
            if (depth = 0)
                return SubStr(line, start, j - start + 1)
        } else if (ch = '"') {
            j += 1
            while (j <= StrLen(line)) {
                c := SubStr(line, j, 1)
                if (c = '"' && SubStr(line, j-1, 1) != "\")
                    break
                j += 1
            }
        }
        j += 1
    }
    return ""
}
--------------
Contents of mru.ahk
--------------
﻿; mru.ahk — track Most-Recently-Used activation order via Shell hook
; Public:
;   MRU_Init()
;   MRU_GetList() -> array of hwnds (most-recent-first)

global _MRU_list := []       ; [hwnd, hwnd, ...] most-recent-first
global _MRU_msg := 0
global _MRU_win := 0

MRU_Init() {
  global _MRU_msg, _MRU_win
  if (_MRU_msg)  ; already initialized
    return

  _MRU_win := Gui("-Caption +ToolWindow")  ; no +Hwnd option in v2
  _MRU_win.Hide()

  ; register hidden GUI as a shell hook window
  DllCall("RegisterShellHookWindow", "ptr", _MRU_win.Hwnd)

  ; get the message id for shell notifications and route it
  _MRU_msg := DllCall("RegisterWindowMessage", "str", "SHELLHOOK", "uint")
  OnMessage(_MRU_msg, MRU_OnShell)
}


MRU_OnShell(wParam, lParam, msg, hwnd) {
  static HSHELL_WINDOWCREATED := 1
  static HSHELL_WINDOWDESTROYED := 2
  static HSHELL_WINDOWACTIVATED := 4
  static HSHELL_RUDEAPPACTIVATED := 0x8004

  if (wParam = HSHELL_WINDOWDESTROYED) {
    MRU_Remove(lParam)
    return
  }

  if (wParam != HSHELL_WINDOWACTIVATED && wParam != HSHELL_RUDEAPPACTIVATED)
    return

  hwndAct := lParam
  if (hwndAct = 0)
    return

  cls := _MRU_GetClass(hwndAct)
  if (cls = "AutoHotkeyGUI")
    return

  MRU_MoveToFront(hwndAct)
}

MRU_Remove(hwnd) {
  global _MRU_list
  for i, h in _MRU_list
    if (h = hwnd) {
      _MRU_list.RemoveAt(i)
      break
    }
}


MRU_MoveToFront(hwnd) {
  global _MRU_list
  ; Remove any prior occurrence
  for i, h in _MRU_list
    if (h = hwnd) {
      _MRU_list.RemoveAt(i)
      break
    }
  _MRU_list.InsertAt(1, hwnd)
}

MRU_GetList() {
  global _MRU_list
  return _MRU_list.Clone()   ; shallow copy
}

_MRU_GetClass(hWnd) {
  buf := Buffer(256*2, 0)
  DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
  return StrGet(buf.Ptr, "UTF-16")
}
--------------
Contents of newgui.ahk
--------------
﻿#Requires AutoHotkey v2.0
; -----------------------------------------------------------------------------
; overlay_list_on_acrylic_poc_scroll_icons.ahk
; - Base: borderless acrylic (no flash)
; - Overlay: layered window same size/pos (catches all clicks), renders a simple
;            “virtual list” with columns + real icon + selection + scroll wheel.
;   Hotkeys:
;   Up/Down, Tab/Shift+Tab : change selection (keeps selection in view)
;   Mouse wheel            : scroll by rows
;   Z / X                  : hide / show overlay (POC toggle)
;   Q                      : cycle footer text (POC)
;   C / K / B              : close / kill (confirm) / blacklist (confirm)
;   Esc                    : exit
; -----------------------------------------------------------------------------

; Reveal both base + overlay together right after first painted frame
global gRevealed := false

global gHoverRow := 0        ; 1-based item index that the mouse is over; 0 = none
global gHoverBtn := ""       ; "", "close", "kill", "blacklist"

; persistent Graphics bound to the backbuffer HDC
global gG := 0

; Footer state (POC text cycle with Q)
global gFooterModes := ["All Windows", "XXX Windows", "XXX Visible Windows"]
global gFooterModeIndex := 1
global gFooterText := gFooterModes[gFooterModeIndex]


; ===== Overlay wiring compatibility (from oldgui) =====
global gGui := 0                  ; your overlay’s top-level GUI/window handle holder
global gOverlayOn := false
global gListSnap := []            ; last list handed to overlay
global gSelSnap := 1              ; last 1-based selection index

; ----- icon cache/pump (GUI-independent) -----
global gIconCache := Map()        ; hwnd -> { hicon: Ptr | 0, pid: UInt, class: Str }
global gIconQueue := []           ; hwnds pending resolution
global gIconPumpOn := false

; Use your existing config entries:
; OverlayTitle := "Switch"
; GUI_StateShort := true
; GUI_HWND_Hex := true
; UseIcons, IconBatchPerTick, IconTimerIntervalMs


; ========================= DEBUG =========================
global DebugGUI := false
global DebugLogPath := A_ScriptDir "\tabby_debug.log"

_DBG(msg) {
    if !DebugGUI {
        return
    }
    path := (DebugLogPath && DebugLogPath != "") ? DebugLogPath : (A_ScriptDir "\tabby_debug.log")
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss")
    SplitPath(path, , &dir)
    try DirCreate(dir)
    FileAppend(ts " | " msg "rn", path, "UTF-8")
}

_DWM_SetAttrInt(hWnd, attrId, value) {
    buf := Buffer(4, 0)
    NumPut("Int", value, buf, 0)
    hr := DllCall("dwmapi\DwmSetWindowAttribute"
        , "ptr", hWnd
        , "int", attrId
        , "ptr", buf.Ptr
        , "int", 4
        , "int")
    _DBG(Format("DWM attr{} val={} hr={}", attrId, value, hr))
    return hr
}

_ConfirmTopmost(text, title := "Confirm") {
    global gOverlayH  ; or gBaseH – either is fine; the owner just needs to be your UI
    res := MsgBox(text, title, "YesNo Icon! Default2 0x1000")
    return (res = "Yes" || res = 6) ; string ("Yes") or numeric (6) for compatibility
}

_FooterBlockDip() {
    global ShowFooter, FooterHeightPx, FooterGapTopPx
    return ShowFooter ? (FooterGapTopPx + FooterHeightPx) : 0
}


_DebugDump(hGui) {
    try _DBG("OS: " A_OSVersion)
    try {
        enabled := 0
        hr := DllCall("dwmapi\DwmIsCompositionEnabled", "int*", &enabled, "int")
        _DBG(Format("DwmIsCompositionEnabled={} hr={}", enabled, hr))
    }
    try {
        trans := RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", "EnableTransparency")
        if (trans = "") {
            trans := "N/A"
        }
        _DBG("EnableTransparency=" trans)
    }
    try {
        GWL_STYLE := -16, GWL_EXSTYLE := -20
        ex := DllCall("user32\GetWindowLongPtrW", "ptr", hGui, "int", GWL_EXSTYLE, "ptr")
        st := DllCall("user32\GetWindowLongPtrW", "ptr", hGui, "int", GWL_STYLE,   "ptr")
        _DBG(Format("GUI style=0x{:X} exstyle=0x{:X}", st, ex))
    }
}

; ========================= NEWGUI PUBLIC SHIMS (ADD) =========================
global __HooksInstalled := false
global __InitOnce := false

NewGUI__EnsureCreated() {
    global __InitOnce, __HooksInstalled
    global gBase, gBaseH, gOverlay, gOverlayH, gGui
    global OverlayTitle, AlwaysOnTop
    global AcrylicAlpha, AcrylicBaseRgb, CornerRadiusPx
    global gListSnap

    if (__InitOnce && gBaseH && gOverlayH)
        return

    ; --- init DPI & GDI+ once ---
    _InitDpiAwareness()
    __Gdip_Startup()

    ; --- compute initial size from current list (or minimum) ---
    rowsDesired := _ComputeRowsToShow(IsObject(gListSnap) ? gListSnap.Length : RowsVisibleMin)
    winX := 0, winY := 0, winW := 0, winH := 0
    _GetWindowRectFromConfig(&winX, &winY, &winW, &winH, rowsDesired)

    ; --- create base (titled) window; this will be our public "GUI" handle ---
    opts := "-Caption"
    if (IsSet(AlwaysOnTop) && AlwaysOnTop)
        opts := "+AlwaysOnTop " . opts
    gBase := Gui(opts, OverlayTitle)
    _StageAndRevealAcrylic(gBase, winX, winY, winW, winH, AcrylicAlpha, AcrylicBaseRgb, CornerRadiusPx, false)
    gBaseH := gBase.Hwnd

    ; Expose the same top-level handle symbol the old code used.
    gGui := gBaseH

    ; --- layered overlay for the painted list ---
    gOverlay  := _Overlay_Create(gBaseH)
    gOverlayH := gOverlay.Hwnd

    ; --- minimal hooks (mouse + wheel + DPI) once ---
    if !__HooksInstalled {
        OnMessage(0x02E0, _OnDpiChanged) ; WM_DPICHANGED
        OnMessage(0x0200, (wParam, lParam, msg, hwnd) => (
            hwnd = gOverlayH ? ( _OnOverlayMouseMove(wParam, lParam, msg, hwnd), 0 ) : 0
        )) ; WM_MOUSEMOVE
        OnMessage(0x0201, (wParam, lParam, msg, hwnd) => (
            hwnd = gOverlayH ? ( _OnOverlayClick(lParam & 0xFFFF, (lParam >> 16) & 0xFFFF), 0 ) : 0
        )) ; WM_LBUTTONDOWN
        OnMessage(0x020A, (wParam, lParam, msg, hwnd) => (
            hwnd = gOverlayH ? ( _OnOverlayWheel(wParam, lParam), 0 ) : 0
        )) ; WM_MOUSEWHEEL
        __HooksInstalled := true
    }

    __InitOnce := true
}

NewGUI__RebuildFromList(list, selIndex) {
    global gItems, gSel, gScrollTop, gOverlayH
    global ScrollKeepHighlightOnTop

    ; Build full row models the painter expects
    gItems := []
    total := list.Length
    if (total) {
        i := 1
        while (i <= total) {
            gItems.Push( NewGUI__BuildRowModel(list[i], i, total) )
            i += 1
        }
    }

    ; Clamp/wrap selection
    if (total = 0) {
        gSel := 1
        gScrollTop := 0
    } else {
        if (selIndex < 1) selIndex := 1
        if (selIndex > total) selIndex := total
        gSel := selIndex
        if (IsSet(ScrollKeepHighlightOnTop) && ScrollKeepHighlightOnTop)
            gScrollTop := gSel - 1
        else
            _EnsureVisible(total)
    }

    ; Resize to fit rows and repaint
    rowsDesired := _ComputeRowsToShow(total)
    _ResizeWindowToRows(rowsDesired)
    _Overlay_Repaint(gOverlayH, gItems, gSel)
}

NewGUI__UpdateSelection(list, selIndex) {
    ; Rebuild (safe & simple; keeps columns/state fresh as windows change)
    NewGUI__RebuildFromList(list, selIndex)
}

NewGUI__QueueIconsForVisibleRows(list, selIndex) {
    global gIconQueue, gOverlayH, gScrollTop

    count := list.Length
    if (count <= 0)
        return

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0)
        vis := Min(RowsVisibleMax, count)

    ; Ensure viewport top is aligned to selection when requested
    start0 := __Wrap0(gScrollTop, count)
    i := 0
    while (i < vis) {
        idx0 := __Wrap0(start0 + i, count)
        idx1 := idx0 + 1
        it := list[idx1]
        if (_Icon_GetCached(it.Hwnd) = 0 && WinExist("ahk_id " it.Hwnd)) {
            gIconQueue.Push(it.Hwnd)
        }
        i += 1
    }
}

NewGUI__InvalidateVisibleRows(list, selIndex) {
    global gOverlayH, gItems, gSel
    _Overlay_Repaint(gOverlayH, gItems, gSel)
}

NewGUI__Show() {
    _RevealBaseAndOverlayTogether()
}

NewGUI__Hide() {
    global gBase, gOverlay
    try gOverlay.Hide()
    try gBase.Hide()
}


; ======= OLD to NEW API SHIM ========
Overlay_ShowList(list, selIndex) {
    global gGui, gOverlayOn, gListSnap, gSelSnap, UseIcons, OverlayTitle, AlwaysOnTop

    gListSnap := list
    gSelSnap  := selIndex

    ; 1) Ensure overlay exists (create if absent) and set title to "Switch"
    NewGUI__EnsureCreated()                  ; <-- implement if you don’t have it
    try WinSetTitle(OverlayTitle, "ahk_id " gGui)  ; keep stable title for blacklist
    if (IsSet(AlwaysOnTop) && AlwaysOnTop)
        try WinSetAlwaysOnTop(1, "ahk_id " gGui)

    ; 2) Rebuild initial view from list + selection
    NewGUI__RebuildFromList(gListSnap, gSelSnap)   ; <-- call your draw/measure code

    ; 3) Kick icon pump if enabled
    if (IsSet(UseIcons) && UseIcons) {
        NewGUI__QueueIconsForVisibleRows(gListSnap, gSelSnap) ; enqueue by hwnd
        _Icon_StartPump()
    }

    ; 4) Show
    NewGUI__Show()                          ; <-- your show (non-activating) call
    gOverlayOn := true
}

Overlay_UpdateSelection(list, selIndex) {
    global gListSnap, gSelSnap, UseIcons
    gListSnap := list
    gSelSnap  := selIndex

    NewGUI__UpdateSelection(gListSnap, gSelSnap)    ; redraw rows only

    if (IsSet(UseIcons) && UseIcons)
        NewGUI__QueueIconsForVisibleRows(gListSnap, gSelSnap)
}

Overlay_Hide() {
    global gGui, gOverlayOn
    gOverlayOn := false
    NewGUI__Hide()                                   ; your hide/destroy path
    ; Optional: _Icon_ClearCache() if you want to free HICONs aggressively
}

; Returns a plain object with what your painter needs for a row
; Returns a plain object the painter uses for a row (ADD/REPLACE)
NewGUI__BuildRowModel(item, idx, total) {
    ; Main + sub
    main := item.Title
    if (StrLen(main) > 140)
        main := SubStr(main, 1, 137) . "..."
    sub  := _StateShort(item.State)

    ; Column text
    hwndStr := (IsSet(GUI_HWND_Hex) && GUI_HWND_Hex)
        ? ("0x" . Format("{:X}", item.Hwnd))
        : (item.Hwnd . "")
    ws := _GetWorkspaceForHwnd(item.Hwnd)

    ; Icon handle if cached (0 until pump resolves)
    hico := _Icon_GetCached(item.Hwnd)

    ; Include both display columns and raw fields so existing code (close/kill placeholders)
    ; can use HWND/PID/Class safely later.
    return {
        Number: "[" idx "/" total "]",
        Title:  main,
        Sub:    sub,
        Col2:   hwndStr,       ; HWND (formatted)
        Col3:   item.Pid,      ; PID
        Col4:   ws,            ; Workspace name
        Col5:   item.ZOrder,   ; Win#
        Col6:   item.Class,    ; Class
        HICON:  hico,

        ; raw passthroughs for actions / future wiring
        HWND:   item.Hwnd,
        PID:    item.Pid,
        Class:  item.Class,
        State:  item.State,
        ZOrder: item.ZOrder
    }
}


;========= ICONS =============
_Icon_GetCached(hwnd) {
    global gIconCache
    return (gIconCache.Has(hwnd) && gIconCache[hwnd].hicon) ? gIconCache[hwnd].hicon : 0
}

_Icon_StartPump() {
    global gIconPumpOn, IconTimerIntervalMs
    if (gIconPumpOn)
        return
    gIconPumpOn := true
    SetTimer(_Icon_Pump, IconTimerIntervalMs)
}

_Icon_Pump() {
    global gIconPumpOn, gIconQueue, IconBatchPerTick, gIconCache, gOverlayOn, gListSnap, gSelSnap

    if (!gOverlayOn) {
        gIconQueue := []
        gIconPumpOn := false
        SetTimer(_Icon_Pump, 0)
        return
    }

    ; resolve a few per tick
    count := 0
    changed := false
    while (gIconQueue.Length && count < IconBatchPerTick) {
        hwnd := gIconQueue.RemoveAt(1)
        if (gIconCache.Has(hwnd)) {
            count += 1
            continue
        }

        pid := 0, cls := ""
        for _, it in gListSnap {           ; fast linear scan OK for small page
            if (it.Hwnd = hwnd) {
                pid := it.Pid
                cls := it.Class
                break
            }
        }

        hico := _Icon_ResolveSmall(hwnd)
        if (!hico) {
            ; attempt from process exe if window didn’t return one
            if (pid) {
                exe := _Icon_GetProcessPath(pid)
                if (exe) {
                    hSmall := 0, hLarge := 0
                    DllCall("Shell32\ExtractIconExW","wstr",exe,"int",0,"ptr*", &hLarge,"ptr*", &hSmall,"uint",1)
                    if (hSmall) {
                        if (hLarge) DllCall("user32\DestroyIcon","ptr",hLarge)
                        hico := hSmall
                    } else if (hLarge) {
                        hico := hLarge
                    }
                }
            }
        }

        gIconCache[hwnd] := { hicon: (hico ? hico : 0), pid: pid, class: cls }
        changed := changed || (hico != 0)
        count += 1
    }

    if (!gIconQueue.Length) {
        gIconPumpOn := false
        SetTimer(_Icon_Pump, 0)
    }

    if (changed) {
        ; Ask your view to redraw only visible rows
        NewGUI__InvalidateVisibleRows(gListSnap, gSelSnap)
    }
}

_Icon_ResolveSmall(hWnd) {
    if !WinExist("ahk_id " . hWnd)
        return 0
    WM_GETICON := 0x7F
    ICON_SMALL2 := 2, ICON_SMALL := 0, ICON_BIG := 1
    try {
        h := SendMessage(WM_GETICON, ICON_SMALL2, 0, , "ahk_id " . hWnd)
        if (!h) h := SendMessage(WM_GETICON, ICON_SMALL, 0, , "ahk_id " . hWnd)
        if (!h) h := SendMessage(WM_GETICON, ICON_BIG,   0, , "ahk_id " . hWnd)
        if (h) {
            return h
        }
    }
    h := DllCall("user32\GetClassLongPtrW","ptr",hWnd,"int",-34,"ptr") ; GCLP_HICONSM
    if (!h) h := DllCall("user32\GetClassLongPtrW","ptr",hWnd,"int",-14,"ptr") ; GCLP_HICON
    return h ? h : 0
}

_Icon_GetProcessPath(pid) {
    PROCESS_QUERY_LIMITED_INFORMATION := 0x1000
    hProc := DllCall("kernel32\OpenProcess","uint",PROCESS_QUERY_LIMITED_INFORMATION,"int",0,"uint",pid,"ptr")
    if (!hProc) {
        return ""
    }
    buf := Buffer(32767 * 2, 0), sz := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW","ptr",hProc,"uint",0,"ptr",buf.Ptr,"uint*",sz,"int")
    DllCall("kernel32\CloseHandle","ptr",hProc)
    return ok ? StrGet(buf.Ptr, "UTF-16") : ""
}

_Icon_ClearCache() {
    global gIconCache
    for hwnd, meta in gIconCache {
        if (meta.hicon)
            DllCall("user32\DestroyIcon","ptr",meta.hicon)
    }
    gIconCache := Map()
}



; ========================= WINDOW HELPERS =========================
_TryEnableDarkTitleBar(hWnd) {
    try _DWM_SetAttrInt(hWnd, 20, 1)  ; DWMWA_USE_IMMERSIVE_DARK_MODE (new)
    try _DWM_SetAttrInt(hWnd, 19, 1)  ; DWMWA_USE_IMMERSIVE_DARK_MODE (old)
}

_SetCornerPreference(hWnd, pref := 2) {
    ; 1=DoNotRound, 2=Round, 3=Small
    try _DWM_SetAttrInt(hWnd, 33, pref)  ; DWMWA_WINDOW_CORNER_PREFERENCE
}


_LoadTestIcon() {
    global gIconImg
    ; Try explorer.exe (most reliable), fall back to shell32.dll
    gIconImg := __LoadGpIconFromFile(A_WinDir "\explorer.exe", 0)
    if (!gIconImg) {
        gIconImg := __LoadGpIconFromFile(A_WinDir "\System32\shell32.dll", 4)
    }
}

_StateShort(s) {
    if !(IsSet(GUI_StateShort) && GUI_StateShort)
        return s
    sw := StrLower(Trim(s))
    if (sw = "workspaceshowing")      {
        return "WS-Shown"
        }
    else if (sw = "workspaceminimized") {
        return "WS-Min"
    }
    else if (sw = "workspacehidden")   {

     return "WS-Hidden"
    }
    else if (sw = "otherworkspace")    {
     return "Other-WS"
    }
    return s
}

_GetWorkspaceForHwnd(hwnd) {
    ws := ""
    try {
        if Komorebi_SubTryMap(hwnd, &ws) && (ws != "")
            return ws
    } catch {
    }
    return ""
}

_WrapIndex(idx, len) {
    if (len <= 0) {
        return 1
    }
    n := Mod(idx - 1, len)
    if (n < 0) n += len
    return n + 1
}


_GetIconLeftMarginDip(scale) {
    global IconLeftMargin
    try {
        return Round(IconLeftMargin * scale)
    } catch {
        return 0
    }
}

; Keep hover state (row + which button) aligned with the current cursor
; even if rows move due to scroll/selection changes.
_RecalcHoverFromCurrentCursor() {
    global gOverlayH, gHoverRow, gHoverBtn
    if (!gOverlayH) {
        return false
    }
    ; Get cursor in screen coords
    pt := Buffer(8, 0)
    if !DllCall("user32\GetCursorPos", "ptr", pt) {
        return false
    }
    ; Convert to overlay client coords (physical px)
    if !DllCall("user32\ScreenToClient", "ptr", gOverlayH, "ptr", pt.Ptr) {
        return false
    }
    x := NumGet(pt, 0, "Int")
    y := NumGet(pt, 4, "Int")

    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)

    changed := (idx != gHoverRow || act != gHoverBtn)
    gHoverRow := idx
    gHoverBtn := act
    return changed
}


_HeaderBlockDip() {
    ; 32 == 4px top pad + 28px header line height
    global ShowHeader
    return ShowHeader ? 32 : 0
}

__FontStyleFromWeight(w) {
    ; GDI+ style: 0=Regular, 1=Bold
    try {
        return (w+0 >= 600) ? 1 : 0
    } catch {
        return 0
    }
}

_EnsureGraphics() {
    global gBackHdc, gG
    ; If there's no backbuffer DC, we can't make a Graphics
    if (!gBackHdc) {
        return 0
    }
    ; Always rebuild the GDI+ Graphics from the CURRENT backbuffer HDC.
    ; This avoids intermittently using a Graphics tied to an old/invalid surface.
    if (gG) {
        try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
        gG := 0
    }
    DllCall("gdiplus\GdipCreateFromHDC", "ptr", gBackHdc, "ptr*", &gG)
    if (!gG) {
        return 0
    }
    SmoothingModeAntiAlias := 4
    TextRenderingHintClearTypeGridFit := 5
    DllCall("gdiplus\GdipSetSmoothingMode", "ptr", gG, "int", SmoothingModeAntiAlias)
    DllCall("gdiplus\GdipSetTextRenderingHint", "ptr", gG, "int", TextRenderingHintClearTypeGridFit)
    return gG
}

__Wrap0(i, count) {
    ; returns 0..count-1 (handles negative i)
    if (count <= 0) {
        return 0
    }
    r := Mod(i, count)
    if (r < 0) {
        r := r + count
    }
    return r
}

__Wrap1(i, count) {
    ; returns 1..count (handles negative i)
    if (count <= 0) {
        return 0
    }
    r := Mod(i - 1, count)
    if (r < 0) {
        r := r + count
    }
    return r + 1
}


__GetWorkAreaFromHwndPhys(hWnd, &left, &top, &right, &bottom) {
    MONITOR_DEFAULTTONEAREST := 2
    hMon := DllCall("user32\MonitorFromWindow", "ptr", hWnd, "uint", MONITOR_DEFAULTTONEAREST, "ptr")
    if (!hMon) {
        left := top := right := bottom := 0
        return
    }
    ; MONITORINFO is 40 bytes: cbSize(4) + rcMonitor(16) + rcWork(16) + dwFlags(4)
    mi := Buffer(40, 0)
    NumPut("UInt", 40, mi, 0) ; cbSize
    if !DllCall("user32\GetMonitorInfoW", "ptr", hMon, "ptr", mi.Ptr, "int") {
        left := top := right := bottom := 0
        return
    }
    ; rcWork at offset 20
    left   := NumGet(mi, 20, "Int")
    top    := NumGet(mi, 24, "Int")
    right  := NumGet(mi, 28, "Int")
    bottom := NumGet(mi, 32, "Int")
}

_RandomSpacedText(minTotal := 5, maxTotal := 20, minRun := 4, maxRun := 8) {
    total := Round(Random(minTotal, maxTotal))
    out := ""
    run := 0
    nextBreak := Round(Random(minRun, maxRun))

    while (StrLen(out) < total) {
        if (run >= nextBreak) {
            if (StrLen(out) + 1 > total) {
                break
            }
            out .= " "
            run := 0
            nextBreak := Round(Random(minRun, maxRun))
        } else {
            ; a–z
            ch := Chr(Round(Random(97, 122)))
            out .= ch
            run += 1
        }
    }
    if (StrLen(out) > total) {
        out := SubStr(out, 1, total)
    }
    return RTrim(out)
}

__SetWindowPosPhys(hWnd, xPhys, yPhys, wPhys, hPhys) {
    SWP_NOZORDER      := 0x0004
    SWP_NOOWNERZORDER := 0x0200
    SWP_NOACTIVATE    := 0x0010
    flags := SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOACTIVATE
    return DllCall("user32\SetWindowPos"
        , "ptr", hWnd
        , "ptr", 0
        , "int", xPhys
        , "int", yPhys
        , "int", wPhys
        , "int", hPhys
        , "uint", flags
        , "int")
}

; Per-monitor scale from a RECT (all params are PHYSICAL px)
__GetMonitorScaleFromRect(left, top, right, bottom) {
    ; Build RECT
    rc := Buffer(16, 0)
    NumPut("Int", left,   rc, 0)
    NumPut("Int", top,    rc, 4)
    NumPut("Int", right,  rc, 8)
    NumPut("Int", bottom, rc, 12)

    ; Get HMONITOR for this rect
    MONITOR_DEFAULTTONEAREST := 2
    hMon := DllCall("user32\MonitorFromRect", "ptr", rc.Ptr, "uint", MONITOR_DEFAULTTONEAREST, "ptr")

    ; shcore!GetDpiForMonitor → effective DPI for that monitor
    dpiX := 0, dpiY := 0
    success := false
    try {
        hr := DllCall("shcore\GetDpiForMonitor", "ptr", hMon, "int", 0, "uint*", &dpiX, "uint*", &dpiY, "int") ; MDT_EFFECTIVE_DPI=0
        if (hr = 0 && dpiX > 0) {
            success := true
        }
    }
    if (success) {
        return dpiX / 96.0
    }
    ; Fallback: system DPI
    return __GetSystemScale()
}

; System DPI → scale (physical / 96)
__GetSystemScale() {
    dpi := 0
    try {
        dpi := DllCall("user32\GetDpiForSystem", "uint")
    }
    if (!dpi) {
        dpi := A_ScreenDPI
    }
    return dpi / 96.0
}

; GetWindowRect in PHYSICAL pixels (no DPI math needed here)
__GetWindowRectPhys(hWnd, &x, &y, &w, &h) {
    rc := Buffer(16, 0) ; RECT {left,top,right,bottom}
    ok := DllCall("user32\GetWindowRect", "ptr", hWnd, "ptr", rc.Ptr, "int")
    if (!ok) {
        x := y := w := h := 0
        return
    }
    left   := NumGet(rc, 0, "Int")
    top    := NumGet(rc, 4, "Int")
    right  := NumGet(rc, 8, "Int")
    bottom := NumGet(rc, 12, "Int")
    x := left
    y := top
    w := right - left
    h := bottom - top
}


_ComputeRowsToShow(count) {
    global RowsVisibleMin, RowsVisibleMax
    if (RowsVisibleMax < RowsVisibleMin) {
        ; guard: swap if user misconfigures
        tmp := RowsVisibleMin
        RowsVisibleMin := RowsVisibleMax
        RowsVisibleMax := tmp
    }
    if (count >= RowsVisibleMax)
        return RowsVisibleMax
    if (count > RowsVisibleMin)
        return count
    return RowsVisibleMin
}

_ResizeWindowToRows(rowsToShow) {
    global gBase, gBaseH, gOverlay, gOverlayH, CornerRadiusPx

    ; Compute centered x/y/w/h (DIPs) on the SAME monitor as the base window
    xDip := 0, yDip := 0, wDip := 0, hDip := 0
    _GetWindowRectForWindowMonitor(&xDip, &yDip, &wDip, &hDip, rowsToShow, gBaseH)

    ; Convert those DIPs to PHYSICAL px for exact positioning without DPI drift
    ; Use the work area of the base window's monitor to get its scale
    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(gBaseH, &waL, &waT, &waR, &waB)
    monScale := __GetMonitorScaleFromRect(waL, waT, waR, waB)

    xPhys := Round(xDip * monScale)
    yPhys := Round(yDip * monScale)
    wPhys := Round(wDip * monScale)
    hPhys := Round(hDip * monScale)

    ; Physically move/resize both windows in lockstep (no Show() coords → no DPI hops)
    __SetWindowPosPhys(gBaseH,   xPhys, yPhys, wPhys, hPhys)
    __SetWindowPosPhys(gOverlayH, xPhys, yPhys, wPhys, hPhys)

    ; Re-apply rounded region using DIP sizes so the region matches the visual
    _ApplyRoundRegion(gBaseH, CornerRadiusPx, wDip, hDip)

    ; Make sure composition commits before the next layered blit
    try DllCall("dwmapi\DwmFlush")
}

__GetScaleForWindow(hWnd) {
    dpi := 0
    try {
        dpi := DllCall("user32\GetDpiForWindow", "ptr", hWnd, "uint")
    }
    if (!dpi) {
        dpi := A_ScreenDPI ; fallback
    }
    return dpi / 96.0
}

_InitDpiAwareness() {
    ; Prefer Per-Monitor V2; fall back gracefully if unavailable.
    try {
        ; DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 = -4
        DllCall("user32\SetProcessDpiAwarenessContext", "ptr", -4, "ptr")
    } catch {
        try {
            ; PROCESS_PER_MONITOR_DPI_AWARE = 2
            DllCall("shcore\SetProcessDpiAwareness", "int", 2, "int")
        } catch {
            ; Last resort: system-DPI aware
            try DllCall("user32\SetProcessDPIAware")
        }
    }
}

_GetWindowRectFromConfig(&x, &y, &w, &h, rowsToShow := "") {
    global ScreenWidthPct, RowHeight, MarginY

    if (rowsToShow == "" || rowsToShow < 1) {
        global RowsVisibleMin
        rowsToShow := RowsVisibleMin
    }

    left := 0, top := 0, right := 0, bottom := 0
    MonitorGetWorkArea(0, &left, &top, &right, &bottom)
    waW_phys := right - left
    waH_phys := bottom - top

    monScale := __GetMonitorScaleFromRect(left, top, right, bottom)

    pct := ScreenWidthPct
    if (pct <= 0)
        pct := 0.10
    if (pct > 1.0)
        pct := pct / 100.0

    waW_dip := waW_phys / monScale
    waH_dip := waH_phys / monScale
    left_dip := left / monScale
    top_dip  := top  / monScale

    w := Round(waW_dip * pct)

    headerBlock := _HeaderBlockDip()
    footerBlock := _FooterBlockDip()
    h := MarginY + headerBlock + rowsToShow * RowHeight + footerBlock + MarginY

    x := Round(left_dip + (waW_dip - w) / 2)
    y := Round(top_dip  + (waH_dip - h) / 2)
}

_ApplyRoundRegion(hWnd, radiusPx, optW := 0, optH := 0) {
    if (!hWnd || radiusPx <= 0) {
        return
    }

    local wx := 0, wy := 0, ww := 0, wh := 0
    local cx := 0, cy := 0, cw := 0, ch := 0
    local hrgn := 0

    if (optW > 0 && optH > 0) {
        ww := optW
        wh := optH
    } else {
        try {
            WinGetClientPos(&cx, &cy, &cw, &ch, "ahk_id " hWnd)
            if (cw > 0 && ch > 0) {
                ww := cw
                wh := ch
            }
        }
        if (ww <= 0 || wh <= 0) {
            try WinGetPos(&wx, &wy, &ww, &wh, "ahk_id " hWnd)
        }
    }

    if (ww <= 0 || wh <= 0) {
        return
    }

    hrgn := DllCall("gdi32\CreateRoundRectRgn"
        , "int", 0, "int", 0
        , "int", ww + 1, "int", wh + 1
        , "int", radiusPx * 2, "int", radiusPx * 2
        , "ptr")
    if (hrgn) {
        DllCall("user32\SetWindowRgn", "ptr", hWnd, "ptr", hrgn, "int", 1)
    }
}

_ForceNoLayered(hWnd) {
    GWL_EXSTYLE   := -20
    WS_EX_LAYERED := 0x00080000
    try {
        ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", GWL_EXSTYLE, "ptr")
        if (ex & WS_EX_LAYERED) {
            ex := ex & ~WS_EX_LAYERED
            DllCall("user32\SetWindowLongPtrW", "ptr", hWnd, "int", GWL_EXSTYLE, "ptr", ex, "ptr")
            SWP_NOSIZE := 0x0001, SWP_NOMOVE := 0x0002, SWP_NOZORDER := 0x0004, SWP_FRAMECHANGED := 0x0020
            flags := SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED
            DllCall("user32\SetWindowPos", "ptr", hWnd, "ptr", 0, "int", 0, "int", 0, "int", 0, "int", 0, "uint", flags)
            _DBG("Removed WS_EX_LAYERED.")
        }
    }
}

; Prevent default white erase (stop flash)
global __BASE_HGUI := 0
__OnEraseBk(wParam, lParam, msg, hwnd) {
    global __BASE_HGUI
    if (__BASE_HGUI && hwnd = __BASE_HGUI) {
        return 1
    }
    return 0
}
_InstallEraseBkSwallow(hWnd) {
    global __BASE_HGUI
    __BASE_HGUI := hWnd
    OnMessage(0x0014, __OnEraseBk) ; WM_ERASEBKGND
}

; ---- Perf caches (drawing + scale) ----
global gCurScale := 1.0              ; current monitor scale for our window
global gResScale := 0.0              ; scale the GDI+ resources were built for
global gRes := Map()                 ; cached GDI+ resources: brushes, fonts, families, formats

; Persistent ARGB backbuffer (reused every paint)
global gBackHdc := 0, gBackHBM := 0, gBackPrev := 0, gBackW := 0, gBackH := 0

; Paint/resize throttles
global gLastRowsDesired := -1

; -------- Scale cache + DPI hook --------
_EnsureScaleCache() {
    global gCurScale, gBaseH
    s := __GetScaleForWindow(gBaseH)
    if (s <= 0) {
        s := 1.0
    }
    gCurScale := s
}

_OnDpiChanged(wParam, lParam, msg, hwnd) {
    global gResScale
    _EnsureScaleCache()
    ; Invalidate resource cache (rebuild next paint)
    gResScale := 0.0
    return 0
}

; -------- Backbuffer management (top-down 32bpp ARGB DIB) --------
_EnsureBackbuffer(wPhys, hPhys) {
    global gBackHdc, gBackHBM, gBackPrev, gBackW, gBackH, gG

    ; Create the memory DC once
    if (!gBackHdc) {
        gBackHdc := DllCall("gdi32\CreateCompatibleDC", "ptr", 0, "ptr")
        if (gG) {
            try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
            gG := 0
        }
    }

    ; Hidden/just-shown windows can briefly report 0x0; clamp to >=1
    wPhys := Max(1, wPhys)
    hPhys := Max(1, hPhys)

    ; No change → keep current surface
    if (wPhys = gBackW && hPhys = gBackH && gBackHBM) {
        return
    }

    ; Replace bitmap surface
    if (gBackHBM) {
        DllCall("gdi32\SelectObject", "ptr", gBackHdc, "ptr", gBackPrev, "ptr")
        DllCall("gdi32\DeleteObject", "ptr", gBackHBM)
        gBackHBM := 0
    }

    ; Build a new top-down 32bpp DIB section
    bi := Buffer(40, 0)
    NumPut("UInt", 40, bi, 0)          ; biSize
    NumPut("Int",  wPhys, bi, 4)       ; biWidth
    NumPut("Int", -hPhys, bi, 8)       ; biHeight (negative => top-down)
    NumPut("UShort", 1,  bi, 12)       ; biPlanes
    NumPut("UShort", 32, bi, 14)       ; biBitCount
    NumPut("UInt", 0,  bi, 16)         ; biCompression = BI_RGB

    pvBits := 0
    gBackHBM := DllCall("gdi32\CreateDIBSection"
        , "ptr", gBackHdc, "ptr", bi.Ptr, "uint", 0, "ptr*", &pvBits, "ptr", 0, "uint", 0, "ptr")
    gBackPrev := DllCall("gdi32\SelectObject", "ptr", gBackHdc, "ptr", gBackHBM, "ptr")

    ; Invalidate any Graphics tied to the old surface to avoid AV on next paint
    if (gG) {
        try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
        gG := 0
    }

    gBackW := wPhys
    gBackH := hPhys
}

; -------- GDI+ resource cache (fonts/brushes/formats) --------
_DisposeGdipResources() {
    global gRes, gResScale
    if !gRes.Count {
        gResScale := 0.0
        return
    }
    for k in ["brMain","brMainHi","brSub","brSubHi","brCol","brColHi","brHdr","brHit","brFooterText"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteBrush", "ptr", gRes[k])
    }
    for k in ["fMain","fMainHi","fSub","fSubHi","fCol","fColHi","fHdr","fAction","fFooter"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteFont", "ptr", gRes[k])
    }
    for k in ["ffMain","ffMainHi","ffSub","ffSubHi","ffCol","ffColHi","ffHdr","ffAction","ffFooter"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteFontFamily", "ptr", gRes[k])
    }
    for k in ["fmt","fmtCenter","fmtRight","fmtLeft","fmtLeftCol","fmtFooterLeft","fmtFooterCenter","fmtFooterRight"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteStringFormat", "ptr", gRes[k])
    }
    ; NEW: dispose any cached scaled icon
    if (gRes.Has("iconScaled") && gRes["iconScaled"]) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", gRes["iconScaled"])
    }
    gRes := Map()
    gResScale := 0.0
}


__PointInRect(px, py, x, y, w, h) {
    return (px >= x && px < x + w && py >= y && py < y + h)
}

__Gdip_StrokeRoundRect(g, argb, x, y, w, h, r, width := 1) {
    if (w <= 0 || h <= 0) {
        return
    }
    pPath := 0, pPen := 0
    r2 := r * 2.0
    DllCall("gdiplus\GdipCreatePath", "int", 0, "ptr*", &pPath)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y,           "float", r2, "float", r2, "float", 180.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + r,      "float", y,           "float", x + w - r, "float", y)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y,           "float", r2, "float", r2, "float", 270.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w,      "float", y + r,       "float", x + w, "float", y + h - r)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y + h - r2,  "float", r2, "float", r2, "float", 0.0,   "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w - r,  "float", y + h,       "float", x + r, "float", y + h)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y + h - r2,  "float", r2, "float", r2, "float", 90.0,  "float", 90.0)
    DllCall("gdiplus\GdipClosePathFigure", "ptr", pPath)
    DllCall("gdiplus\GdipCreatePen1", "int", argb, "float", width, "int", 2, "ptr*", &pPen) ; UnitPixel=2
    DllCall("gdiplus\GdipDrawPath", "ptr", g, "ptr", pPen, "ptr", pPath)
    if (pPen)  {
      DllCall("gdiplus\GdipDeletePen",  "ptr", pPen)
    }
    if (pPath) {
      DllCall("gdiplus\GdipDeletePath", "ptr", pPath)
    }
}

__Gdip_DrawCenteredTextRect(g, text, x, y, w, h, argb, font) {
    global gRes
    rf := Buffer(16, 0)
    NumPut("Float", x, rf, 0), NumPut("Float", y, rf, 4), NumPut("Float", w, rf, 8), NumPut("Float", h, rf, 12)
    br := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &br)
    DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", gRes["fmtCenter"], "ptr", br)
    if (br) {
      DllCall("gdiplus\GdipDeleteBrush", "ptr", br)
    }
}

__DrawActionButtons(g, wPhys, yRow, rowHPhys, scale, isHoveredRow := true) {
    global ShowCloseButton, ShowKillButton, ShowBlacklistButton
    global ActionBtnSizePx, ActionBtnGapPx, ActionBtnRadiusPx, MarginX
    global CloseButtonBGARGB, CloseButtonBGHoverARGB, CloseButtonBorderARGB, CloseButtonBorderPx
         , CloseButtonTextARGB, CloseButtonTextHoverARGB, CloseButtonGlyph
    global KillButtonBGARGB,  KillButtonBGHoverARGB,  KillButtonBorderARGB,  KillButtonBorderPx
         , KillButtonTextARGB, KillButtonTextHoverARGB, KillButtonGlyph
    global BlacklistButtonBGARGB, BlacklistButtonBGHoverARGB, BlacklistButtonBorderARGB, BlacklistButtonBorderPx
         , BlacklistButtonTextARGB, BlacklistButtonTextHoverARGB, BlacklistButtonGlyph
    global gHoverBtn, gRes

    size := Max(12, Round(ActionBtnSizePx * scale))
    gap  := Max(2,  Round(ActionBtnGapPx  * scale))
    rad  := Max(2,  Round(ActionBtnRadiusPx * scale))
    marR := Round(MarginX * scale)

    x := wPhys - marR - size
    y := yRow + (rowHPhys - size) // 2

    drawOne(name, glyph, bg, bgH, text, textH, border, borderPx) {
        local w := size, h := size, hovered := (gHoverBtn = name && isHoveredRow)
        local bgCol := hovered ? bgH : bg
        local txCol := hovered ? textH : text
        __Gdip_FillRoundRect(g, bgCol, x, y, w, h, rad)
        if (borderPx > 0) {
            __Gdip_StrokeRoundRect(g, border, x+0.5, y+0.5, w-1, h-1, rad, Max(1, Round(borderPx*scale)))
        }
        __Gdip_DrawCenteredTextRect(g, glyph, x, y, w, h, txCol, gRes["fAction"])
        x := x - (w + gap)
        return x
    }

    ; Order: Close (rightmost), then Kill, then Blacklist
    if (ShowCloseButton) {
        x := drawOne("close", CloseButtonGlyph, CloseButtonBGARGB, CloseButtonBGHoverARGB
            , CloseButtonTextARGB, CloseButtonTextHoverARGB, CloseButtonBorderARGB, CloseButtonBorderPx)
    }
    if (ShowKillButton) {
        x := drawOne("kill", KillButtonGlyph, KillButtonBGARGB, KillButtonBGHoverARGB
            , KillButtonTextARGB, KillButtonTextHoverARGB, KillButtonBorderARGB, KillButtonBorderPx)
    }
    if (ShowBlacklistButton) {
        x := drawOne("blacklist", BlacklistButtonGlyph, BlacklistButtonBGARGB, BlacklistButtonBGHoverARGB
            , BlacklistButtonTextARGB, BlacklistButtonTextHoverARGB, BlacklistButtonBorderARGB, BlacklistButtonBorderPx)
    }
}


_EnsureGdipResources(scale) {
    global gRes, gResScale
    if (Abs(gResScale - scale) < 0.001 && gRes.Count) {
        return
    }
    _DisposeGdipResources()
    __Gdip_Startup()

    ; ---- Brushes ----
    global MainARGB, MainARGBHi, SubARGB, SubARGBHi, ColARGB, ColARGBHi, HdrARGB, FooterTextARGB
    br := 0
    for _ in [ ["brMain",    MainARGB]
             , ["brMainHi",  MainARGBHi]
             , ["brSub",     SubARGB]
             , ["brSubHi",   SubARGBHi]
             , ["brCol",     ColARGB]
             , ["brColHi",   ColARGBHi]
             , ["brHdr",     HdrARGB]
             , ["brHit",     0x01000000]
             , ["brFooterText", FooterTextARGB] ] {
        DllCall("gdiplus\GdipCreateSolidFill", "int", _[2], "ptr*", &br)
        gRes[ _[1] ] := br, br := 0
    }

    ; ---- Fonts ----
    global MainFontName, MainFontSize, MainFontWeight
         , MainFontNameHi, MainFontSizeHi, MainFontWeightHi
         , SubFontName,  SubFontSize,  SubFontWeight
         , SubFontNameHi,SubFontSizeHi,SubFontWeightHi
         , ColFontName,  ColFontSize,  ColFontWeight
         , ColFontNameHi,ColFontSizeHi,ColFontWeightHi
         , HdrFontName,  HdrFontSize,  HdrFontWeight
         , ActionFontName, ActionFontSize, ActionFontWeight
         , FooterFontName, FooterFontSize, FooterFontWeight

    UnitPixel := 2
    mkFont(name, size, weight, keyFam, keyFont) {
        local fam := 0, f := 0, style := __FontStyleFromWeight(weight)
        DllCall("gdiplus\GdipCreateFontFamilyFromName", "wstr", name, "ptr", 0, "ptr*", &fam)
        DllCall("gdiplus\GdipCreateFont", "ptr", fam, "float", size*scale, "int", style, "int", UnitPixel, "ptr*", &f)
        gRes[keyFam]  := fam
        gRes[keyFont] := f
    }
    mkFont(MainFontName,    MainFontSize,    MainFontWeight,    "ffMain",   "fMain")
    mkFont(MainFontNameHi,  MainFontSizeHi,  MainFontWeightHi,  "ffMainHi", "fMainHi")
    mkFont(SubFontName,     SubFontSize,     SubFontWeight,     "ffSub",    "fSub")
    mkFont(SubFontNameHi,   SubFontSizeHi,   SubFontWeightHi,   "ffSubHi",  "fSubHi")
    mkFont(ColFontName,     ColFontSize,     ColFontWeight,     "ffCol",    "fCol")
    mkFont(ColFontNameHi,   ColFontSizeHi,   ColFontWeightHi,   "ffColHi",  "fColHi")
    mkFont(HdrFontName,     HdrFontSize,     HdrFontWeight,     "ffHdr",    "fHdr")
    mkFont(ActionFontName,  ActionFontSize,  ActionFontWeight,  "ffAction", "fAction")
    mkFont(FooterFontName,  FooterFontSize,  FooterFontWeight,  "ffFooter", "fFooter")

    ; ---- String formats (create independent instances; do NOT use GenericDefault) ----
    StringAlignmentNear := 0, StringAlignmentCenter := 1, StringAlignmentFar := 2
    StringFormatFlagsNoWrap := 0x00001000
    StringFormatFlagsNoClip := 0x00004000
    StringTrimmingEllipsisCharacter := 3
    flags := StringFormatFlagsNoWrap | StringFormatFlagsNoClip

    mkFmt(&out, align, valign) {
        out := 0
        ; independent instance
        DllCall("gdiplus\GdipCreateStringFormat", "int", 0, "ushort", 0, "ptr*", &out)
        DllCall("gdiplus\GdipSetStringFormatFlags",     "ptr", out, "int", flags)
        DllCall("gdiplus\GdipSetStringFormatTrimming",  "ptr", out, "int", StringTrimmingEllipsisCharacter)
        DllCall("gdiplus\GdipSetStringFormatAlign",     "ptr", out, "int", align)
        DllCall("gdiplus\GdipSetStringFormatLineAlign", "ptr", out, "int", valign)
    }

    ; General text formats
    fmt := 0, fmtC := 0, fmtR := 0, fmtLcol := 0
    mkFmt(&fmt,     StringAlignmentNear,   StringAlignmentNear)    ; left/top
    mkFmt(&fmtC,    StringAlignmentCenter, StringAlignmentNear)    ; center/top
    mkFmt(&fmtR,    StringAlignmentFar,    StringAlignmentNear)    ; right/top
    mkFmt(&fmtLcol, StringAlignmentNear,   StringAlignmentNear)    ; explicit left for Column 1

    gRes["fmt"]        := fmt
    gRes["fmtCenter"]  := fmtC
    gRes["fmtRight"]   := fmtR
    gRes["fmtLeft"]    := fmtLcol
    gRes["fmtLeftCol"] := fmtLcol   ; alias used by list/headers

    ; Footer formats (vertical center looks nicer)
    fL := 0, fC := 0, fR := 0
    mkFmt(&fL, StringAlignmentNear,   StringAlignmentCenter)   ; left/center
    mkFmt(&fC, StringAlignmentCenter, StringAlignmentCenter)   ; center/center
    mkFmt(&fR, StringAlignmentFar,    StringAlignmentCenter)   ; right/center
    gRes["fmtFooterLeft"]   := fL
    gRes["fmtFooterCenter"] := fC
    gRes["fmtFooterRight"]  := fR

    gResScale := scale
}


_EnsureScaledIcon(scale, ISize, pSrcIcon) {
    global gRes
    if (!pSrcIcon || ISize <= 0) {
        return 0
    }
    if (gRes.Has("iconScaled") && gRes["iconScaled"] && gRes.Has("iconScalePx") && gRes["iconScalePx"] = ISize) {
        return gRes["iconScaled"]
    }
    ; Dispose previous
    if (gRes.Has("iconScaled") && gRes["iconScaled"]) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", gRes["iconScaled"])
        gRes["iconScaled"] := 0
    }

    PixelFormat32bppPARGB := 0x26200A
    pDst := 0, g2 := 0
    DllCall("gdiplus\GdipCreateBitmapFromScan0", "int", ISize, "int", ISize, "int", 0, "int", PixelFormat32bppPARGB, "ptr", 0, "ptr*", &pDst)
    DllCall("gdiplus\GdipGetImageGraphicsContext", "ptr", pDst, "ptr*", &g2)
    ; Interpolation high-quality for visual parity with GDI+ scaling in DrawImageRectI
    InterpolationModeHighQualityBicubic := 7
    DllCall("gdiplus\GdipSetInterpolationMode", "ptr", g2, "int", InterpolationModeHighQualityBicubic)
    DllCall("gdiplus\GdipDrawImageRectI", "ptr", g2, "ptr", pSrcIcon, "int", 0, "int", 0, "int", ISize, "int", ISize)
    if (g2) {
        DllCall("gdiplus\GdipDeleteGraphics", "ptr", g2)
    }

    gRes["iconScaled"] := pDst
    gRes["iconScalePx"] := ISize
    return pDst
}


; -------- Paint directly into backbuffer using GDI+ over HDC --------
; -------- Paint directly into backbuffer using GDI+ over HDC (REPLACE) --------
__Gdip_PaintOverlay(items, selIndex, wPhys, hPhys, scrollTop := "", pIcon := 0, scale := 1.0) {
    global RowHeight, MarginX, MarginY, IconSize, RowRadius, SelARGB
         , gScrollTop, gIconImg, ShowHeader, EmptyListText
         , ColFixed2, ColFixed3, ColFixed4, ColFixed5, ColFixed6
         , Col2Name, Col3Name, Col4Name, Col5Name, Col6Name
         , gHoverRow, MainARGB, ShowFooter, FooterHeightPx, FooterGapTopPx

    _EnsureGdipResources(scale)
    global gRes, gBackHdc

    g := _EnsureGraphics()
    if (!g)
        return

    ; Clear + full-surface hit matte
    DllCall("gdiplus\GdipGraphicsClear", "ptr", g, "int", 0x00000000)
    DllCall("gdiplus\GdipFillRectangle", "ptr", g, "ptr", gRes["brHit"], "float", 0, "float", 0, "float", wPhys, "float", hPhys)

    if (scrollTop == "")
        scrollTop := gScrollTop
    if (!pIcon && IsSet(gIconImg) && gIconImg)
        pIcon := gIconImg

    fmtLeft := (gRes.Has("fmtLeft") && gRes["fmtLeft"]) ? gRes["fmtLeft"] : gRes["fmt"]

    ; ---- Metrics (PHYSICAL px) ----
    RowH    := Max(1, Round(RowHeight * scale))
    Mx      := Round(MarginX  * scale)
    My      := Round(MarginY  * scale)
    ISize   := Round(IconSize * scale)
    Rad     := Round(RowRadius * scale)
    gapText := Round(12 * scale)
    gapCols := Round(10 * scale)
    hdrY4   := Round(4  * scale)
    hdrH28  := Round(28 * scale)

    iconLeftDip := _GetIconLeftMarginDip(scale)

    y     := My
    leftX := Mx + iconLeftDip
    textX := leftX + ISize + gapText

    ; Right-side columns (use consistent keys Col2..Col6)
    cols := []
    Col6W := Round(ColFixed6 * scale), Col5W := Round(ColFixed5 * scale)
    Col4W := Round(ColFixed4 * scale), Col3W := Round(ColFixed3 * scale)
    Col2W := Round(ColFixed2 * scale)

    rightX := wPhys - Mx
    if (Col6W > 0) { 
        x := rightX - Col6W, cols.Push({name:Col6Name, w:Col6W, key:"Col6", x:x}), rightX := x - gapCols 
    }
    if (Col5W > 0) { 
        x := rightX - Col5W, cols.Push({name:Col5Name, w:Col5W, key:"Col5", x:x}), rightX := x - gapCols
     }
    if (Col4W > 0) { 
        x := rightX - Col4W, cols.Push({name:Col4Name, w:Col4W, key:"Col4", x:x}), rightX := x - gapCols 
    }
    if (Col3W > 0) { 
        x := rightX - Col3W, cols.Push({name:Col3Name, w:Col3W, key:"Col3", x:x}), rightX := x - gapCols
     }
    if (Col2W > 0) { 
        x := rightX - Col2W, cols.Push({name:Col2Name, w:Col2W, key:"Col2", x:x}), rightX := x - gapCols 
    }

    textW := (rightX - Round(16*scale)) - textX
    if (textW < 0)
        textW := 0

    ; ---- Optional header ----
    if (ShowHeader) {
        hdrY := y + hdrY4
        __Gdip_DrawText(g, "Title", textX, hdrY, textW, Round(20*scale), gRes["brHdr"], gRes["fHdr"], fmtLeft)
        for _, col in cols {
            __Gdip_DrawText(g, col.name, col.x, hdrY, col.w, Round(20*scale), gRes["brHdr"], gRes["fHdr"], gRes["fmt"])
        }
        y += hdrH28
    }

    contentTopY := y
    count := items.Length

    ; Compute available rows area (reserve space for footer if shown)
    footerH := ShowFooter ? Round(FooterHeightPx * scale) : 0
    footerGap := ShowFooter ? Round(FooterGapTopPx * scale) : 0
    availH := hPhys - My - contentTopY - footerH - footerGap
    if (availH < 0)
        availH := 0

    rowsCap := (availH > 0) ? Floor(availH / RowH) : 0
    rowsToDraw := (count <= rowsCap) ? count : rowsCap

    ; ---- Empty list ----
    if (count = 0) {
        rectX := Mx
        rectW := wPhys - 2*Mx
        rectH := RowH
        rectY := contentTopY + Max(0, (availH - rectH) // 2)
        __Gdip_DrawCenteredTextRect(g, EmptyListText, rectX, rectY, rectW, rectH, MainARGB, gRes["fMain"])
        ; still draw footer (below)
    } else if (rowsToDraw > 0) {
        start0 := __Wrap0(scrollTop, count)
        i := 0
        yRow := y

        while (i < rowsToDraw && (yRow + RowH <= contentTopY + availH)) {
            idx0 := __Wrap0(start0 + i, count)
            idx1 := idx0 + 1
            cur  := items[idx1]
            isSel := (idx1 = selIndex)

            if (isSel)
                __Gdip_FillRoundRect(g, SelARGB, Mx - Round(4*scale), yRow - Round(2*scale), wPhys - 2*Mx + Round(8*scale), RowH, Rad)

            ; ---- Icon (per row) ----
            ix := leftX
            iy := yRow + (RowH - ISize)//2
            drewIcon := false
            if (cur.HasOwnProp("HICON") && cur.HICON) {
                pImg := 0
                DllCall("gdiplus\GdipCreateBitmapFromHICON", "ptr", cur.HICON, "ptr*", &pImg)
                if (pImg) {
                    DllCall("gdiplus\GdipDrawImageRectI", "ptr", g, "ptr", pImg, "int", ix, "int", iy, "int", ISize, "int", ISize)
                    DllCall("gdiplus\GdipDisposeImage", "ptr", pImg)
                    drewIcon := true
                }
            }
            if (!drewIcon) {
                if (pIcon) {
                    DllCall("gdiplus\GdipDrawImageRectI", "ptr", g, "ptr", pIcon, "int", ix, "int", iy, "int", ISize, "int", ISize)
                } else {
                    __Gdip_FillEllipse(g, __ARGB_FromIndex(idx1), ix, iy, ISize, ISize)
                }
            }

            ; ---- Text (main + sub) ----
            fMainUse  := isSel ? gRes["fMainHi"] : gRes["fMain"]
            fSubUse   := isSel ? gRes["fSubHi"]  : gRes["fSub"]
            fColUse   := isSel ? gRes["fColHi"]  : gRes["fCol"]
            brMainUse := isSel ? gRes["brMainHi"] : gRes["brMain"]
            brSubUse  := isSel ? gRes["brSubHi"]  : gRes["brSub"]
            brColUse  := isSel ? gRes["brColHi"]  : gRes["brCol"]

            title := cur.HasOwnProp("Title") ? cur.Title : ""
            __Gdip_DrawText(g, title, textX, yRow + Round(6*scale),  textW, Round(24*scale), brMainUse, fMainUse, fmtLeft)

            sub := cur.HasOwnProp("Sub") ? cur.Sub : ""
            __Gdip_DrawText(g, sub,   textX, yRow + Round(28*scale), textW, Round(18*scale), brSubUse,  fSubUse,  fmtLeft)

            ; ---- Right columns ----
            for _, col in cols {
                val := cur.HasOwnProp(col.key) ? cur.%col.key% : ""
                __Gdip_DrawText(g, val, col.x, yRow + Round(10*scale), col.w, Round(20*scale), brColUse, fColUse, gRes["fmt"])
            }

            ; ---- Row actions on hover ----
            if (idx1 = gHoverRow) {
                __DrawActionButtons(g, wPhys, yRow, RowH, scale, true)
            }

            yRow += RowH
            i += 1
        }
    }

    ; virtual scrollbar if needed
    if (count > rowsToDraw && rowsToDraw > 0) {
        __DrawVirtualScrollbar(g, wPhys, contentTopY, rowsToDraw, RowH, scrollTop, count, scale)
    }

    ; Footer (bottom anchored)
    if (ShowFooter) {
        _DrawFooter(g, wPhys, hPhys, scale)
    }
}


_DetectActionAtPoint(xPhys, yPhys, &action, &idx1) {
    global gItems, gScrollTop, gOverlayH, MarginY, RowHeight
    global ShowCloseButton, ShowKillButton, ShowBlacklistButton
    global ActionBtnSizePx, ActionBtnGapPx, MarginX

    action := "", idx1 := 0
    count := gItems.Length
    if (count <= 0) {
        return
    }

    scale := __GetScaleForWindow(gOverlayH)
    RowH := Max(1, Round(RowHeight * scale))
    My   := Round(MarginY  * scale)
    hdr  := Round(_HeaderBlockDip() * scale)
    topY := My + hdr

    if (yPhys < topY) {
        return
    }

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    local rel := yPhys - topY
    local rowVis := Floor(rel / RowH) + 1
    if (rowVis < 1 || rowVis > vis) {
        return
    }

    ; 1-based item index under cursor (wrap-aware viewport)
    local idx0 := __Wrap0(gScrollTop + (rowVis - 1), count)
    idx1 := idx0 + 1

    ; Build button rects (right aligned)
    size := Max(12, Round(ActionBtnSizePx * scale))
    gap  := Max(2,  Round(ActionBtnGapPx  * scale))
    marR := Round(MarginX * scale)

    ox := 0, oy := 0, ow := 0, oh := 0
    __GetWindowRectPhys(gOverlayH, &ox, &oy, &ow, &oh)

    x := ow - marR - size
    y := topY + (rowVis - 1) * RowH + (RowH - size) // 2

    ; Test in order: Close (rightmost), Kill, Blacklist
    if (ShowCloseButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "close"
        return
    }
    x := x - (size + gap)
    if (ShowKillButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "kill"
        return
    }
    x := x - (size + gap)
    if (ShowBlacklistButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "blacklist"
        return
    }
}

; ========================= ACRYLIC (ACCENT) =========================
ApplyAccentAcrylic(hWnd, alpha, baseRgb) {
    bb := (baseRgb >> 16) & 0xFF
    gg := (baseRgb >> 8)  & 0xFF
    rr := (baseRgb)       & 0xFF
    grad := (alpha << 24) | (bb << 16) | (gg << 8) | rr  ; 0xAABBGGRR

    ACCENT_ENABLE_ACRYLICBLURBEHIND := 4
    accent := Buffer(16, 0)
    NumPut("Int", ACCENT_ENABLE_ACRYLICBLURBEHIND, accent, 0)
    NumPut("Int", 0, accent, 4)
    NumPut("Int", grad, accent, 8)
    NumPut("Int", 0, accent, 12)

    WCA_ACCENT_POLICY := 19
    data := Buffer(A_PtrSize * 3, 0)
    NumPut("Int", WCA_ACCENT_POLICY, data, 0)
    NumPut("Ptr", accent.Ptr,        data, A_PtrSize)
    NumPut("Int", accent.Size,       data, A_PtrSize*2)

    ok := DllCall("user32\SetWindowCompositionAttribute", "ptr", hWnd, "ptr", data.Ptr, "int")
    _DBG("SetWindowCompositionAttribute(Acrylic) ok=" ok " alpha=" alpha " baseRgb=0x" Format("{:06X}", baseRgb))
    return ok
}

; ========================= STAGE + REVEAL (no flash) =========================
_StageAndRevealAcrylic(guiObj, x, y, wDip, hDip, alpha, baseRgb, cornerRadius, revealNow := true) {
    ; 1) Create/size hidden (width/height only, let AHK/DWM establish actual size)
    guiObj.Show("Hide w" wDip " h" hDip)
    hWnd := guiObj.Hwnd

    ; 2) Read actual PHYSICAL window size now
    curX := 0, curY := 0, curW := 0, curH := 0
    __GetWindowRectPhys(hWnd, &curX, &curY, &curW, &curH)

    ; 3) Get the work area of the monitor this window is on (PHYSICAL)
    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(hWnd, &waL, &waT, &waR, &waB)
    waW := waR - waL
    waH := waB - waT

    ; 4) Compute perfect physical center and move (still hidden → no flash)
    tgtX := waL + (waW - curW) // 2
    tgtY := waT + (waH - curH) // 2
    __SetWindowPosPhys(hWnd, tgtX, tgtY, curW, curH)

    ; 5) Cosmetics (after size is final)
    _TryEnableDarkTitleBar(hWnd)
    _SetCornerPreference(hWnd, 2)
    _ForceNoLayered(hWnd)
    _InstallEraseBkSwallow(hWnd)
    _ApplyRoundRegion(hWnd, cornerRadius, wDip, hDip)

    ; 6) Apply acrylic
    ApplyAccentAcrylic(hWnd, alpha, baseRgb)
    try DllCall("dwmapi\DwmFlush")

    ; 7) Reveal now or defer for a synchronized reveal with overlay
    if (revealNow) {
        guiObj.Show("NA")
        SetTimer(() => _ApplyRoundRegion(hWnd, cornerRadius), -1)
    }
}


; ========================= GDI+ HELPERS =========================
__Gdip_Startup() {
    ; Start GDI+ once; keep the token internally (and mirror to a global for shutdown).
    static token := 0
    if (token)
        return token

    si := Buffer(A_PtrSize=8 ? 24 : 16, 0)  ; GdiplusStartupInput
    NumPut("UInt", 1, si, 0)                ; version = 1

    status := DllCall("gdiplus\GdiplusStartup", "ptr*", &token, "ptr", si.Ptr, "ptr", 0, "int")
    if (status = 0 && token) {
        global gGdipToken
        gGdipToken := token   ; optional mirror for shutdown visibility
        return token
    }
    return 0
}

__Gdip_FillRoundRect(g, argb, x, y, w, h, r) {
    if (w <= 0 || h <= 0) {
        return
    }
    if (r <= 0) {
        pBr := 0
        DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
        DllCall("gdiplus\GdipFillRectangle", "ptr", g, "ptr", pBr, "float", x, "float", y, "float", w, "float", h)
        if (pBr) {
            DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
        }
        return
    }
    pPath := 0
    pBr   := 0
    r2    := r * 2.0
    DllCall("gdiplus\GdipCreatePath", "int", 0, "ptr*", &pPath)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y,           "float", r2, "float", r2, "float", 180.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + r,      "float", y,           "float", x + w - r, "float", y)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y,           "float", r2, "float", r2, "float", 270.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w,      "float", y + r,       "float", x + w, "float", y + h - r)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y + h - r2,  "float", r2, "float", r2, "float", 0.0,   "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w - r,  "float", y + h,       "float", x + r, "float", y + h)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y + h - r2,  "float", r2, "float", r2, "float", 90.0,  "float", 90.0)
    DllCall("gdiplus\GdipClosePathFigure", "ptr", pPath)
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
    DllCall("gdiplus\GdipFillPath", "ptr", g, "ptr", pBr, "ptr", pPath)
    if (pBr) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
    }
    if (pPath) {
        DllCall("gdiplus\GdipDeletePath",  "ptr", pPath)
    }
}

__Gdip_DrawText(g, text, x, y, w, h, br, font, fmt) {
    rf := Buffer(16, 0)
    NumPut("Float", x, rf, 0)
    NumPut("Float", y, rf, 4)
    NumPut("Float", w, rf, 8)
    NumPut("Float", h, rf, 12)
    DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", fmt, "ptr", br)
}

__Gdip_FillEllipse(g, argb, x, y, w, h) {
    pBr := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
    DllCall("gdiplus\GdipFillEllipse", "ptr", g, "ptr", pBr, "float", x, "float", y, "float", w, "float", h)
    if (pBr) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
    }
}

; ===== Icon loading (explorer.exe) → GDI+ image =====
__LoadGpIconFromFile(path, index := 0) {
    __Gdip_Startup()
    hIconLarge := 0
    got := DllCall("shell32\ExtractIconExW", "wstr", path, "int", index, "ptr*", &hIconLarge, "ptr", 0, "uint", 1, "uint")
    if (got = 0 || !hIconLarge) {
        return 0
    }
    pImg := 0
    DllCall("gdiplus\GdipCreateBitmapFromHICON", "ptr", hIconLarge, "ptr*", &pImg)
    DllCall("user32\DestroyIcon", "ptr", hIconLarge)
    return pImg  ; caller must GdipDisposeImage
}

__DrawVirtualScrollbar(g, wPhys, contentTopY, rowsDrawn, rowHPhys, scrollTop, count, scale) {
    global ScrollBarEnabled, ScrollBarWidthPx, ScrollBarMarginRightPx
         , ScrollBarThumbARGB, ScrollBarGutterEnabled, ScrollBarGutterARGB

    if (!ScrollBarEnabled) {
        return
    }
    if (count <= 0 || rowsDrawn <= 0 || rowHPhys <= 0) {
        return
    }

    ; viewport and track geometry (PHYSICAL px)
    trackH := rowsDrawn * rowHPhys
    if (trackH <= 0) {
        return
    }
    trackW := Max(2, Round(ScrollBarWidthPx * scale))
    marR   := Max(0, Round(ScrollBarMarginRightPx * scale))
    x      := wPhys - marR - trackW
    y      := contentTopY
    r      := trackW // 2  ; pill radius

    ; thumb size scales by visible/count (min height guard)
    visCount := rowsDrawn
    thumbH := Max(3, Floor(trackH * visCount / count))

    ; wrap-aware start (0..count-1)
    start0 := __Wrap0(scrollTop, count)
    startRatio := start0 / count
    y1 := y + Floor(startRatio * trackH)
    y2 := y1 + thumbH
    yEnd := y + trackH

    ; brushes
    brThumb := 0, brGutter := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", ScrollBarThumbARGB, "ptr*", &brThumb)

    if (ScrollBarGutterEnabled) {
        DllCall("gdiplus\GdipCreateSolidFill", "int", ScrollBarGutterARGB, "ptr*", &brGutter)
        __Gdip_FillRoundRect(g, ScrollBarGutterARGB, x, y, trackW, trackH, r)
    }

    ; draw thumb (1 or 2 segments if wrapping across end → top)
    if (y2 <= yEnd) {
        __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y1, trackW, thumbH, r)
    } else {
        ; segment 1: bottom tail
        h1 := yEnd - y1
        if (h1 > 0) {
            __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y1, trackW, h1, r)
        }
        ; segment 2: wrap to top
        h2 := y2 - yEnd
        if (h2 > 0) {
            __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y, trackW, h2, r)
        }
    }

    if (brThumb)  {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", brThumb)
    }
    if (brGutter) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", brGutter)
    }
}


__ARGB_FromIndex(i) {
    ; fallback colored circle (unused if icon loads)
    r := (37 * i)  & 0xFF
    g := (71 * i)  & 0xFF
    b := (113 * i) & 0xFF
    return (0xCC << 24) | (r << 16) | (g << 8) | b
}

; ========================= OVERLAY (layered) =========================
global gBase := 0, gOverlay := 0, gBaseH := 0, gOverlayH := 0
global gItems := [], gSel := 1
global gScrollTop := 0
global gIconImg := 0

_BuildSampleItems() {
    arr := []
    ; vary count a bit to simulate changing results
    count := Round(Random(4, 12))
    i := 1
    while (i <= count) {
        hwnd := Format("0x{:X}", 0x10000 + Round(Random(1000, 99999)))
        title := _RandomSpacedText(5, 20, 4, 8)
        arr.Push({
            Title: title,
            Class: "Class" i,
            HWND:  hwnd,
            PID:   "" Round(Random(500, 99999))
        })
        i += 1
    }
    return arr
}

_HideOverlay() {
    global gBase, gOverlay
    try gOverlay.Hide()
    try gBase.Hide()
}

_ShowOverlay() {
    global gBase, gBaseH, gOverlay, gOverlayH, gItems, gSel, gScrollTop

    ; simulate changed contents each time we show
    gItems := _BuildSampleItems()
    gSel := 1
    gScrollTop := 0

    ; Ensure the base is visible/sized so GetWindowRect returns valid dimensions
    try gBase.Show("NA")

    ; Force size/rows to match new item count before repaint (ensures non-zero backbuffer)
    rowsDesired := _ComputeRowsToShow(gItems.Length)
    _ResizeWindowToRows(rowsDesired)

    ; Now (re)paint and reveal overlay
    _Overlay_Repaint(gOverlayH, gItems, gSel)
    try gOverlay.Show("NA")
    try DllCall("dwmapi\DwmFlush")
}

_Overlay_Create(ownerHwnd) {
    ; Create overlay as hidden first to avoid any black flash before first paint
    ov := Gui("+AlwaysOnTop -Caption +ToolWindow +Owner" ownerHwnd)
    ov.Show("Hide")

    ; Match owner (base) window position/size in PHYSICAL pixels
    ox := 0, oy := 0, ow := 0, oh := 0
    __GetWindowRectPhys(ownerHwnd, &ox, &oy, &ow, &oh)
    __SetWindowPosPhys(ov.Hwnd, ox, oy, ow, oh)

    return ov
}

_GetWindowRectForWindowMonitor(&x, &y, &w, &h, rowsToShow, hWnd) {
    global ScreenWidthPct, RowHeight, MarginY

    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(hWnd, &waL, &waT, &waR, &waB)

    monScale := __GetMonitorScaleFromRect(waL, waT, waR, waB)

    waW_dip := (waR - waL) / monScale
    waH_dip := (waB - waT) / monScale
    left_dip := waL / monScale
    top_dip  := waT / monScale

    pct := ScreenWidthPct
    if (pct <= 0)
        pct := 0.10
    if (pct > 1.0)
        pct := pct / 100.0

    w := Round(waW_dip * pct)

    headerBlock := _HeaderBlockDip()
    footerBlock := _FooterBlockDip()
    h := MarginY + headerBlock + rowsToShow * RowHeight + footerBlock + MarginY

    x := Round(left_dip + (waW_dip - w) / 2)
    y := Round(top_dip  + (waH_dip - h) / 2)
}

_GetVisibleRowsFromOverlay() {
    global gOverlayH, MarginY, RowHeight

    ox := 0, oy := 0, owPhys := 0, ohPhys := 0
    __GetWindowRectPhys(gOverlayH, &ox, &oy, &owPhys, &ohPhys)

    scale := __GetScaleForWindow(gOverlayH)
    ohDip := ohPhys / scale

    headerTopDip := MarginY + _HeaderBlockDip()
    footerDip := _FooterBlockDip()
    usableDip := ohDip - headerTopDip - MarginY - footerDip

    if (usableDip < RowHeight)
        return 0
    return Floor(usableDip / RowHeight)
}

_DrawFooter(g, wPhys, hPhys, scale) {
    global ShowFooter, FooterHeightPx, FooterGapTopPx, FooterBGARGB, FooterBGRadius
         , FooterBorderPx, FooterBorderARGB, FooterPaddingX, FooterTextAlign
         , FooterTextARGB, MarginX, MarginY, gFooterText, gRes

    if (!ShowFooter)
        return

    fh := Max(1, Round(FooterHeightPx * scale))
    mx := Round(MarginX * scale)
    my := Round(MarginY * scale)

    x := mx
    y := hPhys - my - fh
    w := wPhys - 2*mx
    r := Max(0, Round(FooterBGRadius * scale))

    __Gdip_FillRoundRect(g, FooterBGARGB, x, y, w, fh, r)
    if (FooterBorderPx > 0)
        __Gdip_StrokeRoundRect(g, FooterBorderARGB, x+0.5, y+0.5, w-1, fh-1, r, Max(1, Round(FooterBorderPx*scale)))

    pad := Max(0, Round(FooterPaddingX * scale))
    tx := x + pad
    tw := w - 2*pad

    t := StrLower(Trim(FooterTextAlign))
    fmt := gRes.Has("fmtFooterCenter") ? gRes["fmtFooterCenter"] : (gRes.Has("fmtCenter") ? gRes["fmtCenter"] : 0)
    if (t = "left")
        fmt := gRes.Has("fmtFooterLeft")  ? gRes["fmtFooterLeft"]  : (gRes.Has("fmt") ? gRes["fmt"] : fmt)
    else if (t = "right")
        fmt := gRes.Has("fmtFooterRight") ? gRes["fmtFooterRight"] : (gRes.Has("fmtRight") ? gRes["fmtRight"] : fmt)

    rf := Buffer(16, 0)
    NumPut("Float", tx, rf, 0)
    NumPut("Float", y,  rf, 4)
    NumPut("Float", tw, rf, 8)
    NumPut("Float", fh, rf, 12)

    DllCall("gdiplus\GdipDrawString"
        , "ptr", g
        , "wstr", gFooterText
        , "int", -1
        , "ptr", gRes["fFooter"]
        , "ptr", rf.Ptr
        , "ptr", fmt
        , "ptr", gRes["brFooterText"])
}

_ScrollBy(step) {
    global gScrollTop, gItems, gOverlayH, gSel

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    count := gItems.Length
    if (count <= 0) {
        return
    }

    visEff := Min(vis, count)
    if (count <= visEff) {
        ; Everything fits; nothing to scroll.
        return
    }

    ; Wrap-aware scrolling for the circular viewport
    gScrollTop := __Wrap0(gScrollTop + step, count)

    ; Recompute hover from current cursor so action icons stay under the pointer
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_Overlay_Repaint(hOv, items, selIndex) {
    global gBaseH, gOverlay, gLastRowsDesired, gLastItemCount

    ; ----- Throttled dynamic height: only when rows-to-show actually changes -----
    count := items.Length
    rowsDesired := _ComputeRowsToShow(count)
    if (rowsDesired != gLastRowsDesired) {
        _ResizeWindowToRows(rowsDesired)
        gLastRowsDesired := rowsDesired
    }

    ; Base rect in PHYSICAL pixels
    phX := 0, phY := 0, phW := 0, phH := 0
    __GetWindowRectPhys(gBaseH, &phX, &phY, &phW, &phH)

    ; Ensure scale + backbuffer + resources
    _EnsureScaleCache()
    scale := gCurScale
    _EnsureBackbuffer(phW, phH)

    ; Paint directly into backbuffer
    __Gdip_PaintOverlay(items, selIndex, phW, phH, "", 0, scale)

    ; BLENDFUNCTION
    bf := Buffer(4, 0)
    NumPut("UChar", 0x00, bf, 0) ; AC_SRC_OVER
    NumPut("UChar", 0x00, bf, 1)
    NumPut("UChar", 255,  bf, 2) ; per-pixel alpha
    NumPut("UChar", 0x01, bf, 3) ; AC_SRC_ALPHA

    ; SIZE and POINT (PHYSICAL)
    sz := Buffer(8, 0), ptDst := Buffer(8, 0), ptSrc := Buffer(8, 0)
    NumPut("Int", phW, sz, 0), NumPut("Int", phH, sz, 4)
    NumPut("Int", phX, ptDst, 0), NumPut("Int", phY, ptDst, 4)

    ; Ensure WS_EX_LAYERED
    GWL_EXSTYLE := -20, WS_EX_LAYERED := 0x80000
    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hOv, "int", GWL_EXSTYLE, "ptr")
    if !(ex & WS_EX_LAYERED) {
        ex |= WS_EX_LAYERED
        DllCall("user32\SetWindowLongPtrW", "ptr", hOv, "int", GWL_EXSTYLE, "ptr", ex, "ptr")
    }

    ; Update layered directly from persistent backbuffer DC/bitmap
    ULW_ALPHA := 0x2
    hdcScreen := DllCall("user32\GetDC", "ptr", 0, "ptr")
    DllCall("user32\UpdateLayeredWindow"
        , "ptr", hOv
        , "ptr", hdcScreen
        , "ptr", ptDst.Ptr
        , "ptr", sz.Ptr
        , "ptr", gBackHdc
        , "ptr", ptSrc.Ptr
        , "int", 0
        , "ptr", bf.Ptr
        , "uint", ULW_ALPHA
        , "int")
    DllCall("user32\ReleaseDC", "ptr", 0, "ptr", hdcScreen)

    ; Synchronized first reveal
    _RevealBaseAndOverlayTogether()
}

; Keep selection visible after changing gSel
_EnsureVisible(totalCount) {
    global gSel, gScrollTop
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0 || totalCount <= 0) {
        return
    }
    visEff := Min(vis, totalCount)
    if (visEff <= 0) {
        return
    }
    if (gSel < gScrollTop + 1) {
        gScrollTop := gSel - 1
    } else if (gSel > gScrollTop + visEff) {
        gScrollTop := gSel - visEff
    }
    if (gScrollTop < 0)
        gScrollTop := 0
    maxTop := Max(0, totalCount - visEff)
    if (gScrollTop > maxTop)
        gScrollTop := maxTop
}

; Full-row click → select clicked row (not just icon)
_OnOverlayClick(x, y) {
    global gItems, gSel, gOverlayH, MarginY, RowHeight, gScrollTop, ScrollKeepHighlightOnTop

    ; First: did we click an action button?
    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)
    if (act != "") {
        _Action_Perform(act, idx)
        return
    }

    ; Otherwise: regular row selection behavior
    count := gItems.Length
    if (count = 0) {
        return
    }

    scale := __GetScaleForWindow(gOverlayH)
    yDip := Round(y / scale)

    rowsTopDip := MarginY + _HeaderBlockDip()
    if (yDip < rowsTopDip) {
        return
    }

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    rowsDrawn := Min(vis, count)

    idxVisible := ((yDip - rowsTopDip) // RowHeight) + 1
    if (idxVisible < 1) {
        idxVisible := 1
    }
    if (idxVisible > rowsDrawn) {
        return
    }

    top0 := gScrollTop
    idx0 := __Wrap0(top0 + (idxVisible - 1), count)
    gSel := idx0 + 1

    if (ScrollKeepHighlightOnTop) {
        gScrollTop := gSel - 1
    }

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}

_OnOverlayMouseMove(wParam, lParam, msg, hwnd) {
    global gOverlayH, gHoverRow, gHoverBtn, gItems, gSel
    if (hwnd != gOverlayH) {
        return 0
    }
    x := lParam & 0xFFFF
    y := (lParam >> 16) & 0xFFFF

    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)

    prevRow := gHoverRow
    prevBtn := gHoverBtn
    gHoverRow := idx
    gHoverBtn := act

    if (gHoverRow != prevRow || gHoverBtn != prevBtn) {
        _Overlay_Repaint(gOverlayH, gItems, gSel)
    }
    return 0
}

_MoveSelection(delta) {
    global gSel, gItems, gScrollTop, gOverlayH, gSel, ScrollKeepHighlightOnTop

    if (gItems.Length = 0 || delta = 0) {
        return
    }

    count := gItems.Length
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        vis := 1
    }
    if (vis > count) {
        vis := count
    }

    if (ScrollKeepHighlightOnTop) {
        ; ===================== TOP-ANCHOR MODE (true) =====================
        if (delta > 0) {
            gSel := __Wrap1(gSel + 1, count)
        } else {
            gSel := __Wrap1(gSel - 1, count)
        }
        gScrollTop := gSel - 1           ; let rendering wrap; no clamping
    } else {
        ; ===================== STICKY-EDGE MODE (false) =====================
        top0 := gScrollTop

        if (delta > 0) {
            ; move selection down (wrap 1..count)
            gSel := __Wrap1(gSel + 1, count)
            sel0 := gSel - 1
            pos := __Wrap0(sel0 - top0, count)
            ; If offscreen OR already at bottom, anchor selection to bottom row.
            if (pos >= vis || pos = vis - 1) {
                gScrollTop := sel0 - (vis - 1)
            }
        } else {
            ; move selection up (wrap 1..count)
            gSel := __Wrap1(gSel - 1, count)
            sel0 := gSel - 1
            pos := __Wrap0(sel0 - top0, count)
            ; If offscreen OR already at top, anchor selection to top row.
            if (pos >= vis || pos = 0) {
                gScrollTop := sel0
            }
        }
    }

    ; Recompute hover from current cursor so action icons stay under the pointer
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_RemoveItemAt(idx1) {
    global gItems, gSel, gScrollTop, gOverlayH
    if (idx1 < 1 || idx1 > gItems.Length) {
        return
    }
    gItems.RemoveAt(idx1)

    if (gItems.Length = 0) {
        gSel := 1
        gScrollTop := 0
    } else {
        if (gSel > gItems.Length) {
            gSel := gItems.Length
        }
        _EnsureVisible(gItems.Length)
    }

    ; Keep hover aligned with the cursor after the list compacts
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_Action_Perform(action, idx1 := 0) {
    global gItems, gSel
    if (idx1 = 0) {
        idx1 := gSel
    }
    if (idx1 < 1 || idx1 > gItems.Length) {
        return
    }
    cur := gItems[idx1]

    if (action = "close") {
        ; TODO: Real close: PostMessage(WM_CLOSE) to cur.HWND
        _RemoveItemAt(idx1)
        return
    }
    if (action = "kill") {
        pid := cur.HasOwnProp("PID") ? cur.PID : "?"
        ttl := cur.HasOwnProp("Title") ? cur.Title : "window"
        if _ConfirmTopmost("Are you sure you want to TERMINATE process " pid " for '" ttl "'?", "Confirm terminate") {
            ; TODO: ProcessClose(pid)
            _RemoveItemAt(idx1)
        }
        return
    }

    if (action = "blacklist") {
        ttl := cur.HasOwnProp("Title") ? cur.Title : "window"
        cls := cur.HasOwnProp("Class") ? cur.Class : "?"
        if _ConfirmTopmost("Blacklist '" ttl "' from class '" cls "'?", "Confirm blacklist") {
            ; TODO: add to config/store
            _RemoveItemAt(idx1)
        }
        return
    }

}

; Mouse wheel scroll (row-based)
_OnOverlayWheel(wParam, lParam) {
    global gOverlayH, ScrollKeepHighlightOnTop
    delta := (wParam >> 16) & 0xFFFF
    if (delta >= 0x8000) {
        delta -= 0x10000
    }
    step := (delta > 0) ? -1 : 1  ; up = -1, down = +1

    if (ScrollKeepHighlightOnTop) {
        _MoveSelection(step)
    } else {
        _ScrollBy(step)
    }
}

_RevealBaseAndOverlayTogether() {
    global gBase, gBaseH, gOverlay, CornerRadiusPx, gRevealed
    if (gRevealed) {
        return
    }
    ; Re-apply rounded region once on-screen, then show both windows
    try _ApplyRoundRegion(gBaseH, CornerRadiusPx)
    try gBase.Show("NA")
    try gOverlay.Show("NA")
    try DllCall("dwmapi\DwmFlush")
    gRevealed := true
}


; ========================= MAIN =========================

; ========================= HOTKEYS =========================
Up:: {
    _MoveSelection(-1)
}
Down:: {
    _MoveSelection(1)
}

; C = Close (no confirmation)
;c:: {
;    global AllowCloseKeystroke
;    if (AllowCloseKeystroke) {
;        _Action_Perform("close")
;    }
;}

; K = Kill (confirm)
;k:: {
;    global AllowKillKeystroke
;    if (AllowKillKeystroke) {
;        _Action_Perform("kill")
;    }
;}

; B = Blacklist (confirm)
;b:: {
;    global AllowBlacklistKeystroke
;    if (AllowBlacklistKeystroke) {
;        _Action_Perform("blacklist")
;    }
;}

z:: {
    _HideOverlay()
}
x:: {
    _ShowOverlay()
}

; Q = cycle footer scope text (POC only)
q:: {
    global gFooterModes, gFooterModeIndex, gFooterText, gOverlayH, gItems, gSel
    gFooterModeIndex := (gFooterModeIndex >= gFooterModes.Length) ? 1 : (gFooterModeIndex + 1)
    gFooterText := gFooterModes[gFooterModeIndex]
    _Overlay_Repaint(gOverlayH, gItems, gSel)
}

--------------
Contents of switcher.ahk
--------------
﻿#Requires AutoHotkey v2.0
#SingleInstance Force
#UseHook true                          ; force hook for all keyboard hotkeys.

; Ensure the keyboard hook is up from the start (predictable ordering/behavior)
InstallKeybdHook(true)  ; v2 function — replaces #InstallKeybdHook directive.

; Prevent Alt/Win menu side-effects with an inert mask key (vkE8).
; AHK auto-masks Alt/Win-up after suppressed hotkeys; vkE8 has no side-effects. 
A_MenuMaskKey := "vkE8"

#Include config.ahk
#Include helpers.ahk ; provides _Log, RunTry, etc.
#Include komorebi.ahk ; include after helpers.ahk  ; uses _Log, RunTry
#Include komorebi_sub.ahk ; include after helpers.ahk AND after komorebi.ahk
#Include winenum.ahk
#Include mru.ahk
#Include ipc_targeted.ahk
#Include newgui.ahk
#Include altlogic.ahk 

ALTAB_Init()           ; start everything 
Komorebi_SubEnsure()
; Komorebi_DebugPing()   ; optional, do a debug ping at start of debug log
--------------
Contents of winenum.ahk
--------------
﻿; winenum.ahk — fast Z-order enumeration with DWM cloaking info
; Non-blocking debug: buffered + capped logging controlled by DebugBlacklist flag.

global _WN_all := []
global _WN_zCounter := 0
global _WN_shell := 0

; --- debug buffer + caps per enumeration pass ---
global _WN_logbuf := ""
global _WN_traceLeft := 0
global _WN_traceDeadline := 0

WinList_EnumerateAll() {
    global _WN_all, _WN_zCounter, _WN_shell
    global _WN_logbuf, _WN_traceLeft, _WN_traceDeadline

    ; Read globals without shadowing them
    dbg       := (IsSet(DebugBlacklist) && DebugBlacklist)
    maxLines  := IsSet(DebugMaxLinesPerSession) ? DebugMaxLinesPerSession : 200
    maxMillis := IsSet(DebugMaxDurationMs)      ? DebugMaxDurationMs      : 200

    DllCall("LoadLibrary", "str", "dwmapi.dll")
    _WN_shell := DllCall("user32\GetShellWindow", "ptr")
    _WN_zCounter := 0
    _WN_all := []

    ; prepare debug budget
    if (dbg) {
        _WN_logbuf := ""
        _WN_traceLeft := maxLines
        _WN_traceDeadline := A_TickCount + maxMillis
        _WN_Log("=== WinList_EnumerateAll (begin) ===")
    } else {
        _WN_logbuf := ""
        _WN_traceLeft := 0
        _WN_traceDeadline := 0
    }

    cb := CallbackCreate(_WN_EnumProc, "Fast", 2)
    DllCall("user32\EnumWindows", "ptr", cb, "ptr", 0, "int")
    CallbackFree(cb)

    if (dbg) {
        _WN_Log("=== WinList_EnumerateAll (end) ===")
        _WN_FlushLog()
    }
    return _WN_all
}

_WN_EnumProc(hWnd, lParam) {
    global _WN_all, _WN_zCounter, _WN_shell, BlacklistTitle, BlacklistClass, BlacklistPair, UseAltTabEligibility

    if (hWnd = 0)
        return 1
    if (hWnd = _WN_shell) {
        _WN_zCounter++
        return 1
    }

    ; Fast class/title pull
    cls := _GetClass(hWnd)
    ttl := _GetTitle(hWnd)

    ; ---------- HARD FILTER for GDI+ helper windows ----------
    if (_IsGdiPlusHelper(ttl, cls)) {
        _Trace("Skip GDI+ helper", ttl, cls)
        _WN_zCounter++
        return 1
    }
    ; ----------------------------------------------------------

    ; Early blacklist — class first, then title
    if (MatchAny(cls, BlacklistClass)) {
        _Trace("Hit Class list", ttl, cls)
        _WN_zCounter++
        return 1
    }
    if (!ttl) {
        _WN_zCounter++
        return 1
    }
    if (MatchAny(ttl, BlacklistTitle)) {
        _Trace("Hit Title list", ttl, cls)
        _WN_zCounter++
        return 1
    }
    if (MatchPairs(ttl, cls, BlacklistPair)) {
        _Trace("Hit Pair list", ttl, cls)
        _WN_zCounter++
        return 1
    }

    ; visibility / cloaked / minimized
    isVisible := !!DllCall("user32\IsWindowVisible", "ptr", hWnd, "int")
    isMin     := !!DllCall("user32\IsIconic",        "ptr", hWnd, "int")

    cloakedBuf := Buffer(4, 0)
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hWnd, "uint", 14, "ptr", cloakedBuf.Ptr, "uint", 4, "int")
    isCloaked := (hr = 0) && (NumGet(cloakedBuf, 0, "UInt") != 0)

    state := "WorkspaceHidden"
    if (isCloaked)
        state := "OtherWorkspace"
    else if (isMin)
        state := "WorkspaceMinimized"
    else if (isVisible)
        state := "WorkspaceShowing"

    pidBuf := Buffer(4, 0)
    DllCall("user32\GetWindowThreadProcessId", "ptr", hWnd, "ptr", pidBuf.Ptr, "uint")
    pid := NumGet(pidBuf, 0, "UInt")

    if (UseAltTabEligibility) {
        if !_IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) {
            _Trace("Ineligible (Alt-Tab rules)", ttl, cls)
            _WN_zCounter++
            return 1
        }
    }

    _WN_all.Push({ Hwnd: hWnd, Title: ttl, Class: cls, Pid: pid, State: state, ZOrder: _WN_zCounter })
    _WN_zCounter++
    return 1
}

_GetTitle(hWnd) {
    buf := Buffer(512*2, 0)
    DllCall("user32\GetWindowTextW", "ptr", hWnd, "ptr", buf.Ptr, "int", 512, "int")
    s := StrGet(buf.Ptr, "UTF-16")
    return Trim(RegExReplace(s, "[\r\n\t]+", " "))
}

_GetClass(hWnd) {
    buf := Buffer(256*2, 0)
    DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
    return StrGet(buf.Ptr, "UTF-16")
}

_IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) {
    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", -20, "ptr")
    WS_EX_TOOLWINDOW := 0x00000080
    WS_EX_APPWINDOW  := 0x00040000
    isTool := (ex & WS_EX_TOOLWINDOW) != 0
    isApp  := (ex & WS_EX_APPWINDOW)  != 0

    owner := DllCall("user32\GetWindow", "ptr", hWnd, "uint", 4, "ptr") ; GW_OWNER

    if (isTool)
        return false
    if !(owner = 0 || isApp)
        return false
    if !(isVisible || isMin || isCloaked)
        return false
    return true
}

; ---------- module-local helpers ----------

_IsGdiPlusHelper(ttl, cls) {
    ttlN := NormalizeMatchText(ttl)
    clsN := NormalizeMatchText(cls)
    if (clsN != "GDI+Hook Window Class")
        return false
    return RegExMatch(ttlN, "^GDI\+Window \([^)]+\)$")
}

_Trace(tag, ttl, cls) {
    global _WN_traceLeft, _WN_traceDeadline
    ; Check debug flags once per call (no shadowing)
    dbg := (IsSet(DebugBlacklist) && DebugBlacklist)
    if !dbg
        return
    if (_WN_traceLeft <= 0 || (_WN_traceDeadline && A_TickCount > _WN_traceDeadline))
        return
    _WN_traceLeft -= 3  ; each block ~3 lines budget
    _WN_Log("[" . tag . "]")
    _WN_Log("  Title: " . ttl)
    _WN_Log("  Class: " . cls)
}

_WN_Log(line) {
    global _WN_logbuf
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff")
    _WN_logbuf .= ts . "  " . line . "rn"
}

_WN_GetLogPath() {
    ; Prefer user-configured path
    if (IsSet(DebugLogPath) && DebugLogPath) {
        return DebugLogPath
    }
    return A_ScriptDir . "\tabby_debug.log"
}

_WN_FlushLog() {
    global _WN_logbuf
    if (_WN_logbuf = "")
        return

    path := _WN_GetLogPath()

    ; Ensure directory exists
    SplitPath path, , &dir
    if (dir != "")
        try DirCreate(dir)

    ; Try chosen path, then fallback to %TEMP%
    ok := false
    try {
        FileAppend(_WN_logbuf, path, "UTF-8")
        ok := true
    }
    catch {
        try {
            FileAppend(_WN_logbuf, A_Temp . "\tabby_debug.log", "UTF-8")
            ok := true
        }
        catch {
            ; give up
        }
    }

    _WN_logbuf := ""
}
--------------
You are assisting me in building in AHKv2 based alt-tab replacement. The obbsessive focus of this program is speed. Nothing should stop alt-tab from triggering, everything needs to be non-blocking and instant.

Remember the code is AHKv2 syntax, thats version 2 syntax.

When responding, dont give replacements for individual code lines. Do one of the following
1. Give function replements. Note the target file and function, then give replacement.
2. For truly new files, of course can output fully.

Ok, followed your last prompt. The program compiles and run.

But when I press alt+tab, the GUI doesnt come up. I dont know if thats from altlogic.ahk or the ipc from the interceptor, but whatever is supposed to trigger the gui is NOT

I left in for testing my z/x show/hide keys. When I use these to forceibly show the UI, it STILL does not contain any real PROCESS_QUERY_LIMITED_INFORMATION
and in fact contains all the test strings, meaning we still have test code in newgui.ahk.

So give me your commentary, but for code give me the
1. target file
2. FULL contents function ADD / REPLACE / REMOVE instructions

to remediate these issues
1. lack of gui on alt-tab
2. gui still containing randomly generated test strings 
ok, well, thats all cool but.
1. you didnt follow my instructions to give me FULL function ADD / REPLACES, you are given me partial functions and im getting lost
2. You didnt actually remediate the core issues I told you to tackle. The GUI isnt actually coming up when we alt-tab. plus if i force it with my z/x buttons, it still is full of our test strings. meaning its not pulling in real window information AND we still have unneeded test generation code

also I tried updating this function like you said:
NewGUI__QueueIconsForVisibleRows(list, selIndex) {
    global gIconQueue, gOverlayH, gScrollTop

    count := list.Length
    if (count <= 0)
        return

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0)
        vis := Min(RowsVisibleMax, count)

    ; Ensure viewport top is aligned to selection when requested
    start0 := __Wrap0(gScrollTop, count)
    i := 0
    ; Build list of visible indices with the selected one first
    order := []
    sel0 := __Wrap0(gScrollTop, count) + (gSelSnap - 1 = __Wrap0(gScrollTop, count) ? 0 : (gSelSnap - 1 - gScrollTop))
    selIdx0 := __Wrap0(gSelSnap - 1, count)

    ; selected first (if visible)
    start0 := __Wrap0(gScrollTop, count)
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) vis := Min(RowsVisibleMax, count)

    for i, k in (Range(0, vis-1)) {
        idx0 := __Wrap0(start0 + k, count)
        if (idx0 = selIdx0)
            order.Push(idx0)
    }
    for i, k in (Range(0, vis-1)) {
        idx0 := __Wrap0(start0 + k, count)
        if (idx0 != selIdx0)
            order.Push(idx0)
    }

    for _, idx0 in order {
        it := list[idx0 + 1]
        if (_Icon_GetCached(it.Hwnd) = 0 && WinExist("ahk_id " it.Hwnd))
            gIconQueue.Push(it.Hwnd)
    }

}

But I ended up breaking it 
NewGUI__QueueIconsForVisibleRows(list, selIndex) {
    global gIconQueue, gOverlayH, gScrollTop

    count := list.Length
    if (count <= 0)
        return

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0)
        vis := Min(RowsVisibleMax, count)

    ; Ensure viewport top is aligned to selection when requested
    start0 := __Wrap0(gScrollTop, count)
    i := 0
    ; Build list of visible indices with the selected one first
    order := []
    sel0 := __Wrap0(gScrollTop, count) + (gSelSnap - 1 = __Wrap0(gScrollTop, count) ? 0 : (gSelSnap - 1 - gScrollTop))
    selIdx0 := __Wrap0(gSelSnap - 1, count)

    ; selected first (if visible)
    start0 := __Wrap0(gScrollTop, count)
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) vis := Min(RowsVisibleMax, count)

    for i, k in (Range(0, vis-1)) {
        idx0 := __Wrap0(start0 + k, count)
        if (idx0 = selIdx0)
            order.Push(idx0)
    }
    for i, k in (Range(0, vis-1)) {
        idx0 := __Wrap0(start0 + k, count)
        if (idx0 != selIdx0)
            order.Push(idx0)
    }

    for _, idx0 in order {
        it := list[idx0 + 1]
        if (_Icon_GetCached(it.Hwnd) = 0 && WinExist("ahk_id " it.Hwnd))
            gIconQueue.Push(it.Hwnd)
    }

}
so can we fix this warn and address the 2 core issues please
while giving me FULL FUNCTION code

Error: This local variable declaration conflicts with an existing global variable.

Text:	OverlayEnabled
Line:	415
File:	C:\Users\codyj\Desktop\tabby\altlogic.ahk

The program will exit.
inside this while
    while (i < vis) {
        idx0 := __Wrap0(top0 + i, count)
        dup := false
        for _, v in order
            if (v = idx0) { 
                dup := true, break 
            }
        if (!dup)
            order.Push(idx0)
        i += 1
    }

get an error on
                dup := true, break 

the following reserver word 'break' must not be used as a variable name
yes, yes. working a bit better. a few more bugs on the merge to work out, but we are close now

 here is our newgui.ahk
--------------
#Requires AutoHotkey v2.0
; -----------------------------------------------------------------------------
; overlay_list_on_acrylic_poc_scroll_icons.ahk
; - Base: borderless acrylic (no flash)
; - Overlay: layered window same size/pos (catches all clicks), renders a simple
;            “virtual list” with columns + real icon + selection + scroll wheel.
;   Hotkeys:
;   Up/Down, Tab/Shift+Tab : change selection (keeps selection in view)
;   Mouse wheel            : scroll by rows
;   Z / X                  : hide / show overlay (POC toggle)
;   Q                      : cycle footer text (POC)
;   C / K / B              : close / kill (confirm) / blacklist (confirm)
;   Esc                    : exit
; -----------------------------------------------------------------------------

; Reveal both base + overlay together right after first painted frame
global gRevealed := false

global gHoverRow := 0        ; 1-based item index that the mouse is over; 0 = none
global gHoverBtn := ""       ; "", "close", "kill", "blacklist"

; persistent Graphics bound to the backbuffer HDC
global gG := 0

; Footer state (POC text cycle with Q)
global gFooterModes := ["All Windows", "XXX Windows", "XXX Visible Windows"]
global gFooterModeIndex := 1
global gFooterText := gFooterModes[gFooterModeIndex]


; ===== Overlay wiring compatibility (from oldgui) =====
global gGui := 0                  ; your overlay’s top-level GUI/window handle holder
global gOverlayOn := false
global gListSnap := []            ; last list handed to overlay
global gSelSnap := 1              ; last 1-based selection index

; ----- icon cache/pump (GUI-independent) -----
global gIconCache := Map()        ; hwnd -> { hicon: Ptr | 0, pid: UInt, class: Str }
global gIconQueue := []           ; hwnds pending resolution
global gIconPumpOn := false

; Use your existing config entries:
; OverlayTitle := "Switch"
; GUI_StateShort := true
; GUI_HWND_Hex := true
; UseIcons, IconBatchPerTick, IconTimerIntervalMs


; ========================= DEBUG =========================
global DebugGUI := false
global DebugLogPath := A_ScriptDir "\tabby_debug.log"

_DBG(msg) {
    if !DebugGUI {
        return
    }
    path := (DebugLogPath && DebugLogPath != "") ? DebugLogPath : (A_ScriptDir "\tabby_debug.log")
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss")
    SplitPath(path, , &dir)
    try DirCreate(dir)
    FileAppend(ts " | " msg "rn", path, "UTF-8")
}

_DWM_SetAttrInt(hWnd, attrId, value) {
    buf := Buffer(4, 0)
    NumPut("Int", value, buf, 0)
    hr := DllCall("dwmapi\DwmSetWindowAttribute"
        , "ptr", hWnd
        , "int", attrId
        , "ptr", buf.Ptr
        , "int", 4
        , "int")
    _DBG(Format("DWM attr{} val={} hr={}", attrId, value, hr))
    return hr
}

_ConfirmTopmost(text, title := "Confirm") {
    global gOverlayH  ; or gBaseH – either is fine; the owner just needs to be your UI
    res := MsgBox(text, title, "YesNo Icon! Default2 0x1000")
    return (res = "Yes" || res = 6) ; string ("Yes") or numeric (6) for compatibility
}

_FooterBlockDip() {
    global ShowFooter, FooterHeightPx, FooterGapTopPx
    return ShowFooter ? (FooterGapTopPx + FooterHeightPx) : 0
}


_DebugDump(hGui) {
    try _DBG("OS: " A_OSVersion)
    try {
        enabled := 0
        hr := DllCall("dwmapi\DwmIsCompositionEnabled", "int*", &enabled, "int")
        _DBG(Format("DwmIsCompositionEnabled={} hr={}", enabled, hr))
    }
    try {
        trans := RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", "EnableTransparency")
        if (trans = "") {
            trans := "N/A"
        }
        _DBG("EnableTransparency=" trans)
    }
    try {
        GWL_STYLE := -16, GWL_EXSTYLE := -20
        ex := DllCall("user32\GetWindowLongPtrW", "ptr", hGui, "int", GWL_EXSTYLE, "ptr")
        st := DllCall("user32\GetWindowLongPtrW", "ptr", hGui, "int", GWL_STYLE,   "ptr")
        _DBG(Format("GUI style=0x{:X} exstyle=0x{:X}", st, ex))
    }
}

; ========================= NEWGUI PUBLIC SHIMS (ADD) =========================
global __HooksInstalled := false
global __InitOnce := false

NewGUI__EnsureCreated() {
    global __InitOnce, __HooksInstalled
    global gBase, gBaseH, gOverlay, gOverlayH, gGui
    global OverlayTitle, AlwaysOnTop
    global AcrylicAlpha, AcrylicBaseRgb, CornerRadiusPx
    global gListSnap

    if (__InitOnce && gBaseH && gOverlayH)
        return

    ; --- init DPI & GDI+ once ---
    _InitDpiAwareness()
    __Gdip_Startup()

    ; --- compute initial size from current list (or minimum) ---
    rowsDesired := _ComputeRowsToShow(IsObject(gListSnap) ? gListSnap.Length : RowsVisibleMin)
    winX := 0, winY := 0, winW := 0, winH := 0
    _GetWindowRectFromConfig(&winX, &winY, &winW, &winH, rowsDesired)

    ; --- create base (titled) window; this will be our public "GUI" handle ---
    opts := "-Caption"
    if (IsSet(AlwaysOnTop) && AlwaysOnTop)
        opts := "+AlwaysOnTop " . opts
    gBase := Gui(opts, OverlayTitle)
    _StageAndRevealAcrylic(gBase, winX, winY, winW, winH, AcrylicAlpha, AcrylicBaseRgb, CornerRadiusPx, false)
    gBaseH := gBase.Hwnd

    ; Expose the same top-level handle symbol the old code used.
    gGui := gBaseH

    ; --- layered overlay for the painted list ---
    gOverlay  := _Overlay_Create(gBaseH)
    gOverlayH := gOverlay.Hwnd

    ; --- minimal hooks (mouse + wheel + DPI) once ---
    if !__HooksInstalled {
        OnMessage(0x02E0, _OnDpiChanged) ; WM_DPICHANGED
        OnMessage(0x0200, (wParam, lParam, msg, hwnd) => (
            hwnd = gOverlayH ? ( _OnOverlayMouseMove(wParam, lParam, msg, hwnd), 0 ) : 0
        )) ; WM_MOUSEMOVE
        OnMessage(0x0201, (wParam, lParam, msg, hwnd) => (
            hwnd = gOverlayH ? ( _OnOverlayClick(lParam & 0xFFFF, (lParam >> 16) & 0xFFFF), 0 ) : 0
        )) ; WM_LBUTTONDOWN
        OnMessage(0x020A, (wParam, lParam, msg, hwnd) => (
            hwnd = gOverlayH ? ( _OnOverlayWheel(wParam, lParam), 0 ) : 0
        )) ; WM_MOUSEWHEEL
        __HooksInstalled := true
    }

    __InitOnce := true
}

NewGUI__RebuildFromList(list, selIndex) {
    global gItems, gSel, gScrollTop, gOverlayH

    ; build row models strictly from provided list (no test strings)
    gItems := []
    total := list.Length
    if (total > 0) {
        i := 1
        while (i <= total) {
            gItems.Push( NewGUI__BuildRowModel(list[i], i, total) )
            i += 1
        }
    }

    ; selection + viewport
    if (total = 0) {
        gSel := 1
        gScrollTop := 0
    } else {
        if (selIndex < 1) selIndex := 1
        if (selIndex > total) selIndex := total
        gSel := selIndex
        if (IsSet(ScrollKeepHighlightOnTop) && ScrollKeepHighlightOnTop)
            gScrollTop := gSel - 1
        else
            _EnsureVisible(total)  ; your existing helper
    }

    ; resize and paint
    rowsDesired := _ComputeRowsToShow(total)
    _ResizeWindowToRows(rowsDesired)
    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


NewGUI__UpdateSelection(list, selIndex) {
    ; Rebuild (safe & simple; keeps columns/state fresh as windows change)
    NewGUI__RebuildFromList(list, selIndex)
}

NewGUI__QueueIconsForVisibleRows(list, selIndex) {
    global gIconQueue, gOverlayH, gScrollTop, RowsVisibleMax

    count := list.Length
    if (count <= 0)
        return

    ; how many rows are currently visible on the overlay
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0)
        vis := Min(RowsVisibleMax, count)

    ; viewport top (0-based), and selected row (0-based)
    top0 := __Wrap0(gScrollTop, count)
    sel0 := __Wrap0(selIndex - 1, count)

    ; order = selected (if visible) first, then the rest of the visible rows
    seen  := Map()   ; 0-based idx -> true
    order := []

    ; selected first if it's in the visible window
    i := 0
    while (i < vis) {
        idx0 := __Wrap0(top0 + i, count)
        if (idx0 = sel0) {
            order.Push(idx0)
            seen[idx0] := true
            break
        }
        i += 1
    }

    ; then the rest, in viewport order, skipping what we've already added
    i := 0
    while (i < vis) {
        idx0 := __Wrap0(top0 + i, count)
        if !seen.Has(idx0) {
            order.Push(idx0)
            seen[idx0] := true
        }
        i += 1
    }

    ; enqueue icon resolves for rows that lack a cached icon and still exist
    for _, idx0 in order {
        it := list[idx0 + 1]              ; convert 0-based -> 1-based
        if (_Icon_GetCached(it.Hwnd) = 0 && WinExist("ahk_id " it.Hwnd)) {
            gIconQueue.Push(it.Hwnd)
        }
    }
}



NewGUI__InvalidateVisibleRows(list, selIndex) {
    global gOverlayH, gItems, gSel
    _Overlay_Repaint(gOverlayH, gItems, gSel)
}

NewGUI__Show() {
    global gBase, gOverlay
    ; Show both immediately (no “first-paint” gate so Alt+Tab never stalls)
    try gBase.Show("NA")
    try gOverlay.Show("NA")
}

NewGUI__Hide() {
    global gBase, gOverlay
    try gOverlay.Hide()
    try gBase.Hide()
}

_GetVisibleRowsFromOverlay() {
    global gOverlayH, RowHeight, MarginY
    try {
        cx := 0, cy := 0, cw := 0, ch := 0
        WinGetClientPos &cx, &cy, &cw, &ch, "ahk_id " gOverlayH
        listArea := ch - (MarginY + _HeaderBlockDip() + _FooterBlockDip() + MarginY)
        if (listArea <= 0)
            return 0
        return Max(0, Floor(listArea / RowHeight))
    } catch {
        return 0
    }
}



; ======= OLD to NEW API SHIM ========
; ======= OLD to NEW API SHIM ========
Overlay_ShowList(list, selIndex) {
    global gGui, gOverlayOn, gListSnap, gSelSnap, UseIcons, OverlayTitle, AlwaysOnTop

    ; snapshot real list/selection (no test data)
    gListSnap := IsObject(list) ? list : []
    gSelSnap  := (selIndex >= 1 ? selIndex : 1)

    ; ensure overlay exists
    NewGUI__EnsureCreated()
    try WinSetTitle(OverlayTitle, "ahk_id " gGui)
    if (IsSet(AlwaysOnTop) && AlwaysOnTop)
        try WinSetAlwaysOnTop(1, "ahk_id " gGui)

    ; build rows from the real list (no dummy generation)
    NewGUI__RebuildFromList(gListSnap, gSelSnap)

    ; icon prefetch for currently visible rows
    if (IsSet(UseIcons) && UseIcons) {
        NewGUI__QueueIconsForVisibleRows(gListSnap, gSelSnap)
        _Icon_StartPump()
    }

    ; show right now
    NewGUI__Show()
    gOverlayOn := true
}


Overlay_UpdateSelection(list, selIndex) {
    global gListSnap, gSelSnap, UseIcons

    if (!IsObject(list))
        list := []

    ; cheap skip if nothing changed that the painter would notice
    if (gSelSnap = selIndex && gListSnap.Length = list.Length) {
        if (IsSet(UseIcons) && UseIcons)
            NewGUI__QueueIconsForVisibleRows(gListSnap, gSelSnap)
        return
    }

    gListSnap := list
    gSelSnap  := selIndex

    NewGUI__UpdateSelection(gListSnap, gSelSnap)

    if (IsSet(UseIcons) && UseIcons)
        NewGUI__QueueIconsForVisibleRows(gListSnap, gSelSnap)
}


Overlay_Hide() {
    global gGui, gOverlayOn
    gOverlayOn := false
    NewGUI__Hide()                                   ; your hide/destroy path
    ; Optional: _Icon_ClearCache() if you want to free HICONs aggressively
}

; Returns a plain object with what your painter needs for a row
; Returns a plain object the painter uses for a row (ADD/REPLACE)
NewGUI__BuildRowModel(item, idx, total) {
    ; Main + sub
    main := item.Title
    if (StrLen(main) > 140)
        main := SubStr(main, 1, 137) . "..."
    sub  := _StateShort(item.State)

    ; Column text
    hwndStr := (IsSet(GUI_HWND_Hex) && GUI_HWND_Hex)
        ? ("0x" . Format("{:X}", item.Hwnd))
        : (item.Hwnd . "")
    ws := _GetWorkspaceForHwnd(item.Hwnd)

    ; Icon handle if cached (0 until pump resolves)
    hico := _Icon_GetCached(item.Hwnd)

    ; Include both display columns and raw fields so existing code (close/kill placeholders)
    ; can use HWND/PID/Class safely later.
    return {
        Number: "[" idx "/" total "]",
        Title:  main,
        Sub:    sub,
        Col2:   hwndStr,       ; HWND (formatted)
        Col3:   item.Pid,      ; PID
        Col4:   ws,            ; Workspace name
        Col5:   item.ZOrder,   ; Win#
        Col6:   item.Class,    ; Class
        HICON:  hico,

        ; raw passthroughs for actions / future wiring
        HWND:   item.Hwnd,
        PID:    item.Pid,
        Class:  item.Class,
        State:  item.State,
        ZOrder: item.ZOrder
    }
}


;========= ICONS =============
_Icon_GetCached(hwnd) {
    global gIconCache
    return (gIconCache.Has(hwnd) && gIconCache[hwnd].hicon) ? gIconCache[hwnd].hicon : 0
}

_Icon_StartPump() {
    global gIconPumpOn, IconTimerIntervalMs
    if (gIconPumpOn)
        return
    gIconPumpOn := true
    SetTimer(_Icon_Pump, IconTimerIntervalMs)
}

_Icon_Pump() {
    global gIconPumpOn, gIconQueue, IconBatchPerTick, gIconCache, gOverlayOn, gListSnap, gSelSnap

    if (!gOverlayOn) {
        gIconQueue := []
        gIconPumpOn := false
        SetTimer(_Icon_Pump, 0)
        return
    }

    ; resolve a few per tick
    count := 0
    changed := false
    while (gIconQueue.Length && count < IconBatchPerTick) {
        hwnd := gIconQueue.RemoveAt(1)
        if (gIconCache.Has(hwnd)) {
            count += 1
            continue
        }

        pid := 0, cls := ""
        for _, it in gListSnap {           ; fast linear scan OK for small page
            if (it.Hwnd = hwnd) {
                pid := it.Pid
                cls := it.Class
                break
            }
        }

        hico := _Icon_ResolveSmall(hwnd)
        if (!hico) {
            ; attempt from process exe if window didn’t return one
            if (pid) {
                exe := _Icon_GetProcessPath(pid)
                if (exe) {
                    hSmall := 0, hLarge := 0
                    DllCall("Shell32\ExtractIconExW","wstr",exe,"int",0,"ptr*", &hLarge,"ptr*", &hSmall,"uint",1)
                    if (hSmall) {
                        if (hLarge) DllCall("user32\DestroyIcon","ptr",hLarge)
                        hico := hSmall
                    } else if (hLarge) {
                        hico := hLarge
                    }
                }
            }
        }

        gIconCache[hwnd] := { hicon: (hico ? hico : 0), pid: pid, class: cls }
        changed := changed || (hico != 0)
        count += 1
    }

    if (!gIconQueue.Length) {
        gIconPumpOn := false
        SetTimer(_Icon_Pump, 0)
    }

    if (changed) {
        ; Ask your view to redraw only visible rows
        NewGUI__InvalidateVisibleRows(gListSnap, gSelSnap)
    }
}

_Icon_ResolveSmall(hWnd) {
    if !WinExist("ahk_id " . hWnd)
        return 0
    WM_GETICON := 0x7F
    ICON_SMALL2 := 2, ICON_SMALL := 0, ICON_BIG := 1
    try {
        h := SendMessage(WM_GETICON, ICON_SMALL2, 0, , "ahk_id " . hWnd)
        if (!h) h := SendMessage(WM_GETICON, ICON_SMALL, 0, , "ahk_id " . hWnd)
        if (!h) h := SendMessage(WM_GETICON, ICON_BIG,   0, , "ahk_id " . hWnd)
        if (h) {
            return h
        }
    }
    h := DllCall("user32\GetClassLongPtrW","ptr",hWnd,"int",-34,"ptr") ; GCLP_HICONSM
    if (!h) h := DllCall("user32\GetClassLongPtrW","ptr",hWnd,"int",-14,"ptr") ; GCLP_HICON
    return h ? h : 0
}

_Icon_GetProcessPath(pid) {
    PROCESS_QUERY_LIMITED_INFORMATION := 0x1000
    hProc := DllCall("kernel32\OpenProcess","uint",PROCESS_QUERY_LIMITED_INFORMATION,"int",0,"uint",pid,"ptr")
    if (!hProc) {
        return ""
    }
    buf := Buffer(32767 * 2, 0), sz := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW","ptr",hProc,"uint",0,"ptr",buf.Ptr,"uint*",sz,"int")
    DllCall("kernel32\CloseHandle","ptr",hProc)
    return ok ? StrGet(buf.Ptr, "UTF-16") : ""
}

_Icon_ClearCache() {
    global gIconCache
    for hwnd, meta in gIconCache {
        if (meta.hicon)
            DllCall("user32\DestroyIcon","ptr",meta.hicon)
    }
    gIconCache := Map()
}



; ========================= WINDOW HELPERS =========================
_TryEnableDarkTitleBar(hWnd) {
    try _DWM_SetAttrInt(hWnd, 20, 1)  ; DWMWA_USE_IMMERSIVE_DARK_MODE (new)
    try _DWM_SetAttrInt(hWnd, 19, 1)  ; DWMWA_USE_IMMERSIVE_DARK_MODE (old)
}

_SetCornerPreference(hWnd, pref := 2) {
    ; 1=DoNotRound, 2=Round, 3=Small
    try _DWM_SetAttrInt(hWnd, 33, pref)  ; DWMWA_WINDOW_CORNER_PREFERENCE
}


_LoadTestIcon() {
    global gIconImg
    ; Try explorer.exe (most reliable), fall back to shell32.dll
    gIconImg := __LoadGpIconFromFile(A_WinDir "\explorer.exe", 0)
    if (!gIconImg) {
        gIconImg := __LoadGpIconFromFile(A_WinDir "\System32\shell32.dll", 4)
    }
}

_StateShort(s) {
    if !(IsSet(GUI_StateShort) && GUI_StateShort)
        return s
    sw := StrLower(Trim(s))
    if (sw = "workspaceshowing")      {
        return "WS-Shown"
        }
    else if (sw = "workspaceminimized") {
        return "WS-Min"
    }
    else if (sw = "workspacehidden")   {

     return "WS-Hidden"
    }
    else if (sw = "otherworkspace")    {
     return "Other-WS"
    }
    return s
}

_GetWorkspaceForHwnd(hwnd) {
    ws := ""
    try {
        if Komorebi_SubTryMap(hwnd, &ws) && (ws != "")
            return ws
    } catch {
    }
    return ""
}

_WrapIndex(idx, len) {
    if (len <= 0) {
        return 1
    }
    n := Mod(idx - 1, len)
    if (n < 0) n += len
    return n + 1
}


_GetIconLeftMarginDip(scale) {
    global IconLeftMargin
    try {
        return Round(IconLeftMargin * scale)
    } catch {
        return 0
    }
}

; Keep hover state (row + which button) aligned with the current cursor
; even if rows move due to scroll/selection changes.
_RecalcHoverFromCurrentCursor() {
    global gOverlayH, gHoverRow, gHoverBtn
    if (!gOverlayH) {
        return false
    }
    ; Get cursor in screen coords
    pt := Buffer(8, 0)
    if !DllCall("user32\GetCursorPos", "ptr", pt) {
        return false
    }
    ; Convert to overlay client coords (physical px)
    if !DllCall("user32\ScreenToClient", "ptr", gOverlayH, "ptr", pt.Ptr) {
        return false
    }
    x := NumGet(pt, 0, "Int")
    y := NumGet(pt, 4, "Int")

    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)

    changed := (idx != gHoverRow || act != gHoverBtn)
    gHoverRow := idx
    gHoverBtn := act
    return changed
}


_HeaderBlockDip() {
    ; 32 == 4px top pad + 28px header line height
    global ShowHeader
    return ShowHeader ? 32 : 0
}

__FontStyleFromWeight(w) {
    ; GDI+ style: 0=Regular, 1=Bold
    try {
        return (w+0 >= 600) ? 1 : 0
    } catch {
        return 0
    }
}

_EnsureGraphics() {
    global gBackHdc, gG
    ; If there's no backbuffer DC, we can't make a Graphics
    if (!gBackHdc) {
        return 0
    }
    ; Always rebuild the GDI+ Graphics from the CURRENT backbuffer HDC.
    ; This avoids intermittently using a Graphics tied to an old/invalid surface.
    if (gG) {
        try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
        gG := 0
    }
    DllCall("gdiplus\GdipCreateFromHDC", "ptr", gBackHdc, "ptr*", &gG)
    if (!gG) {
        return 0
    }
    SmoothingModeAntiAlias := 4
    TextRenderingHintClearTypeGridFit := 5
    DllCall("gdiplus\GdipSetSmoothingMode", "ptr", gG, "int", SmoothingModeAntiAlias)
    DllCall("gdiplus\GdipSetTextRenderingHint", "ptr", gG, "int", TextRenderingHintClearTypeGridFit)
    return gG
}

__Wrap0(i, count) {
    ; returns 0..count-1 (handles negative i)
    if (count <= 0) {
        return 0
    }
    r := Mod(i, count)
    if (r < 0) {
        r := r + count
    }
    return r
}

__Wrap1(i, count) {
    ; returns 1..count (handles negative i)
    if (count <= 0) {
        return 0
    }
    r := Mod(i - 1, count)
    if (r < 0) {
        r := r + count
    }
    return r + 1
}


__GetWorkAreaFromHwndPhys(hWnd, &left, &top, &right, &bottom) {
    MONITOR_DEFAULTTONEAREST := 2
    hMon := DllCall("user32\MonitorFromWindow", "ptr", hWnd, "uint", MONITOR_DEFAULTTONEAREST, "ptr")
    if (!hMon) {
        left := top := right := bottom := 0
        return
    }
    ; MONITORINFO is 40 bytes: cbSize(4) + rcMonitor(16) + rcWork(16) + dwFlags(4)
    mi := Buffer(40, 0)
    NumPut("UInt", 40, mi, 0) ; cbSize
    if !DllCall("user32\GetMonitorInfoW", "ptr", hMon, "ptr", mi.Ptr, "int") {
        left := top := right := bottom := 0
        return
    }
    ; rcWork at offset 20
    left   := NumGet(mi, 20, "Int")
    top    := NumGet(mi, 24, "Int")
    right  := NumGet(mi, 28, "Int")
    bottom := NumGet(mi, 32, "Int")
}

_RandomSpacedText(minTotal := 5, maxTotal := 20, minRun := 4, maxRun := 8) {
    total := Round(Random(minTotal, maxTotal))
    out := ""
    run := 0
    nextBreak := Round(Random(minRun, maxRun))

    while (StrLen(out) < total) {
        if (run >= nextBreak) {
            if (StrLen(out) + 1 > total) {
                break
            }
            out .= " "
            run := 0
            nextBreak := Round(Random(minRun, maxRun))
        } else {
            ; a–z
            ch := Chr(Round(Random(97, 122)))
            out .= ch
            run += 1
        }
    }
    if (StrLen(out) > total) {
        out := SubStr(out, 1, total)
    }
    return RTrim(out)
}

__SetWindowPosPhys(hWnd, xPhys, yPhys, wPhys, hPhys) {
    SWP_NOZORDER      := 0x0004
    SWP_NOOWNERZORDER := 0x0200
    SWP_NOACTIVATE    := 0x0010
    flags := SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOACTIVATE
    return DllCall("user32\SetWindowPos"
        , "ptr", hWnd
        , "ptr", 0
        , "int", xPhys
        , "int", yPhys
        , "int", wPhys
        , "int", hPhys
        , "uint", flags
        , "int")
}

; Per-monitor scale from a RECT (all params are PHYSICAL px)
__GetMonitorScaleFromRect(left, top, right, bottom) {
    ; Build RECT
    rc := Buffer(16, 0)
    NumPut("Int", left,   rc, 0)
    NumPut("Int", top,    rc, 4)
    NumPut("Int", right,  rc, 8)
    NumPut("Int", bottom, rc, 12)

    ; Get HMONITOR for this rect
    MONITOR_DEFAULTTONEAREST := 2
    hMon := DllCall("user32\MonitorFromRect", "ptr", rc.Ptr, "uint", MONITOR_DEFAULTTONEAREST, "ptr")

    ; shcore!GetDpiForMonitor → effective DPI for that monitor
    dpiX := 0, dpiY := 0
    success := false
    try {
        hr := DllCall("shcore\GetDpiForMonitor", "ptr", hMon, "int", 0, "uint*", &dpiX, "uint*", &dpiY, "int") ; MDT_EFFECTIVE_DPI=0
        if (hr = 0 && dpiX > 0) {
            success := true
        }
    }
    if (success) {
        return dpiX / 96.0
    }
    ; Fallback: system DPI
    return __GetSystemScale()
}

; System DPI → scale (physical / 96)
__GetSystemScale() {
    dpi := 0
    try {
        dpi := DllCall("user32\GetDpiForSystem", "uint")
    }
    if (!dpi) {
        dpi := A_ScreenDPI
    }
    return dpi / 96.0
}

; GetWindowRect in PHYSICAL pixels (no DPI math needed here)
__GetWindowRectPhys(hWnd, &x, &y, &w, &h) {
    rc := Buffer(16, 0) ; RECT {left,top,right,bottom}
    ok := DllCall("user32\GetWindowRect", "ptr", hWnd, "ptr", rc.Ptr, "int")
    if (!ok) {
        x := y := w := h := 0
        return
    }
    left   := NumGet(rc, 0, "Int")
    top    := NumGet(rc, 4, "Int")
    right  := NumGet(rc, 8, "Int")
    bottom := NumGet(rc, 12, "Int")
    x := left
    y := top
    w := right - left
    h := bottom - top
}


_ComputeRowsToShow(count) {
    global RowsVisibleMin, RowsVisibleMax
    if (RowsVisibleMax < RowsVisibleMin) {
        ; guard: swap if user misconfigures
        tmp := RowsVisibleMin
        RowsVisibleMin := RowsVisibleMax
        RowsVisibleMax := tmp
    }
    if (count >= RowsVisibleMax)
        return RowsVisibleMax
    if (count > RowsVisibleMin)
        return count
    return RowsVisibleMin
}

_ResizeWindowToRows(rowsToShow) {
    global gBase, gBaseH, gOverlay, gOverlayH, CornerRadiusPx

    ; Compute centered x/y/w/h (DIPs) on the SAME monitor as the base window
    xDip := 0, yDip := 0, wDip := 0, hDip := 0
    _GetWindowRectForWindowMonitor(&xDip, &yDip, &wDip, &hDip, rowsToShow, gBaseH)

    ; Convert those DIPs to PHYSICAL px for exact positioning without DPI drift
    ; Use the work area of the base window's monitor to get its scale
    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(gBaseH, &waL, &waT, &waR, &waB)
    monScale := __GetMonitorScaleFromRect(waL, waT, waR, waB)

    xPhys := Round(xDip * monScale)
    yPhys := Round(yDip * monScale)
    wPhys := Round(wDip * monScale)
    hPhys := Round(hDip * monScale)

    ; Physically move/resize both windows in lockstep (no Show() coords → no DPI hops)
    __SetWindowPosPhys(gBaseH,   xPhys, yPhys, wPhys, hPhys)
    __SetWindowPosPhys(gOverlayH, xPhys, yPhys, wPhys, hPhys)

    ; Re-apply rounded region using DIP sizes so the region matches the visual
    _ApplyRoundRegion(gBaseH, CornerRadiusPx, wDip, hDip)

    ; Make sure composition commits before the next layered blit
    try DllCall("dwmapi\DwmFlush")
}

__GetScaleForWindow(hWnd) {
    dpi := 0
    try {
        dpi := DllCall("user32\GetDpiForWindow", "ptr", hWnd, "uint")
    }
    if (!dpi) {
        dpi := A_ScreenDPI ; fallback
    }
    return dpi / 96.0
}

_InitDpiAwareness() {
    ; Prefer Per-Monitor V2; fall back gracefully if unavailable.
    try {
        ; DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 = -4
        DllCall("user32\SetProcessDpiAwarenessContext", "ptr", -4, "ptr")
    } catch {
        try {
            ; PROCESS_PER_MONITOR_DPI_AWARE = 2
            DllCall("shcore\SetProcessDpiAwareness", "int", 2, "int")
        } catch {
            ; Last resort: system-DPI aware
            try DllCall("user32\SetProcessDPIAware")
        }
    }
}

_GetWindowRectFromConfig(&x, &y, &w, &h, rowsToShow := "") {
    global ScreenWidthPct, RowHeight, MarginY

    if (rowsToShow == "" || rowsToShow < 1) {
        global RowsVisibleMin
        rowsToShow := RowsVisibleMin
    }

    left := 0, top := 0, right := 0, bottom := 0
    MonitorGetWorkArea(0, &left, &top, &right, &bottom)
    waW_phys := right - left
    waH_phys := bottom - top

    monScale := __GetMonitorScaleFromRect(left, top, right, bottom)

    pct := ScreenWidthPct
    if (pct <= 0)
        pct := 0.10
    if (pct > 1.0)
        pct := pct / 100.0

    waW_dip := waW_phys / monScale
    waH_dip := waH_phys / monScale
    left_dip := left / monScale
    top_dip  := top  / monScale

    w := Round(waW_dip * pct)

    headerBlock := _HeaderBlockDip()
    footerBlock := _FooterBlockDip()
    h := MarginY + headerBlock + rowsToShow * RowHeight + footerBlock + MarginY

    x := Round(left_dip + (waW_dip - w) / 2)
    y := Round(top_dip  + (waH_dip - h) / 2)
}

_ApplyRoundRegion(hWnd, radiusPx, optW := 0, optH := 0) {
    if (!hWnd || radiusPx <= 0) {
        return
    }

    local wx := 0, wy := 0, ww := 0, wh := 0
    local cx := 0, cy := 0, cw := 0, ch := 0
    local hrgn := 0

    if (optW > 0 && optH > 0) {
        ww := optW
        wh := optH
    } else {
        try {
            WinGetClientPos(&cx, &cy, &cw, &ch, "ahk_id " hWnd)
            if (cw > 0 && ch > 0) {
                ww := cw
                wh := ch
            }
        }
        if (ww <= 0 || wh <= 0) {
            try WinGetPos(&wx, &wy, &ww, &wh, "ahk_id " hWnd)
        }
    }

    if (ww <= 0 || wh <= 0) {
        return
    }

    hrgn := DllCall("gdi32\CreateRoundRectRgn"
        , "int", 0, "int", 0
        , "int", ww + 1, "int", wh + 1
        , "int", radiusPx * 2, "int", radiusPx * 2
        , "ptr")
    if (hrgn) {
        DllCall("user32\SetWindowRgn", "ptr", hWnd, "ptr", hrgn, "int", 1)
    }
}

_ForceNoLayered(hWnd) {
    GWL_EXSTYLE   := -20
    WS_EX_LAYERED := 0x00080000
    try {
        ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", GWL_EXSTYLE, "ptr")
        if (ex & WS_EX_LAYERED) {
            ex := ex & ~WS_EX_LAYERED
            DllCall("user32\SetWindowLongPtrW", "ptr", hWnd, "int", GWL_EXSTYLE, "ptr", ex, "ptr")
            SWP_NOSIZE := 0x0001, SWP_NOMOVE := 0x0002, SWP_NOZORDER := 0x0004, SWP_FRAMECHANGED := 0x0020
            flags := SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED
            DllCall("user32\SetWindowPos", "ptr", hWnd, "ptr", 0, "int", 0, "int", 0, "int", 0, "int", 0, "uint", flags)
            _DBG("Removed WS_EX_LAYERED.")
        }
    }
}

; Prevent default white erase (stop flash)
global __BASE_HGUI := 0
__OnEraseBk(wParam, lParam, msg, hwnd) {
    global __BASE_HGUI
    if (__BASE_HGUI && hwnd = __BASE_HGUI) {
        return 1
    }
    return 0
}
_InstallEraseBkSwallow(hWnd) {
    global __BASE_HGUI
    __BASE_HGUI := hWnd
    OnMessage(0x0014, __OnEraseBk) ; WM_ERASEBKGND
}

; ---- Perf caches (drawing + scale) ----
global gCurScale := 1.0              ; current monitor scale for our window
global gResScale := 0.0              ; scale the GDI+ resources were built for
global gRes := Map()                 ; cached GDI+ resources: brushes, fonts, families, formats

; Persistent ARGB backbuffer (reused every paint)
global gBackHdc := 0, gBackHBM := 0, gBackPrev := 0, gBackW := 0, gBackH := 0

; Paint/resize throttles
global gLastRowsDesired := -1

; -------- Scale cache + DPI hook --------
_EnsureScaleCache() {
    global gCurScale, gBaseH
    s := __GetScaleForWindow(gBaseH)
    if (s <= 0) {
        s := 1.0
    }
    gCurScale := s
}

_OnDpiChanged(wParam, lParam, msg, hwnd) {
    global gResScale
    _EnsureScaleCache()
    ; Invalidate resource cache (rebuild next paint)
    gResScale := 0.0
    return 0
}

; -------- Backbuffer management (top-down 32bpp ARGB DIB) --------
_EnsureBackbuffer(wPhys, hPhys) {
    global gBackHdc, gBackHBM, gBackPrev, gBackW, gBackH, gG

    ; Create the memory DC once
    if (!gBackHdc) {
        gBackHdc := DllCall("gdi32\CreateCompatibleDC", "ptr", 0, "ptr")
        if (gG) {
            try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
            gG := 0
        }
    }

    ; Hidden/just-shown windows can briefly report 0x0; clamp to >=1
    wPhys := Max(1, wPhys)
    hPhys := Max(1, hPhys)

    ; No change → keep current surface
    if (wPhys = gBackW && hPhys = gBackH && gBackHBM) {
        return
    }

    ; Replace bitmap surface
    if (gBackHBM) {
        DllCall("gdi32\SelectObject", "ptr", gBackHdc, "ptr", gBackPrev, "ptr")
        DllCall("gdi32\DeleteObject", "ptr", gBackHBM)
        gBackHBM := 0
    }

    ; Build a new top-down 32bpp DIB section
    bi := Buffer(40, 0)
    NumPut("UInt", 40, bi, 0)          ; biSize
    NumPut("Int",  wPhys, bi, 4)       ; biWidth
    NumPut("Int", -hPhys, bi, 8)       ; biHeight (negative => top-down)
    NumPut("UShort", 1,  bi, 12)       ; biPlanes
    NumPut("UShort", 32, bi, 14)       ; biBitCount
    NumPut("UInt", 0,  bi, 16)         ; biCompression = BI_RGB

    pvBits := 0
    gBackHBM := DllCall("gdi32\CreateDIBSection"
        , "ptr", gBackHdc, "ptr", bi.Ptr, "uint", 0, "ptr*", &pvBits, "ptr", 0, "uint", 0, "ptr")
    gBackPrev := DllCall("gdi32\SelectObject", "ptr", gBackHdc, "ptr", gBackHBM, "ptr")

    ; Invalidate any Graphics tied to the old surface to avoid AV on next paint
    if (gG) {
        try DllCall("gdiplus\GdipDeleteGraphics", "ptr", gG)
        gG := 0
    }

    gBackW := wPhys
    gBackH := hPhys
}

; -------- GDI+ resource cache (fonts/brushes/formats) --------
_DisposeGdipResources() {
    global gRes, gResScale
    if !gRes.Count {
        gResScale := 0.0
        return
    }
    for k in ["brMain","brMainHi","brSub","brSubHi","brCol","brColHi","brHdr","brHit","brFooterText"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteBrush", "ptr", gRes[k])
    }
    for k in ["fMain","fMainHi","fSub","fSubHi","fCol","fColHi","fHdr","fAction","fFooter"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteFont", "ptr", gRes[k])
    }
    for k in ["ffMain","ffMainHi","ffSub","ffSubHi","ffCol","ffColHi","ffHdr","ffAction","ffFooter"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteFontFamily", "ptr", gRes[k])
    }
    for k in ["fmt","fmtCenter","fmtRight","fmtLeft","fmtLeftCol","fmtFooterLeft","fmtFooterCenter","fmtFooterRight"] {
        if (gRes.Has(k) && gRes[k])
            DllCall("gdiplus\GdipDeleteStringFormat", "ptr", gRes[k])
    }
    ; NEW: dispose any cached scaled icon
    if (gRes.Has("iconScaled") && gRes["iconScaled"]) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", gRes["iconScaled"])
    }
    gRes := Map()
    gResScale := 0.0
}


__PointInRect(px, py, x, y, w, h) {
    return (px >= x && px < x + w && py >= y && py < y + h)
}

__Gdip_StrokeRoundRect(g, argb, x, y, w, h, r, width := 1) {
    if (w <= 0 || h <= 0) {
        return
    }
    pPath := 0, pPen := 0
    r2 := r * 2.0
    DllCall("gdiplus\GdipCreatePath", "int", 0, "ptr*", &pPath)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y,           "float", r2, "float", r2, "float", 180.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + r,      "float", y,           "float", x + w - r, "float", y)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y,           "float", r2, "float", r2, "float", 270.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w,      "float", y + r,       "float", x + w, "float", y + h - r)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y + h - r2,  "float", r2, "float", r2, "float", 0.0,   "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w - r,  "float", y + h,       "float", x + r, "float", y + h)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y + h - r2,  "float", r2, "float", r2, "float", 90.0,  "float", 90.0)
    DllCall("gdiplus\GdipClosePathFigure", "ptr", pPath)
    DllCall("gdiplus\GdipCreatePen1", "int", argb, "float", width, "int", 2, "ptr*", &pPen) ; UnitPixel=2
    DllCall("gdiplus\GdipDrawPath", "ptr", g, "ptr", pPen, "ptr", pPath)
    if (pPen)  {
      DllCall("gdiplus\GdipDeletePen",  "ptr", pPen)
    }
    if (pPath) {
      DllCall("gdiplus\GdipDeletePath", "ptr", pPath)
    }
}

__Gdip_DrawCenteredTextRect(g, text, x, y, w, h, argb, font) {
    global gRes
    rf := Buffer(16, 0)
    NumPut("Float", x, rf, 0), NumPut("Float", y, rf, 4), NumPut("Float", w, rf, 8), NumPut("Float", h, rf, 12)
    br := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &br)
    DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", gRes["fmtCenter"], "ptr", br)
    if (br) {
      DllCall("gdiplus\GdipDeleteBrush", "ptr", br)
    }
}

__DrawActionButtons(g, wPhys, yRow, rowHPhys, scale, isHoveredRow := true) {
    global ShowCloseButton, ShowKillButton, ShowBlacklistButton
    global ActionBtnSizePx, ActionBtnGapPx, ActionBtnRadiusPx, MarginX
    global CloseButtonBGARGB, CloseButtonBGHoverARGB, CloseButtonBorderARGB, CloseButtonBorderPx
         , CloseButtonTextARGB, CloseButtonTextHoverARGB, CloseButtonGlyph
    global KillButtonBGARGB,  KillButtonBGHoverARGB,  KillButtonBorderARGB,  KillButtonBorderPx
         , KillButtonTextARGB, KillButtonTextHoverARGB, KillButtonGlyph
    global BlacklistButtonBGARGB, BlacklistButtonBGHoverARGB, BlacklistButtonBorderARGB, BlacklistButtonBorderPx
         , BlacklistButtonTextARGB, BlacklistButtonTextHoverARGB, BlacklistButtonGlyph
    global gHoverBtn, gRes

    size := Max(12, Round(ActionBtnSizePx * scale))
    gap  := Max(2,  Round(ActionBtnGapPx  * scale))
    rad  := Max(2,  Round(ActionBtnRadiusPx * scale))
    marR := Round(MarginX * scale)

    x := wPhys - marR - size
    y := yRow + (rowHPhys - size) // 2

    drawOne(name, glyph, bg, bgH, text, textH, border, borderPx) {
        local w := size, h := size, hovered := (gHoverBtn = name && isHoveredRow)
        local bgCol := hovered ? bgH : bg
        local txCol := hovered ? textH : text
        __Gdip_FillRoundRect(g, bgCol, x, y, w, h, rad)
        if (borderPx > 0) {
            __Gdip_StrokeRoundRect(g, border, x+0.5, y+0.5, w-1, h-1, rad, Max(1, Round(borderPx*scale)))
        }
        __Gdip_DrawCenteredTextRect(g, glyph, x, y, w, h, txCol, gRes["fAction"])
        x := x - (w + gap)
        return x
    }

    ; Order: Close (rightmost), then Kill, then Blacklist
    if (ShowCloseButton) {
        x := drawOne("close", CloseButtonGlyph, CloseButtonBGARGB, CloseButtonBGHoverARGB
            , CloseButtonTextARGB, CloseButtonTextHoverARGB, CloseButtonBorderARGB, CloseButtonBorderPx)
    }
    if (ShowKillButton) {
        x := drawOne("kill", KillButtonGlyph, KillButtonBGARGB, KillButtonBGHoverARGB
            , KillButtonTextARGB, KillButtonTextHoverARGB, KillButtonBorderARGB, KillButtonBorderPx)
    }
    if (ShowBlacklistButton) {
        x := drawOne("blacklist", BlacklistButtonGlyph, BlacklistButtonBGARGB, BlacklistButtonBGHoverARGB
            , BlacklistButtonTextARGB, BlacklistButtonTextHoverARGB, BlacklistButtonBorderARGB, BlacklistButtonBorderPx)
    }
}


_EnsureGdipResources(scale) {
    global gRes, gResScale
    if (Abs(gResScale - scale) < 0.001 && gRes.Count) {
        return
    }
    _DisposeGdipResources()
    __Gdip_Startup()

    ; ---- Brushes ----
    global MainARGB, MainARGBHi, SubARGB, SubARGBHi, ColARGB, ColARGBHi, HdrARGB, FooterTextARGB
    br := 0
    for _ in [ ["brMain",    MainARGB]
             , ["brMainHi",  MainARGBHi]
             , ["brSub",     SubARGB]
             , ["brSubHi",   SubARGBHi]
             , ["brCol",     ColARGB]
             , ["brColHi",   ColARGBHi]
             , ["brHdr",     HdrARGB]
             , ["brHit",     0x01000000]
             , ["brFooterText", FooterTextARGB] ] {
        DllCall("gdiplus\GdipCreateSolidFill", "int", _[2], "ptr*", &br)
        gRes[ _[1] ] := br, br := 0
    }

    ; ---- Fonts ----
    global MainFontName, MainFontSize, MainFontWeight
         , MainFontNameHi, MainFontSizeHi, MainFontWeightHi
         , SubFontName,  SubFontSize,  SubFontWeight
         , SubFontNameHi,SubFontSizeHi,SubFontWeightHi
         , ColFontName,  ColFontSize,  ColFontWeight
         , ColFontNameHi,ColFontSizeHi,ColFontWeightHi
         , HdrFontName,  HdrFontSize,  HdrFontWeight
         , ActionFontName, ActionFontSize, ActionFontWeight
         , FooterFontName, FooterFontSize, FooterFontWeight

    UnitPixel := 2
    mkFont(name, size, weight, keyFam, keyFont) {
        local fam := 0, f := 0, style := __FontStyleFromWeight(weight)
        DllCall("gdiplus\GdipCreateFontFamilyFromName", "wstr", name, "ptr", 0, "ptr*", &fam)
        DllCall("gdiplus\GdipCreateFont", "ptr", fam, "float", size*scale, "int", style, "int", UnitPixel, "ptr*", &f)
        gRes[keyFam]  := fam
        gRes[keyFont] := f
    }
    mkFont(MainFontName,    MainFontSize,    MainFontWeight,    "ffMain",   "fMain")
    mkFont(MainFontNameHi,  MainFontSizeHi,  MainFontWeightHi,  "ffMainHi", "fMainHi")
    mkFont(SubFontName,     SubFontSize,     SubFontWeight,     "ffSub",    "fSub")
    mkFont(SubFontNameHi,   SubFontSizeHi,   SubFontWeightHi,   "ffSubHi",  "fSubHi")
    mkFont(ColFontName,     ColFontSize,     ColFontWeight,     "ffCol",    "fCol")
    mkFont(ColFontNameHi,   ColFontSizeHi,   ColFontWeightHi,   "ffColHi",  "fColHi")
    mkFont(HdrFontName,     HdrFontSize,     HdrFontWeight,     "ffHdr",    "fHdr")
    mkFont(ActionFontName,  ActionFontSize,  ActionFontWeight,  "ffAction", "fAction")
    mkFont(FooterFontName,  FooterFontSize,  FooterFontWeight,  "ffFooter", "fFooter")

    ; ---- String formats (create independent instances; do NOT use GenericDefault) ----
    StringAlignmentNear := 0, StringAlignmentCenter := 1, StringAlignmentFar := 2
    StringFormatFlagsNoWrap := 0x00001000
    StringFormatFlagsNoClip := 0x00004000
    StringTrimmingEllipsisCharacter := 3
    flags := StringFormatFlagsNoWrap | StringFormatFlagsNoClip

    mkFmt(&out, align, valign) {
        out := 0
        ; independent instance
        DllCall("gdiplus\GdipCreateStringFormat", "int", 0, "ushort", 0, "ptr*", &out)
        DllCall("gdiplus\GdipSetStringFormatFlags",     "ptr", out, "int", flags)
        DllCall("gdiplus\GdipSetStringFormatTrimming",  "ptr", out, "int", StringTrimmingEllipsisCharacter)
        DllCall("gdiplus\GdipSetStringFormatAlign",     "ptr", out, "int", align)
        DllCall("gdiplus\GdipSetStringFormatLineAlign", "ptr", out, "int", valign)
    }

    ; General text formats
    fmt := 0, fmtC := 0, fmtR := 0, fmtLcol := 0
    mkFmt(&fmt,     StringAlignmentNear,   StringAlignmentNear)    ; left/top
    mkFmt(&fmtC,    StringAlignmentCenter, StringAlignmentNear)    ; center/top
    mkFmt(&fmtR,    StringAlignmentFar,    StringAlignmentNear)    ; right/top
    mkFmt(&fmtLcol, StringAlignmentNear,   StringAlignmentNear)    ; explicit left for Column 1

    gRes["fmt"]        := fmt
    gRes["fmtCenter"]  := fmtC
    gRes["fmtRight"]   := fmtR
    gRes["fmtLeft"]    := fmtLcol
    gRes["fmtLeftCol"] := fmtLcol   ; alias used by list/headers

    ; Footer formats (vertical center looks nicer)
    fL := 0, fC := 0, fR := 0
    mkFmt(&fL, StringAlignmentNear,   StringAlignmentCenter)   ; left/center
    mkFmt(&fC, StringAlignmentCenter, StringAlignmentCenter)   ; center/center
    mkFmt(&fR, StringAlignmentFar,    StringAlignmentCenter)   ; right/center
    gRes["fmtFooterLeft"]   := fL
    gRes["fmtFooterCenter"] := fC
    gRes["fmtFooterRight"]  := fR

    gResScale := scale
}


_EnsureScaledIcon(scale, ISize, pSrcIcon) {
    global gRes
    if (!pSrcIcon || ISize <= 0) {
        return 0
    }
    if (gRes.Has("iconScaled") && gRes["iconScaled"] && gRes.Has("iconScalePx") && gRes["iconScalePx"] = ISize) {
        return gRes["iconScaled"]
    }
    ; Dispose previous
    if (gRes.Has("iconScaled") && gRes["iconScaled"]) {
        DllCall("gdiplus\GdipDisposeImage", "ptr", gRes["iconScaled"])
        gRes["iconScaled"] := 0
    }

    PixelFormat32bppPARGB := 0x26200A
    pDst := 0, g2 := 0
    DllCall("gdiplus\GdipCreateBitmapFromScan0", "int", ISize, "int", ISize, "int", 0, "int", PixelFormat32bppPARGB, "ptr", 0, "ptr*", &pDst)
    DllCall("gdiplus\GdipGetImageGraphicsContext", "ptr", pDst, "ptr*", &g2)
    ; Interpolation high-quality for visual parity with GDI+ scaling in DrawImageRectI
    InterpolationModeHighQualityBicubic := 7
    DllCall("gdiplus\GdipSetInterpolationMode", "ptr", g2, "int", InterpolationModeHighQualityBicubic)
    DllCall("gdiplus\GdipDrawImageRectI", "ptr", g2, "ptr", pSrcIcon, "int", 0, "int", 0, "int", ISize, "int", ISize)
    if (g2) {
        DllCall("gdiplus\GdipDeleteGraphics", "ptr", g2)
    }

    gRes["iconScaled"] := pDst
    gRes["iconScalePx"] := ISize
    return pDst
}


; -------- Paint directly into backbuffer using GDI+ over HDC --------
; -------- Paint directly into backbuffer using GDI+ over HDC (REPLACE) --------
__Gdip_PaintOverlay(items, selIndex, wPhys, hPhys, scrollTop := "", pIcon := 0, scale := 1.0) {
    global RowHeight, MarginX, MarginY, IconSize, RowRadius, SelARGB
         , gScrollTop, gIconImg, ShowHeader, EmptyListText
         , ColFixed2, ColFixed3, ColFixed4, ColFixed5, ColFixed6
         , Col2Name, Col3Name, Col4Name, Col5Name, Col6Name
         , gHoverRow, MainARGB, ShowFooter, FooterHeightPx, FooterGapTopPx

    _EnsureGdipResources(scale)
    global gRes, gBackHdc

    g := _EnsureGraphics()
    if (!g)
        return

    ; Clear + full-surface hit matte
    DllCall("gdiplus\GdipGraphicsClear", "ptr", g, "int", 0x00000000)
    DllCall("gdiplus\GdipFillRectangle", "ptr", g, "ptr", gRes["brHit"], "float", 0, "float", 0, "float", wPhys, "float", hPhys)

    if (scrollTop == "")
        scrollTop := gScrollTop
    if (!pIcon && IsSet(gIconImg) && gIconImg)
        pIcon := gIconImg

    fmtLeft := (gRes.Has("fmtLeft") && gRes["fmtLeft"]) ? gRes["fmtLeft"] : gRes["fmt"]

    ; ---- Metrics (PHYSICAL px) ----
    RowH    := Max(1, Round(RowHeight * scale))
    Mx      := Round(MarginX  * scale)
    My      := Round(MarginY  * scale)
    ISize   := Round(IconSize * scale)
    Rad     := Round(RowRadius * scale)
    gapText := Round(12 * scale)
    gapCols := Round(10 * scale)
    hdrY4   := Round(4  * scale)
    hdrH28  := Round(28 * scale)

    iconLeftDip := _GetIconLeftMarginDip(scale)

    y     := My
    leftX := Mx + iconLeftDip
    textX := leftX + ISize + gapText

    ; Right-side columns (use consistent keys Col2..Col6)
    cols := []
    Col6W := Round(ColFixed6 * scale), Col5W := Round(ColFixed5 * scale)
    Col4W := Round(ColFixed4 * scale), Col3W := Round(ColFixed3 * scale)
    Col2W := Round(ColFixed2 * scale)

    rightX := wPhys - Mx
    if (Col6W > 0) { 
        x := rightX - Col6W, cols.Push({name:Col6Name, w:Col6W, key:"Col6", x:x}), rightX := x - gapCols 
    }
    if (Col5W > 0) { 
        x := rightX - Col5W, cols.Push({name:Col5Name, w:Col5W, key:"Col5", x:x}), rightX := x - gapCols
     }
    if (Col4W > 0) { 
        x := rightX - Col4W, cols.Push({name:Col4Name, w:Col4W, key:"Col4", x:x}), rightX := x - gapCols 
    }
    if (Col3W > 0) { 
        x := rightX - Col3W, cols.Push({name:Col3Name, w:Col3W, key:"Col3", x:x}), rightX := x - gapCols
     }
    if (Col2W > 0) { 
        x := rightX - Col2W, cols.Push({name:Col2Name, w:Col2W, key:"Col2", x:x}), rightX := x - gapCols 
    }

    textW := (rightX - Round(16*scale)) - textX
    if (textW < 0)
        textW := 0

    ; ---- Optional header ----
    if (ShowHeader) {
        hdrY := y + hdrY4
        __Gdip_DrawText(g, "Title", textX, hdrY, textW, Round(20*scale), gRes["brHdr"], gRes["fHdr"], fmtLeft)
        for _, col in cols {
            __Gdip_DrawText(g, col.name, col.x, hdrY, col.w, Round(20*scale), gRes["brHdr"], gRes["fHdr"], gRes["fmt"])
        }
        y += hdrH28
    }

    contentTopY := y
    count := items.Length

    ; Compute available rows area (reserve space for footer if shown)
    footerH := ShowFooter ? Round(FooterHeightPx * scale) : 0
    footerGap := ShowFooter ? Round(FooterGapTopPx * scale) : 0
    availH := hPhys - My - contentTopY - footerH - footerGap
    if (availH < 0)
        availH := 0

    rowsCap := (availH > 0) ? Floor(availH / RowH) : 0
    rowsToDraw := (count <= rowsCap) ? count : rowsCap

    ; ---- Empty list ----
    if (count = 0) {
        rectX := Mx
        rectW := wPhys - 2*Mx
        rectH := RowH
        rectY := contentTopY + Max(0, (availH - rectH) // 2)
        __Gdip_DrawCenteredTextRect(g, EmptyListText, rectX, rectY, rectW, rectH, MainARGB, gRes["fMain"])
        ; still draw footer (below)
    } else if (rowsToDraw > 0) {
        start0 := __Wrap0(scrollTop, count)
        i := 0
        yRow := y

        while (i < rowsToDraw && (yRow + RowH <= contentTopY + availH)) {
            idx0 := __Wrap0(start0 + i, count)
            idx1 := idx0 + 1
            cur  := items[idx1]
            isSel := (idx1 = selIndex)

            if (isSel)
                __Gdip_FillRoundRect(g, SelARGB, Mx - Round(4*scale), yRow - Round(2*scale), wPhys - 2*Mx + Round(8*scale), RowH, Rad)

            ; ---- Icon (per row) ----
            ix := leftX
            iy := yRow + (RowH - ISize)//2
            drewIcon := false
            if (cur.HasOwnProp("HICON") && cur.HICON) {
                pImg := 0
                DllCall("gdiplus\GdipCreateBitmapFromHICON", "ptr", cur.HICON, "ptr*", &pImg)
                if (pImg) {
                    DllCall("gdiplus\GdipDrawImageRectI", "ptr", g, "ptr", pImg, "int", ix, "int", iy, "int", ISize, "int", ISize)
                    DllCall("gdiplus\GdipDisposeImage", "ptr", pImg)
                    drewIcon := true
                }
            }
            if (!drewIcon) {
                if (pIcon) {
                    DllCall("gdiplus\GdipDrawImageRectI", "ptr", g, "ptr", pIcon, "int", ix, "int", iy, "int", ISize, "int", ISize)
                } else {
                    __Gdip_FillEllipse(g, __ARGB_FromIndex(idx1), ix, iy, ISize, ISize)
                }
            }

            ; ---- Text (main + sub) ----
            fMainUse  := isSel ? gRes["fMainHi"] : gRes["fMain"]
            fSubUse   := isSel ? gRes["fSubHi"]  : gRes["fSub"]
            fColUse   := isSel ? gRes["fColHi"]  : gRes["fCol"]
            brMainUse := isSel ? gRes["brMainHi"] : gRes["brMain"]
            brSubUse  := isSel ? gRes["brSubHi"]  : gRes["brSub"]
            brColUse  := isSel ? gRes["brColHi"]  : gRes["brCol"]

            title := cur.HasOwnProp("Title") ? cur.Title : ""
            __Gdip_DrawText(g, title, textX, yRow + Round(6*scale),  textW, Round(24*scale), brMainUse, fMainUse, fmtLeft)

            sub := cur.HasOwnProp("Sub") ? cur.Sub : ""
            __Gdip_DrawText(g, sub,   textX, yRow + Round(28*scale), textW, Round(18*scale), brSubUse,  fSubUse,  fmtLeft)

            ; ---- Right columns ----
            for _, col in cols {
                val := cur.HasOwnProp(col.key) ? cur.%col.key% : ""
                __Gdip_DrawText(g, val, col.x, yRow + Round(10*scale), col.w, Round(20*scale), brColUse, fColUse, gRes["fmt"])
            }

            ; ---- Row actions on hover ----
            if (idx1 = gHoverRow) {
                __DrawActionButtons(g, wPhys, yRow, RowH, scale, true)
            }

            yRow += RowH
            i += 1
        }
    }

    ; virtual scrollbar if needed
    if (count > rowsToDraw && rowsToDraw > 0) {
        __DrawVirtualScrollbar(g, wPhys, contentTopY, rowsToDraw, RowH, scrollTop, count, scale)
    }

    ; Footer (bottom anchored)
    if (ShowFooter) {
        _DrawFooter(g, wPhys, hPhys, scale)
    }
}


_DetectActionAtPoint(xPhys, yPhys, &action, &idx1) {
    global gItems, gScrollTop, gOverlayH, MarginY, RowHeight
    global ShowCloseButton, ShowKillButton, ShowBlacklistButton
    global ActionBtnSizePx, ActionBtnGapPx, MarginX

    action := "", idx1 := 0
    count := gItems.Length
    if (count <= 0) {
        return
    }

    scale := __GetScaleForWindow(gOverlayH)
    RowH := Max(1, Round(RowHeight * scale))
    My   := Round(MarginY  * scale)
    hdr  := Round(_HeaderBlockDip() * scale)
    topY := My + hdr

    if (yPhys < topY) {
        return
    }

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    local rel := yPhys - topY
    local rowVis := Floor(rel / RowH) + 1
    if (rowVis < 1 || rowVis > vis) {
        return
    }

    ; 1-based item index under cursor (wrap-aware viewport)
    local idx0 := __Wrap0(gScrollTop + (rowVis - 1), count)
    idx1 := idx0 + 1

    ; Build button rects (right aligned)
    size := Max(12, Round(ActionBtnSizePx * scale))
    gap  := Max(2,  Round(ActionBtnGapPx  * scale))
    marR := Round(MarginX * scale)

    ox := 0, oy := 0, ow := 0, oh := 0
    __GetWindowRectPhys(gOverlayH, &ox, &oy, &ow, &oh)

    x := ow - marR - size
    y := topY + (rowVis - 1) * RowH + (RowH - size) // 2

    ; Test in order: Close (rightmost), Kill, Blacklist
    if (ShowCloseButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "close"
        return
    }
    x := x - (size + gap)
    if (ShowKillButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "kill"
        return
    }
    x := x - (size + gap)
    if (ShowBlacklistButton && __PointInRect(xPhys, yPhys, x, y, size, size)) {
        action := "blacklist"
        return
    }
}

; ========================= ACRYLIC (ACCENT) =========================
ApplyAccentAcrylic(hWnd, alpha, baseRgb) {
    bb := (baseRgb >> 16) & 0xFF
    gg := (baseRgb >> 8)  & 0xFF
    rr := (baseRgb)       & 0xFF
    grad := (alpha << 24) | (bb << 16) | (gg << 8) | rr  ; 0xAABBGGRR

    ACCENT_ENABLE_ACRYLICBLURBEHIND := 4
    accent := Buffer(16, 0)
    NumPut("Int", ACCENT_ENABLE_ACRYLICBLURBEHIND, accent, 0)
    NumPut("Int", 0, accent, 4)
    NumPut("Int", grad, accent, 8)
    NumPut("Int", 0, accent, 12)

    WCA_ACCENT_POLICY := 19
    data := Buffer(A_PtrSize * 3, 0)
    NumPut("Int", WCA_ACCENT_POLICY, data, 0)
    NumPut("Ptr", accent.Ptr,        data, A_PtrSize)
    NumPut("Int", accent.Size,       data, A_PtrSize*2)

    ok := DllCall("user32\SetWindowCompositionAttribute", "ptr", hWnd, "ptr", data.Ptr, "int")
    _DBG("SetWindowCompositionAttribute(Acrylic) ok=" ok " alpha=" alpha " baseRgb=0x" Format("{:06X}", baseRgb))
    return ok
}

; ========================= STAGE + REVEAL (no flash) =========================
_StageAndRevealAcrylic(guiObj, x, y, wDip, hDip, alpha, baseRgb, cornerRadius, revealNow := true) {
    ; 1) Create/size hidden (width/height only, let AHK/DWM establish actual size)
    guiObj.Show("Hide w" wDip " h" hDip)
    hWnd := guiObj.Hwnd

    ; 2) Read actual PHYSICAL window size now
    curX := 0, curY := 0, curW := 0, curH := 0
    __GetWindowRectPhys(hWnd, &curX, &curY, &curW, &curH)

    ; 3) Get the work area of the monitor this window is on (PHYSICAL)
    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(hWnd, &waL, &waT, &waR, &waB)
    waW := waR - waL
    waH := waB - waT

    ; 4) Compute perfect physical center and move (still hidden → no flash)
    tgtX := waL + (waW - curW) // 2
    tgtY := waT + (waH - curH) // 2
    __SetWindowPosPhys(hWnd, tgtX, tgtY, curW, curH)

    ; 5) Cosmetics (after size is final)
    _TryEnableDarkTitleBar(hWnd)
    _SetCornerPreference(hWnd, 2)
    _ForceNoLayered(hWnd)
    _InstallEraseBkSwallow(hWnd)
    _ApplyRoundRegion(hWnd, cornerRadius, wDip, hDip)

    ; 6) Apply acrylic
    ApplyAccentAcrylic(hWnd, alpha, baseRgb)
    try DllCall("dwmapi\DwmFlush")

    ; 7) Reveal now or defer for a synchronized reveal with overlay
    if (revealNow) {
        guiObj.Show("NA")
        SetTimer(() => _ApplyRoundRegion(hWnd, cornerRadius), -1)
    }
}


; ========================= GDI+ HELPERS =========================
__Gdip_Startup() {
    ; Start GDI+ once; keep the token internally (and mirror to a global for shutdown).
    static token := 0
    if (token)
        return token

    si := Buffer(A_PtrSize=8 ? 24 : 16, 0)  ; GdiplusStartupInput
    NumPut("UInt", 1, si, 0)                ; version = 1

    status := DllCall("gdiplus\GdiplusStartup", "ptr*", &token, "ptr", si.Ptr, "ptr", 0, "int")
    if (status = 0 && token) {
        global gGdipToken
        gGdipToken := token   ; optional mirror for shutdown visibility
        return token
    }
    return 0
}

__Gdip_FillRoundRect(g, argb, x, y, w, h, r) {
    if (w <= 0 || h <= 0) {
        return
    }
    if (r <= 0) {
        pBr := 0
        DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
        DllCall("gdiplus\GdipFillRectangle", "ptr", g, "ptr", pBr, "float", x, "float", y, "float", w, "float", h)
        if (pBr) {
            DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
        }
        return
    }
    pPath := 0
    pBr   := 0
    r2    := r * 2.0
    DllCall("gdiplus\GdipCreatePath", "int", 0, "ptr*", &pPath)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y,           "float", r2, "float", r2, "float", 180.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + r,      "float", y,           "float", x + w - r, "float", y)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y,           "float", r2, "float", r2, "float", 270.0, "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w,      "float", y + r,       "float", x + w, "float", y + h - r)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x + w - r2, "float", y + h - r2,  "float", r2, "float", r2, "float", 0.0,   "float", 90.0)
    DllCall("gdiplus\GdipAddPathLine", "ptr", pPath, "float", x + w - r,  "float", y + h,       "float", x + r, "float", y + h)
    DllCall("gdiplus\GdipAddPathArc",  "ptr", pPath, "float", x,          "float", y + h - r2,  "float", r2, "float", r2, "float", 90.0,  "float", 90.0)
    DllCall("gdiplus\GdipClosePathFigure", "ptr", pPath)
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
    DllCall("gdiplus\GdipFillPath", "ptr", g, "ptr", pBr, "ptr", pPath)
    if (pBr) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
    }
    if (pPath) {
        DllCall("gdiplus\GdipDeletePath",  "ptr", pPath)
    }
}

__Gdip_DrawText(g, text, x, y, w, h, br, font, fmt) {
    rf := Buffer(16, 0)
    NumPut("Float", x, rf, 0)
    NumPut("Float", y, rf, 4)
    NumPut("Float", w, rf, 8)
    NumPut("Float", h, rf, 12)
    DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", fmt, "ptr", br)
}

__Gdip_FillEllipse(g, argb, x, y, w, h) {
    pBr := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", argb, "ptr*", &pBr)
    DllCall("gdiplus\GdipFillEllipse", "ptr", g, "ptr", pBr, "float", x, "float", y, "float", w, "float", h)
    if (pBr) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", pBr)
    }
}

; ===== Icon loading (explorer.exe) → GDI+ image =====
__LoadGpIconFromFile(path, index := 0) {
    __Gdip_Startup()
    hIconLarge := 0
    got := DllCall("shell32\ExtractIconExW", "wstr", path, "int", index, "ptr*", &hIconLarge, "ptr", 0, "uint", 1, "uint")
    if (got = 0 || !hIconLarge) {
        return 0
    }
    pImg := 0
    DllCall("gdiplus\GdipCreateBitmapFromHICON", "ptr", hIconLarge, "ptr*", &pImg)
    DllCall("user32\DestroyIcon", "ptr", hIconLarge)
    return pImg  ; caller must GdipDisposeImage
}

__DrawVirtualScrollbar(g, wPhys, contentTopY, rowsDrawn, rowHPhys, scrollTop, count, scale) {
    global ScrollBarEnabled, ScrollBarWidthPx, ScrollBarMarginRightPx
         , ScrollBarThumbARGB, ScrollBarGutterEnabled, ScrollBarGutterARGB

    if (!ScrollBarEnabled) {
        return
    }
    if (count <= 0 || rowsDrawn <= 0 || rowHPhys <= 0) {
        return
    }

    ; viewport and track geometry (PHYSICAL px)
    trackH := rowsDrawn * rowHPhys
    if (trackH <= 0) {
        return
    }
    trackW := Max(2, Round(ScrollBarWidthPx * scale))
    marR   := Max(0, Round(ScrollBarMarginRightPx * scale))
    x      := wPhys - marR - trackW
    y      := contentTopY
    r      := trackW // 2  ; pill radius

    ; thumb size scales by visible/count (min height guard)
    visCount := rowsDrawn
    thumbH := Max(3, Floor(trackH * visCount / count))

    ; wrap-aware start (0..count-1)
    start0 := __Wrap0(scrollTop, count)
    startRatio := start0 / count
    y1 := y + Floor(startRatio * trackH)
    y2 := y1 + thumbH
    yEnd := y + trackH

    ; brushes
    brThumb := 0, brGutter := 0
    DllCall("gdiplus\GdipCreateSolidFill", "int", ScrollBarThumbARGB, "ptr*", &brThumb)

    if (ScrollBarGutterEnabled) {
        DllCall("gdiplus\GdipCreateSolidFill", "int", ScrollBarGutterARGB, "ptr*", &brGutter)
        __Gdip_FillRoundRect(g, ScrollBarGutterARGB, x, y, trackW, trackH, r)
    }

    ; draw thumb (1 or 2 segments if wrapping across end → top)
    if (y2 <= yEnd) {
        __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y1, trackW, thumbH, r)
    } else {
        ; segment 1: bottom tail
        h1 := yEnd - y1
        if (h1 > 0) {
            __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y1, trackW, h1, r)
        }
        ; segment 2: wrap to top
        h2 := y2 - yEnd
        if (h2 > 0) {
            __Gdip_FillRoundRect(g, ScrollBarThumbARGB, x, y, trackW, h2, r)
        }
    }

    if (brThumb)  {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", brThumb)
    }
    if (brGutter) {
        DllCall("gdiplus\GdipDeleteBrush", "ptr", brGutter)
    }
}


__ARGB_FromIndex(i) {
    ; fallback colored circle (unused if icon loads)
    r := (37 * i)  & 0xFF
    g := (71 * i)  & 0xFF
    b := (113 * i) & 0xFF
    return (0xCC << 24) | (r << 16) | (g << 8) | b
}

; ========================= OVERLAY (layered) =========================
global gBase := 0, gOverlay := 0, gBaseH := 0, gOverlayH := 0
global gItems := [], gSel := 1
global gScrollTop := 0
global gIconImg := 0

_BuildSampleItems() {
    arr := []
    ; vary count a bit to simulate changing results
    count := Round(Random(4, 12))
    i := 1
    while (i <= count) {
        hwnd := Format("0x{:X}", 0x10000 + Round(Random(1000, 99999)))
        title := _RandomSpacedText(5, 20, 4, 8)
        arr.Push({
            Title: title,
            Class: "Class" i,
            HWND:  hwnd,
            PID:   "" Round(Random(500, 99999))
        })
        i += 1
    }
    return arr
}

_HideOverlay() {
    global gBase, gOverlay
    try gOverlay.Hide()
    try gBase.Hide()
}

_ShowOverlay() {
    global gBase, gBaseH, gOverlay, gOverlayH, gItems, gSel, gScrollTop

    ; simulate changed contents each time we show
    gItems := _BuildSampleItems()
    gSel := 1
    gScrollTop := 0

    ; Ensure the base is visible/sized so GetWindowRect returns valid dimensions
    try gBase.Show("NA")

    ; Force size/rows to match new item count before repaint (ensures non-zero backbuffer)
    rowsDesired := _ComputeRowsToShow(gItems.Length)
    _ResizeWindowToRows(rowsDesired)

    ; Now (re)paint and reveal overlay
    _Overlay_Repaint(gOverlayH, gItems, gSel)
    try gOverlay.Show("NA")
    try DllCall("dwmapi\DwmFlush")
}

_Overlay_Create(ownerHwnd) {
    ; Create overlay as hidden first to avoid any black flash before first paint
    ov := Gui("+AlwaysOnTop -Caption +ToolWindow +Owner" ownerHwnd)
    ov.Show("Hide")

    ; Match owner (base) window position/size in PHYSICAL pixels
    ox := 0, oy := 0, ow := 0, oh := 0
    __GetWindowRectPhys(ownerHwnd, &ox, &oy, &ow, &oh)
    __SetWindowPosPhys(ov.Hwnd, ox, oy, ow, oh)

    return ov
}

_GetWindowRectForWindowMonitor(&x, &y, &w, &h, rowsToShow, hWnd) {
    global ScreenWidthPct, RowHeight, MarginY

    waL := 0, waT := 0, waR := 0, waB := 0
    __GetWorkAreaFromHwndPhys(hWnd, &waL, &waT, &waR, &waB)

    monScale := __GetMonitorScaleFromRect(waL, waT, waR, waB)

    waW_dip := (waR - waL) / monScale
    waH_dip := (waB - waT) / monScale
    left_dip := waL / monScale
    top_dip  := waT / monScale

    pct := ScreenWidthPct
    if (pct <= 0)
        pct := 0.10
    if (pct > 1.0)
        pct := pct / 100.0

    w := Round(waW_dip * pct)

    headerBlock := _HeaderBlockDip()
    footerBlock := _FooterBlockDip()
    h := MarginY + headerBlock + rowsToShow * RowHeight + footerBlock + MarginY

    x := Round(left_dip + (waW_dip - w) / 2)
    y := Round(top_dip  + (waH_dip - h) / 2)
}

_DrawFooter(g, wPhys, hPhys, scale) {
    global ShowFooter, FooterHeightPx, FooterGapTopPx, FooterBGARGB, FooterBGRadius
         , FooterBorderPx, FooterBorderARGB, FooterPaddingX, FooterTextAlign
         , FooterTextARGB, MarginX, MarginY, gFooterText, gRes

    if (!ShowFooter)
        return

    fh := Max(1, Round(FooterHeightPx * scale))
    mx := Round(MarginX * scale)
    my := Round(MarginY * scale)

    x := mx
    y := hPhys - my - fh
    w := wPhys - 2*mx
    r := Max(0, Round(FooterBGRadius * scale))

    __Gdip_FillRoundRect(g, FooterBGARGB, x, y, w, fh, r)
    if (FooterBorderPx > 0)
        __Gdip_StrokeRoundRect(g, FooterBorderARGB, x+0.5, y+0.5, w-1, fh-1, r, Max(1, Round(FooterBorderPx*scale)))

    pad := Max(0, Round(FooterPaddingX * scale))
    tx := x + pad
    tw := w - 2*pad

    t := StrLower(Trim(FooterTextAlign))
    fmt := gRes.Has("fmtFooterCenter") ? gRes["fmtFooterCenter"] : (gRes.Has("fmtCenter") ? gRes["fmtCenter"] : 0)
    if (t = "left")
        fmt := gRes.Has("fmtFooterLeft")  ? gRes["fmtFooterLeft"]  : (gRes.Has("fmt") ? gRes["fmt"] : fmt)
    else if (t = "right")
        fmt := gRes.Has("fmtFooterRight") ? gRes["fmtFooterRight"] : (gRes.Has("fmtRight") ? gRes["fmtRight"] : fmt)

    rf := Buffer(16, 0)
    NumPut("Float", tx, rf, 0)
    NumPut("Float", y,  rf, 4)
    NumPut("Float", tw, rf, 8)
    NumPut("Float", fh, rf, 12)

    DllCall("gdiplus\GdipDrawString"
        , "ptr", g
        , "wstr", gFooterText
        , "int", -1
        , "ptr", gRes["fFooter"]
        , "ptr", rf.Ptr
        , "ptr", fmt
        , "ptr", gRes["brFooterText"])
}

_ScrollBy(step) {
    global gScrollTop, gItems, gOverlayH, gSel

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    count := gItems.Length
    if (count <= 0) {
        return
    }

    visEff := Min(vis, count)
    if (count <= visEff) {
        ; Everything fits; nothing to scroll.
        return
    }

    ; Wrap-aware scrolling for the circular viewport
    gScrollTop := __Wrap0(gScrollTop + step, count)

    ; Recompute hover from current cursor so action icons stay under the pointer
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_Overlay_Repaint(hOv, items, selIndex) {
    global gBaseH, gOverlay, gLastRowsDesired, gLastItemCount

    ; ----- Throttled dynamic height: only when rows-to-show actually changes -----
    count := items.Length
    rowsDesired := _ComputeRowsToShow(count)
    if (rowsDesired != gLastRowsDesired) {
        _ResizeWindowToRows(rowsDesired)
        gLastRowsDesired := rowsDesired
    }

    ; Base rect in PHYSICAL pixels
    phX := 0, phY := 0, phW := 0, phH := 0
    __GetWindowRectPhys(gBaseH, &phX, &phY, &phW, &phH)

    ; Ensure scale + backbuffer + resources
    _EnsureScaleCache()
    scale := gCurScale
    _EnsureBackbuffer(phW, phH)

    ; Paint directly into backbuffer
    __Gdip_PaintOverlay(items, selIndex, phW, phH, "", 0, scale)

    ; BLENDFUNCTION
    bf := Buffer(4, 0)
    NumPut("UChar", 0x00, bf, 0) ; AC_SRC_OVER
    NumPut("UChar", 0x00, bf, 1)
    NumPut("UChar", 255,  bf, 2) ; per-pixel alpha
    NumPut("UChar", 0x01, bf, 3) ; AC_SRC_ALPHA

    ; SIZE and POINT (PHYSICAL)
    sz := Buffer(8, 0), ptDst := Buffer(8, 0), ptSrc := Buffer(8, 0)
    NumPut("Int", phW, sz, 0), NumPut("Int", phH, sz, 4)
    NumPut("Int", phX, ptDst, 0), NumPut("Int", phY, ptDst, 4)

    ; Ensure WS_EX_LAYERED
    GWL_EXSTYLE := -20, WS_EX_LAYERED := 0x80000
    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hOv, "int", GWL_EXSTYLE, "ptr")
    if !(ex & WS_EX_LAYERED) {
        ex |= WS_EX_LAYERED
        DllCall("user32\SetWindowLongPtrW", "ptr", hOv, "int", GWL_EXSTYLE, "ptr", ex, "ptr")
    }

    ; Update layered directly from persistent backbuffer DC/bitmap
    ULW_ALPHA := 0x2
    hdcScreen := DllCall("user32\GetDC", "ptr", 0, "ptr")
    DllCall("user32\UpdateLayeredWindow"
        , "ptr", hOv
        , "ptr", hdcScreen
        , "ptr", ptDst.Ptr
        , "ptr", sz.Ptr
        , "ptr", gBackHdc
        , "ptr", ptSrc.Ptr
        , "int", 0
        , "ptr", bf.Ptr
        , "uint", ULW_ALPHA
        , "int")
    DllCall("user32\ReleaseDC", "ptr", 0, "ptr", hdcScreen)

    ; Synchronized first reveal
    _RevealBaseAndOverlayTogether()
}

; Keep selection visible after changing gSel
_EnsureVisible(totalCount) {
    global gSel, gScrollTop
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0 || totalCount <= 0) {
        return
    }
    visEff := Min(vis, totalCount)
    if (visEff <= 0) {
        return
    }
    if (gSel < gScrollTop + 1) {
        gScrollTop := gSel - 1
    } else if (gSel > gScrollTop + visEff) {
        gScrollTop := gSel - visEff
    }
    if (gScrollTop < 0)
        gScrollTop := 0
    maxTop := Max(0, totalCount - visEff)
    if (gScrollTop > maxTop)
        gScrollTop := maxTop
}

; Full-row click → select clicked row (not just icon)
_OnOverlayClick(x, y) {
    global gItems, gSel, gOverlayH, MarginY, RowHeight, gScrollTop, ScrollKeepHighlightOnTop

    ; First: did we click an action button?
    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)
    if (act != "") {
        _Action_Perform(act, idx)
        return
    }

    ; Otherwise: regular row selection behavior
    count := gItems.Length
    if (count = 0) {
        return
    }

    scale := __GetScaleForWindow(gOverlayH)
    yDip := Round(y / scale)

    rowsTopDip := MarginY + _HeaderBlockDip()
    if (yDip < rowsTopDip) {
        return
    }

    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        return
    }
    rowsDrawn := Min(vis, count)

    idxVisible := ((yDip - rowsTopDip) // RowHeight) + 1
    if (idxVisible < 1) {
        idxVisible := 1
    }
    if (idxVisible > rowsDrawn) {
        return
    }

    top0 := gScrollTop
    idx0 := __Wrap0(top0 + (idxVisible - 1), count)
    gSel := idx0 + 1

    if (ScrollKeepHighlightOnTop) {
        gScrollTop := gSel - 1
    }

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}

_OnOverlayMouseMove(wParam, lParam, msg, hwnd) {
    global gOverlayH, gHoverRow, gHoverBtn, gItems, gSel
    if (hwnd != gOverlayH) {
        return 0
    }
    x := lParam & 0xFFFF
    y := (lParam >> 16) & 0xFFFF

    act := "", idx := 0
    _DetectActionAtPoint(x, y, &act, &idx)

    prevRow := gHoverRow
    prevBtn := gHoverBtn
    gHoverRow := idx
    gHoverBtn := act

    if (gHoverRow != prevRow || gHoverBtn != prevBtn) {
        _Overlay_Repaint(gOverlayH, gItems, gSel)
    }
    return 0
}

_MoveSelection(delta) {
    global gSel, gItems, gScrollTop, gOverlayH, gSel, ScrollKeepHighlightOnTop

    if (gItems.Length = 0 || delta = 0) {
        return
    }

    count := gItems.Length
    vis := _GetVisibleRowsFromOverlay()
    if (vis <= 0) {
        vis := 1
    }
    if (vis > count) {
        vis := count
    }

    if (ScrollKeepHighlightOnTop) {
        ; ===================== TOP-ANCHOR MODE (true) =====================
        if (delta > 0) {
            gSel := __Wrap1(gSel + 1, count)
        } else {
            gSel := __Wrap1(gSel - 1, count)
        }
        gScrollTop := gSel - 1           ; let rendering wrap; no clamping
    } else {
        ; ===================== STICKY-EDGE MODE (false) =====================
        top0 := gScrollTop

        if (delta > 0) {
            ; move selection down (wrap 1..count)
            gSel := __Wrap1(gSel + 1, count)
            sel0 := gSel - 1
            pos := __Wrap0(sel0 - top0, count)
            ; If offscreen OR already at bottom, anchor selection to bottom row.
            if (pos >= vis || pos = vis - 1) {
                gScrollTop := sel0 - (vis - 1)
            }
        } else {
            ; move selection up (wrap 1..count)
            gSel := __Wrap1(gSel - 1, count)
            sel0 := gSel - 1
            pos := __Wrap0(sel0 - top0, count)
            ; If offscreen OR already at top, anchor selection to top row.
            if (pos >= vis || pos = 0) {
                gScrollTop := sel0
            }
        }
    }

    ; Recompute hover from current cursor so action icons stay under the pointer
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_RemoveItemAt(idx1) {
    global gItems, gSel, gScrollTop, gOverlayH
    if (idx1 < 1 || idx1 > gItems.Length) {
        return
    }
    gItems.RemoveAt(idx1)

    if (gItems.Length = 0) {
        gSel := 1
        gScrollTop := 0
    } else {
        if (gSel > gItems.Length) {
            gSel := gItems.Length
        }
        _EnsureVisible(gItems.Length)
    }

    ; Keep hover aligned with the cursor after the list compacts
    _RecalcHoverFromCurrentCursor()

    _Overlay_Repaint(gOverlayH, gItems, gSel)
}


_Action_Perform(action, idx1 := 0) {
    global gItems, gSel
    if (idx1 = 0) {
        idx1 := gSel
    }
    if (idx1 < 1 || idx1 > gItems.Length) {
        return
    }
    cur := gItems[idx1]

    if (action = "close") {
        ; TODO: Real close: PostMessage(WM_CLOSE) to cur.HWND
        _RemoveItemAt(idx1)
        return
    }
    if (action = "kill") {
        pid := cur.HasOwnProp("PID") ? cur.PID : "?"
        ttl := cur.HasOwnProp("Title") ? cur.Title : "window"
        if _ConfirmTopmost("Are you sure you want to TERMINATE process " pid " for '" ttl "'?", "Confirm terminate") {
            ; TODO: ProcessClose(pid)
            _RemoveItemAt(idx1)
        }
        return
    }

    if (action = "blacklist") {
        ttl := cur.HasOwnProp("Title") ? cur.Title : "window"
        cls := cur.HasOwnProp("Class") ? cur.Class : "?"
        if _ConfirmTopmost("Blacklist '" ttl "' from class '" cls "'?", "Confirm blacklist") {
            ; TODO: add to config/store
            _RemoveItemAt(idx1)
        }
        return
    }

}

; Mouse wheel scroll (row-based)
_OnOverlayWheel(wParam, lParam) {
    global gOverlayH, ScrollKeepHighlightOnTop
    delta := (wParam >> 16) & 0xFFFF
    if (delta >= 0x8000) {
        delta -= 0x10000
    }
    step := (delta > 0) ? -1 : 1  ; up = -1, down = +1

    if (ScrollKeepHighlightOnTop) {
        _MoveSelection(step)
    } else {
        _ScrollBy(step)
    }
}

_RevealBaseAndOverlayTogether() {
    global gBase, gBaseH, gOverlay, CornerRadiusPx, gRevealed
    if (gRevealed) {
        return
    }
    ; Re-apply rounded region once on-screen, then show both windows
    try _ApplyRoundRegion(gBaseH, CornerRadiusPx)
    try gBase.Show("NA")
    try gOverlay.Show("NA")
    try DllCall("dwmapi\DwmFlush")
    gRevealed := true
}


; ========================= MAIN =========================

; ========================= HOTKEYS =========================
Up:: {
    _MoveSelection(-1)
}
Down:: {
    _MoveSelection(1)
}

; C = Close (no confirmation)
;c:: {
;    global AllowCloseKeystroke
;    if (AllowCloseKeystroke) {
;        _Action_Perform("close")
;    }
;}

; K = Kill (confirm)
;k:: {
;    global AllowKillKeystroke
;    if (AllowKillKeystroke) {
;        _Action_Perform("kill")
;    }
;}

; B = Blacklist (confirm)
;b:: {
;    global AllowBlacklistKeystroke
;    if (AllowBlacklistKeystroke) {
;        _Action_Perform("blacklist")
;    }
;}

;z:: {
;    _HideOverlay()
;}
;x:: {
;    _ShowOverlay()
;}

; Q = cycle footer scope text (POC only)
;q:: {
;    global gFooterModes, gFooterModeIndex, gFooterText, gOverlayH, gItems, gSel
;    gFooterModeIndex := (gFooterModeIndex >= gFooterModes.Length) ? 1 : (gFooterModeIndex + 1)
;    gFooterText := gFooterModes[gFooterModeIndex]
;    _Overlay_Repaint(gOverlayH, gItems, gSel)
;}

----------
and it might be relevant to show our altlogic.ahk
----------
; altlogic.ahk — Lightning-fast Alt+Tab with overlay, MRU, blacklist debugger (press B while overlay is up)
; altlogic.ahk — Lightning-fast Alt+Tab (receiver mode via IPC)
ALTAB_Init() {
  SetKeyDelay -1, -1
  SetMouseDelay -1
  SetWinDelay -1
  ProcessSetPriority("High")
  
  global QuitHotkey
  __RX_linesThisSession := 0
    
  if !IsSet(RefreshOnOverlay)
    global RefreshOnOverlay := true
  if !IsSet(RefreshOnAltUp)
    global RefreshOnAltUp := true

  global AL_uiInvalid := false

  ; --- RX logging toggles ---
  if !IsSet(DebugLogReceived)
    global DebugLogReceived := false
  if !IsSet(DebugRxLogPath)
    global DebugRxLogPath := (IsSet(DebugLogPath) ? DebugLogPath : A_ScriptDir "\tabby_debug.log")
  if !IsSet(DebugMaxLinesPerSession)
    global DebugMaxLinesPerSession := 200
  global __RX_linesThisSession := 0

  ; --- RX/session bookkeeping ---
  global AL_rxAltHeld       := false   ; logical “Alt is held” from micro
  global AL_rxEventCount    := 0
  global AL_lastRxTick      := 0

  ; --- NEW: event queue & processing flags ---
  global AL_evtQ            := []      ; queue of step dirs (+1 / -1)
  global AL_altUpPending    := false
  global AL_processingQ     := false

  ; optional watchdog to self-heal ultra-edge cases
  if !IsSet(UseRxWatchdog)
    global UseRxWatchdog := true
  if !IsSet(RxWatchdogMs)
    global RxWatchdogMs := 120

  Hotkey(QuitHotkey, ALTAB_Quit)
  Hotkey("#^Esc", ALTAB_Quit)
  A_TrayMenu.Add("Exit", ALTAB_Quit)

  ; === IPC receiver init (targeted IPC) ===
  TABBY_IPC_InitReceiver(ALTAB_IPC_Handler)

  ; Debug helpers
  MRU_Init()

  if (UseRxWatchdog)
    SetTimer(ALTAB_RxWatchdog_Tick, RxWatchdogMs)
}



; ---- New: IPC event handler (called by TABBY_IPC_Listen) ----
; ---- IPC event handler (called by TABBY_IPC_Listen) ----
ALTAB_IPC_Handler(ev, flags, lParam) {
  global AL_rxEventCount, AL_lastRxTick, AL_evtQ, AL_altUpPending, AL_rxAltHeld, AL_processingQ

  AL_rxEventCount += 1
  AL_lastRxTick := A_TickCount
  __RX_Log(Format("RX #{1} ev={2} flags={3} lParam={4} tick={5} sess={6} presses={7}"
    , AL_rxEventCount, ev, flags, lParam, A_TickCount, AL_session, AL_pressCount))

  if (ev = 1) {                       ; TAB_STEP
    AL_evtQ.Push((flags & 0x01) ? -1 : +1)
    AL_rxAltHeld := true
  } else if (ev = 2) {                ; ALT_UP
    AL_altUpPending := true
    AL_rxAltHeld := false
  }

  ; Drain in a single tick after we return (prevents re-entrancy races).
  SetTimer(ALTAB_ProcessQueue, -1)
}

ALTAB_UI_Flush() {
  global AL_uiInvalid, AL_list, AL_sel
  if (!AL_uiInvalid)
    return
  AL_uiInvalid := false
  if (AL_list.Length)
    ALTAB_UpdateOverlay()
}

ALTAB_ProcessQueue() {
  global AL_processingQ, AL_evtQ, AL_altUpPending
  global AL_session, AL_tabHeld, AL_firstTick, AL_pressCount, AL_list, AL_len
  global AL_sel, AL_base, HoldMs

  if (AL_processingQ)
    return
  AL_processingQ := true

  try {
    loop {
      ; 3a) Apply any queued steps first
      while (AL_evtQ.Length) {
        ; session start on first step
        if !AL_session {
          AL_list := ALTAB_BuildList()
          AL_len  := AL_list.Length
          if (AL_len = 0) {
            __RX_Log("session start aborted: empty list")
            AL_evtQ := []
            AL_altUpPending := false
            return
          }
          curr := WinGetID("A")
          AL_base := ALTAB_IndexOf(AL_list, curr)
          if (AL_base = 0)
            AL_base := 1
          AL_sel := AL_base

          AL_session    := true
          AL_pressCount := 0
          AL_firstTick  := A_TickCount
          SetTimer(ALTAB_ShowOverlayIfEligible, -HoldMs)
          __RX_Log(Format("session start: base={1} len={2} hold={3}ms", AL_base, AL_len, HoldMs))
        }

        dir := AL_evtQ.RemoveAt(1)
        AL_pressCount += 1
        AL_sel := ALTAB_Wrap(AL_sel + dir, AL_len)
        __RX_Log(Format("step dir={1} sel={2}/{3} presses={4}", dir, AL_sel, AL_len, AL_pressCount))

        if (AL_pressCount >= 2) {
          ALTAB_ShowOverlayNow()
          SetTimer(ALTAB_ShowOverlayIfEligible, 0)
          __RX_Log("overlay forced now (>=2 presses)")
        }
        AL_uiInvalid := true
        SetTimer(ALTAB_UI_Flush, -1)

      }

      ; 3b) If ALT_UP is pending, finalize now (after applying all steps)
      if (AL_altUpPending) {
        AL_altUpPending := false

        SetTimer(ALTAB_ShowOverlayIfEligible, 0)
        Overlay_Hide()
        SetTimer(ALTAB_UI_Flush, 0)
        AL_uiInvalid := false
        AL_overlayUp := false

        len := (IsSet(AL_list) && IsObject(AL_list)) ? AL_list.Length : 0
        __RX_Log(Format("ALT_UP: sess={1} presses={2} list={3}", AL_session, AL_pressCount, len))

        if (AL_session && AL_pressCount >= 1 && len >= 1) {
          if (IsSet(RefreshOnAltUp) && RefreshOnAltUp) {
            currentSel := AL_list[AL_sel].Hwnd
            fresh := ALTAB_BuildList()
            if (fresh.Length) {
              AL_list := fresh
              idx := ALTAB_IndexOf(AL_list, currentSel)
              if (idx)
                AL_sel := idx
              else if (AL_sel > AL_list.Length)
                AL_sel := 1
            }
          }
          target := AL_list[AL_sel]
          ok := ActivateHwnd(target.Hwnd, target.State)
          __RX_Log(Format("activate hwnd={1} state={2} ok={3}", target.Hwnd, target.State, ok))
          if (ok)
            MRU_MoveToFront(target.Hwnd)
        }

        ALTAB_ResetSessionState()
        __RX_Log("session reset")
        ; after ALT_UP we’re done; break outer loop
        break
      } else {
        ; nothing more pending
        break
      }
    }
  } finally {
    AL_processingQ := false
  }
}


; dir: +1 forward, -1 backward
ALTAB_IPC_TabStep(dir) {
  global AL_session, AL_tabHeld, AL_firstTick, AL_pressCount, AL_list, AL_len
  global AL_sel, AL_base, HoldMs, AL_rxAltHeld

  if (AL_tabHeld)
    return
  AL_tabHeld := true
  AL_rxAltHeld := true

  if !AL_session {
    AL_list := ALTAB_BuildList()
    AL_len  := AL_list.Length
    if (AL_len = 0) {
      AL_tabHeld := false
      __RX_Log("RX step: list=0 → noop")
      return
    }
    curr    := WinGetID("A")
    AL_base := ALTAB_IndexOf(AL_list, curr)
    if (AL_base = 0)
      AL_base := 1
    AL_sel := AL_base

    AL_session    := true
    AL_pressCount := 0
    AL_firstTick  := A_TickCount
    SetTimer(ALTAB_ShowOverlayIfEligible, -HoldMs)
    __RX_Log(Format("session start: base={1} len={2} hold={3}ms", AL_base, AL_len, HoldMs))
  }

  AL_pressCount += 1
  AL_sel := ALTAB_Wrap(AL_sel + dir, AL_len)
  __RX_Log(Format("step dir={1} sel={2}/{3} presses={4}", dir, AL_sel, AL_len, AL_pressCount))

  if (AL_pressCount >= 2) {
    ALTAB_ShowOverlayNow()
    SetTimer(ALTAB_ShowOverlayIfEligible, 0)
    __RX_Log("overlay forced now (>=2 presses)")
  }
  AL_uiInvalid := true
  SetTimer(ALTAB_UI_Flush, -1)

  AL_tabHeld := false
}




ALTAB_IPC_AltUp() {
  global AL_session, AL_pressCount, AL_list, AL_sel, AL_overlayUp
  global RefreshOnAltUp, AL_rxAltHeld

  AL_rxAltHeld := false
  SetTimer(ALTAB_ShowOverlayIfEligible, 0)
  Overlay_Hide()
  AL_overlayUp := false
  SetTimer(ALTAB_UI_Flush, 0)
  AL_uiInvalid := false

  len := (IsSet(AL_list) && IsObject(AL_list)) ? AL_list.Length : 0
  __RX_Log(Format("ALT_UP: sess={1} presses={2} list={3}", AL_session, AL_pressCount, len))

  if (AL_session && AL_pressCount >= 1 && len >= 1) {
    if (RefreshOnAltUp) {
      currentSel := AL_list[AL_sel].Hwnd
      fresh := ALTAB_BuildList()
      if (fresh.Length) {
        AL_list := fresh
        idx := ALTAB_IndexOf(AL_list, currentSel)
        if (idx)
          AL_sel := idx
        else if (AL_sel > AL_list.Length)
          AL_sel := 1
      }
    }
    target := AL_list[AL_sel]
    ok := ActivateHwnd(target.Hwnd, target.State)
    __RX_Log(Format("activate hwnd={1} state={2} ok={3}", target.Hwnd, target.State, ok))
    if (ok)
      MRU_MoveToFront(target.Hwnd)
  }

  ALTAB_ResetSessionState()
  __RX_Log("session reset")
}






; ---- Context predicate for blacklist helper ----
IsBLHotkeyActive(*) {
  global AL_session, AL_overlayUp
  return AL_session && AL_overlayUp && GetKeyState("Alt","P")
}

; ---- State ----
global AL_session     := false
global AL_tabHeld     := false
global AL_firstTick   := 0
global AL_pressCount  := 0
global AL_list        := []
global AL_len         := 0
global AL_sel         := 0
global AL_base        := 0
global AL_overlayUp   := false


; ---- Event helpers ----
ALTAB_Quit(*) {
  Overlay_Hide()
  Komorebi_SubStop()
  ExitApp()
}


; ---- Core Alt+Tab logic ----


ALTAB_Wrap(idx, len) {
  if (idx < 1)
    return len
  if (idx > len)
    return 1
  return idx
}
ALTAB_IndexOf(arr, hwnd) {
  for idx, it in arr
    if (it.Hwnd = hwnd)
      return idx
  return 0
}

; ---- Alt release = perform switch (if any) ----

ALTAB_ResetSessionState() {
  global AL_session, AL_pressCount, AL_tabHeld, AL_list, AL_len, AL_sel, AL_base
  global AL_pendingTabTick, AL_rxAltHeld
  global AL_evtQ, AL_altUpPending

  ; cancel any overlay delay timer
  SetTimer(ALTAB_ShowOverlayIfEligible, 0)

  AL_session    := false
  AL_pressCount := 0
  AL_tabHeld    := false
  AL_list       := []
  AL_len        := 0
  AL_sel        := 0
  AL_base       := 0
  AL_pendingTabTick := -1

  ; clear RX logical state & queue
  AL_rxAltHeld    := false
  AL_evtQ         := []
  AL_altUpPending := false

  SetTimer(ALTAB_UI_Flush, 0)
  AL_uiInvalid := false
}



; ---- RX debug logging (non-blocking guard) ----
ALTAB_Debug_ToggleRxLog(*) {
  global DebugLogReceived
  DebugLogReceived := !DebugLogReceived
  ToolTip "DebugLogReceived = " (DebugLogReceived ? "ON" : "OFF")
  SetTimer(() => ToolTip(), -800)
  __RX_Log("=== toggled DebugLogReceived → " . (DebugLogReceived ? "ON" : "OFF") . " ===")
}
__RX_Log(msg) {
  if !(IsSet(DebugLogReceived) && DebugLogReceived)
    return
  global DebugRxLogPath
  global __RX_linesThisSession, DebugMaxLinesPerSession
  if (__RX_linesThisSession >= DebugMaxLinesPerSession)
    return
  __RX_linesThisSession += 1

  ts := A_YYYY . "-" . A_MM . "-" . A_DD . " " . A_Hour . ":" . A_Min . ":" . A_Sec . "." . SubStr(A_MSec "000", 1, 3)
  try FileAppend(ts . "  [RX] " . msg . "rn", DebugRxLogPath, "UTF-8")
}



; ---- Overlay ----
; ---- Overlay ----
ALTAB_ShowOverlayIfEligible() {
  global AL_session, AL_firstTick, HoldMs, AL_rxAltHeld
  if !AL_session
    return
  if !AL_rxAltHeld
    return
  if (A_TickCount - AL_firstTick) < HoldMs
    return
  __RX_Log("overlay eligible → show now")
  ALTAB_ShowOverlayNow()
}



ALTAB_RxWatchdog_Tick() {
  global UseRxWatchdog, AL_session, AL_rxAltHeld, AL_lastRxTick
  if !UseRxWatchdog
    return
  if !(AL_session && AL_rxAltHeld)
    return
  ; if no RX activity for a bit and Alt is physically up, infer ALT_UP
  if ((A_TickCount - AL_lastRxTick) > 80 && !GetKeyState("Alt","P")) {
    __RX_Log("watchdog: inferred ALT_UP → self-heal")
    ; queue an alt-up and process
    global AL_altUpPending := true
    SetTimer(ALTAB_ProcessQueue, -1)
  }
}



ALTAB_ShowOverlayNow() {
  global AL_list, AL_sel, AL_overlayUp, RefreshOnOverlay, OverlayEnabled

  ; do NOT shadow the global; use a different local name
  ovEnabled := IsSet(OverlayEnabled) ? !!OverlayEnabled : true
  if !ovEnabled
    return
  if (!IsObject(AL_list) || AL_list.Length = 0)
    return

  if (IsSet(RefreshOnOverlay) && RefreshOnOverlay) {
    prev := (AL_sel >= 1 && AL_sel <= AL_list.Length) ? AL_list[AL_sel].Hwnd : 0
    fresh := ALTAB_BuildList()
    if (fresh.Length) {
      AL_list := fresh
      if (prev) {
        idx := ALTAB_IndexOf(AL_list, prev)
        if (idx)
          AL_sel := idx
        else if (AL_sel > AL_list.Length)
          AL_sel := 1
      } else if (AL_sel > AL_list.Length) {
        AL_sel := 1
      }
    }
  }

  Overlay_ShowList(AL_list, AL_sel)
  AL_overlayUp := true
}



ALTAB_UpdateOverlay() {
  global AL_list, AL_sel
  if (AL_list.Length = 0)
    return
  Overlay_UpdateSelection(AL_list, AL_sel)
}

; ---- MRU + Z-order ----
ALTAB_BuildList() {
  global UseMRU
  arr := WinList_EnumerateAll()  ; filtered, Z-order list
  if (!UseMRU)
    return arr

  local hmap := Map(), ordered := [], mru := MRU_GetList()
  for _, item in arr
    hmap[item.Hwnd] := item
  if IsObject(mru) {
    for _, h in mru
      if hmap.Has(h) {
        ordered.Push(hmap[h])
        hmap.Delete(h)
      }
  }
  for hwnd, item in hmap
    ordered.Push(item)
  return ordered
}
-------
we have a separation between how the list of windows is showing, and what windows are actually changing in the logic

we had up and down, and the scroll wheel, bound to 
_MoveSelection(-1)
_MoveSelection(1)

to move around in our new gui. but if I do so with these, and then release alt, the movements done on these have no bearing on what windows are activated. the activated window seems to be based solely on my use of TAB and SHIFT-TAB

but vice versa is also true, but use of TAB and SHIFT-TAB, while clearly effecting what window is activated upon alt release, are not showing in the gui at all.

How do we marry these two behaviors
Pressing TAB should have the in UI effect of _MoveSelection(1)
Pressing SHIFT-TAB should the in UI effect of _MoveSelection(-1)

and any UI stuff I do, including mouse wheeling or clicking on a row to select it, should change the logical position in whatever in memory list is effecting window activation

its like the visual list and the logical list controlling activation are disconnected!

You have done an excellent job in responding with FULL FUNCTION ADD / REPLACE / REMOVE, please keep it up
probably a step in the right direction, but still feels way off. also intermittently generating an error
_______________
Error: An exception was thrown.

Specifically: 0xc0000005

	---- C:\Users\codyj\Desktop\tabby\newgui.ahk
	1673: NumPut("Float", w, rf, 8)
	1674: NumPut("Float", h, rf, 12)
▶	1675: DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", fmt, "ptr", br)
	1676: }
	1678: {

The current thread will exit.

Call stack:
C:\Users\codyj\Desktop\tabby\newgui.ahk (1675) : [DllCall] DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", fmt, "ptr", br)
C:\Users\codyj\Desktop\tabby\newgui.ahk (1675) : [__Gdip_DrawText] DllCall("gdiplus\GdipDrawString", "ptr", g, "wstr", text, "int", -1, "ptr", font, "ptr", rf.Ptr, "ptr", fmt, "ptr", br)
C:\Users\codyj\Desktop\tabby\newgui.ahk (1462) : [__Gdip_PaintOverlay] __Gdip_DrawText(g, val, col.x, yRow + Round(10*scale), col.w, Round(20*scale), brColUse, fColUse, gRes["fmt"])
C:\Users\codyj\Desktop\tabby\newgui.ahk (1967) : [_Overlay_Repaint] __Gdip_PaintOverlay(items, selIndex, phW, phH, "", 0, scale)
C:\Users\codyj\Desktop\tabby\newgui.ahk (2160) : [_MoveSelection] _Overlay_Repaint(gOverlayH, gItems, gSel)
C:\Users\codyj\Desktop\tabby\newgui.ahk (2245) : [_OnOverlayWheel] _MoveSelection(step)
C:\Users\codyj\Desktop\tabby\newgui.ahk (158) : [] Return  ( hwnd = gOverlayH ? ( _OnOverlayWheel(wParam, lParam), 0 ) : 0 )
> OnMessage
_____________
its still misbehaving
-if i click a row in the GUI, it will now often not change the gui. yet if i let go of alt, i does activate the one i clicked. so we are passing it back right, but somehow the UI is sticky and either never changes from the current one (before i clicked), or changes then flashes right back
- scrolling with the mouse wheel is similair. if will scroll in a direction one or two rows, then snap back to whatever the current highlight (pre scrolling was). thus i can never scroll far, as it keeps snapping back
- ALT-TAB and SHIFT-TAB still NEVER update the UI, although they are clearly accurately effecting the alt-tab activation properly
On top of that, it feels like what is shown in the list is very different from what the alt tab logic is activating, but that can just be a side effect of the above bugs, I wont know until they are all solved.

its our program, we can change these things as much as possible. Part of me feels we should have one data object we are sharing, not trying to sync changes between the two. Unify it into one object that shares the whole state of the windows listing, from everything that the mru is learning, the alt tab logic, the gui display, the komorebi and winenum info. should it be in one?

And if not, then at least shouldnt we unify what altlogic and newgui are doing? 

Your thoughts? 
Continue the full function replacements / adds  please. 
No, its still a shit show.
if I set HoldMs to like 20,000 and just play with tab and alt-tab, its properly following the previous windows. it seems like altlogic.ahks mental model is still good.
but the gui is just wrong.
 tab and shift tab are still not updating the list. 
There is less snapping on scrolling, but not none. 
clicking is working right logicly, but not visually. 

Dont respond with code. brainstorm with me. what is the right way to solve this. 
Is synchronizing two data structures really the right call? it seems like what is calling the trouble. 

altlogic.ahk uses ALTAB_BuildList() to build the list right? do we start there?
or do we make a list.ahk and start centralizing everything there. 

what data structures, maps, arrays, dicts, etc would we ideally we use?

We could maintain a list of all HWNDs. whats the source of truth? the window enum from winenum.ahk? 

so we have a data structure with all HWNDs? 
call winenum.ahk to search for windows and fill out there values (PID, class, etc) 
Calling mru.ahk will update all the MRU values?
komorebi.ahk and komorebi_sub.ahk can fill in the komorebi data point (workspace) and (is current active window), plus as the komorebi sub show anytime the workspace is changed or hwnds are focused, so they can add any missing hwnds to the data structure and trigger the other functions to update? as well as maintain a global * current workspace* if they dont already? 
should icon logic be in here too? just have icons be a first class member of the HWND data structure? they can be fetched when komorebi says which window is active, grab its icon if not already cached. 
and a data point for IsFocused, that our GUI is up and its currently focused. 
maybe instead of the GUI eventually handling window close / process kill / blacklist, it flags a column in the data structure and the window/list manager handles it? 

how would we refactor this?
what options can you think of? give a few and say what you think is best. 
no code. we are brainstorming
OK, I agree, I like Option B — Central “WindowStore” (list.ahk) as the source of truth; AltLogic owns session. 

I know you gave phases, but lets go a little more step by step as this is complicated for me. Where do you want to start? Like do we develop an ideal list.ahk in a vacuum, then I start giving you one by one the AHKs, like altlogic.ahk, winenum.ahk, mru.ahk, and one by one we wire them into the list.ahk? gui would be last of course. 

give me some Step 1 x, step 2 y, step 3. brake it down for me to understand but only 1-2 sentence each step. 

And super important question - if the GUI is "dumb" and just rendering the list, and it has to report back to altlogic.ahk on EVERY scroll or click - will that feel good? I mean i scroll wheel FAST. I'm assuming its minimal because its all single thread and we are just manipulating an object, but will this make it feel laggy? 

still no code just discussing 
okay, lets start with step 1. 

for API defining, i will depend on you. I agree it sounds like we need
UpsertWindow - we are adding one or more new windows
RemoveWindow - we are removing one or more windows
UpdateFields - we arent adding a window, but have new information about one or more windows
GetProjection
GetRev - 
GetByHwnd - we need all the fields, or one field, for a HWND

Fields
hwnd (UInt)

pid (UInt)

class (Str)

title (Str, normalized)
process name (string?)
state (string) -  these are the WorkspaceHidden, WorkspaceMinimized, etc our winenum does

zOrder (Int) — or capture “last seen Z”

what comes from mru.ahk? let me know if you need to see it 

workspace (Str/Int) — from Komorebi. i think we get string and int? let me know if you need to see komorebi.ahk 

isVisible, isMinimized, isOnCurrentWorkspace (Bool)
IsCurrentlyActive - what do you think?  

isBlacklisted (Bool)

iconHicon (Ptr) — cache; 0 if not resolved yet

rev (UInt) — per-record revision (optional)

Global store revision (UInt): bumps whenever any record added/removed/changed.
do we want timestamps?
FirstSeen
LastActive
TotalTimeActive - maybe since we know changes from MRU and komorebi we track how much time in each window? could be useful for later filter algos

anything else you can think of? or comments/questions on any of those

no code -brainstorming
Answers
Do you want tombstone + grace period (e.g., remove windows only if unseen for N ms), or immediate removal on enum miss? Hmmm. I think if they have missed an enum, we definitely shouldnt show them in the GUI. But I think its okay to hang on to them for X seconds just to make sure it wasnt a bad API call. keep X configurable? 

Should blacklist be persisted elsewhere and mirrored in the store, or is it volatile (store-only) for now? hmm. thing about the blacklist is right now we have a window blacklist, process blacklist, and window+process blacklist, and...well multiple methods. point is winenum.ahk handles that, so wouldnt we just have winenum.ahk write back that state into the store? so list.ahk doesnt worry about it, it justs gets told and regurgitates

For GetProjection.sort, is the default MRU (descending lastActivatedTick) acceptable, or do you prefer Z by default when overlay shows? write now the config lets it be specified whether to use the MRU received from MRU.ahk or use the Z order received by winenum.ahk. In the future, all add other sorting algos, like once that use active time, group by process, etc. so we want sorting to be configurable by the user, so the store has to support that. Long way to say yes MRU is an acceptable default sort, but if im understanding the model right, altlogic.ahk will own the session and be resonsible for sorting ultimately. 

For activity time, do we treat minimized-but-focused as inactive? (I’d say inactive.) I agree, not active!

Are we OK using A_TickCount everywhere for timing v1? You tell me, if its best use it. remember speed is our overriding goal
I'm ready to generate the list.ahk. Give it to me baby. Comment it well. 
OK. You had a lot v1 syntax on your IFs but I cleaned it up, remember it we are using AHKv2. OK, this executes without errors.

I believe our next step is to adapt winenum.ahk  to feed into this store. 
Here is the current winenum.ahk
-------
; winenum.ahk — fast Z-order enumeration with DWM cloaking info
; Non-blocking debug: buffered + capped logging controlled by DebugBlacklist flag.

global _WN_all := []
global _WN_zCounter := 0
global _WN_shell := 0

; --- debug buffer + caps per enumeration pass ---
global _WN_logbuf := ""
global _WN_traceLeft := 0
global _WN_traceDeadline := 0

WinList_EnumerateAll() {
    global _WN_all, _WN_zCounter, _WN_shell
    global _WN_logbuf, _WN_traceLeft, _WN_traceDeadline

    ; Read globals without shadowing them
    dbg       := (IsSet(DebugBlacklist) && DebugBlacklist)
    maxLines  := IsSet(DebugMaxLinesPerSession) ? DebugMaxLinesPerSession : 200
    maxMillis := IsSet(DebugMaxDurationMs)      ? DebugMaxDurationMs      : 200

    DllCall("LoadLibrary", "str", "dwmapi.dll")
    _WN_shell := DllCall("user32\GetShellWindow", "ptr")
    _WN_zCounter := 0
    _WN_all := []

    ; prepare debug budget
    if (dbg) {
        _WN_logbuf := ""
        _WN_traceLeft := maxLines
        _WN_traceDeadline := A_TickCount + maxMillis
        _WN_Log("=== WinList_EnumerateAll (begin) ===")
    } else {
        _WN_logbuf := ""
        _WN_traceLeft := 0
        _WN_traceDeadline := 0
    }

    cb := CallbackCreate(_WN_EnumProc, "Fast", 2)
    DllCall("user32\EnumWindows", "ptr", cb, "ptr", 0, "int")
    CallbackFree(cb)

    if (dbg) {
        _WN_Log("=== WinList_EnumerateAll (end) ===")
        _WN_FlushLog()
    }
    return _WN_all
}

_WN_EnumProc(hWnd, lParam) {
    global _WN_all, _WN_zCounter, _WN_shell, BlacklistTitle, BlacklistClass, BlacklistPair, UseAltTabEligibility

    if (hWnd = 0)
        return 1
    if (hWnd = _WN_shell) {
        _WN_zCounter++
        return 1
    }

    ; Fast class/title pull
    cls := _GetClass(hWnd)
    ttl := _GetTitle(hWnd)

    ; ---------- HARD FILTER for GDI+ helper windows ----------
    if (_IsGdiPlusHelper(ttl, cls)) {
        _Trace("Skip GDI+ helper", ttl, cls)
        _WN_zCounter++
        return 1
    }
    ; ----------------------------------------------------------

    ; Early blacklist — class first, then title
    if (MatchAny(cls, BlacklistClass)) {
        _Trace("Hit Class list", ttl, cls)
        _WN_zCounter++
        return 1
    }
    if (!ttl) {
        _WN_zCounter++
        return 1
    }
    if (MatchAny(ttl, BlacklistTitle)) {
        _Trace("Hit Title list", ttl, cls)
        _WN_zCounter++
        return 1
    }
    if (MatchPairs(ttl, cls, BlacklistPair)) {
        _Trace("Hit Pair list", ttl, cls)
        _WN_zCounter++
        return 1
    }

    ; visibility / cloaked / minimized
    isVisible := !!DllCall("user32\IsWindowVisible", "ptr", hWnd, "int")
    isMin     := !!DllCall("user32\IsIconic",        "ptr", hWnd, "int")

    cloakedBuf := Buffer(4, 0)
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hWnd, "uint", 14, "ptr", cloakedBuf.Ptr, "uint", 4, "int")
    isCloaked := (hr = 0) && (NumGet(cloakedBuf, 0, "UInt") != 0)

    state := "WorkspaceHidden"
    if (isCloaked)
        state := "OtherWorkspace"
    else if (isMin)
        state := "WorkspaceMinimized"
    else if (isVisible)
        state := "WorkspaceShowing"

    pidBuf := Buffer(4, 0)
    DllCall("user32\GetWindowThreadProcessId", "ptr", hWnd, "ptr", pidBuf.Ptr, "uint")
    pid := NumGet(pidBuf, 0, "UInt")

    if (UseAltTabEligibility) {
        if !_IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) {
            _Trace("Ineligible (Alt-Tab rules)", ttl, cls)
            _WN_zCounter++
            return 1
        }
    }

    _WN_all.Push({ Hwnd: hWnd, Title: ttl, Class: cls, Pid: pid, State: state, ZOrder: _WN_zCounter })
    _WN_zCounter++
    return 1
}

_GetTitle(hWnd) {
    buf := Buffer(512*2, 0)
    DllCall("user32\GetWindowTextW", "ptr", hWnd, "ptr", buf.Ptr, "int", 512, "int")
    s := StrGet(buf.Ptr, "UTF-16")
    return Trim(RegExReplace(s, "[\r\n\t]+", " "))
}

_GetClass(hWnd) {
    buf := Buffer(256*2, 0)
    DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
    return StrGet(buf.Ptr, "UTF-16")
}

_IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) {
    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", -20, "ptr")
    WS_EX_TOOLWINDOW := 0x00000080
    WS_EX_APPWINDOW  := 0x00040000
    isTool := (ex & WS_EX_TOOLWINDOW) != 0
    isApp  := (ex & WS_EX_APPWINDOW)  != 0

    owner := DllCall("user32\GetWindow", "ptr", hWnd, "uint", 4, "ptr") ; GW_OWNER

    if (isTool)
        return false
    if !(owner = 0 || isApp)
        return false
    if !(isVisible || isMin || isCloaked)
        return false
    return true
}

; ---------- module-local helpers ----------

_IsGdiPlusHelper(ttl, cls) {
    ttlN := NormalizeMatchText(ttl)
    clsN := NormalizeMatchText(cls)
    if (clsN != "GDI+Hook Window Class")
        return false
    return RegExMatch(ttlN, "^GDI\+Window \([^)]+\)$")
}

_Trace(tag, ttl, cls) {
    global _WN_traceLeft, _WN_traceDeadline
    ; Check debug flags once per call (no shadowing)
    dbg := (IsSet(DebugBlacklist) && DebugBlacklist)
    if !dbg
        return
    if (_WN_traceLeft <= 0 || (_WN_traceDeadline && A_TickCount > _WN_traceDeadline))
        return
    _WN_traceLeft -= 3  ; each block ~3 lines budget
    _WN_Log("[" . tag . "]")
    _WN_Log("  Title: " . ttl)
    _WN_Log("  Class: " . cls)
}

_WN_Log(line) {
    global _WN_logbuf
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff")
    _WN_logbuf .= ts . "  " . line . "rn"
}

_WN_GetLogPath() {
    ; Prefer user-configured path
    if (IsSet(DebugLogPath) && DebugLogPath) {
        return DebugLogPath
    }
    return A_ScriptDir . "\tabby_debug.log"
}

_WN_FlushLog() {
    global _WN_logbuf
    if (_WN_logbuf = "")
        return

    path := _WN_GetLogPath()

    ; Ensure directory exists
    SplitPath path, , &dir
    if (dir != "")
        try DirCreate(dir)

    ; Try chosen path, then fallback to %TEMP%
    ok := false
    try {
        FileAppend(_WN_logbuf, path, "UTF-8")
        ok := true
    }
    catch {
        try {
            FileAppend(_WN_logbuf, A_Temp . "\tabby_debug.log", "UTF-8")
            ok := true
        }
        catch {
            ; give up
        }
    }

    _WN_logbuf := ""
}
-----------
Now, if I understand this correctly, altlogic.ahk calls winenum every time we detect an alt-tab - so we are building it every time and not caching it.

I think we will still want to do that right? do a safety winenum every time before pulling a projection? or do you think mru / komorebi analysis will be robust enough?

i imagine we winenum all when our program starts to prime the store
winenum before pulling a projection for alt tab use
right now its WinList_EnumerateAll. Should we also add the ability to WinList_EnumerateByHwnd or something - so that later is our MRU or komorebi monitors detect an Hwnd not in the store, we can get all its details and add to store?

Stop and ask me questions if you need, or if that makes sense, generate a new winenum.ahk

OK. You had a lot v1 syntax on your IFs but I cleaned it up, remember it we are using AHKv2. OK, this executes without errors. I believe our next step is to adapt winenum.ahk to feed into this store. Here is the current winenum.ahk ------- ; winenum.ahk — fast Z-order enumeration with DWM cloaking info ; Non-blocking debug: buffered + capped logging controlled by DebugBlacklist flag. global _WN_all := [] global _WN_zCounter := 0 global _WN_shell := 0 ; --- debug buffer + caps per enumeration pass --- global _WN_logbuf := "" global _WN_traceLeft := 0 global _WN_traceDeadline := 0 WinList_EnumerateAll() { global _WN_all, _WN_zCounter, _WN_shell global _WN_logbuf, _WN_traceLeft, _WN_traceDeadline ; Read globals without shadowing them dbg := (IsSet(DebugBlacklist) && DebugBlacklist) maxLines := IsSet(DebugMaxLinesPerSession) ? DebugMaxLinesPerSession : 200 maxMillis := IsSet(DebugMaxDurationMs) ? DebugMaxDurationMs : 200 DllCall("LoadLibrary", "str", "dwmapi.dll") _WN_shell := DllCall("user32\GetShellWindow", "ptr") _WN_zCounter := 0 _WN_all := [] ; prepare debug budget if (dbg) { _WN_logbuf := "" _WN_traceLeft := maxLines _WN_traceDeadline := A_TickCount + maxMillis _WN_Log("=== WinList_EnumerateAll (begin) ===") } else { _WN_logbuf := "" _WN_traceLeft := 0 _WN_traceDeadline := 0 } cb := CallbackCreate(_WN_EnumProc, "Fast", 2) DllCall("user32\EnumWindows", "ptr", cb, "ptr", 0, "int") CallbackFree(cb) if (dbg) { _WN_Log("=== WinList_EnumerateAll (end) ===") _WN_FlushLog() } return _WN_all } _WN_EnumProc(hWnd, lParam) { global _WN_all, _WN_zCounter, _WN_shell, BlacklistTitle, BlacklistClass, BlacklistPair, UseAltTabEligibility if (hWnd = 0) return 1 if (hWnd = _WN_shell) { _WN_zCounter++ return 1 } ; Fast class/title pull cls := _GetClass(hWnd) ttl := _GetTitle(hWnd) ; ---------- HARD FILTER for GDI+ helper windows ---------- if (_IsGdiPlusHelper(ttl, cls)) { _Trace("Skip GDI+ helper", ttl, cls) _WN_zCounter++ return 1 } ; ---------------------------------------------------------- ; Early blacklist — class first, then title if (MatchAny(cls, BlacklistClass)) { _Trace("Hit Class list", ttl, cls) _WN_zCounter++ return 1 } if (!ttl) { _WN_zCounter++ return 1 } if (MatchAny(ttl, BlacklistTitle)) { _Trace("Hit Title list", ttl, cls) _WN_zCounter++ return 1 } if (MatchPairs(ttl, cls, BlacklistPair)) { _Trace("Hit Pair list", ttl, cls) _WN_zCounter++ return 1 } ; visibility / cloaked / minimized isVisible := !!DllCall("user32\IsWindowVisible", "ptr", hWnd, "int") isMin := !!DllCall("user32\IsIconic", "ptr", hWnd, "int") cloakedBuf := Buffer(4, 0) hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hWnd, "uint", 14, "ptr", cloakedBuf.Ptr, "uint", 4, "int") isCloaked := (hr = 0) && (NumGet(cloakedBuf, 0, "UInt") != 0) state := "WorkspaceHidden" if (isCloaked) state := "OtherWorkspace" else if (isMin) state := "WorkspaceMinimized" else if (isVisible) state := "WorkspaceShowing" pidBuf := Buffer(4, 0) DllCall("user32\GetWindowThreadProcessId", "ptr", hWnd, "ptr", pidBuf.Ptr, "uint") pid := NumGet(pidBuf, 0, "UInt") if (UseAltTabEligibility) { if !_IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) { _Trace("Ineligible (Alt-Tab rules)", ttl, cls) _WN_zCounter++ return 1 } } _WN_all.Push({ Hwnd: hWnd, Title: ttl, Class: cls, Pid: pid, State: state, ZOrder: _WN_zCounter }) _WN_zCounter++ return 1 } _GetTitle(hWnd) { buf := Buffer(512*2, 0) DllCall("user32\GetWindowTextW", "ptr", hWnd, "ptr", buf.Ptr, "int", 512, "int") s := StrGet(buf.Ptr, "UTF-16") return Trim(RegExReplace(s, "[\r\n\t]+", " ")) } _GetClass(hWnd) { buf := Buffer(256*2, 0) DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int") return StrGet(buf.Ptr, "UTF-16") } _IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) { ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", -20, "ptr") WS_EX_TOOLWINDOW := 0x00000080 WS_EX_APPWINDOW := 0x00040000 isTool := (ex & WS_EX_TOOLWINDOW) != 0 isApp := (ex & WS_EX_APPWINDOW) != 0 owner := DllCall("user32\GetWindow", "ptr", hWnd, "uint", 4, "ptr") ; GW_OWNER if (isTool) return false if !(owner = 0 || isApp) return false if !(isVisible || isMin || isCloaked) return false return true } ; ---------- module-local helpers ---------- _IsGdiPlusHelper(ttl, cls) { ttlN := NormalizeMatchText(ttl) clsN := NormalizeMatchText(cls) if (clsN != "GDI+Hook Window Class") return false return RegExMatch(ttlN, "^GDI\+Window \([^)]+\)$") } _Trace(tag, ttl, cls) { global _WN_traceLeft, _WN_traceDeadline ; Check debug flags once per call (no shadowing) dbg := (IsSet(DebugBlacklist) && DebugBlacklist) if !dbg return if (_WN_traceLeft <= 0 || (_WN_traceDeadline && A_TickCount > _WN_traceDeadline)) return _WN_traceLeft -= 3 ; each block ~3 lines budget _WN_Log("[" . tag . "]") _WN_Log(" Title: " . ttl) _WN_Log(" Class: " . cls) } _WN_Log(line) { global _WN_logbuf ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff") _WN_logbuf .= ts . " " . line . "rn" } _WN_GetLogPath() { ; Prefer user-configured path if (IsSet(DebugLogPath) && DebugLogPath) { return DebugLogPath } return A_ScriptDir . "\tabby_debug.log" } _WN_FlushLog() { global _WN_logbuf if (_WN_logbuf = "") return path := _WN_GetLogPath() ; Ensure directory exists SplitPath path, , &dir if (dir != "") try DirCreate(dir) ; Try chosen path, then fallback to %TEMP% ok := false try { FileAppend(_WN_logbuf, path, "UTF-8") ok := true } catch { try { FileAppend(_WN_logbuf, A_Temp . "\tabby_debug.log", "UTF-8") ok := true } catch { ; give up } } _WN_logbuf := "" } ----------- Now, if I understand this correctly, altlogic.ahk calls winenum every time we detect an alt-tab - so we are building it every time and not caching it. I think we will still want to do that right? do a safety winenum every time before pulling a projection? or do you think mru / komorebi analysis will be robust enough? i imagine we winenum all when our program starts to prime the store winenum before pulling a projection for alt tab use right now its WinList_EnumerateAll. Should we also add the ability to WinList_EnumerateByHwnd or something - so that later is our MRU or komorebi monitors detect an Hwnd not in the store, we can get all its details and add to store? Stop and ask me questions if you need, or if that makes sense, generate a new winenum.ahk
-----------
this prompt is a repeat of my previous prompt. If you can see your response, know that I cannot. I saw it streaming in, you had rewritten winenum.ahk to use our new API. it was looking really good, you add a variable to toggle whether blacklists are recorded into the list or not at the winenum level, which was cool, and made the single HWND checker. but the partial response was interrupted and I cant see it. So please repeat it. 
ok, so that brings up some questions and you kind of hit it.
I imagine WinList_EnumerateAll() will be called when program starts and right as an alt-tab is done as a catch all. probably when the komorebi workspace is changed to.
WinList_EnumerateByHwnd() will be called when komorebi/MRU notice hwnds.
So my question was, who will actually drop old windows from the store? Is that what you mention beginscan() and endscan() for?

And second question, I see this wineenum.ahk has WN_FetchProcessName. Obviously thats an extra cost. but its also something we only ever have to do once, as a windows process is obviously never going to change with the HWND changing. 

So is winenum.ahk the right place to do that? Because winenum.ahk will end up processing the same hwnds over and over throughout our  apps lifecycle.

I was going to ask the same question about icons. obviously we should pull the icon pump logic out of our GUI and into its own icon.ahk. But icons are another thing are expensive to query, and once we have an answer, we never have to check it again. so we would have something like GetIcon(Hwnds), that checks the given HWNDs in the store, if they have an icon, does nothing, if they dont have an icon, try to fill it.

then we would have the same time of GetProcess(Hwnds).

So where should these calls to update information exist. For example:
Should winenum.ahk, as the function about to insert data to the store, need to call GetIcon() and GetProcess()? Or should the list.ahk API itself call it. The list API would know anytime (1) a new row is added and (2) an existing row is updated.
anytime either of those happen, it would know to check if it has an icon or process, and if not, batch call the relevant function to get them? or if komorebi sees a hwnd and adds it, the listapi could see its missing class and status information and call winenum. like each column in the API optionally has a function to call if empty after an upsert? 

or is that not the right place for the api, it only stores whats its handed never calls out for updates? 

no code just discussing best way to handle this given our app 
OK, one last bit of discussion. win winenum upserts, especially first time, it will be for hwnds that we dont know the komorebi workspace for. So should we also have a needsWS flag and queue for that?

When the komorebi detector and mru detector find a hwnd, what should they do? should they attempt to upsert it? because then they might upsert windows missing information that winenum hasnt added (class, pid, etc). which then the API might have to detect and flag into a queue. OR, should they just call into WinList_EnumerateByHwnd() and let it handle the upsert? If they call into WinList_EnumerateByHwnd, then shouldnt they also be able to pass on what they know, like the WS name for komorebi or the MRU, so they would call like WinList_EnumerateByHwnd(hwnd=x, ws=y) or (hwnd=z, mru=a)?
Should WinList_EnumerateByHwnd() be updated to handle 1 or more HWND, instead of just 1? 

No code, just discussion
Okay, hopefully last followup. You say What should MRU/Komorebi do on events?

If hwnd is known then xxxxx If hwnd unknown then yyyyy
How do they know its known? Did we have with the API a way to check? 

Also, an API thing. I realize there is one more "state" issue that list.ahk is not tracking. with the komorebi integration we have, we know the current workspace. its something altlogic.ahk will use later for filtering/UI stuff. In this system does it suffice to just have komorebi.ahk update a global variable? Or do we need to somehow have API calls for CheckCurrentWS() UpdateWS() and a seperate data structure? If its just a single string a global variable should suffice? 

Discussion only. 
OK. So given our latest discussion, it sounds like we need to update the api in list.ahk. List.ahk is currently
----------
#Requires AutoHotkey v2.0
;===============================================================================
; list.ahk  —  WindowStore (single source of truth)
; ------------------------------------------------------------------------------
; Purpose:
;   Centralized, in-memory store for window metadata. Everyone (winenum, MRU,
;   Komorebi, icon pump, AltLogic, GUI) reads/writes here instead of syncing
;   disparate structures. AltLogic owns session selection and just asks the
;   store for ordered projections.
;
; Design highlights:
;   - BeginBatch/EndBatch coalesce rev bumps (rev increments once per meaningful
;     change set). GetRev() exposes current global revision.
;   - BeginSweep/EndSweep implement enum “sweeps”; missing windows are hidden
;     immediately from projections (present=false) and hard-removed after a
;     configurable TTL (MissingTTLms). Icons are destroyed on hard removal.
;   - UpsertWindow / UpdateFields merge fields idempotently with normalization.
;   - GetProjection builds a filtered + sorted view (MRU/Z/etc). It can return
;     just hwnds (fast) or GUI-ready “items” (raw fields the GUI expects).
;   - GetIndexOf maps a hwnd to its index within a given projection spec.
;
; Threading:
;   AHK runs single-threaded user code; we keep data-structure ops simple and
;   cheap. GUI scroll/click never touches the store in normal flow; AltLogic
;   updates its session indices and repaints from cached items until rev changes.
;
; Public API (functions):
;   WindowStore_Init(config?)
;   WindowStore_BeginBatch()
;   WindowStore_EndBatch() -> {rev, changed}
;   WindowStore_BeginSweep(sweepId)
;   WindowStore_EndSweep(sweepId) -> {hiddenNow, tombstoned, removed, rev}
;   WindowStore_UpsertWindow(records[]) -> {added, updated, rev?}
;   WindowStore_UpdateFields(hwnd, patch) -> {changed, rev?}
;   WindowStore_RemoveWindow(hwnds) -> {removed, rev?}
;   WindowStore_GetRev()
;   WindowStore_GetByHwnd(hwnd) -> record?
;   WindowStore_GetProjection(opts?) -> {rev, hwnds, items?, meta}
;   WindowStore_GetIndexOf(hwnd, opts?) -> index?  (1-based)
;
; opts for GetProjection (defaults shown):
;   {
;     filter: {
;       presentOnly: true,
;       currentWorkspaceOnly: false,
;       blacklistMode: "exclude",   ; "exclude" | "include" | "only"
;       classes: [],                ; whitelist if provided
;       pids: []                    ; whitelist if provided
;     },
;     sort: "MRU",                  ; "MRU" | "Z" | "Title" | "Pid" | "ProcessName"
;     columns: "hwndsOnly"          ; "hwndsOnly" | "items"
;   }
;
; Record schema (per HWND):
;   See _WS_NewRecord() below; fields match our earlier spec.
;===============================================================================

;============================== GLOBAL STATE ===================================

global gWS_Store            := Map()     ; hwnd (UInt) -> record (Object)
global gWS_Rev              := 0         ; global store revision (monotonic)
global gWS_Batching         := false     ; inside BeginBatch/EndBatch
global gWS_PendingRevBump   := false     ; accumulate rev bump during batch
global gWS_CurrentSweepId   := 0         ; 0 = no active sweep
global gWS_Config           := Map()     ; runtime config (MissingTTLms, etc.)

; sensible defaults
gWS_Config["MissingTTLms"]        := 1200
gWS_Config["DefaultSort"]         := "MRU"
gWS_Config["NormalizeTitleMax"]   := 260    ; clamp super long titles
gWS_Config["TitleCollapseSpaces"] := true

;=============================== PUBLIC API ====================================

WindowStore_Init(config := 0) {
    ; Optional: set/override config keys at startup.
    global gWS_Config
    if IsObject(config) {
        for k, v in config
            gWS_Config[k] := v
    }
}

WindowStore_BeginBatch() {
    global gWS_Batching, gWS_PendingRevBump
    gWS_Batching := true
    gWS_PendingRevBump := false
}

WindowStore_EndBatch() {
    global gWS_Batching, gWS_PendingRevBump, gWS_Rev
    changed := false
    if (gWS_PendingRevBump) {
        gWS_Rev += 1
        changed := true
    }
    gWS_Batching := false
    gWS_PendingRevBump := false
    return { rev: gWS_Rev, changed: changed }
}

WindowStore_BeginSweep(sweepId) {
    global gWS_CurrentSweepId
    gWS_CurrentSweepId := sweepId
}

WindowStore_EndSweep(sweepId) {
    global gWS_Store, gWS_CurrentSweepId
    global gWS_Config
    if (sweepId != gWS_CurrentSweepId) {
        ; defensive: ignore out-of-order sweep ends
        return { hiddenNow: 0, tombstoned: 0, removed: 0, rev: WindowStore_GetRev() }
    }

    now := _WS_Now()
    ttl := gWS_Config["MissingTTLms"] + 0

    hiddenNow := 0
    tombstoned := 0
    removed := 0
    changed := false

    ; pass 1: hide anything not seen this sweep; set missingSinceTick if first miss
    for hwnd, rec in gWS_Store {
        if (rec.lastSeenSweep != sweepId) {
            if (rec.present) {
                rec.present := false    ; hide immediately from projections
                hiddenNow += 1
                changed := true
            }
            if (!rec.missingSinceTick) {
                rec.missingSinceTick := now
                tombstoned += 1
                changed := true
            }
        } else {
            ; seen this sweep → clear missing marker + ensure present
            if (!rec.present) {
                rec.present := true
                changed := true
            }
            if (rec.missingSinceTick) {
                rec.missingSinceTick := 0
                changed := true
            }
        }
    }

    ; pass 2: hard remove beyond TTL
    removals := []
    for hwnd, rec in gWS_Store {
        if (rec.missingSinceTick && (now - rec.missingSinceTick >= ttl)) {
            removals.Push(hwnd)
        }
    }
    if (removals.Length) {
        tmp := WindowStore_RemoveWindow(removals)
        removed += tmp.removed
        changed := changed || (tmp.removed > 0)
    }

    if (changed)
        _WS_RequestRevBump()

    ; clear active sweep marker (optional; safe to keep too)
    gWS_CurrentSweepId := 0

    return { hiddenNow: hiddenNow, tombstoned: tombstoned, removed: removed, rev: WindowStore_GetRev() }
}

WindowStore_UpsertWindow(records) {
    ; records: array of objects; minimally {hwnd: UInt}, plus any fields to merge.
    global gWS_Store, gWS_CurrentSweepId
    if !IsObject(records)
        records := [records]

    now := _WS_Now()
    added := 0, updated := 0
    changed := false

    for _, patch in records {
        if (!IsObject(patch) || !patch.Has("hwnd"))
            continue
        hwnd := patch.hwnd + 0

        rec := gWS_Store.Has(hwnd) ? gWS_Store[hwnd] : 0
        if (!rec) {
            rec := _WS_NewRecord(hwnd)
            gWS_Store[hwnd] := rec
            added += 1
            changed := true
        }

        ; Merge fields (with normalization + canonicalization).
        if (_WS_MergeInto(rec, patch))
            updated += 1, changed := true

        ; Mark presence for this sweep.
        if (gWS_CurrentSweepId)
            rec.lastSeenSweep := gWS_CurrentSweepId
        rec.lastSeenTick := now
        rec.present := true
        ; firstSeenTick is set on creation
        rec.missingSinceTick := 0
    }

    if (changed)
        _WS_RequestRevBump()

    return { added: added, updated: updated, rev: WindowStore_GetRev() }
}

WindowStore_UpdateFields(hwnd, patch) {
    ; Merge partial updates into a single record.
    global gWS_Store
    if (!gWS_Store.Has(hwnd))
        return { changed: false, rev: WindowStore_GetRev() }

    rec := gWS_Store[hwnd]
    changed := _WS_MergeInto(rec, patch)
    if (changed)
        _WS_RequestRevBump()
    return { changed: changed, rev: WindowStore_GetRev() }
}

WindowStore_RemoveWindow(hwnds) {
    ; Immediate hard removal (destroy icon if any). Accept scalar or array.
    global gWS_Store
    if !IsObject(hwnds)
        hwnds := [hwnds]

    removed := 0
    for _, h in hwnds {
        hwnd := h + 0
        if (!gWS_Store.Has(hwnd))
            continue
        rec := gWS_Store[hwnd]
        ; cleanup icon
        if (rec.iconHicon) {
            try DllCall("user32\DestroyIcon", "ptr", rec.iconHicon)
        }
        gWS_Store.Delete(hwnd)
        removed += 1
    }
    if (removed > 0)
        _WS_RequestRevBump()
    return { removed: removed, rev: WindowStore_GetRev() }
}

WindowStore_GetRev() {
    global gWS_Rev
    return gWS_Rev
}

WindowStore_GetByHwnd(hwnd) {
    global gWS_Store
    return gWS_Store.Has(hwnd) ? gWS_Store[hwnd] : 0
}

WindowStore_GetProjection(opts := 0) {
    ; Returns {rev, hwnds, items?, meta}
    global gWS_Config
    if (!IsObject(opts))
        opts := Map()

    filter := _WS_DefaultFilter()
    if (opts.Has("filter") && IsObject(opts.filter))
        filter := _WS_MergeFilter(filter, opts.filter)

    sortKey := opts.Has("sort") ? _WS_ValidateSort(opts.sort) : (gWS_Config["DefaultSort"] . "")
    cols    := opts.Has("columns") ? _WS_ValidateColumns(opts.columns) : "hwndsOnly"

    ; Build filtered list of records (presentOnly by default, etc).
    recs := _WS_FilterRecords(filter)

    ; Sort in-place per sortKey.
    _WS_SortRecords(recs, sortKey)

    ; Build outputs.
    hwnds := []
    for _, r in recs
        hwnds.Push(r.hwnd)

    out := { rev: WindowStore_GetRev(), hwnds: hwnds, meta: {
        count: _WS_TotalCount(), filteredCount: hwnds.Length, sortKey: sortKey
    }}

    if (cols = "items") {
        items := []
        total := recs.Length
        i := 1
        while (i <= total) {
            items.Push(_WS_ToGuiItem(recs[i], i, total))
            i += 1
        }
        out.items := items
    }
    return out
}

WindowStore_GetIndexOf(hwnd, opts := 0) {
    ; 1-based index of hwnd in the projection defined by opts; 0 if not present.
    proj := WindowStore_GetProjection(opts)
    i := 1
    while (i <= proj.hwnds.Length) {
        if (proj.hwnds[i] = hwnd)
            return i
        i += 1
    }
    return 0
}

;============================= INTERNAL HELPERS ================================

_WS_RequestRevBump() {
    global gWS_Batching, gWS_PendingRevBump, gWS_Rev
    if (gWS_Batching) {
        gWS_PendingRevBump := true
    } else {
        gWS_Rev += 1
    }
}

_WS_Now() {
    return A_TickCount + 0
}

_WS_Basename(path) {
    if (!path)
        return ""
    SplitPath(path, &fname)
    return fname
}

_WS_NormalizeTitle(s) {
    global gWS_Config
    if (s = "")
        return ""
    out := s . ""
    ; Replace CR/LF/tabs with spaces
    out := StrReplace(out, "r", " ")
    out := StrReplace(out, "n", " ")
    out := StrReplace(out, "t", " ")
    if gWS_Config["TitleCollapseSpaces"] {
        ; collapse runs of spaces
        while InStr(out, "  ")
            out := StrReplace(out, "  ", " ")
    }
    out := Trim(out, " t")
    max := gWS_Config["NormalizeTitleMax"] + 0
    if (max > 0 && StrLen(out) > max)
        out := SubStr(out, 1, max)
    return out
}

_WS_StateCanonical(s) {
    if (!s)
        return "Unknown"
    t := StrLower(Trim(s))
    if (t = "workspaceshowing")    {
      return "WorkspaceShowing"
    }
    if (t = "workspaceminimized")  {
      return "WorkspaceMinimized"
    }
    if (t = "workspacehidden")     {
      return "WorkspaceHidden"
    }
    if (t = "otherworkspace")      {
      return "OtherWorkspace"
    }
    return "Unknown"
}

_WS_NewRecord(hwnd) {
    now := _WS_Now()
    return {
        ; Identity / process
        hwnd: hwnd + 0,
        pid: 0,
        class: "",
        exePath: "",
        processName: "",

        ; Titles
        titleRaw: "",
        title: "",

        ; State
        state: "Unknown",
        zOrder: 0,
        isVisible: false,
        isMinimized: false,
        isOnCurrentWorkspace: false,
        isFocused: false,
        isBlacklisted: false,

        ; Workspace
        workspaceId: "",
        workspaceName: "",

        ; MRU / activity
        lastActivatedTick: 0,
        totalActiveMs: 0,
        mruRank: 0,

        ; Icons
        iconHicon: 0,
        iconKey: "",

        ; Sweep / lifecycle
        present: true,
        lastSeenSweep: 0,
        lastSeenTick: now,
        missingSinceTick: 0,
        firstSeenTick: now,

        ; Record bookkeeping
        rev: 0
    }
}

; Merge patch object into rec. Returns true if any meaningful field changed.
_WS_MergeInto(rec, patch) {
    changed := false

    ; Identity / process
    if (patch.Has("pid"))           changed := changed || _WS_AssignIfDiff(rec, "pid", patch.pid + 0)
    if (patch.Has("class"))         changed := changed || _WS_AssignIfDiff(rec, "class", patch.class . "")
    if (patch.Has("exePath")) {
        path := patch.exePath . ""
        pname := _WS_Basename(path)
        changed := changed || _WS_AssignIfDiff(rec, "exePath", path)
        if (pname != "" && rec.processName != pname)
            rec.processName := pname, changed := true
    }
    if (patch.Has("processName"))   changed := changed || _WS_AssignIfDiff(rec, "processName", patch.processName . "")

    ; Titles
    if (patch.Has("titleRaw")) {
        raw := patch.titleRaw . ""
        norm := _WS_NormalizeTitle(raw)
        if (rec.titleRaw != raw) {
          rec.titleRaw := raw, changed := true
        }
        if (rec.title != norm)   {
          rec.title    := norm, changed := true
        }
    } else if (patch.Has("title")) {
        ; Allow callers to supply already-normalized title
        norm := _WS_NormalizeTitle(patch.title . "")
        if (rec.title != norm) {
          rec.title := norm, changed := true
        }
    }

    ; State
    if (patch.Has("state"))         changed := changed || _WS_AssignIfDiff(rec, "state", _WS_StateCanonical(patch.state))
    if (patch.Has("zOrder"))        changed := changed || _WS_AssignIfDiff(rec, "zOrder", patch.zOrder + 0)
    if (patch.Has("isVisible"))     changed := changed || _WS_AssignIfDiff(rec, "isVisible", !!patch.isVisible)
    if (patch.Has("isMinimized"))   changed := changed || _WS_AssignIfDiff(rec, "isMinimized", !!patch.isMinimized)
    if (patch.Has("isOnCurrentWorkspace")) changed := changed || _WS_AssignIfDiff(rec, "isOnCurrentWorkspace", !!patch.isOnCurrentWorkspace)
    if (patch.Has("isFocused"))     changed := changed || _WS_AssignIfDiff(rec, "isFocused", !!patch.isFocused)
    if (patch.Has("isBlacklisted")) changed := changed || _WS_AssignIfDiff(rec, "isBlacklisted", !!patch.isBlacklisted)

    ; Workspace
    if (patch.Has("workspaceId"))   changed := changed || _WS_AssignIfDiff(rec, "workspaceId", patch.workspaceId)
    if (patch.Has("workspaceName")) changed := changed || _WS_AssignIfDiff(rec, "workspaceName", patch.workspaceName . "")

    ; MRU / activity
    if (patch.Has("lastActivatedTick")) {
        ; Accept newer timestamps; if you want “source of truth” MRU, drop the guard.
        t := patch.lastActivatedTick + 0
        if (t != rec.lastActivatedTick)  ; simple overwrite is usually fine
            rec.lastActivatedTick := t, changed := true
    }
    if (patch.Has("totalActiveMs")) changed := changed || _WS_AssignIfDiff(rec, "totalActiveMs", patch.totalActiveMs + 0)
    if (patch.Has("mruRank"))       changed := changed || _WS_AssignIfDiff(rec, "mruRank", patch.mruRank + 0)

    ; Icons
    if (patch.Has("iconHicon")) {
        ; If caller replaces an existing icon, destroy the old one to avoid leaks.
        newH := patch.iconHicon + 0
        if (newH != rec.iconHicon) {
            if (rec.iconHicon)
                try DllCall("user32\DestroyIcon", "ptr", rec.iconHicon)
            rec.iconHicon := newH, changed := true
        }
    }
    if (patch.Has("iconKey"))       changed := changed || _WS_AssignIfDiff(rec, "iconKey", patch.iconKey . "")

    ; Lifecycle flags are controlled by sweep/Upsert; don't set present directly here
    return changed
}

_WS_AssignIfDiff(rec, key, val) {
    if (!rec.Has(key) || rec.%key% != val) {
        rec.%key% := val
        return true
    }
    return false
}

_WS_DefaultFilter() {
    return {
        presentOnly: true,
        currentWorkspaceOnly: false,
        blacklistMode: "exclude",
        classes: [],
        pids: []
    }
}

_WS_MergeFilter(base, override) {
    out := Map()
    ; copy base first
    for k, v in base
        out[k] := v
    ; overlay any provided keys
    for k, v in override
        out[k] := v
    ; normalize values
    out.presentOnly := !!out.presentOnly
    out.currentWorkspaceOnly := !!out.currentWorkspaceOnly
    bm := StrLower(out.blacklistMode . "")
    if (bm != "include" && bm != "only")
        bm := "exclude"
    out.blacklistMode := bm
    if !IsObject(out.classes) out.classes := []
    if !IsObject(out.pids)    out.pids := []
    return out
}

_WS_ValidateSort(s) {
    t := StrUpper(Trim(s . ""))
    if (t = "MRU" || t = "Z" || t = "TITLE" || t = "PID" || t = "PROCESSNAME")
        return t
    return "MRU"
}

_WS_ValidateColumns(c) {
    t := StrLower(Trim(c . ""))
    if (t = "items")
        return "items"
    return "hwndsOnly"
}

_WS_FilterRecords(filter) {
    global gWS_Store
    recs := []
    for hwnd, rec in gWS_Store {
        if (filter.presentOnly && !rec.present)
            continue
        if (filter.currentWorkspaceOnly && !rec.isOnCurrentWorkspace)
            continue
        if (filter.blacklistMode = "exclude" && rec.isBlacklisted)
            continue
        if (filter.blacklistMode = "only" && !rec.isBlacklisted)
            continue
        if (filter.classes.Length) {
            keep := false
            for _, cls in filter.classes
                if (rec.class = (cls . "")) {
                    keep := true
                    break
                }
            if !keep
                continue
        }
        if (filter.pids.Length) {
            keep2 := false
            for _, p in filter.pids
                if (rec.pid = (p + 0)) {
                    keep2 := true
                    break
                }
            if !keep2
                continue
        }
        recs.Push(rec)
    }
    return recs
}

_WS_SortRecords(recs, sortKey) {
    ; In-place sort of an array of record objects.
    if (sortKey = "MRU") {
        recs.Sort((a, b) => _WS_CompareDesc(a.lastActivatedTick, b.lastActivatedTick, a, b))
        return
    }
    if (sortKey = "Z") {
        ; Lower Z-order at front (or reverse if your Z means “on top” is smaller).
        recs.Sort((a, b) => _WS_CompareAsc(a.zOrder, b.zOrder, a, b))
        return
    }
    if (sortKey = "TITLE") {
        recs.Sort((a, b) => _WS_CompareStrAsc(a.title, b.title, a, b))
        return
    }
    if (sortKey = "PID") {
        recs.Sort((a, b) => _WS_CompareAsc(a.pid, b.pid, a, b))
        return
    }
    if (sortKey = "PROCESSNAME") {
        recs.Sort((a, b) => _WS_CompareStrAsc(a.processName, b.processName, a, b))
        return
    }
    ; default fallback
    recs.Sort((a, b) => _WS_CompareDesc(a.lastActivatedTick, b.lastActivatedTick, a, b))
}

_WS_CompareAsc(x, y, a, b) {
    if (x < y)  {
      return -1
    }
    if (x > y)  {
      return 1
    }
    ; tie-breakers for stability
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}
_WS_CompareDesc(x, y, a, b) {
    if (x > y)  {
      return -1
    }
    if (x < y)  {
      return 1
    }
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}
_WS_CompareStrAsc(x, y, a, b) {
    sx := x . "", sy := y . ""
    c := StrCompare(sx, sy, true)  ; case-insensitive
    if (c < 0) {
      return -1
    }
    if (c > 0) {
      return 1
    }
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}

_WS_TotalCount() {
    global gWS_Store
    c := 0
    for _, _ in gWS_Store
        c += 1
    return c
}

; Convert a record to a “raw GUI item” expected by NewGUI__BuildRowModel in your newgui.ahk.
_WS_ToGuiItem(rec, idx, total) {
    ; Subtext comes from state (shortened later by GUI code if configured).
    wsName := rec.workspaceName ? rec.workspaceName : ""
    return {
        Title: rec.title != "" ? rec.title : (rec.processName != "" ? rec.processName : "(untitled)"),
        State: rec.state,
        Hwnd:  rec.hwnd,
        Pid:   rec.pid,
        ZOrder: rec.zOrder,
        Class: rec.class,
        Workspace: wsName,

        ; optional extras (GUI won’t break if unused)
        ProcessName: rec.processName,
        WorkspaceId: rec.workspaceId,
        IsBlacklisted: rec.isBlacklisted,
        IsVisible: rec.isVisible,
        IsMinimized: rec.isMinimized,
        IsOnCurrentWorkspace: rec.isOnCurrentWorkspace,
        IsFocused: rec.isFocused,

        ; icon handle is available if you wire GUI to read it; otherwise the
        ; existing icon pump caches via hwnd anyway.
        HICON: rec.iconHicon
    }
}
----------
This is a big file, and might be a lot for you to spit out changes. You can alternative just tell me which full functions to ADD / REPLACE / REMOVE and we can update it that way. Per our latest discussion what are all the updates we need? Lets make them now. I count as needed:
WindowStore.BeginScan
WindowStore.EndScan(scanToken, graceMs):
tombstones (or deletes) records that have been presentNow=false for > graceMs.
Frees associated heavy resources (e.g., icons) at tombstone time.
Set “need flags”:
needsProcName if pid>0 && processName==""

needsIcon if iconHicon==0

needsWS if workspace==""
Push identifiers into deduped queues (pidQueue, hwndQueue, wsQueue).
Maintain per-record flags (presentNow, lastSeenTick, needsIcon, needsProcName).
Add WindowStore.Ensure(hwnd, hints?).
If it doesn’t → call an injected fetcher (function pointer set at init) that does the minimal enumerate-by-hwnd, then apply hints.

Caches:

PID→ProcessName cache (evict when no rows reference that PID after tombstone).

HWND→HICON cache (destroy when the row is fully removed).

Optional EXE→HICON fallback cache to avoid repeated ExtractIconEx

Expose a constant-time check from the store so MRU/Komorebi can branch without guessing:

WindowStore.Has(hwnd) → bool (O(1) map lookup).

WindowStore.GetByHwnd(hwnd) → record | "" if you need to read fields.

WindowStore.Ensure(hwnd, hints?) → {record, existed: bool} so callers can do a single call and not care which branch they’re on. If existed=false, Ensure uses your injected EnumerateByHwnd fetcher (or calls winenum directly, depending on which wiring you chose) and merges hints.

Have a tiny meta section in WindowStore:

SetCurrentWorkspace(id, name?)
GetCurrentWorkspace() → {id, name}

did i capture it all? if not at the rest per our discussion. Lets get this added. Either respond with a full new list.ahk, or i dont mind full function level ADD / REPLACE / DELETE instructions 
Alright, given that, can you now make three ahks for the pumps - icon, process, and komorebi. For the komorebi pump, it can be placeholders for how it will interact with our greater komorebi.ahk because we haven't refaftired that yet. So focus on how it needs to interact with the api but the calls into komorebi.ahk functions can be placeholder. For the other 2 pumps, you should be able to fully code them. 
OK, so here is the winenum.ahk after we first refactored to use our WindowStore API
-------------------
#Requires AutoHotkey v2.0
; =============================================================================
; winenum.ahk — fast Z-order enumeration with DWM cloaking info
; - Back-compat: WinList_EnumerateAll() still returns [{Hwnd, Title, Class, Pid, State, ZOrder}, ...]
; - New: Also feeds results into WindowStore.UpsertWindow([]) in a single batch
; - New: WinList_EnumerateByHwnd(hwnd) → single record + upsert to store
; - Optional: mirror blacklisted hits into the store with isBlacklisted=true (off by default)
; =============================================================================

; ----------------------------- Config toggles -------------------------------
; If true: when a window hits any blacklist, still Upsert to store with isBlacklisted=true
; If false (default): blacklist is filtered from the store feed (behavior matches old overlay result list)
global WN_RecordBlacklistInStore := false

; If true: also fetch the process executable name (costs one OpenProcess + QueryFullProcessImageName)
global WN_FetchProcessName := true

; If true: apply Alt-Tab eligibility filter (WS_EX_TOOLWINDOW, owner-window, etc.)
; This is the same flag your old file honored; we read it if set, else default true.
if !IsSet(UseAltTabEligibility)
    global UseAltTabEligibility := true

; ---------------------------- Module state (debug) --------------------------
global _WN_all := []           ; back-compat return list
global _WN_zCounter := 0
global _WN_shell := 0
global _WN_logbuf := ""
global _WN_traceLeft := 0
global _WN_traceDeadline := 0

; ------------------------------ Public API ----------------------------------

; Back-compat enumerator (also feeds the WindowStore in one batch).
WinList_EnumerateAll() {
    global _WN_all, _WN_zCounter, _WN_shell
    global _WN_logbuf, _WN_traceLeft, _WN_traceDeadline
    global WN_RecordBlacklistInStore

    dbg       := (IsSet(DebugBlacklist) && DebugBlacklist)
    maxLines  := IsSet(DebugMaxLinesPerSession) ? DebugMaxLinesPerSession : 200
    maxMillis := IsSet(DebugMaxDurationMs)      ? DebugMaxDurationMs      : 200

    DllCall("LoadLibrary", "str", "dwmapi.dll")
    _WN_shell := DllCall("user32\GetShellWindow", "ptr")
    _WN_zCounter := 0
    _WN_all := []
    toStore := []   ; batch upsert payload for WindowStore

    ; prepare debug budget
    if (dbg) {
        _WN_logbuf := ""
        _WN_traceLeft := maxLines
        _WN_traceDeadline := A_TickCount + maxMillis
        _WN_Log("=== WinList_EnumerateAll (begin) ===")
    } else {
        _WN_logbuf := ""
        _WN_traceLeft := 0
        _WN_traceDeadline := 0
    }

    ; Enumerate using a capturing closure so we can accumulate both return-list and store payload.
    enumCb := (hWnd, lParam) => _WN_EnumProc_ForAll(hWnd, &toStore)
    cb := CallbackCreate(enumCb, "Fast", 2)
    DllCall("user32\EnumWindows", "ptr", cb, "ptr", 0, "int")
    CallbackFree(cb)

    ; Feed the store in one shot (if present)
    if (toStore.Length) {
        try UpsertWindow(toStore)
        catch as e {
            _WN_Log("UpsertWindow(toStore) failed: " e.Message)
        }
    }

    if (dbg) {
        _WN_Log("=== WinList_EnumerateAll (end) ===")
        _WN_FlushLog()
    }
    return _WN_all
}

; Single-window probe (MRU/Komorebi can call when a new HWND appears).
; Returns {} if ineligible/blacklisted, else {Hwnd, Title, Class, Pid, State, ZOrder}
; Also upserts to WindowStore (mirrors blacklist state if WN_RecordBlacklistInStore=true).
WinList_EnumerateByHwnd(hWnd) {
    if (!hWnd)
        return {}
    rec := _WN_ProbeOne(hWnd)
    if (rec.Has("forStore")) {
        ; Upsert into WindowStore
        try UpsertWindow([rec.forStore])
        catch as e {
            _WN_Log("UpsertWindow([one]) failed: " e.Message)
        }
    }
    ; Back-compat shape for AltLogic usage
    if (rec.Has("forList"))
        return rec.forList
    return {}
}

; ---------------------------- Enumeration core ------------------------------

; EnumWindows callback body used by WinList_EnumerateAll
_WN_EnumProc_ForAll(hWnd, &toStore) {
    global _WN_all, _WN_zCounter, _WN_shell
    if (hWnd = 0)
        return 1
    if (hWnd = _WN_shell) {
        _WN_zCounter += 1
        return 1
    }

    rec := _WN_ProbeOne(hWnd)
    ; Store payload (if present)
    if (rec.Has("forStore"))
        toStore.Push(rec.forStore)
    ; Back-compat return-list (if present)
    if (rec.Has("forList"))
        _WN_all.Push(rec.forList)

    _WN_zCounter += 1
    return 1
}

; Probe one HWND → apply filters, compute fields, build
; - forStore: canonical WindowStore record (lowercase keys, booleans, etc.)
; - forList : legacy overlay record (Title/Class/Pid/ZOrder)
_WN_ProbeOne(hWnd) {
    global _WN_zCounter, WN_RecordBlacklistInStore, WN_FetchProcessName, UseAltTabEligibility
    global BlacklistTitle, BlacklistClass, BlacklistPair

    out := {}

    ; Fast pulls
    cls := _GetClass(hWnd)
    ttl := _GetTitle(hWnd)

    ; ---------- HARD FILTER: GDI+ helper windows ----------
    if (_IsGdiPlusHelper(ttl, cls)) {
        _Trace("Skip GDI+ helper", ttl, cls)
        return out
    }
    ; ------------------------------------------------------

    ; Early blacklist checks
    isBList := false
    if (MatchAny(cls, BlacklistClass)) {
        _Trace("Hit Class list", ttl, cls), isBList := true
    } else if (!ttl) {
        ; Blank title => drop (also back-compat behavior)
        return out
    } else if (MatchAny(ttl, BlacklistTitle)) {
        _Trace("Hit Title list", ttl, cls), isBList := true
    } else if (MatchPairs(ttl, cls, BlacklistPair)) {
        _Trace("Hit Pair list", ttl, cls), isBList := true
    }

    ; Visibility / minimized / cloaked
    isVisible := !!DllCall("user32\IsWindowVisible", "ptr", hWnd, "int")
    isMin     := !!DllCall("user32\IsIconic",        "ptr", hWnd, "int")

    cloakedBuf := Buffer(4, 0)
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hWnd, "uint", 14, "ptr", cloakedBuf.Ptr, "uint", 4, "int")
    isCloaked := (hr = 0) && (NumGet(cloakedBuf, 0, "UInt") != 0)

    state := "WorkspaceHidden"
    if (isCloaked)
        state := "OtherWorkspace"
    else if (isMin)
        state := "WorkspaceMinimized"
    else if (isVisible)
        state := "WorkspaceShowing"

    ; Alt-Tab eligibility (if toggled on)
    eligible := _IsAltTabEligible(hWnd, isVisible, isMin, isCloaked)
    if (UseAltTabEligibility && !eligible) {
        _Trace("Ineligible (Alt-Tab rules)", ttl, cls)
        ; We only mirror to store if explicitly asked to keep all
        if (WN_RecordBlacklistInStore) {
            pid := _GetPid(hWnd)
            procName := WN_FetchProcessName ? _GetProcessName(pid) : ""
            out.forStore := _WN_MakeStoreRecord(hWnd, pid, cls, ttl, procName, state, _WN_zCounter
                , isVisible, isMin, isCloaked, true, false, eligible)
        }
        return out
    }

    ; If blacklisted: either mirror to store (flagged) or drop
    if (isBList) {
        if (WN_RecordBlacklistInStore) {
            pid := _GetPid(hWnd)
            procName := WN_FetchProcessName ? _GetProcessName(pid) : ""
            out.forStore := _WN_MakeStoreRecord(hWnd, pid, cls, ttl, procName, state, _WN_zCounter
                , isVisible, isMin, isCloaked, true, false, eligible)
        }
        return out
    }

    ; Eligible path
    pid := _GetPid(hWnd)
    procName := WN_FetchProcessName ? _GetProcessName(pid) : ""

    ; Store record (canonical)
    out.forStore := _WN_MakeStoreRecord(hWnd, pid, cls, ttl, procName, state, _WN_zCounter
        , isVisible, isMin, isCloaked, false, true, eligible)

    ; Back-compat return-list row
    out.forList := { Hwnd: hWnd, Title: ttl, Class: cls, Pid: pid, State: state, ZOrder: _WN_zCounter }

    return out
}

; Build canonical WindowStore record (lowercase keys)
_WN_MakeStoreRecord(hWnd, pid, cls, ttl, procName, state, z
    , isVisible, isMin, isCloaked, isBlacklisted, presentNow, eligible) {
    rec := {
        hwnd: hWnd,
        pid: pid,
        class: cls,
        title: ttl,              ; store can normalize if desired
        processName: procName,   ; may be "", based on WN_FetchProcessName
        state: state,
        zOrder: z,
        isVisible: isVisible,
        isMinimized: isMin,
        isCloaked: isCloaked,
        isBlacklisted: isBlacklisted,
        altTabEligible: eligible,
        presentNow: presentNow,
        lastSeenTick: A_TickCount,
        source: "winenum"
    }
    return rec
}

; ------------------------------ Helpers -------------------------------------

_GetTitle(hWnd) {
    buf := Buffer(512*2, 0)
    DllCall("user32\GetWindowTextW", "ptr", hWnd, "ptr", buf.Ptr, "int", 512, "int")
    s := StrGet(buf.Ptr, "UTF-16")
    return Trim(RegExReplace(s, "[\r\n\t]+", " "))
}

_GetClass(hWnd) {
    buf := Buffer(256*2, 0)
    DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
    return StrGet(buf.Ptr, "UTF-16")
}

_GetPid(hWnd) {
    pidBuf := Buffer(4, 0)
    DllCall("user32\GetWindowThreadProcessId", "ptr", hWnd, "ptr", pidBuf.Ptr, "uint")
    return NumGet(pidBuf, 0, "UInt")
}

_GetProcessName(pid) {
    if (!pid)
        return ""
    PROCESS_QUERY_LIMITED_INFORMATION := 0x1000
    hProc := DllCall("kernel32\OpenProcess","uint",PROCESS_QUERY_LIMITED_INFORMATION,"int",0,"uint",pid,"ptr")
    if (!hProc)
        return ""
    buf := Buffer(32767 * 2, 0), sz := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW","ptr",hProc,"uint",0,"ptr",buf.Ptr,"uint*",sz,"int")
    DllCall("kernel32\CloseHandle","ptr",hProc)
    if (!ok)
        return ""
    full := StrGet(buf.Ptr, "UTF-16")
    SplitPath(full, &nameOnly)
    return nameOnly
}

_IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) {
    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", -20, "ptr")
    WS_EX_TOOLWINDOW := 0x00000080
    WS_EX_APPWINDOW  := 0x00040000
    isTool := (ex & WS_EX_TOOLWINDOW) != 0
    isApp  := (ex & WS_EX_APPWINDOW)  != 0

    owner := DllCall("user32\GetWindow", "ptr", hWnd, "uint", 4, "ptr") ; GW_OWNER

    if (isTool)
        return false
    if !(owner = 0 || isApp)
        return false
    if !(isVisible || isMin || isCloaked)
        return false
    return true
}

; ---------- module-local debug helpers ----------

_IsGdiPlusHelper(ttl, cls) {
    ttlN := NormalizeMatchText(ttl)
    clsN := NormalizeMatchText(cls)
    if (clsN != "GDI+Hook Window Class")
        return false
    return RegExMatch(ttlN, "^GDI\+Window \([^)]+\)$")
}

_Trace(tag, ttl, cls) {
    global _WN_traceLeft, _WN_traceDeadline
    dbg := (IsSet(DebugBlacklist) && DebugBlacklist)
    if !dbg
        return
    if (_WN_traceLeft <= 0 || (_WN_traceDeadline && A_TickCount > _WN_traceDeadline))
        return
    _WN_traceLeft -= 3  ; each block ~3 lines budget
    _WN_Log("[" tag "]")
    _WN_Log("  Title: " ttl)
    _WN_Log("  Class: " cls)
}

_WN_Log(line) {
    global _WN_logbuf
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff")
    _WN_logbuf .= ts "  " line "rn"
}

_WN_GetLogPath() {
    if (IsSet(DebugLogPath) && DebugLogPath)
        return DebugLogPath
    return A_ScriptDir "\tabby_debug.log"
}

_WN_FlushLog() {
    global _WN_logbuf
    if (_WN_logbuf = "")
        return
    path := _WN_GetLogPath()

    SplitPath path, , &dir
    if (dir != "")
        try DirCreate(dir)

    ok := false
    try {
        FileAppend(_WN_logbuf, path, "UTF-8")
        ok := true
    } catch {
        try {
            FileAppend(_WN_logbuf, A_Temp "\tabby_debug.log", "UTF-8")
            ok := true
        } catch {
            ; give up
        }
    }
    _WN_logbuf := ""
}

----------------------

But given our latest round of discussion, dont we need to make some changes?

Add BeginScan and EndScan 
ensure presentnow and lastseentick 
keep UseAltTabEligibility := true behavior from our original 
your words "Trim winenum.ahk to only do the base fields and drive scans." i think you meant no process names
update WinList_EnumerateByHwnd to accept hints
update WinList_EnumerateByHwnd to accept more than 1 hwnd (batches) or make dedicated EnumerateByHwndMany


whatever you meant by this that I didnt fully follow:
-----------
Option A (cleanest): Ensure + injected fetcher

Add WindowStore.Ensure(hwnd, hints?).

If the hwnd exists → just UpdateFields(hints).

If it doesn’t → call an injected fetcher (function pointer set at init) that does the minimal enumerate-by-hwnd, then apply hints.

This keeps WindowStore independent (no import of winenum), but lets it guarantee base fields exist before any hints land.
---------------

Anything else I'm missing? Per our latst discussion and API updates?

You can respond with a full new winenum.ahk, or you've doing great with full function level ADD / REPLACE / REMOVE
Nice, thank you. 

So the next point is MRU. Currently my mru.ahk looks like this
----------
; mru.ahk — track Most-Recently-Used activation order via Shell hook
; Public:
;   MRU_Init()
;   MRU_GetList() -> array of hwnds (most-recent-first)

global _MRU_list := []       ; [hwnd, hwnd, ...] most-recent-first
global _MRU_msg := 0
global _MRU_win := 0

MRU_Init() {
  global _MRU_msg, _MRU_win
  if (_MRU_msg)  ; already initialized
    return

  _MRU_win := Gui("-Caption +ToolWindow")  ; no +Hwnd option in v2
  _MRU_win.Hide()

  ; register hidden GUI as a shell hook window
  DllCall("RegisterShellHookWindow", "ptr", _MRU_win.Hwnd)

  ; get the message id for shell notifications and route it
  _MRU_msg := DllCall("RegisterWindowMessage", "str", "SHELLHOOK", "uint")
  OnMessage(_MRU_msg, MRU_OnShell)
}


MRU_OnShell(wParam, lParam, msg, hwnd) {
  static HSHELL_WINDOWCREATED := 1
  static HSHELL_WINDOWDESTROYED := 2
  static HSHELL_WINDOWACTIVATED := 4
  static HSHELL_RUDEAPPACTIVATED := 0x8004

  if (wParam = HSHELL_WINDOWDESTROYED) {
    MRU_Remove(lParam)
    return
  }

  if (wParam != HSHELL_WINDOWACTIVATED && wParam != HSHELL_RUDEAPPACTIVATED)
    return

  hwndAct := lParam
  if (hwndAct = 0)
    return

  cls := _MRU_GetClass(hwndAct)
  if (cls = "AutoHotkeyGUI")
    return

  ttl := ""
  try ttl := WinGetTitle("ahk_id " hwndAct)
  if (ttl = OverlayTitle)
    return

  MRU_MoveToFront(hwndAct)
}

MRU_Remove(hwnd) {
  global _MRU_list
  for i, h in _MRU_list
    if (h = hwnd) {
      _MRU_list.RemoveAt(i)
      break
    }
}


MRU_MoveToFront(hwnd) {
  global _MRU_list
  ; Remove any prior occurrence
  for i, h in _MRU_list
    if (h = hwnd) {
      _MRU_list.RemoveAt(i)
      break
    }
  _MRU_list.InsertAt(1, hwnd)
}

MRU_GetList() {
  global _MRU_list
  return _MRU_list.Clone()   ; shallow copy
}

_MRU_GetClass(hWnd) {
  buf := Buffer(256*2, 0)
  DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
  return StrGet(buf.Ptr, "UTF-16")
}
----------

Now its used in altlogic.ahk in a few ways, such as when building _MRU_list
; ---- MRU + Z-order ----
ALTAB_BuildList() {
  global UseMRU
  arr := WinList_EnumerateAll()  ; filtered, Z-order list
  if (!UseMRU)
    return arr

  local hmap := Map(), ordered := [], mru := MRU_GetList()
  for _, item in arr
    hmap[item.Hwnd] := item
  if IsObject(mru) {
    for _, h in mru
      if hmap.Has(h) {
        ordered.Push(hmap[h])
        hmap.Delete(h)
      }
  }
  for hwnd, item in hmap
    ordered.Push(item)
  return ordered
}

and after it activates an hwnd, it calls into it
    ok := ActivateHwnd(target.Hwnd, target.State)
    __RX_Log(Format("activate hwnd={1} state={2} ok={3}", target.Hwnd, target.State, ok))
    if (ok)
      MRU_MoveToFront(target.Hwnd)

its never been clear to me, is this something we query a will window list from?
or do we just get a stream of updates with
HSHELL_WINDOWCREATED
HSHELL_WINDOWDESTROYED
HSHELL_WINDOWACTIVATED
HSHELL_RUDEAPPACTIVATED
Or both?

And how do want to refactor this given everything discussed above and the new WindowStore API? 

We've talked about it a few ways
------

If they spot an unknown HWND: call WinList_EnumerateByHwnd(hwnd) (or UpsertWindow with what they know), the store will schedule any missing bits.

2) Who should upsert when MRU/Komorebi see a new hwnd?

Avoid skeleton records that lack base fields. Use one of these (ordered by cleanliness):

Option A (cleanest): Ensure + injected fetcher

Add WindowStore.Ensure(hwnd, hints?).

If the hwnd exists → just UpdateFields(hints).

If it doesn’t → call an injected fetcher (function pointer set at init) that does the minimal enumerate-by-hwnd, then apply hints.

This keeps WindowStore independent (no import of winenum), but lets it guarantee base fields exist before any hints land.

If hwnd is known: WindowStore.UpdateFields(hwnd, {lastActivatedTick, workspace, isOnCurrentWorkspace, ...}).

If hwnd unknown: call Ensure (Option A) or WinList_EnumerateByHwnd(hwnd, hints) (Option B).

Great q’s—these two decisions will save you a bunch of whack-a-mole later.

1) “Is this HWND known already?”

Expose a constant-time check from the store so MRU/Komorebi can branch without guessing:

WindowStore.Has(hwnd) → bool (O(1) map lookup).

WindowStore.GetByHwnd(hwnd) → record | "" if you need to read fields.

(Nice-to-have) WindowStore.Ensure(hwnd, hints?) → {record, existed: bool} so callers can do a single call and not care which branch they’re on. If existed=false, Ensure uses your injected EnumerateByHwnd fetcher (or calls winenum directly, depending on which wiring you chose) and merges hints.
-------

so again, im a bit lost. should we have mru.ahk check
WindowStore.Has(hwnd) → bool and decide to call into winenum.ahk for new hwnd(s)?
or does the WindowStore know how to call into the WinList_Enumerate functions? Because I don't see "WinList_Enumerate" anywhere in list.ahk.

So walk me through how these questions and how we will refactor mru.ahk

(no code discussion first)
ok, i like it. generate me our new mru.ahk as you just described.

on your commentery
no we dont need to handle workspace we will let the komorebi pump do it
cheaply debounce repeated activations. I dont think thats necessary? Or add it but behind a config flag for the ms, where 0ms = off



OK, lets talk our komorebi module next. Before I share code for my existing module, here is a high level concept.

komorebi.ahk has a method _Komorebi_GetStateText() that runs a cli, runs the komorebi state command, outputs to a temp file, then reads it back. So it gets the entire state. and from that it can extract what workspace belongs to an HWND. It is also responsible for when it is time to activate an HWND not in our current workspace, determining the right monitor/workspace and sending the right komorebic command to activate. 

On the other hand, we have komorebi_sub.ahk - this opens a named pipe to get subscribe to komorebi events. so from each event it can get an hwnd -> workspace_name and maintains a cache, and handles Auto-reconnect & backoff.

Now I'm also not 100% how its working in practice because its vibe coded with you, but thats the gist of it. 

So, how do you propose we refactor it into our new WindowStore API?
Is it simply calling UpsertWindow with a timestamp and workstation?
but what if it tries to upsert something thats not there yet, then it wont have the winenum data
does it Ensure instead? 
does it have some logic to decide between ensure and upsert, or is that automatic with ensure (if it is spell it out for me so i can remember)
and I presume it should keep a cache of LastSeenWorkspace, and when it changes, fire WindowStore_SetCurrentWorkspace(). 
Unless there is a dedicated workspace change in the subscription, but im not seeing that now (youll see when I share the full code).

Thoughts on what are refactor plan / goals are?

commentary only no code
Still discussion - do we have to worry about multiple watchers firing or race conditions?
by that I mean, if I switch focus from window X to window Y, both MRU.ahk and komorebi_sub.ahk are going to get info and start calling ensure()? is that an issue?
also, do we let komorebi pass in a last seen timestamp or leave that fully to MRU and komorebi only worries about its specific items.
no code discussion only
ok, quick clarification, you say field ownership and guards, like:
MRU owns lastActivatedTick (and, if you want, isFocused).

WinEnum owns present/presentNow/lastSeenTick/zOrder/isVisible/isMinimized/state.

Komorebi owns workspaceId/workspaceName and the global current workspace.

Icons/Process pumps own their fields.
so my question to confirm, this "ownership" is design level ownership from us right? like the WindowStoreAPI isnt actually verify which sub functions are calling into and validating ownership somehow? Like I could totally pass an MRU field from my komorebi.ahk right? not that I would, but its our job not to? or does the API know and enforce ownership? 
do you think its wise to add it? I'm thinking yes, because I'm coding this so heavy in partnership with you, an LLM, it might help the context / focused memory of, well frankly ME but also you, the LLM? 

here is my current list.ahk
-----------
#Requires AutoHotkey v2.0
;===============================================================================
; list.ahk  —  WindowStore (single source of truth)
; ------------------------------------------------------------------------------
; Purpose:
;   Centralized, in-memory store for window metadata. Everyone (winenum, MRU,
;   Komorebi, icon pump, AltLogic, GUI) reads/writes here instead of syncing
;   disparate structures. AltLogic owns session selection and just asks the
;   store for ordered projections.
;
; Design highlights:
;   - BeginBatch/EndBatch coalesce rev bumps (rev increments once per meaningful
;     change set). GetRev() exposes current global revision.
;   - BeginSweep/EndSweep implement enum “sweeps”; missing windows are hidden
;     immediately from projections (present=false) and hard-removed after a
;     configurable TTL (MissingTTLms). Icons are destroyed on hard removal.
;   - UpsertWindow / UpdateFields merge fields idempotently with normalization.
;   - GetProjection builds a filtered + sorted view (MRU/Z/etc). It can return
;     just hwnds (fast) or GUI-ready “items” (raw fields the GUI expects).
;   - GetIndexOf maps a hwnd to its index within a given projection spec.
;
; Threading:
;   AHK runs single-threaded user code; we keep data-structure ops simple and
;   cheap. GUI scroll/click never touches the store in normal flow; AltLogic
;   updates its session indices and repaints from cached items until rev changes.
;
; Public API (functions):
;   WindowStore_Init(config?)
;   WindowStore_BeginBatch()
;   WindowStore_EndBatch() -> {rev, changed}
;   WindowStore_BeginSweep(sweepId)
;   WindowStore_EndSweep(sweepId) -> {hiddenNow, tombstoned, removed, rev}
;   WindowStore_UpsertWindow(records[]) -> {added, updated, rev?}
;   WindowStore_UpdateFields(hwnd, patch) -> {changed, rev?}
;   WindowStore_RemoveWindow(hwnds) -> {removed, rev?}
;   WindowStore_GetRev()
;   WindowStore_GetByHwnd(hwnd) -> record?
;   WindowStore_GetProjection(opts?) -> {rev, hwnds, items?, meta}
;   WindowStore_GetIndexOf(hwnd, opts?) -> index?  (1-based)
;
; opts for GetProjection (defaults shown):
;   {
;     filter: {
;       presentOnly: true,
;       currentWorkspaceOnly: false,
;       blacklistMode: "exclude",   ; "exclude" | "include" | "only"
;       classes: [],                ; whitelist if provided
;       pids: []                    ; whitelist if provided
;     },
;     sort: "MRU",                  ; "MRU" | "Z" | "Title" | "Pid" | "ProcessName"
;     columns: "hwndsOnly"          ; "hwndsOnly" | "items"
;   }
;
; Record schema (per HWND):
;   See _WS_NewRecord() below; fields match our earlier spec.
;===============================================================================

;============================== GLOBAL STATE ===================================

global gWS_Store            := Map()     ; hwnd (UInt) -> record (Object)
global gWS_Rev              := 0         ; global store revision (monotonic)
global gWS_Batching         := false     ; inside BeginBatch/EndBatch
global gWS_PendingRevBump   := false     ; accumulate rev bump during batch
global gWS_CurrentSweepId   := 0         ; 0 = no active sweep
global gWS_Config           := Map()     ; runtime config (MissingTTLms, etc.)

; sensible defaults
gWS_Config["MissingTTLms"]        := 1200
gWS_Config["DefaultSort"]         := "MRU"
gWS_Config["NormalizeTitleMax"]   := 260    ; clamp super long titles
gWS_Config["TitleCollapseSpaces"] := true

global gWS_ScanId           := 0               ; monotonic scan token
global gWS_Meta             := Map()           ; meta store (current WS, etc.)
gWS_Meta["currentWSId"]     := ""
gWS_Meta["currentWSName"]   := ""

; De-duped work queues (used by pumps outside the store)
global gWS_Q_Pid            := Map()           ; pid -> true (needs process name)
global gWS_Q_Icon           := Map()           ; hwnd -> true (needs icon)
global gWS_Q_WS             := Map()           ; hwnd -> true (needs workspace)

; PID->processName cache + refcounts (drop name when last ref is gone)
global gWS_ProcCache        := Map()           ; pid -> processName
global gWS_ProcRef          := Map()           ; pid -> refcount

; Optional EXE->HICON cache (we keep one master HICON per exe; callers CopyIcon)
global gWS_ExeIconCache     := Map()           ; exePath -> hicon

; Injected fetchers (set by winenum): { ByHwnd: Func }
global gWS_Fetch_ByHwnd     := 0               ; function object or 0

;=============================== PUBLIC API ====================================

WindowStore_Init(config := 0) {
    ; Optional: set/override config keys at startup.
    global gWS_Config
    if IsObject(config) {
        for k, v in config
            gWS_Config[k] := v
    }
}

WindowStore_BeginBatch() {
    global gWS_Batching, gWS_PendingRevBump
    gWS_Batching := true
    gWS_PendingRevBump := false
}

WindowStore_EndBatch() {
    global gWS_Batching, gWS_PendingRevBump, gWS_Rev
    changed := false
    if (gWS_PendingRevBump) {
        gWS_Rev += 1
        changed := true
    }
    gWS_Batching := false
    gWS_PendingRevBump := false
    return { rev: gWS_Rev, changed: changed }
}

WindowStore_Has(hwnd) {
    global gWS_Store
    return gWS_Store.Has(hwnd + 0)
}

WindowStore_SetFetchers(fns) {
    ; fns example: { ByHwnd: Func("WinList_EnumerateByHwnd") }
    global gWS_Fetch_ByHwnd
    gWS_Fetch_ByHwnd := 0
    if (IsObject(fns) && fns.Has("ByHwnd") && (fns.ByHwnd is Func))
        gWS_Fetch_ByHwnd := fns.ByHwnd
}

WindowStore_Ensure(hwnd, hints := 0) {
    global gWS_Store, gWS_Fetch_ByHwnd
    hwnd := hwnd + 0
    if (gWS_Store.Has(hwnd)) {
        if (IsObject(hints))
            WindowStore_UpdateFields(hwnd, hints)
        return { record: gWS_Store[hwnd], existed: true }
    }
    ; Try injected fetcher
    if (gWS_Fetch_ByHwnd) {
        fetched := ""
        ; Expect the fetcher to accept (hwnds, optHints) or (hwnd, optHints), so pass array.
        try fetched := gWS_Fetch_ByHwnd.Call([hwnd], hints ? hints : Map())
        catch {}
        ; fetcher is expected to upsert via WindowStore_UpsertWindow internally.
    }
    if (!gWS_Store.Has(hwnd)) {
        ; Create a skeleton row if fetcher didn’t provide it yet
        WindowStore_UpsertWindow([{ hwnd: hwnd }])
    }
    if (IsObject(hints))
        WindowStore_UpdateFields(hwnd, hints)
    return { record: gWS_Store[hwnd], existed: false }
}

WindowStore_BeginScan() {
    global gWS_ScanId
    if (gWS_ScanId = 0x7FFFFFFF)
        gWS_ScanId := 0
    gWS_ScanId += 1
    return gWS_ScanId
}

WindowStore_EndScan(graceMs := "") {
    global gWS_Store, gWS_ScanId, gWS_Config
    now := _WS_Now()
    ttl := (graceMs != "" ? graceMs + 0 : (gWS_Config.Has("MissingTTLms") ? gWS_Config["MissingTTLms"] + 0 : 1200))

    hiddenNow := 0
    tombstoned := 0
    removed := 0
    changed := false

    ; pass 1: hide rows not seen this scan (presentNow=false), start tombstone
    for hwnd, rec in gWS_Store {
        if (rec.lastSeenScanId != gWS_ScanId) {
            if (rec.presentNow) {
                rec.presentNow := false
                rec.present := false
                changed := true
                hiddenNow += 1
            }
            if (rec.missingSinceTick = 0) {
                rec.missingSinceTick := now
                tombstoned += 1
                changed := true
            }
        } else {
            ; seen → ensure visible and clear tombstone marker
            if (!rec.presentNow || !rec.present) {
                rec.presentNow := true
                rec.present := true
                changed := true
            }
            if (rec.missingSinceTick) {
                rec.missingSinceTick := 0
                changed := true
            }
        }
    }

    ; pass 2: hard-remove beyond TTL
    doomed := []
    for hwnd, rec in gWS_Store {
        if (rec.missingSinceTick && (now - rec.missingSinceTick >= ttl))
            doomed.Push(hwnd)
    }
    if (doomed.Length) {
        tmp := WindowStore_RemoveWindow(doomed)
        removed += tmp.removed
        changed := changed || (tmp.removed > 0)
    }

    if (changed)
        _WS_RequestRevBump()

    ; clear current scan token
    gWS_ScanId := 0

    return { hiddenNow: hiddenNow, tombstoned: tombstoned, removed: removed, rev: WindowStore_GetRev() }
}

WindowStore_PopPidBatch(n := 32) {
    global gWS_Q_Pid
    out := []
    for pid, _ in gWS_Q_Pid {
        out.Push(pid + 0)
        gWS_Q_Pid.Delete(pid)
        if (out.Length >= n)
            break
    }
    return out
}

WindowStore_PopIconBatch(n := 32) {
    global gWS_Q_Icon
    out := []
    for hwnd, _ in gWS_Q_Icon {
        out.Push(hwnd + 0)
        gWS_Q_Icon.Delete(hwnd)
        if (out.Length >= n)
            break
    }
    return out
}

WindowStore_PopWSBatch(n := 32) {
    global gWS_Q_WS
    out := []
    for hwnd, _ in gWS_Q_WS {
        out.Push(hwnd + 0)
        gWS_Q_WS.Delete(hwnd)
        if (out.Length >= n)
            break
    }
    return out
}

WindowStore_SetCurrentWorkspace(id, name := "") {
    global gWS_Meta, gWS_Store
    prevId  := gWS_Meta["currentWSId"]
    prevNam := gWS_Meta["currentWSName"]

    gWS_Meta["currentWSId"]   := id . ""
    gWS_Meta["currentWSName"] := name . ""

    ; If rows already know their workspace, recompute isOnCurrentWorkspace
    changed := false
    for hwnd, rec in gWS_Store {
        known := (rec.workspaceId != "" || rec.workspaceName != "")
        wasOn := rec.isOnCurrentWorkspace
        nowOn := wasOn
        if (known) {
            if (rec.workspaceId != "")
                nowOn := (rec.workspaceId = gWS_Meta["currentWSId"])
            else
                nowOn := (rec.workspaceName = gWS_Meta["currentWSName"])
        } else {
            ; Unknown workspace → mark needsWS and enqueue
            rec.needsWS := true
            _WS_QueueWS(rec.hwnd)
        }
        if (nowOn != wasOn) {
            rec.isOnCurrentWorkspace := nowOn
            changed := true
        }
    }
    if (changed || id . "" != prevId . "" || name . "" != prevNam . "")
        _WS_RequestRevBump()
    return { id: gWS_Meta["currentWSId"], name: gWS_Meta["currentWSName"], rev: WindowStore_GetRev() }
}

WindowStore_GetCurrentWorkspace() {
    global gWS_Meta
    return { id: gWS_Meta["currentWSId"], name: gWS_Meta["currentWSName"] }
}

WindowStore_GetProcNameCached(pid) {
    global gWS_ProcCache
    return (pid > 0 && gWS_ProcCache.Has(pid)) ? (gWS_ProcCache[pid] . "") : ""
}

WindowStore_UpdateProcessName(pid, name) {
    ; Called by your proc-name pump once it resolves a name.
    global gWS_ProcCache, gWS_Store
    pid := pid + 0
    if (pid <= 0)
        return { updated: 0, rev: WindowStore_GetRev() }

    gWS_ProcCache[pid] := name . ""
    ; Fan-out to rows lacking a name
    updated := 0
    for hwnd, rec in gWS_Store {
        if (rec.pid = pid && rec.processName = "") {
            rec.processName := gWS_ProcCache[pid]
            updated += 1
            ; updating text should bump rev once; safe to set per-row then bump at end
        }
    }
    if (updated > 0)
        _WS_RequestRevBump()
    return { updated: updated, rev: WindowStore_GetRev() }
}

WindowStore_ExeIconCachePut(exePath, hIcon) {
    ; Store/replace the master icon for an exe. We own the previous and will destroy it.
    global gWS_ExeIconCache
    key := exePath . ""
    if (key = "")
        return
    if (gWS_ExeIconCache.Has(key)) {
        old := gWS_ExeIconCache[key]
        if (old)
            try DllCall("user32\DestroyIcon", "ptr", old)
    }
    gWS_ExeIconCache[key] := hIcon + 0
}

WindowStore_GetExeIconCopy(exePath) {
    ; Returns a CopyIcon() of the master (caller owns/destroys). 0 if none.
    global gWS_ExeIconCache
    key := exePath . ""
    if (key = "" || !gWS_ExeIconCache.Has(key))
        return 0
    master := gWS_ExeIconCache[key]
    if (!master)
        return 0
    return DllCall("user32\CopyIcon", "ptr", master, "ptr")
}

WindowStore_ClearExeIconCache() {
    global gWS_ExeIconCache
    for k, h in gWS_ExeIconCache {
        if (h)
            try DllCall("user32\DestroyIcon", "ptr", h)
    }
    gWS_ExeIconCache := Map()
}


WindowStore_UpsertWindow(records) {
    global gWS_Store, gWS_ScanId
    if !IsObject(records)
        records := [records]

    now := _WS_Now()
    added := 0, updated := 0
    changed := false

    for _, patch in records {
        if (!IsObject(patch) || !patch.Has("hwnd"))
            continue
        hwnd := patch.hwnd + 0

        rec := gWS_Store.Has(hwnd) ? gWS_Store[hwnd] : 0
        if (!rec) {
            rec := _WS_NewRecord(hwnd)
            gWS_Store[hwnd] := rec
            added += 1
            changed := true
        }

        oldPid := rec.pid
        if (_WS_MergeInto(rec, patch)) {
            updated += 1
            changed := true
        }

        ; pid refcount maintenance (after merge)
        if (rec.pid != oldPid)
            _WS_AdjustPidRefs(oldPid, rec.pid)

        ; mark seen in current scan (if any)
        if (gWS_ScanId > 0) {
            rec.lastSeenScanId := gWS_ScanId
        }
        rec.lastSeenTick := now
        rec.present      := true
        rec.presentNow   := true
        rec.missingSinceTick := 0

        ; recompute needs + enqueue if newly needed
        _WS_RefreshNeeds(rec)
    }

    if (changed)
        _WS_RequestRevBump()

    return { added: added, updated: updated, rev: WindowStore_GetRev() }
}


WindowStore_UpdateFields(hwnd, patch) {
    global gWS_Store
    if (!gWS_Store.Has(hwnd))
        return { changed: false, rev: WindowStore_GetRev() }

    rec := gWS_Store[hwnd]
    oldPid := rec.pid
    changed := _WS_MergeInto(rec, patch)

    if (rec.pid != oldPid)
        _WS_AdjustPidRefs(oldPid, rec.pid)

    _WS_RefreshNeeds(rec)

    if (changed)
        _WS_RequestRevBump()
    return { changed: changed, rev: WindowStore_GetRev() }
}


WindowStore_RemoveWindow(hwnds) {
    global gWS_Store, gWS_Q_Icon, gWS_Q_WS
    if !IsObject(hwnds)
        hwnds := [hwnds]

    removed := 0
    for _, h in hwnds {
        hwnd := h + 0
        if (!gWS_Store.Has(hwnd))
            continue
        rec := gWS_Store[hwnd]

        ; pid refcount + optional cache drop
        _WS_AdjustPidRefs(rec.pid, 0)

        ; cleanup icon
        if (rec.iconHicon) {
            try DllCall("user32\DestroyIcon", "ptr", rec.iconHicon)
        }

        ; remove from queues if present
        if (gWS_Q_Icon.Has(hwnd))
            gWS_Q_Icon.Delete(hwnd)
        if (gWS_Q_WS.Has(hwnd))
            gWS_Q_WS.Delete(hwnd)

        gWS_Store.Delete(hwnd)
        removed += 1
    }
    if (removed > 0)
        _WS_RequestRevBump()
    return { removed: removed, rev: WindowStore_GetRev() }
}


WindowStore_GetRev() {
    global gWS_Rev
    return gWS_Rev
}

WindowStore_GetByHwnd(hwnd) {
    global gWS_Store
    return gWS_Store.Has(hwnd) ? gWS_Store[hwnd] : 0
}

WindowStore_GetProjection(opts := 0) {
    ; Returns {rev, hwnds, items?, meta}
    global gWS_Config
    if (!IsObject(opts))
        opts := Map()

    filter := _WS_DefaultFilter()
    if (opts.Has("filter") && IsObject(opts.filter))
        filter := _WS_MergeFilter(filter, opts.filter)

    sortKey := opts.Has("sort") ? _WS_ValidateSort(opts.sort) : (gWS_Config["DefaultSort"] . "")
    cols    := opts.Has("columns") ? _WS_ValidateColumns(opts.columns) : "hwndsOnly"

    ; Build filtered list of records (presentOnly by default, etc).
    recs := _WS_FilterRecords(filter)

    ; Sort in-place per sortKey.
    _WS_SortRecords(recs, sortKey)

    ; Build outputs.
    hwnds := []
    for _, r in recs
        hwnds.Push(r.hwnd)

    out := { rev: WindowStore_GetRev(), hwnds: hwnds, meta: {
        count: _WS_TotalCount(), filteredCount: hwnds.Length, sortKey: sortKey
    }}

    if (cols = "items") {
        items := []
        total := recs.Length
        i := 1
        while (i <= total) {
            items.Push(_WS_ToGuiItem(recs[i], i, total))
            i += 1
        }
        out.items := items
    }
    return out
}

WindowStore_GetIndexOf(hwnd, opts := 0) {
    ; 1-based index of hwnd in the projection defined by opts; 0 if not present.
    proj := WindowStore_GetProjection(opts)
    i := 1
    while (i <= proj.hwnds.Length) {
        if (proj.hwnds[i] = hwnd)
            return i
        i += 1
    }
    return 0
}

;============================= INTERNAL HELPERS ================================

_WS_QueuePid(pid) {
    global gWS_Q_Pid
    if (pid > 0 && !gWS_Q_Pid.Has(pid))
        gWS_Q_Pid[pid] := true
}

_WS_QueueIcon(hwnd) {
    global gWS_Q_Icon
    if (hwnd > 0 && !gWS_Q_Icon.Has(hwnd))
        gWS_Q_Icon[hwnd] := true
}

_WS_QueueWS(hwnd) {
    global gWS_Q_WS
    if (hwnd > 0 && !gWS_Q_WS.Has(hwnd))
        gWS_Q_WS[hwnd] := true
}

_WS_RefreshNeeds(rec) {
    ; Compute needs flags from fields, enqueue newly-needed work.
    needProc := (rec.pid > 0 && rec.processName = "")
    needIcon := (rec.iconHicon = 0)
    needWS   := (rec.workspaceId = "" && rec.workspaceName = "")

    if (needProc && !rec.needsProcName) {
        _WS_QueuePid(rec.pid)
    }
    if (needIcon && !rec.needsIcon) {
        _WS_QueueIcon(rec.hwnd)
    }
    if (needWS && !rec.needsWS) {
        _WS_QueueWS(rec.hwnd)
    }
    rec.needsProcName := needProc
    rec.needsIcon     := needIcon
    rec.needsWS       := needWS
}

_WS_AdjustPidRefs(oldPid, newPid) {
    global gWS_ProcRef, gWS_ProcCache
    if (oldPid = newPid)
        return
    if (oldPid > 0 && gWS_ProcRef.Has(oldPid)) {
        gWS_ProcRef[oldPid] -= 1
        if (gWS_ProcRef[oldPid] <= 0) {
            gWS_ProcRef.Delete(oldPid)
            ; Optional: drop cached name when last ref leaves
            if (gWS_ProcCache.Has(oldPid))
                gWS_ProcCache.Delete(oldPid)
        }
    }
    if (newPid > 0) {
        if (!gWS_ProcRef.Has(newPid))
            gWS_ProcRef[newPid] := 0
        gWS_ProcRef[newPid] += 1
    }
}

_WS_RequestRevBump() {
    global gWS_Batching, gWS_PendingRevBump, gWS_Rev
    if (gWS_Batching) {
        gWS_PendingRevBump := true
    } else {
        gWS_Rev += 1
    }
}

_WS_Now() {
    return A_TickCount + 0
}

_WS_Basename(path) {
    if (!path)
        return ""
    SplitPath(path, &fname)
    return fname
}

_WS_NormalizeTitle(s) {
    global gWS_Config
    if (s = "")
        return ""
    out := s . ""
    ; Replace CR/LF/tabs with spaces
    out := StrReplace(out, "r", " ")
    out := StrReplace(out, "n", " ")
    out := StrReplace(out, "t", " ")
    if gWS_Config["TitleCollapseSpaces"] {
        ; collapse runs of spaces
        while InStr(out, "  ")
            out := StrReplace(out, "  ", " ")
    }
    out := Trim(out, " t")
    max := gWS_Config["NormalizeTitleMax"] + 0
    if (max > 0 && StrLen(out) > max)
        out := SubStr(out, 1, max)
    return out
}

_WS_StateCanonical(s) {
    if (!s)
        return "Unknown"
    t := StrLower(Trim(s))
    if (t = "workspaceshowing")    {
      return "WorkspaceShowing"
    }
    if (t = "workspaceminimized")  {
      return "WorkspaceMinimized"
    }
    if (t = "workspacehidden")     {
      return "WorkspaceHidden"
    }
    if (t = "otherworkspace")      {
      return "OtherWorkspace"
    }
    return "Unknown"
}

_WS_NewRecord(hwnd) {
    now := _WS_Now()
    return {
        ; Identity / process
        hwnd: hwnd + 0,
        pid: 0,
        class: "",
        exePath: "",
        processName: "",

        ; Titles
        titleRaw: "",
        title: "",

        ; State
        state: "Unknown",
        zOrder: 0,
        isVisible: false,
        isMinimized: false,
        isOnCurrentWorkspace: false,
        isFocused: false,
        isBlacklisted: false,

        ; Workspace
        workspaceId: "",
        workspaceName: "",

        ; MRU / activity
        lastActivatedTick: 0,
        totalActiveMs: 0,
        mruRank: 0,

        ; Icons
        iconHicon: 0,
        iconKey: "",

        ; Needs flags (populated by _WS_RefreshNeeds)
        needsProcName: false,
        needsIcon: false,
        needsWS: false,

        ; Sweep / lifecycle
        present: true,
        presentNow: true,
        lastSeenScanId: 0,
        lastSeenSweep: 0,   ; kept for backward-compat shims
        lastSeenTick: now,
        missingSinceTick: 0,
        firstSeenTick: now,

        ; Record bookkeeping
        rev: 0
    }
}

; Merge patch object into rec. Returns true if any meaningful field changed.
_WS_MergeInto(rec, patch) {
    changed := false

    ; Identity / process
    if (patch.Has("pid"))           changed := changed || _WS_AssignIfDiff(rec, "pid", patch.pid + 0)
    if (patch.Has("class"))         changed := changed || _WS_AssignIfDiff(rec, "class", patch.class . "")
    if (patch.Has("exePath")) {
        path := patch.exePath . ""
        pname := _WS_Basename(path)
        changed := changed || _WS_AssignIfDiff(rec, "exePath", path)
        if (pname != "" && rec.processName != pname)
            rec.processName := pname, changed := true
    }
    if (patch.Has("processName"))   changed := changed || _WS_AssignIfDiff(rec, "processName", patch.processName . "")

    ; Titles
    if (patch.Has("titleRaw")) {
        raw := patch.titleRaw . ""
        norm := _WS_NormalizeTitle(raw)
        if (rec.titleRaw != raw) {
          rec.titleRaw := raw, changed := true
        }
        if (rec.title != norm)   {
          rec.title    := norm, changed := true
        }
    } else if (patch.Has("title")) {
        ; Allow callers to supply already-normalized title
        norm := _WS_NormalizeTitle(patch.title . "")
        if (rec.title != norm) {
          rec.title := norm, changed := true
        }
    }

    ; State
    if (patch.Has("state"))         changed := changed || _WS_AssignIfDiff(rec, "state", _WS_StateCanonical(patch.state))
    if (patch.Has("zOrder"))        changed := changed || _WS_AssignIfDiff(rec, "zOrder", patch.zOrder + 0)
    if (patch.Has("isVisible"))     changed := changed || _WS_AssignIfDiff(rec, "isVisible", !!patch.isVisible)
    if (patch.Has("isMinimized"))   changed := changed || _WS_AssignIfDiff(rec, "isMinimized", !!patch.isMinimized)
    if (patch.Has("isOnCurrentWorkspace")) changed := changed || _WS_AssignIfDiff(rec, "isOnCurrentWorkspace", !!patch.isOnCurrentWorkspace)
    if (patch.Has("isFocused"))     changed := changed || _WS_AssignIfDiff(rec, "isFocused", !!patch.isFocused)
    if (patch.Has("isBlacklisted")) changed := changed || _WS_AssignIfDiff(rec, "isBlacklisted", !!patch.isBlacklisted)

    ; Workspace
    if (patch.Has("workspaceId"))   changed := changed || _WS_AssignIfDiff(rec, "workspaceId", patch.workspaceId)
    if (patch.Has("workspaceName")) changed := changed || _WS_AssignIfDiff(rec, "workspaceName", patch.workspaceName . "")

    ; MRU / activity
    if (patch.Has("lastActivatedTick")) {
        ; Accept newer timestamps; if you want “source of truth” MRU, drop the guard.
        t := patch.lastActivatedTick + 0
        if (t != rec.lastActivatedTick)  ; simple overwrite is usually fine
            rec.lastActivatedTick := t, changed := true
    }
    if (patch.Has("totalActiveMs")) changed := changed || _WS_AssignIfDiff(rec, "totalActiveMs", patch.totalActiveMs + 0)
    if (patch.Has("mruRank"))       changed := changed || _WS_AssignIfDiff(rec, "mruRank", patch.mruRank + 0)

    ; Icons
    if (patch.Has("iconHicon")) {
        ; If caller replaces an existing icon, destroy the old one to avoid leaks.
        newH := patch.iconHicon + 0
        if (newH != rec.iconHicon) {
            if (rec.iconHicon)
                try DllCall("user32\DestroyIcon", "ptr", rec.iconHicon)
            rec.iconHicon := newH, changed := true
        }
    }
    if (patch.Has("iconKey"))       changed := changed || _WS_AssignIfDiff(rec, "iconKey", patch.iconKey . "")

    ; Lifecycle flags are controlled by sweep/Upsert; don't set present directly here
    return changed
}

_WS_AssignIfDiff(rec, key, val) {
    if (!rec.Has(key) || rec.%key% != val) {
        rec.%key% := val
        return true
    }
    return false
}

_WS_DefaultFilter() {
    return {
        presentOnly: true,
        currentWorkspaceOnly: false,
        blacklistMode: "exclude",
        classes: [],
        pids: []
    }
}

_WS_MergeFilter(base, override) {
    out := Map()
    ; copy base first
    for k, v in base
        out[k] := v
    ; overlay any provided keys
    for k, v in override
        out[k] := v
    ; normalize values
    out.presentOnly := !!out.presentOnly
    out.currentWorkspaceOnly := !!out.currentWorkspaceOnly
    bm := StrLower(out.blacklistMode . "")
    if (bm != "include" && bm != "only")
        bm := "exclude"
    out.blacklistMode := bm
    if !IsObject(out.classes) out.classes := []
    if !IsObject(out.pids)    out.pids := []
    return out
}

_WS_ValidateSort(s) {
    t := StrUpper(Trim(s . ""))
    if (t = "MRU" || t = "Z" || t = "TITLE" || t = "PID" || t = "PROCESSNAME")
        return t
    return "MRU"
}

_WS_ValidateColumns(c) {
    t := StrLower(Trim(c . ""))
    if (t = "items")
        return "items"
    return "hwndsOnly"
}

_WS_FilterRecords(filter) {
    global gWS_Store
    recs := []
    for hwnd, rec in gWS_Store {
        if (filter.presentOnly && !rec.present)
            continue
        if (filter.currentWorkspaceOnly && !rec.isOnCurrentWorkspace)
            continue
        if (filter.blacklistMode = "exclude" && rec.isBlacklisted)
            continue
        if (filter.blacklistMode = "only" && !rec.isBlacklisted)
            continue
        if (filter.classes.Length) {
            keep := false
            for _, cls in filter.classes
                if (rec.class = (cls . "")) {
                    keep := true
                    break
                }
            if !keep
                continue
        }
        if (filter.pids.Length) {
            keep2 := false
            for _, p in filter.pids
                if (rec.pid = (p + 0)) {
                    keep2 := true
                    break
                }
            if !keep2
                continue
        }
        recs.Push(rec)
    }
    return recs
}

_WS_SortRecords(recs, sortKey) {
    ; In-place sort of an array of record objects.
    if (sortKey = "MRU") {
        recs.Sort((a, b) => _WS_CompareDesc(a.lastActivatedTick, b.lastActivatedTick, a, b))
        return
    }
    if (sortKey = "Z") {
        ; Lower Z-order at front (or reverse if your Z means “on top” is smaller).
        recs.Sort((a, b) => _WS_CompareAsc(a.zOrder, b.zOrder, a, b))
        return
    }
    if (sortKey = "TITLE") {
        recs.Sort((a, b) => _WS_CompareStrAsc(a.title, b.title, a, b))
        return
    }
    if (sortKey = "PID") {
        recs.Sort((a, b) => _WS_CompareAsc(a.pid, b.pid, a, b))
        return
    }
    if (sortKey = "PROCESSNAME") {
        recs.Sort((a, b) => _WS_CompareStrAsc(a.processName, b.processName, a, b))
        return
    }
    ; default fallback
    recs.Sort((a, b) => _WS_CompareDesc(a.lastActivatedTick, b.lastActivatedTick, a, b))
}

_WS_CompareAsc(x, y, a, b) {
    if (x < y)  {
      return -1
    }
    if (x > y)  {
      return 1
    }
    ; tie-breakers for stability
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}
_WS_CompareDesc(x, y, a, b) {
    if (x > y)  {
      return -1
    }
    if (x < y)  {
      return 1
    }
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}
_WS_CompareStrAsc(x, y, a, b) {
    sx := x . "", sy := y . ""
    c := StrCompare(sx, sy, true)  ; case-insensitive
    if (c < 0) {
      return -1
    }
    if (c > 0) {
      return 1
    }
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}

_WS_TotalCount() {
    global gWS_Store
    c := 0
    for _, _ in gWS_Store
        c += 1
    return c
}

; Convert a record to a “raw GUI item” expected by NewGUI__BuildRowModel in your newgui.ahk.
_WS_ToGuiItem(rec, idx, total) {
    ; Subtext comes from state (shortened later by GUI code if configured).
    wsName := rec.workspaceName ? rec.workspaceName : ""
    return {
        Title: rec.title != "" ? rec.title : (rec.processName != "" ? rec.processName : "(untitled)"),
        State: rec.state,
        Hwnd:  rec.hwnd,
        Pid:   rec.pid,
        ZOrder: rec.zOrder,
        Class: rec.class,
        Workspace: wsName,

        ; optional extras (GUI won’t break if unused)
        ProcessName: rec.processName,
        WorkspaceId: rec.workspaceId,
        IsBlacklisted: rec.isBlacklisted,
        IsVisible: rec.isVisible,
        IsMinimized: rec.isMinimized,
        IsOnCurrentWorkspace: rec.isOnCurrentWorkspace,
        IsFocused: rec.isFocused,

        ; icon handle is available if you wire GUI to read it; otherwise the
        ; existing icon pump caches via hwnd anyway.
        HICON: rec.iconHicon
    }
}
-----------
give me function level ADD / REPLACE / DELETE for adding this ownership paradigm as we just discussed on who owns what. 

Also, we patched this once before and never updated the documentation up top with our new items like ensure(). give me a fresh documentation block with our last changes and now this ownership change 
ok, two things. First, what do you mean by this
------
If you want, I can also give a tiny helper layer of wrappers (UpsertWindow(), UpdateFields(), Ensure()) that forward to the namespaced versions and always include the source, so your modules can keep concise calls.
-------
are you saying that rather then going in and updating all my existing pumps/watchers to add a source parameter, this will just magically detect it? how, can ahk somehow know what .ahk file it was in? i thought all imported ahks were kind of just treated as a monolith anyway.

second, did you actually set the filter? I see:
; Map: source -> Map(set of allowed fields)
; e.g. gWS_AllowedFields["winenum"]["pid"] := true
global gWS_AllowedFields := Map()

but am I missing the map? lets actually map them and set to warn to start seeing what we are doing
MRU owns lastActivatedTick (and, if you want, isFocused).

WinEnum owns present/presentNow/lastSeenTick/zOrder/isVisible/isMinimized/state.

Komorebi owns workspaceId/workspaceName and the global current workspace.

Icons/Process pumps own their fields.
got it. heres the current proc pump. 
give me full function ADD / REPLACE / REMOVE in order to get it to send source properly per our ownership change
#Requires AutoHotkey v2.0
; =============================================================================
; proc_pump.ahk — resolves PID→processName and fans out to WindowStore rows
; Notes:
;   - Uses QueryFullProcessImageNameW (fast, limited privilege).
;   - Updates the store-wide cache via WindowStore_UpdateProcessName(pid, name).
; =============================================================================

; ---------- Tunables ----------------------------------------------------------
if !IsSet(ProcBatchPerTick)
    ProcBatchPerTick := 16
if !IsSet(ProcTimerIntervalMs)
    ProcTimerIntervalMs := 100

; ---------- Module state ------------------------------------------------------
global _PP_TimerOn := false

; ---------- Public API --------------------------------------------------------
ProcPump_Start() {
    global _PP_TimerOn, ProcTimerIntervalMs
    if (_PP_TimerOn)
        return
    _PP_TimerOn := true
    SetTimer(_PP_Tick, ProcTimerIntervalMs)
}

ProcPump_Stop() {
    global _PP_TimerOn
    if !_PP_TimerOn
        return
    _PP_TimerOn := false
    SetTimer(_PP_Tick, 0)
}

; ---------- Core --------------------------------------------------------------
_PP_Tick() {
    global ProcBatchPerTick
    pids := WindowStore_PopPidBatch(ProcBatchPerTick)
    if (!IsObject(pids) || pids.Length = 0)
        return

    for _, pid in pids {
        pid := pid + 0
        if (pid <= 0)
            continue

        cached := WindowStore_GetProcNameCached(pid)
        if (cached != "") {
            ; Ensure any rows missing a name receive it.
            WindowStore_UpdateProcessName(pid, cached)
            continue
        }

        path := _PP_GetProcessPath(pid)
        if (path = "")
            continue

        name := _PP_Basename(path)
        if (name != "")
            WindowStore_UpdateProcessName(pid, name)
        ; (Optionally we could also store exePath per row, but icon pump can fetch path on demand.)
    }
}

; ---------- Helpers -----------------------------------------------------------
_PP_GetProcessPath(pid) {
    h := DllCall("kernel32\OpenProcess", "uint", 0x1000, "int", 0, "uint", pid, "ptr") ; QUERY_LIMITED
    if (!h)
        return ""
    buf := Buffer(32767*2, 0), cch := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW", "ptr", h, "uint", 0, "ptr", buf.Ptr, "uint*", &cch, "int")
    DllCall("kernel32\CloseHandle", "ptr", h)
    return ok ? StrGet(buf.Ptr, "UTF-16") : ""
}

_PP_Basename(path) {
    if (path = "")
        return ""
    SplitPath(path, &fn)
    return fn
}
got it. i left as is, if we dont need to change it if its already privledged function calls so be it

 heres the current icon pump. give me full function ADD / REPLACE / REMOVE in order to get it to send source properly per our ownership change 

or if like process its already privileged calls and doenst need source parameter, just tell me that :D 
#Requires AutoHotkey v2.0
; =============================================================================
; icon_pump.ahk — resolves per-window icons (HICON) and updates WindowStore
; Strategy:
;   1) Try WM_GETICON / class icon (CopyIcon before storing).
;   2) Fallback to process EXE icon, cached per EXE (store master in WS cache,
;      CopyIcon per row).
;   3) Light re-try with attempt cap to avoid tight loops.
; =============================================================================

; ---------- Tunables (use your existing globals if already set elsewhere) ----
if !IsSet(IconBatchPerTick)
    IconBatchPerTick := 16
if !IsSet(IconTimerIntervalMs)
    IconTimerIntervalMs := 80
; Limit requeue cycles for windows that temporarily can’t provide icons
if !IsSet(IconMaxAttempts)
    IconMaxAttempts := 4

; ---------- Module state ------------------------------------------------------
global _IP_TimerOn      := false
global _IP_Attempts     := Map()  ; hwnd -> attempts

; ---------- Public API --------------------------------------------------------
IconPump_Start() {
    global _IP_TimerOn, IconTimerIntervalMs
    if (_IP_TimerOn)
        return
    _IP_TimerOn := true
    SetTimer(_IP_Tick, IconTimerIntervalMs)
}

IconPump_Stop() {
    global _IP_TimerOn
    if !_IP_TimerOn
        return
    _IP_TimerOn := false
    SetTimer(_IP_Tick, 0)
}

; ---------- Core --------------------------------------------------------------
_IP_Tick() {
    global IconBatchPerTick, _IP_Attempts, IconMaxAttempts

    hwnds := WindowStore_PopIconBatch(IconBatchPerTick)
    if (!IsObject(hwnds) || hwnds.Length = 0)
        return

    for _, hwnd in hwnds {
        hwnd := hwnd + 0
        rec := WindowStore_GetByHwnd(hwnd)
        if (!rec)
            continue
        if (!WinExist("ahk_id " hwnd)) {
            continue
        }
        if (rec.iconHicon) {
            continue  ; already has one
        }

        h := _IP_TryResolveFromWindow(hwnd)
        if (!h) {
            ; fallback via EXE
            exe := rec.exePath
            if (exe = "" && rec.pid > 0)
                exe := _IP_GetProcessPath(rec.pid)
            if (exe != "") {
                ; try cached master first
                hCopy := WindowStore_GetExeIconCopy(exe)
                if (!hCopy) {
                    ; create/remember a master, then copy
                    master := _IP_ExtractExeIcon(exe)
                    if (master) {
                        WindowStore_ExeIconCachePut(exe, master)  ; we own "master" now
                        hCopy := DllCall("user32\CopyIcon", "ptr", master, "ptr")
                    }
                }
                h := hCopy
            }
        }

        if (h) {
            WindowStore_UpdateFields(hwnd, { iconHicon: h })
            _IP_Attempts[hwnd] := 0
        } else {
            ; controlled re-queue via UpdateFields() (refreshes needs + re-enqueues)
            tries := _IP_Attempts.Has(hwnd) ? (_IP_Attempts[hwnd] + 1) : 1
            _IP_Attempts[hwnd] := tries
            if (tries < IconMaxAttempts) {
                WindowStore_UpdateFields(hwnd, Map())  ; will re-queue needsIcon
            } else {
                ; give up quietly for now
            }
        }
    }
}

; ---------- Icon resolution helpers ------------------------------------------
_IP_TryResolveFromWindow(hWnd) {
    ; Attempts WM_GETICON (SMALL2, SMALL, BIG), then class icons.
    WM_GETICON   := 0x7F
    ICON_SMALL2  := 2
    ICON_SMALL   := 0
    ICON_BIG     := 1
    GCLP_HICONSM := -34
    GCLP_HICON   := -14

    try {
        h := SendMessage(WM_GETICON, ICON_SMALL2, 0, , "ahk_id " hWnd)
        if (!h)
            h := SendMessage(WM_GETICON, ICON_SMALL, 0, , "ahk_id " hWnd)
        if (!h)
            h := SendMessage(WM_GETICON, ICON_BIG,   0, , "ahk_id " hWnd)
        if (!h)
            h := DllCall("user32\GetClassLongPtrW", "ptr", hWnd, "int", GCLP_HICONSM, "ptr")
        if (!h)
            h := DllCall("user32\GetClassLongPtrW", "ptr", hWnd, "int", GCLP_HICON,   "ptr")
        if (h) {
            return DllCall("user32\CopyIcon", "ptr", h, "ptr")  ; copy → store owns it
        }
    } catch {
    }
    return 0
}

_IP_GetProcessPath(pid) {
    ; PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
    hProc := DllCall("kernel32\OpenProcess", "uint", 0x1000, "int", 0, "uint", pid, "ptr")
    if (!hProc)
        return ""
    buf := Buffer(32767*2, 0), cch := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW", "ptr", hProc, "uint", 0, "ptr", buf.Ptr, "uint*", &cch, "int")
    DllCall("kernel32\CloseHandle", "ptr", hProc)
    return ok ? StrGet(buf.Ptr, "UTF-16") : ""
}

_IP_ExtractExeIcon(exePath) {
    ; Extract a single icon (prefer small), return HICON master (pump owns; cache owns after put).
    hSmall := 0, hLarge := 0
    try {
        got := DllCall("shell32\ExtractIconExW", "wstr", exePath, "int", 0, "ptr*", &hLarge, "ptr*", &hSmall, "uint", 1, "uint")
        if (hSmall) {
            if (hLarge) {
                try DllCall("user32\DestroyIcon", "ptr", hLarge)
            }
            return hSmall
        }
        if (hLarge) {
            return hLarge
        }
    } catch {
    }
    ; Try explorer.exe as last resort (usually present)
    try {
        win := A_WinDir . "\explorer.exe"
        got := DllCall("shell32\ExtractIconExW", "wstr", win, "int", 0, "ptr*", &hLarge, "ptr*", &hSmall, "uint", 1, "uint")
        if (hSmall) {
            if (hLarge) {
                try DllCall("user32\DestroyIcon", "ptr", hLarge)
            }
            return hSmall
        }
        if (hLarge) {
            return hLarge
        }
    } catch {
    }
    return 0
}

alright, and while we are at it, we dont have an infinite loop here right? I know some cloaked windows dont like returning icons, so I want to make sure we dont just infinitely loop on an icon. its ok if we try again the next time the hwnd record is tickled because its activated via mru or komorebi workspace change, but while we are idle with a focused window things should truly be idle
ok lets add A plus your polish/performance stuff. but im too dumb to do it. heres the current icon pump
--------
#Requires AutoHotkey v2.0
; =============================================================================
; icon_pump.ahk — resolves per-window icons (HICON) and updates WindowStore
; Strategy:
;   1) Try WM_GETICON / class icon (CopyIcon before storing).
;   2) Fallback to process EXE icon, cached per EXE (store master in WS cache,
;      CopyIcon per row).
;   3) Light re-try with attempt cap to avoid tight loops.
; =============================================================================

; ---------- Tunables (use your existing globals if already set elsewhere) ----
if !IsSet(IconBatchPerTick)
    IconBatchPerTick := 16
if !IsSet(IconTimerIntervalMs)
    IconTimerIntervalMs := 80
; Limit requeue cycles for windows that temporarily can’t provide icons
if !IsSet(IconMaxAttempts)
    IconMaxAttempts := 4

; ---------- Module state ------------------------------------------------------
global _IP_TimerOn      := false
global _IP_Attempts     := Map()  ; hwnd -> attempts

; ---------- Module-local wrappers (ownership-stamped, backward compatible) ---
ICON_UpdateFields(hwnd, patch) {
    ; Prefer the 3-arg API (with source). If your store hasn’t been upgraded yet,
    ; fall back to the 2-arg version.
    try {
        return WindowStore_UpdateFields(hwnd, patch, "icons")
    } catch {
        return WindowStore_UpdateFields(hwnd, patch)
    }
}

; ---------- Public API --------------------------------------------------------
IconPump_Start() {
    global _IP_TimerOn, IconTimerIntervalMs
    if (_IP_TimerOn)
        return
    _IP_TimerOn := true
    SetTimer(_IP_Tick, IconTimerIntervalMs)
}

IconPump_Stop() {
    global _IP_TimerOn
    if !_IP_TimerOn
        return
    _IP_TimerOn := false
    SetTimer(_IP_Tick, 0)
}

; ---------- Core --------------------------------------------------------------
_IP_Tick() {
    global IconBatchPerTick, _IP_Attempts, IconMaxAttempts

    hwnds := WindowStore_PopIconBatch(IconBatchPerTick)
    if (!IsObject(hwnds) || hwnds.Length = 0)
        return

    for _, hwnd in hwnds {
        hwnd := hwnd + 0
        rec := WindowStore_GetByHwnd(hwnd)
        if (!rec)
            continue
        if (!WinExist("ahk_id " hwnd)) {
            continue
        }
        if (rec.iconHicon) {
            continue  ; already has one
        }

        h := _IP_TryResolveFromWindow(hwnd)
        if (!h) {
            ; fallback via EXE
            exe := rec.exePath
            if (exe = "" && rec.pid > 0)
                exe := _IP_GetProcessPath(rec.pid)
            if (exe != "") {
                ; try cached master first
                hCopy := WindowStore_GetExeIconCopy(exe)
                if (!hCopy) {
                    ; create/remember a master, then copy
                    master := _IP_ExtractExeIcon(exe)
                    if (master) {
                        WindowStore_ExeIconCachePut(exe, master)  ; we own "master" now
                        hCopy := DllCall("user32\CopyIcon", "ptr", master, "ptr")
                    }
                }
                h := hCopy
            }
        }

        if (h) {
            ICON_UpdateFields(hwnd, { iconHicon: h })
            _IP_Attempts[hwnd] := 0
        } else {
            ; controlled re-queue via UpdateFields() (refreshes needs + re-enqueues)
            tries := _IP_Attempts.Has(hwnd) ? (_IP_Attempts[hwnd] + 1) : 1
            _IP_Attempts[hwnd] := tries
            if (tries < IconMaxAttempts) {
                ICON_UpdateFields(hwnd, Map())  ; will re-queue needsIcon
            } else {
                ; give up quietly for now
            }
        }
    }
}

; ---------- Icon resolution helpers ------------------------------------------
_IP_TryResolveFromWindow(hWnd) {
    ; Attempts WM_GETICON (SMALL2, SMALL, BIG), then class icons.
    WM_GETICON   := 0x7F
    ICON_SMALL2  := 2
    ICON_SMALL   := 0
    ICON_BIG     := 1
    GCLP_HICONSM := -34
    GCLP_HICON   := -14

    try {
        h := SendMessage(WM_GETICON, ICON_SMALL2, 0, , "ahk_id " hWnd)
        if (!h)
            h := SendMessage(WM_GETICON, ICON_SMALL, 0, , "ahk_id " hWnd)
        if (!h)
            h := SendMessage(WM_GETICON, ICON_BIG,   0, , "ahk_id " hWnd)
        if (!h)
            h := DllCall("user32\GetClassLongPtrW", "ptr", hWnd, "int", GCLP_HICONSM, "ptr")
        if (!h)
            h := DllCall("user32\GetClassLongPtrW", "ptr", hWnd, "int", GCLP_HICON,   "ptr")
        if (h) {
            return DllCall("user32\CopyIcon", "ptr", h, "ptr")  ; copy → store owns it
        }
    } catch {
    }
    return 0
}

_IP_GetProcessPath(pid) {
    ; PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
    hProc := DllCall("kernel32\OpenProcess", "uint", 0x1000, "int", 0, "uint", pid, "ptr")
    if (!hProc)
        return ""
    buf := Buffer(32767*2, 0), cch := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW", "ptr", hProc, "uint", 0, "ptr", buf.Ptr, "uint*", &cch, "int")
    DllCall("kernel32\CloseHandle", "ptr", hProc)
    return ok ? StrGet(buf.Ptr, "UTF-16") : ""
}

_IP_ExtractExeIcon(exePath) {
    ; Extract a single icon (prefer small), return HICON master (pump owns; cache owns after put).
    hSmall := 0, hLarge := 0
    try {
        got := DllCall("shell32\ExtractIconExW", "wstr", exePath, "int", 0, "ptr*", &hLarge, "ptr*", &hSmall, "uint", 1, "uint")
        if (hSmall) {
            if (hLarge) {
                try DllCall("user32\DestroyIcon", "ptr", hLarge)
            }
            return hSmall
        }
        if (hLarge) {
            return hLarge
        }
    } catch {
    }
    ; Try explorer.exe as last resort (usually present)
    try {
        win := A_WinDir . "\explorer.exe"
        got := DllCall("shell32\ExtractIconExW", "wstr", win, "int", 0, "ptr*", &hLarge, "ptr*", &hSmall, "uint", 1, "uint")
        if (hSmall) {
            if (hLarge) {
                try DllCall("user32\DestroyIcon", "ptr", hLarge)
            }
            return hSmall
        }
        if (hLarge) {
            return hLarge
        }
    } catch {
    }
    return 0
}
------
give me full function ADD / REPLACE / REMOVE to accomplish these
as well as any changes needed to list.ahk the API because if I understand correctly we need a change there as well? 
got it. i left as is, if we dont need to change it if its already privledged function calls so be it heres the current komorebi pump. give me full function ADD / REPLACE / REMOVE in order to get it to send source properly per our ownership change or if like process its already privileged calls and doenst need source parameter, just tell me that :D
remember that we have a lot of placeholders to wire back into our full komorebi logic here, thats ok, right now we are just ensuring pump design

----------
#Requires AutoHotkey v2.0
; =============================================================================
; komorebi_pump.ahk — integrates Komorebi workspace/focus info into WindowStore
; Placeholder: calls are wrapped so you can later bind them to your real
; komorebi.ahk API (poll or event-driven). The pump shows how to feed the store.
; =============================================================================

; ---------- Tunables ----------------------------------------------------------
if !IsSet(KomoTimerIntervalMs)
    KomoTimerIntervalMs := 120

; ---------- Module state ------------------------------------------------------
global _KP_TimerOn       := false
global _KP_LastWSId      := ""
global _KP_LastWSName    := ""
global _KP_LastFocused   := 0

; ---------- Public API --------------------------------------------------------
KomorebiPump_Start() {
    global _KP_TimerOn, KomoTimerIntervalMs
    if (_KP_TimerOn)
        return
    _KP_TimerOn := true
    SetTimer(_KP_Tick, KomoTimerIntervalMs)
}

KomorebiPump_Stop() {
    global _KP_TimerOn
    if !_KP_TimerOn
        return
    _KP_TimerOn := false
    SetTimer(_KP_Tick, 0)
}

; ---------- Core (polling placeholder) ---------------------------------------
_KP_Tick() {
    ; 1) Current workspace (id + name)
    ws := _KP_TryGetCurrentWorkspace()  ; {id, name} or ""
    if (IsObject(ws)) {
        if (ws.id . "" != _KP_LastWSId . "" || ws.name . "" != _KP_LastWSName . "") {
            _KP_LastWSId   := ws.id . ""
            _KP_LastWSName := ws.name . ""
            WindowStore_SetCurrentWorkspace(_KP_LastWSId, _KP_LastWSName)
        }
    }

    ; 2) Focused hwnd (mark one true, previous false)
    f := _KP_TryGetFocusedHwnd()
    if (f && f != _KP_LastFocused) {
        if (_KP_LastFocused) {
            WindowStore_UpdateFields(_KP_LastFocused, { isFocused: false })
        }
        _KP_LastFocused := f
        ; Ensure existence and mark focused (also good hint along the way)
        WindowStore_Ensure(f, { isFocused: true })
    }

    ; 3) Per-window workspace mapping (optional but ideal)
    ;    Return an array of { hwnd, wsId?, wsName? }
    map := _KP_TryMapAllWindows()
    if (IsObject(map)) {
        cur := WindowStore_GetCurrentWorkspace()
        for _, it in map {
            if (!IsObject(it) || !it.Has("hwnd"))
                continue
            hwnd := it.hwnd + 0
            hints := Map()
            if (it.Has("wsId"))
                hints["workspaceId"] := it.wsId . ""
            if (it.Has("wsName"))
                hints["workspaceName"] := it.wsName . ""
            ; flag isOnCurrentWorkspace if we know current + id/name
            on := ""
            if (hints.Has("workspaceId") && cur.id != "") {
                on := (hints["workspaceId"] = cur.id)
            } else if (hints.Has("workspaceName") && cur.name != "") {
                on := (hints["workspaceName"] = cur.name)
            }
            if (on != "")
                hints["isOnCurrentWorkspace"] := !!on
            WindowStore_Ensure(hwnd, hints)
        }
    }
}

; ---------- Binding shims (replace with your real Komorebi calls) ------------
; You can switch these to call functions from your komorebi.ahk when ready.

_KP_TryGetCurrentWorkspace() {
    ; Expected return: { id: "2", name: "dev" } or ""
    ; Placeholder: attempt to call Komorebi_GetCurrentWorkspace() if it exists.
    try {
        if (IsSet(Komorebi_GetCurrentWorkspace) && (Komorebi_GetCurrentWorkspace is Func)) {
            return Komorebi_GetCurrentWorkspace.Call()
        }
    } catch {
    }
    return ""  ; unknown (no change)
}

_KP_TryGetFocusedHwnd() {
    ; Expected return: UInt hwnd or 0
    try {
        if (IsSet(Komorebi_GetFocusedHwnd) && (Komorebi_GetFocusedHwnd is Func)) {
            return Komorebi_GetFocusedHwnd.Call() + 0
        }
    } catch {
    }
    return 0
}

_KP_TryMapAllWindows() {
    ; Expected return: [{ hwnd, wsId?, wsName? }, ...]  or ""
    try {
        if (IsSet(Komorebi_MapAllWindows) && (Komorebi_MapAllWindows is Func)) {
            return Komorebi_MapAllWindows.Call()
        }
    } catch {
    }
    return ""
}
---------
ok, i didnt do any of that. 

First, you already had me update WindowStore_Ensure with source, it currently looks like this
----------
WindowStore_Ensure(hwnd, hints := 0, source := "") {
    global gWS_Store, gWS_Fetch_ByHwnd
    hwnd := hwnd + 0
    if (gWS_Store.Has(hwnd)) {
        if (IsObject(hints)) {
            patch := _WS_FilterPatchByOwnership(hints, source)
            WindowStore_UpdateFields(hwnd, patch, source)
        }
        return { record: gWS_Store[hwnd], existed: true }
    }
    ; Try injected fetcher
    if (gWS_Fetch_ByHwnd) {
        fetched := ""
        try fetched := gWS_Fetch_ByHwnd.Call([hwnd], IsObject(hints) ? hints : Map())
        catch {}
        ; fetcher should Upsert into the store; if not, we'll create skeleton below
    }
    if (!gWS_Store.Has(hwnd)) {
        WindowStore_UpsertWindow([{ hwnd: hwnd }], "internal")
    }
    if (IsObject(hints)) {
        patch2 := _WS_FilterPatchByOwnership(hints, source)
        WindowStore_UpdateFields(hwnd, patch2, source)
    }
    return { record: gWS_Store[hwnd], existed: false }
}
--------
are you sure i need to replace it?

Also, your komorebi_pump.ahk changes involve adding backwards compatible wrappers. Smart instinct, but we havent deployed anything yet so we dont need to be adding wrappers we can just modify the core.

So knowing that, and knowing i didnt change anything based on your last response, give me the function level ADD / REPLACE / REMOVE for komorebi_pump (and only if necessary list.ahk changes)
got it.  s heres the current winenum.ahk. give me full function ADD / REPLACE / REMOVE in order to get it to send source properly per our ownership change
you dont need to add backwards compatible wrappers we havent deployed this yet we can change the core windowsstore calls directly

----------
#Requires AutoHotkey v2.0
; =============================================================================
; winenum.ahk — fast Z-order enumeration with DWM cloaking info
; - Drives WindowStore sweeps (BeginScan/EndScan) so presence + TTL are consistent
; - Feeds ONLY base window facts to the store (title/class/pid/state/z/visibility)
; - Optional: mirror blacklisted/alt-tab-ineligible rows into store if enabled
; - Optional: fetch process name (off by default; proc_pump should handle it)
; - Adds single/batch enumerate-by-hwnd with hints
; - Provides a registration helper so WindowStore.Ensure() can call back here
; =============================================================================

; ----------------------------- Config toggles -------------------------------

; If true: when a window hits any blacklist or is alt-tab ineligible, still Upsert
; to the store with isBlacklisted=true (and altTabEligible=false). Default OFF.
global WN_RecordBlacklistInStore := false

; If true: fetch process name immediately (cost: OpenProcess + QueryFullProcessImageName)
; Default OFF; we prefer proc_pump to handle this.
global WN_FetchProcessName := false

; If true: apply Alt-Tab eligibility filter (WS_EX_TOOLWINDOW, owner-window, etc.)
; Default TRUE (matches old behavior)
if !IsSet(UseAltTabEligibility)
    global UseAltTabEligibility := true

; ----------------------------- Module state ---------------------------------
global _WN_all := []                 ; legacy return list
global _WN_zCounter := 0
global _WN_shell := 0

; scan id counter for sweeps
global _WN_scanIdSeq := 0

; debug buffer + throttle
global _WN_logbuf := ""
global _WN_traceLeft := 0
global _WN_traceDeadline := 0

; ------------------------------ Public API ----------------------------------

; Call once during init so WindowStore.Ensure() can delegate enumerate-by-hwnd.
; Expects WindowStore_SetFetchers({ EnumerateByHwnd: <Func> }) to exist in list.ahk.
WinEnum_RegisterWithStore() {
    try {
        if (IsSet(WindowStore_SetFetchers) && (WindowStore_SetFetchers is Func)) {
            WindowStore_SetFetchers(Map("EnumerateByHwnd", WinList_EnumerateByHwnd))
        }
    } catch {
        ; non-fatal
    }
}

; Begin a scan/sweep (wraps WindowStore_BeginSweep with a fresh token).
; Returns the scanId you must pass to EndScan.
WinEnum_BeginScan() {
    global _WN_scanIdSeq
    _WN_scanIdSeq += 1
    scanId := _WN_scanIdSeq
    try WindowStore_BeginSweep(scanId)
    catch {
        ; store may not be loaded yet, keep going
    }
    return scanId
}

; End a scan/sweep (wraps WindowStore_EndSweep) and returns its summary.
WinEnum_EndScan(scanId) {
    summary := ""
    try summary := WindowStore_EndSweep(scanId)
    catch {
        ; ignore
    }
    return summary
}

; Full desktop enumeration.
; - Drives a store sweep (BeginScan/EndScan).
; - Batches Upsert to the store; also returns legacy array for back-compat.
WinList_EnumerateAll() {
    global _WN_all, _WN_zCounter, _WN_shell
    global _WN_logbuf, _WN_traceLeft, _WN_traceDeadline
    global WN_RecordBlacklistInStore

    dbg       := (IsSet(DebugBlacklist) && DebugBlacklist)
    maxLines  := IsSet(DebugMaxLinesPerSession) ? DebugMaxLinesPerSession : 200
    maxMillis := IsSet(DebugMaxDurationMs)      ? DebugMaxDurationMs      : 200

    DllCall("LoadLibrary", "str", "dwmapi.dll")
    _WN_shell := DllCall("user32\GetShellWindow", "ptr")
    _WN_zCounter := 0
    _WN_all := []
    toStore := []

    ; start sweep + batch
    scanId := WinEnum_BeginScan()
    try WindowStore_BeginBatch()

    ; prepare debug budget
    if (dbg) {
        _WN_logbuf := ""
        _WN_traceLeft := maxLines
        _WN_traceDeadline := A_TickCount + maxMillis
        _WN_Log("=== WinList_EnumerateAll (begin) ===")
    } else {
        _WN_logbuf := ""
        _WN_traceLeft := 0
        _WN_traceDeadline := 0
    }

    enumCb := (hWnd, lParam) => _WN_EnumProc_ForAll(hWnd, &toStore)
    cb := CallbackCreate(enumCb, "Fast", 2)
    DllCall("user32\EnumWindows", "ptr", cb, "ptr", 0, "int")
    CallbackFree(cb)

    ; feed the store in one Upsert batch
    if (toStore.Length) {
        try WindowStore_UpsertWindow(toStore)
        catch as e {
            _WN_Log("WindowStore_UpsertWindow(toStore) failed: " e.Message)
        }
    }

    ; end batch + sweep
    try WindowStore_EndBatch()
    summary := WinEnum_EndScan(scanId)

    if (dbg) {
        _WN_Log("=== WinList_EnumerateAll (end) ===")
        if (IsObject(summary))
            _WN_Log("hiddenNow=" summary.hiddenNow " tombstoned=" summary.tombstoned " removed=" summary.removed)
        _WN_FlushLog()
    }

    return _WN_all
}

; Single-window probe (accepts hints).
; - If hwnd is eligible/non-blacklisted, Upsert base facts (+hints) and return legacy row.
; - If blacklisted/ineligible, optionally mirror into store (flagged) when WN_RecordBlacklistInStore=true.
; hints: Map of fields to merge (e.g., { workspaceId: "2", workspaceName: "dev" }).
WinList_EnumerateByHwnd(hwnd, hints := "") {
    if (!hwnd)
        return {}
    rec := _WN_ProbeOne(hwnd)
    ; merge hints (for store)
    if (rec.Has("forStore") && IsObject(hints) && hints.Count) {
        for k, v in hints
            rec.forStore.%k% := v
    }
    ; upsert if we built a store payload
    if (rec.Has("forStore")) {
        try WindowStore_UpsertWindow([rec.forStore])
        catch as e {
            _WN_Log("WindowStore_UpsertWindow([one]) failed: " e.Message)
        }
    }
    return rec.Has("forList") ? rec.forList : {}
}

; Batch variant: input is an array of { hwnd, hints? }.
; Returns an array of legacy rows (like WinList_EnumerateAll()).
WinList_EnumerateByHwndMany(items) {
    if (!IsObject(items) || items.Length = 0)
        return []
    toStore := []
    legacy := []

    try WindowStore_BeginBatch()
    for _, it in items {
        if (!IsObject(it) || !it.Has("hwnd"))
            continue
        hwnd := it.hwnd + 0
        hints := (it.Has("hints") && IsObject(it.hints)) ? it.hints : ""
        rec := _WN_ProbeOne(hwnd)
        if (rec.Has("forStore")) {
            if (IsObject(hints) && hints.Count) {
                for k, v in hints
                    rec.forStore.%k% := v
            }
            toStore.Push(rec.forStore)
        }
        if (rec.Has("forList"))
            legacy.Push(rec.forList)
    }
    if (toStore.Length) {
        try WindowStore_UpsertWindow(toStore)
        catch as e {
            _WN_Log("WindowStore_UpsertWindow(batch one) failed: " e.Message)
        }
    }
    try WindowStore_EndBatch()
    return legacy
}

; ---------------------------- Enumeration core ------------------------------

_WN_EnumProc_ForAll(hWnd, &toStore) {
    global _WN_all, _WN_zCounter, _WN_shell
    if (hWnd = 0)
        return 1
    if (hWnd = _WN_shell) {
        _WN_zCounter += 1
        return 1
    }
    rec := _WN_ProbeOne(hWnd)
    if (rec.Has("forStore"))
        toStore.Push(rec.forStore)
    if (rec.Has("forList"))
        _WN_all.Push(rec.forList)
    _WN_zCounter += 1
    return 1
}

; Probe one HWND → apply filters and build:
; - forStore: minimal canonical patch for WindowStore (only known fields)
; - forList : legacy overlay record
_WN_ProbeOne(hWnd) {
    global _WN_zCounter, WN_RecordBlacklistInStore, WN_FetchProcessName, UseAltTabEligibility
    global BlacklistTitle, BlacklistClass, BlacklistPair

    out := {}

    cls := _GetClass(hWnd)
    ttl := _GetTitle(hWnd)

    ; HARD FILTER: skip known GDI+ helper windows
    if (_IsGdiPlusHelper(ttl, cls)) {
        _Trace("Skip GDI+ helper", ttl, cls)
        return out
    }

    ; Early blacklist checks
    isBList := false
    if (MatchAny(cls, BlacklistClass)) {
        _Trace("Hit Class list", ttl, cls), isBList := true
    } else if (!ttl) {
        ; Blank title: drop (match old behavior)
        return out
    } else if (MatchAny(ttl, BlacklistTitle)) {
        _Trace("Hit Title list", ttl, cls), isBList := true
    } else if (MatchPairs(ttl, cls, BlacklistPair)) {
        _Trace("Hit Pair list", ttl, cls), isBList := true
    }

    ; Visibility / minimized / cloaked
    isVisible := !!DllCall("user32\IsWindowVisible", "ptr", hWnd, "int")
    isMin     := !!DllCall("user32\IsIconic",        "ptr", hWnd, "int")

    cloakedBuf := Buffer(4, 0)
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hWnd, "uint", 14, "ptr", cloakedBuf.Ptr, "uint", 4, "int")
    isCloaked := (hr = 0) && (NumGet(cloakedBuf, 0, "UInt") != 0)

    state := "WorkspaceHidden"
    if (isCloaked)
        state := "OtherWorkspace"
    else if (isMin)
        state := "WorkspaceMinimized"
    else if (isVisible)
        state := "WorkspaceShowing"

    ; Alt-Tab eligibility (if toggled on)
    eligible := _IsAltTabEligible(hWnd, isVisible, isMin, isCloaked)
    if (UseAltTabEligibility && !eligible) {
        _Trace("Ineligible (Alt-Tab rules)", ttl, cls)
        if (WN_RecordBlacklistInStore) {
            pid := _GetPid(hWnd)
            ; prefer letting proc_pump fill processName later
            out.forStore := _WN_MakeStorePatch(hWnd, pid, cls, ttl, state, _WN_zCounter
                , isVisible, isMin, true, false)
        }
        return out
    }

    ; If blacklisted: either mirror to store (flagged) or drop
    if (isBList) {
        if (WN_RecordBlacklistInStore) {
            pid := _GetPid(hWnd)
            out.forStore := _WN_MakeStorePatch(hWnd, pid, cls, ttl, state, _WN_zCounter
                , isVisible, isMin, true, false)
        }
        return out
    }

    ; Eligible path
    pid := _GetPid(hWnd)

    ; Store patch (only fields recognized by WindowStore)
    patch := _WN_MakeStorePatch(hWnd, pid, cls, ttl, state, _WN_zCounter
        , isVisible, isMin, false, true)

    ; (Optionally attach processName for immediate UI—discouraged by default)
    if (WN_FetchProcessName && pid) {
        pname := _GetProcessName(pid)
        if (pname != "")
            patch.processName := pname
    }

    out.forStore := patch
    out.forList  := { Hwnd: hWnd, Title: ttl, Class: cls, Pid: pid, State: state, ZOrder: _WN_zCounter }
    return out
}

; Build a WindowStore patch with only known fields (store will normalize titles).
_WN_MakeStorePatch(hWnd, pid, cls, ttl, state, zOrder
    , isVisible, isMinimized, isBlacklisted, presentNow) {
    return {
        hwnd: hWnd,
        pid: pid,
        class: cls,
        title: ttl,
        state: state,
        zOrder: zOrder,
        isVisible: isVisible,
        isMinimized: isMinimized,
        isBlacklisted: isBlacklisted,
        ; present/lastSeen are handled by sweep + Upsert in the store;
        ; we still pass some friendly hints the store ignores gracefully:
        presentNow: presentNow,
        lastSeenTick: A_TickCount,
        source: "winenum"
    }
}

; ------------------------------ Helpers -------------------------------------

_GetTitle(hWnd) {
    buf := Buffer(512*2, 0)
    DllCall("user32\GetWindowTextW", "ptr", hWnd, "ptr", buf.Ptr, "int", 512, "int")
    s := StrGet(buf.Ptr, "UTF-16")
    return Trim(RegExReplace(s, "[\r\n\t]+", " "))
}

_GetClass(hWnd) {
    buf := Buffer(256*2, 0)
    DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
    return StrGet(buf.Ptr, "UTF-16")
}

_GetPid(hWnd) {
    pidBuf := Buffer(4, 0)
    DllCall("user32\GetWindowThreadProcessId", "ptr", hWnd, "ptr", pidBuf.Ptr, "uint")
    return NumGet(pidBuf, 0, "UInt")
}

_GetProcessName(pid) {
    if (!pid)
        return ""
    PROCESS_QUERY_LIMITED_INFORMATION := 0x1000
    hProc := DllCall("kernel32\OpenProcess","uint",PROCESS_QUERY_LIMITED_INFORMATION,"int",0,"uint",pid,"ptr")
    if (!hProc)
        return ""
    buf := Buffer(32767 * 2, 0), sz := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW","ptr",hProc,"uint",0,"ptr",buf.Ptr,"uint*",sz,"int")
    DllCall("kernel32\CloseHandle","ptr",hProc)
    if (!ok)
        return ""
    full := StrGet(buf.Ptr, "UTF-16")
    SplitPath(full, &nameOnly)
    return nameOnly
}

_IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) {
    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", -20, "ptr")
    WS_EX_TOOLWINDOW := 0x00000080
    WS_EX_APPWINDOW  := 0x00040000
    isTool := (ex & WS_EX_TOOLWINDOW) != 0
    isApp  := (ex & WS_EX_APPWINDOW)  != 0
    owner := DllCall("user32\GetWindow", "ptr", hWnd, "uint", 4, "ptr") ; GW_OWNER
    if (isTool)
        return false
    if !(owner = 0 || isApp)
        return false
    if !(isVisible || isMin || isCloaked)
        return false
    return true
}

; ---------- debug helpers (use your existing Normalize/Match) ----------------

_IsGdiPlusHelper(ttl, cls) {
    ttlN := NormalizeMatchText(ttl)
    clsN := NormalizeMatchText(cls)
    if (clsN != "GDI+Hook Window Class")
        return false
    return RegExMatch(ttlN, "^GDI\+Window \([^)]+\)$")
}

_Trace(tag, ttl, cls) {
    global _WN_traceLeft, _WN_traceDeadline
    dbg := (IsSet(DebugBlacklist) && DebugBlacklist)
    if !dbg
        return
    if (_WN_traceLeft <= 0 || (_WN_traceDeadline && A_TickCount > _WN_traceDeadline))
        return
    _WN_traceLeft -= 3
    _WN_Log("[" tag "]")
    _WN_Log("  Title: " ttl)
    _WN_Log("  Class: " cls)
}

_WN_Log(line) {
    global _WN_logbuf
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff")
    _WN_logbuf .= ts "  " line "rn"
}

_WN_GetLogPath() {
    if (IsSet(DebugLogPath) && DebugLogPath)
        return DebugLogPath
    return A_ScriptDir "\tabby_debug.log"
}

_WN_FlushLog() {
    global _WN_logbuf
    if (_WN_logbuf = "")
        return
    path := _WN_GetLogPath()
    SplitPath path, , &dir
    if (dir != "")
        try DirCreate(dir)
    ok := false
    try {
        FileAppend(_WN_logbuf, path, "UTF-8")
        ok := true
    } catch {
        try {
            FileAppend(_WN_logbuf, A_Temp "\tabby_debug.log", "UTF-8")
            ok := true
        } catch {
            ; give up
        }
    }
    _WN_logbuf := ""
}
got it. heres the current mru.ahk. give me full function ADD / REPLACE / REMOVE in order to get it to send source properly per our ownership change
you dont need to add backwards compatible wrappers we havent deployed this yet we can change the core windowsstore calls directly

----------
#Requires AutoHotkey v2.0
;===============================================================================
; mru.ahk — focus/activation stream → annotate WindowStore
; Public:
;   MRU_Init()
;   MRU_GetList()              -> array of hwnds (most-recent-first) [debug]
;   MRU_SetDebounce(ms)        -> set activation debounce window in ms (0=off)
;   MRU_MoveToFront(hwnd)      -> (debug/back-compat)
;   MRU_Remove(hwnd)           -> (debug/back-compat)
; Notes:
;   - Requires WindowStore_Ensure / WindowStore_UpdateFields / WindowStore_RemoveWindow.
;   - Assumes winenum.ahk has registered its enumerate-by-hwnd fetcher with the store.
;===============================================================================

;------------------------------ Module state ----------------------------------
global _MRU_list := []           ; debug deque (most-recent-first)
global _MRU_msg  := 0
global _MRU_win  := 0

global _MRU_prevFocusedHwnd := 0 ; last hwnd we marked isFocused=true
global _MRU_lastActHwnd     := 0 ; for debounce
global _MRU_lastActTick     := 0

; Config: activation debounce window in ms (0 = off)
global MRU_ActivationDebounceMs := 0

; Optional: set to your overlay title to ignore its focus events
; global OverlayTitle := "Tabby Overlay"  ; (set elsewhere if you’d like)

;------------------------------ Public API ------------------------------------

MRU_Init() {
    global _MRU_msg, _MRU_win
    if (_MRU_msg)  ; already initialized
        return

    _MRU_win := Gui("-Caption +ToolWindow")
    _MRU_win.Hide()

    ; register hidden GUI as a shell hook window
    DllCall("RegisterShellHookWindow", "ptr", _MRU_win.Hwnd)

    ; get the message id for shell notifications and route it
    _MRU_msg := DllCall("RegisterWindowMessage", "str", "SHELLHOOK", "uint")
    OnMessage(_MRU_msg, MRU_OnShell)

    OnExit(_MRU_OnExit)
}

MRU_SetDebounce(ms) {
    global MRU_ActivationDebounceMs
    MRU_ActivationDebounceMs := Max(0, ms + 0)
}

MRU_GetList() {
    global _MRU_list
    return _MRU_list.Clone()   ; shallow copy for safety
}

MRU_MoveToFront(hwnd) {
    global _MRU_list
    hwnd := hwnd + 0
    if (hwnd = 0)
        return
    ; remove old occurrence
    for i, h in _MRU_list {
        if (h = hwnd) {
            _MRU_list.RemoveAt(i)
            break
        }
    }
    _MRU_list.InsertAt(1, hwnd)
}

MRU_Remove(hwnd) {
    global _MRU_list
    hwnd := hwnd + 0
    if (hwnd = 0)
        return
    for i, h in _MRU_list {
        if (h = hwnd) {
            _MRU_list.RemoveAt(i)
            break
        }
    }
}

;--------------------------- Shell hook handler -------------------------------

MRU_OnShell(wParam, lParam, msg, hwnd) {
    static HSHELL_WINDOWCREATED      := 1
    static HSHELL_WINDOWDESTROYED    := 2
    static HSHELL_WINDOWACTIVATED    := 4
    static HSHELL_RUDEAPPACTIVATED   := 0x8004

    if (lParam = 0)
        return

    switch wParam {
        case HSHELL_WINDOWCREATED:
            _MRU_OnCreated(lParam)

        case HSHELL_WINDOWDESTROYED:
            _MRU_OnDestroyed(lParam)

        case HSHELL_WINDOWACTIVATED, HSHELL_RUDEAPPACTIVATED:
            _MRU_OnActivated(lParam)
    }
}

;------------------------------ Event handling --------------------------------

_MRU_OnCreated(hwnd) {
    ; Seed the store quickly so background pumps can enrich later.
    try WindowStore_Ensure(hwnd)
    catch
        ; ignore
    ; Keep debug deque in sync (optional)
    MRU_MoveToFront(hwnd)
}

_MRU_OnDestroyed(hwnd) {
    ; Clean store immediately to avoid “ghosts”.
    try WindowStore_RemoveWindow(hwnd)
    catch
        ; ignore
    ; Sync debug deque
    MRU_Remove(hwnd)
    ; Clear prev focus marker if it was this hwnd
    global _MRU_prevFocusedHwnd
    if (_MRU_prevFocusedHwnd = hwnd)
        _MRU_prevFocusedHwnd := 0
}

_MRU_OnActivated(hwnd) {
    ; Ignore our own AHK/overlay focus to prevent churn
    if (_MRU_ShouldIgnore(hwnd))
        return

    ; Debounce repeated activations (same hwnd within N ms)
    global MRU_ActivationDebounceMs, _MRU_lastActHwnd, _MRU_lastActTick
    now := A_TickCount
    if (MRU_ActivationDebounceMs > 0) {
        if (hwnd = _MRU_lastActHwnd && (now - _MRU_lastActTick) < MRU_ActivationDebounceMs)
            return
        _MRU_lastActHwnd := hwnd
        _MRU_lastActTick := now
    }

    ; Mark new focus & MRU in the store
    try WindowStore_Ensure(hwnd, { lastActivatedTick: now, isFocused: true })
    catch
        ; ignore

    ; Clear focus flag on the previously focused window (if different)
    global _MRU_prevFocusedHwnd
    if (_MRU_prevFocusedHwnd && _MRU_prevFocusedHwnd != hwnd) {
        try WindowStore_UpdateFields(_MRU_prevFocusedHwnd, { isFocused: false })
        catch
            ; ignore
    }
    _MRU_prevFocusedHwnd := hwnd

    ; Keep debug deque in sync
    MRU_MoveToFront(hwnd)
}

;------------------------------ Helpers ---------------------------------------

_MRU_ShouldIgnore(hwnd) {
    ; Ignore known AHK/overlay windows so they don’t pollute MRU.
    cls := _MRU_GetClass(hwnd)
    if (cls = "AutoHotkeyGUI")
        return true

    if (IsSet(OverlayTitle) && OverlayTitle) {
        ttl := ""
        try ttl := WinGetTitle("ahk_id " hwnd)
        if (ttl = OverlayTitle)
            return true
    }
    return false
}

_MRU_GetClass(hWnd) {
    buf := Buffer(256*2, 0)
    DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
    return StrGet(buf.Ptr, "UTF-16")
}

_MRU_OnExit(reason, code) {
    global _MRU_win
    try {
        if IsObject(_MRU_win)
            _MRU_win.Destroy()
    }
}

okay, its time to tackle wiring our komorebi implementation into the new WindowStore paradigm.
I think this will be the hardest part.


Current komorebi.ahk-
---------
; ================== komorebi.ahk ==================
; Single source for Komorebi helpers.
; Depends on: _Log(msg) and RunTry(cmdLine) from helpers.ahk
; Ensure helpers.ahk is #included before this file.

if !IsSet(DebugKomorebi)
    global DebugKomorebi := false

; --- Tiny state TTL cache (avoid re-spawning komorebic state repeatedly)
global KState_Text := ""
global KState_Stamp := 0
global KState_TTL := 180   ; ms

; --- LRU cache for hwnd -> (mIdx, wsIdx, wsName)
global KLRU_Map := Map()    ; hwnd -> {mIdx:Int, wsIdx:Int, wsName:Str}
global KLRU_Order := []     ; keeps recency order of hwnds
global KLRU_Cap := 256


; --- Internal logging wrapper (routes to _Log when DebugKomorebi = true)
_KLog(msg) {
    global DebugKomorebi
    if (DebugKomorebi)
        _Log("[komorebi] " . msg)
}

; --- Quote helper for command lines
_KQuote(s) {
    if !IsSet(s)
        return '""'
    if InStr(s, '"')
        return '"' . StrReplace(s, '"', '""') . '"'
    if InStr(s, ' ')
        return '"' . s . '"'
    return s
}

; --- Run a CLI and capture its stdout to a temp file, then read it back
_KRunCaptureToText(cmd, &outText) {
    tmp := A_Temp . "\komorebi_cap_" . A_TickCount . "_" . Random(1000,9999) . ".tmp"
    ; Run via cmd so we can use redirection
    full := 'cmd.exe /c ' . cmd . ' > ' . _KQuote(tmp) . ' 2>&1'
    code := RunTry(full)
    outText := ""
    try {
        if FileExist(tmp)
            outText := FileRead(tmp, "UTF-8")
    }
    try FileDelete(tmp)
    return code
}

_KLRU_Touch(hwnd) {
    global KLRU_Order
    ; remove any existing
    for i, h in KLRU_Order
        if (h = hwnd) {
            KLRU_Order.RemoveAt(i)
            break
        }
    KLRU_Order.InsertAt(1, hwnd)
}

_KLRU_Put(hwnd, mIdx, wsIdx, wsName) {
    global KLRU_Map, KLRU_Order, KLRU_Cap
    KLRU_Map[hwnd] := { mIdx: mIdx, wsIdx: wsIdx, wsName: wsName }
    _KLRU_Touch(hwnd)
    ; evict if needed
    while (KLRU_Order.Length > KLRU_Cap) {
        old := KLRU_Order.RemoveAt(KLRU_Order.Length)
        if (KLRU_Map.Has(old))
            KLRU_Map.Delete(old)
    }
}

_KLRU_Get(hwnd, &mIdx, &wsIdx, &wsName) {
    global KLRU_Map
    if !KLRU_Map.Has(hwnd) {
        mIdx := -1, wsIdx := -1, wsName := ""
        return false
    }
    v := KLRU_Map[hwnd]
    mIdx := v.mIdx, wsIdx := v.wsIdx, wsName := v.wsName
    _KLRU_Touch(hwnd)
    return true
}


Komorebi_IsAvailable() {
    global KomorebicExe
    return (IsSet(KomorebicExe) && KomorebicExe != "" && FileExist(KomorebicExe))
}

; --- For startup sanity checks
Komorebi_DebugPing() {
    global KomorebicExe
    _KLog("DebugPing: starting…")
    _KLog("DebugPing: KomorebicExe='" . KomorebicExe . "'")
    _KLog("IsAvailable=" . (Komorebi_IsAvailable() ? "true" : "false"))

    if Komorebi_IsAvailable() {
        exeQ := _KQuote(KomorebicExe)
        verTxt := ""
        code := _KRunCaptureToText(exeQ . " --version", &verTxt)
        _KLog("DebugPing: '--version' exit=" . code)
        if (StrLen(Trim(verTxt)) > 0)
            _KLog("DebugPing: version='" . Trim(verTxt) . "'")
    }
}

; --- Get the raw JSON state from komorebi
_Komorebi_GetStateText() {
    global KomorebicExe, KState_Text, KState_Stamp, KState_TTL
    if !Komorebi_IsAvailable()
        return ""

    ; TTL reuse
    now := A_TickCount
    if (KState_Text != "" && (now - KState_Stamp) < KState_TTL)
        return KState_Text

    exeQ := _KQuote(KomorebicExe)
    txt := ""
    code := _KRunCaptureToText(exeQ . " state", &txt)
    _KLog("GetState: exit=" . code . " bytes=" . StrLen(txt))

    if (code = 0 && StrLen(txt))
        KState_Text := txt, KState_Stamp := now
    else
        KState_Text := "", KState_Stamp := 0

    return txt
}


; --- Find the workspace *name* that contains a specific hwnd by scanning the JSON text.
;     Strategy: find the first occurrence of "hwnd": <hwnd>, then walk backward to the
;     nearest preceding "name": "<...>" that also has "containers" before the hwnd.
_Komorebi_FindWorkspaceNameByHwnd(stateText, hwnd) {
    if (stateText = "" || !hwnd)
        return ""

    m := 0
    pos := RegExMatch(stateText, '"hwnd"\s*:\s*' . hwnd . '\b', &m, 1)
    if (pos = 0) {
        _KLog("FindWorkspace: hwnd not found in state")
        return ""
    }

    back := SubStr(stateText, 1, pos)
    names := []
    searchPos := 1
    mm := 0
    while (p := RegExMatch(back, '"name"\s*:\s*"([^"]+)"', &mm, searchPos)) {
        names.Push({ pos: p, name: mm[1], len: StrLen(mm[0]) })
        searchPos := p + StrLen(mm[0])
    }
    if (names.Length = 0) {
        _KLog("FindWorkspace: no name entries before hwnd")
        return ""
    }

    i := names.Length
    loop {
        if (i <= 0)
            break
        cand := names[i]
        block := SubStr(stateText, cand.pos, pos - cand.pos)
        if InStr(block, '"containers"') {
            ws := cand.name
            _KLog("FindWorkspace: hwnd=" . hwnd . " => workspace='" . ws . "'")
            return ws
        }
        i -= 1
    }

    _KLog("FindWorkspace: could not resolve workspace name for hwnd=" . hwnd)
    return ""
}

; --- DWMWA_CLOAKED check
_Komorebi_IsCloaked(hwnd) {
    buf := Buffer(4, 0)
    ; DWMWA_CLOAKED = 14
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hwnd, "uint", 14, "ptr", buf.Ptr, "uint", 4, "int")
    if (hr != 0)
        return false
    return (NumGet(buf, 0, "UInt") != 0)
}

_Komorebi_WaitUncloak(hwnd, waitMs := 300) {
    deadline := A_TickCount + Abs(waitMs)
    loop {
        if !_Komorebi_IsCloaked(hwnd)
            return true
        if (A_TickCount >= deadline)
            break
        Sleep 12
    }
    return !_Komorebi_IsCloaked(hwnd)
}

; === NEW ===
; Robustly find (monitorIndex, workspaceIndex) for the workspace containing the given hwnd.
; Also returns the workspace name (wsName). Returns true on success, false otherwise.
_Komorebi_FindMonitorWorkspaceIndexByHwnd(stateText, hwnd, &mIdx, &wsIdx, &wsName) {
    mIdx := -1, wsIdx := -1, wsName := ""
    if (stateText = "" || !hwnd)
        return false

    ; Absolute position of the target hwnd in the full JSON
    mh := 0
    hx := RegExMatch(stateText, '"hwnd"\s*:\s*' . hwnd . '\b', &mh, 1)
    if (hx = 0) {
        _KLog("IdxFinder: hwnd not found in state")
        return false
    }

    ; Find each monitor's *workspaces* object by anchoring on:
    ;   "workspaces": { ... } , "last_focused_workspace"
    ; The capture group 1 is the *content* of the workspaces object.
    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"last_focused_workspace"'
    posMon := 1
    mm := 0
    curMon := 0
    wsContent := "", wsContentAbsStart := 0
    foundMon := false

    while (p := RegExMatch(stateText, patMon, &mm, posMon)) {
        ; mm.Pos(0) .. mm.Pos(0)+mm.Len(0)-1 is the entire "workspaces":{...},"last_focused_workspace"
        blockStart := mm.Pos(0)
        blockEnd   := mm.Pos(0) + mm.Len(0) - 1

        if (blockStart <= hx && hx <= blockEnd) {
            wsContent := mm[1]
            wsContentAbsStart := mm.Pos(1)  ; absolute start of the captured content
            mIdx := curMon
            foundMon := true
            break
        }

        posMon := mm.Pos(0) + mm.Len(0)
        curMon += 1
    }

    if !foundMon {
        _KLog("IdxFinder: containing workspaces block not found around hwnd")
        return false
    }

    ; Inside the selected monitor's workspaces content, find the last "name" *before* hx
    ; That "name" corresponds to the workspace owning the hwnd.
    patName := 's)"name"\s*:\s*"([^"]+)"'
    posN := 1
    mn := 0
    idx := 0
    lastIdx := -1
    lastName := ""
    lastAbs := 0

    while (q := RegExMatch(wsContent, patName, &mn, posN)) {
        absPos := wsContentAbsStart + q - 1
        if (absPos < hx) {
            lastIdx := idx
            lastName := mn[1]
            lastAbs := absPos
        } else {
            break
        }
        posN := mn.Pos(0) + mn.Len(0)
        idx += 1
    }

    if (lastIdx < 0) {
        _KLog("IdxFinder: no workspace name found before hwnd inside selected monitor")
        return false
    }

    wsIdx  := lastIdx
    wsName := lastName
    _KLog("IdxFinder: resolved mIdx=" . mIdx . " wsIdx=" . wsIdx . " wsName='" . wsName . "'")
    return true
}


; Run komorebic with args, hidden; return exit code
Kom_RunWait(args) {
    global KomorebicExe
    return RunWait('"' KomorebicExe '" ' . args, , "Hide")
}


; --- Main entry used by helpers.ActivateHwnd for OtherWorkspace
;     1) Read state
;     2) Resolve monitor/workspace index that contains hwnd (and log name)
;     3) komorebic focus-monitor <mIdx>, then focus-workspace <wsIdx>
;     4) Wait for uncloaked; return true/false
Komorebi_FocusHwnd(hwnd) {
    global KomorebicExe
    if !Komorebi_IsAvailable() {
        _KLog("Komorebi_FocusHwnd: komorebic.exe not found or path not set")
        return false
    }

    cloakedStart := _Komorebi_IsCloaked(hwnd)
    _KLog("Komorebi_FocusHwnd: hwnd=" . hwnd . " cloakedStart=" . (cloakedStart ? "true" : "false"))

    ; ---------- FAST PATH: subscription map ----------
    wsFast := ""
    if Komorebi_SubTryMap(hwnd, &wsFast) && (wsFast != "") {
        _KLog("Komorebi_FocusHwnd: submap -> " . wsFast)
        if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsFast)) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 180) {
                _KLog("Komorebi_FocusHwnd: success (submap)")
                return true
            }
        }
        _KLog("Komorebi_FocusHwnd: submap focus attempt fell through")
    }

    ; ---------- FAST PATH 2: LRU (no state parse) ----------
    mIdx := -1, wsIdx := -1, wsNameLRU := ""
    if _KLRU_Get(hwnd, &mIdx, &wsIdx, &wsNameLRU) {
        if (mIdx >= 0 && wsIdx >= 0) {
            if (Kom_RunWait('focus-monitor ' . mIdx) = 0 && Kom_RunWait('focus-workspace ' . wsIdx) = 0) {
                Kom_RunWait('focus-window --hwnd ' . hwnd)
                if _Komorebi_WaitUncloak(hwnd, 180) {
                    _KLog("Komorebi_FocusHwnd: success (lru idx)")
                    return true
                }
            }
        }
        if (wsNameLRU != "") {
            if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsNameLRU)) = 0) {
                Kom_RunWait('focus-window --hwnd ' . hwnd)
                if _Komorebi_WaitUncloak(hwnd, 180) {
                    _KLog("Komorebi_FocusHwnd: success (lru name)")
                    return true
                }
            }
        }
        _KLog("Komorebi_FocusHwnd: LRU fell through")
    }

    ; ---------- Normal path: read (TTL-cached) state once ----------
    stateTxt := _Komorebi_GetStateText()
    if (stateTxt = "") {
        _KLog("Komorebi_FocusHwnd: state text empty, abort")
        return false
    }

    wsNameLog := _Komorebi_FindWorkspaceNameByHwnd(stateTxt, hwnd)
    if (wsNameLog != "")
        _KLog("Komorebi_FocusHwnd: workspace='" . wsNameLog . "'")

    mIdx := -1, wsIdx := -1, wsName := ""
    if _Komorebi_FindMonitorWorkspaceIndexByHwnd(stateTxt, hwnd, &mIdx, &wsIdx, &wsName) {
        if (Kom_RunWait('focus-monitor ' . mIdx) = 0 && Kom_RunWait('focus-workspace ' . wsIdx) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 220) {
                _KLog("Komorebi_FocusHwnd: success (index path)")
                _KLRU_Put(hwnd, mIdx, wsIdx, (wsName != "" ? wsName : wsNameLog))
                return true
            } else {
                _KLog("Komorebi_FocusHwnd: cloaked after index path")
            }
        } else {
            _KLog("Komorebi_FocusHwnd: focus-monitor/workspace failed (index path)")
        }
    } else {
        _KLog("Komorebi_FocusHwnd: failed to resolve indexes; trying name fallback")
    }

    ; ----- Fallback: by name ----------
    if (wsNameLog != "") {
        if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsNameLog)) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 220) {
                _KLog("Komorebi_FocusHwnd: success (fallback)")
                _KLRU_Put(hwnd, -1, -1, wsNameLog)
                return true
            }
        } else {
            _KLog("Komorebi_FocusHwnd: focus-named-workspace failed (fallback)")
        }
    }

    return false
}
----------------
current komorebi_sub.ahk
----------------
; ================== komorebi_sub.ahk ==================
; Fast komorebi subscription bridge using a Named Pipe (no PowerShell, no files).
; - AHK hosts \\.\pipe\<name> (overlapped, non-blocking)
; - Launches one hidden: komorebic.exe subscribe-pipe <name>
; - Timer peeks & reads only when bytes are available (never blocks UI)
; - Maintains fast cache: hwnd -> workspace_name, plus last "state" JSON
; - Auto-reconnect & backoff

#Requires AutoHotkey v2.0

; -------- CONFIG --------
global KomorebicExe            := IsSet(KomorebicExe) ? KomorebicExe : "C:\Program Files\komorebi\bin\komorebic.exe"
global KSub_PollMs             := 50           ; timer cadence (lower = snappier)
global KSub_MaxBytesPerTick    := 65536        ; cap bytes processed per tick
global KSub_IdleRecycleMs      := 120000       ; recycle if no events this long (ms)
global KSub_MaxRestartBackoff  := 5000         ; ms

; -------- STATE --------
global KSub_PipeName := "tabby_" A_TickCount "_" Random(1000,9999)
global KSub_hPipe    := 0
global KSub_hEvent   := 0
global KSub_Over     := 0                       ; OVERLAPPED struct buffer
global KSub_Connected := false

global KSub_ClientPid := 0                      ; komorebic subscribe-pipe pid
global KSub_LastEvent := 0
global KSub_BackoffMs := 0
global KSub_LastStart := 0

global KSub_Buf := ""                           ; partial line buffer
global KSub_Map := Map()                        ; hwnd -> workspace_name
global KSub_StateText := ""                     ; last "state" JSON

; -------- Logging (safe if _Log missing) --------
KSub_Log(msg) {
    if (IsSet(DebugKomorebi) && DebugKomorebi) {
        try {
            _Log("[komorebi] " . msg)
        } catch as e {
            ; ignore logging errors
        }
    }
}

; -------- Public API --------
Komorebi_SubEnsure() {
    if (KSub_hPipe && KSub_Connected)
        return true
    return Komorebi_SubStart()
}

Komorebi_SubStart() {
    global KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    global KSub_ClientPid, KSub_LastEvent, KSub_BackoffMs, KSub_LastStart, KSub_PipeName

    Komorebi_SubStop()  ; clean slate

    ; Validate komorebic path
    if !(IsSet(KomorebicExe) && KomorebicExe != "" && FileExist(KomorebicExe)) {
        KSub_Log("SubStart: komorebic.exe not found; will retry")
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Backoff if crash-looping
    now := A_TickCount
    if (KSub_LastStart && now - KSub_LastStart < 3000) {
        KSub_BackoffMs := Min(KSub_MaxRestartBackoff, Max(500, KSub_BackoffMs * 2))
        Sleep KSub_BackoffMs
    } else {
        KSub_BackoffMs := 0
    }
    KSub_LastStart := A_TickCount

    ; Create overlapped Named Pipe server (message mode)
    PIPE_ACCESS_INBOUND   := 0x00000001
    FILE_FLAG_OVERLAPPED  := 0x40000000
    PIPE_TYPE_MESSAGE     := 0x00000004
    PIPE_READMODE_MESSAGE := 0x00000002
    PIPE_WAIT             := 0x00000000

    name := "\\.\pipe\" . KSub_PipeName
    KSub_hPipe := DllCall("CreateNamedPipeW"
        , "str", name
        , "uint", PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED
        , "uint", PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT
        , "uint", 1                 ; max instances
        , "uint", 65536             ; out buffer (unused for inbound)
        , "uint", 65536             ; in buffer
        , "uint", 0                 ; default timeout
        , "ptr", 0                  ; security attrs
        , "ptr")
    if (KSub_hPipe = 0 || KSub_hPipe = -1) {
        KSub_Log("SubStart: CreateNamedPipe failed")
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Create event for OVERLAPPED connect
    KSub_hEvent := DllCall("CreateEventW", "ptr", 0, "int", 1, "int", 0, "ptr", 0, "ptr")
    if (!KSub_hEvent) {
        KSub_Log("SubStart: CreateEvent failed")
        Komorebi_SubStop()
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Allocate OVERLAPPED and set hEvent (x64 offset 24, x86 offset 16)
    KSub_Over := Buffer(A_PtrSize=8 ? 32 : 20, 0)
    NumPut("ptr", KSub_hEvent, KSub_Over, (A_PtrSize=8) ? 24 : 16)

    ; Begin async connect
    ok := DllCall("ConnectNamedPipe", "ptr", KSub_hPipe, "ptr", KSub_Over.Ptr, "int")
    if (!ok) {
        gle := DllCall("GetLastError", "uint")
        if (gle = 997) { ; ERROR_IO_PENDING
            KSub_Connected := false
        } else if (gle = 535) { ; ERROR_PIPE_CONNECTED
            KSub_Connected := true
        } else {
            KSub_Log("SubStart: ConnectNamedPipe err=" . gle)
            Komorebi_SubStop()
            SetTimer(Komorebi_SubPoll, KSub_PollMs)
            return false
        }
    } else {
        KSub_Connected := true
    }

    ; Launch hidden komorebic subscriber (client)
    try {
        KSub_ClientPid := Run('"' KomorebicExe '" subscribe-pipe ' KSub_PipeName, , "Hide")
        KSub_Log("SubStart: spawned client pid=" . KSub_ClientPid . " pipe=" . KSub_PipeName)
    } catch as e {
        KSub_Log("SubStart: failed to start subscribe-pipe: " . e.Message)
        ; keep server alive; we may connect later
    }

    KSub_LastEvent := A_TickCount
    SetTimer(Komorebi_SubPoll, KSub_PollMs)
    return true
}

Komorebi_SubStop() {
    global KSub_ClientPid, KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    SetTimer(Komorebi_SubPoll, 0)

    if (KSub_ClientPid) {
        try {
            ProcessClose(KSub_ClientPid)
        } catch as e {
            ; ignore
        }
        KSub_ClientPid := 0
    }

    if (KSub_hPipe) {
        try {
            DllCall("DisconnectNamedPipe", "ptr", KSub_hPipe)
        } catch as e {
        }
        try {
            DllCall("CloseHandle", "ptr", KSub_hPipe)
        } catch as e {
        }
        KSub_hPipe := 0
    }
    if (KSub_hEvent) {
        try {
            DllCall("CloseHandle", "ptr", KSub_hEvent)
        } catch as e {
        }
        KSub_hEvent := 0
    }
    KSub_Over := 0
    KSub_Connected := false
    KSub_Log("SubStop: done")
}

; ---- Fast map lookup used by your Komorebi_FocusHwnd fast path ----
Komorebi_SubTryMap(hwnd, &ws) {
    global KSub_Map, KSub_StateText
    if (KSub_Map.Has(hwnd)) {
        ws := KSub_Map[hwnd]
        return (ws != "")
    }
    if (KSub_StateText != "") {
        try {
            w := _Komorebi_FindWorkspaceNameByHwnd(KSub_StateText, hwnd)
            if (w != "") {
                KSub_Map[hwnd] := w
                ws := w
                return true
            }
        } catch as e {
            ; ignore
        }
    }
    ws := ""
    return false
}

; -------- Timer: connect progress, read available bytes (non-blocking) --------
Komorebi_SubPoll() {
    global KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    global KSub_ClientPid, KSub_LastEvent, KSub_IdleRecycleMs, KSub_MaxBytesPerTick

    if (!KSub_hPipe) {
        Komorebi_SubStart()
        return
    }

    ; If not connected yet, check the event
    if (!KSub_Connected) {
        res := DllCall("kernel32\WaitForSingleObject", "ptr", KSub_hEvent, "uint", 0, "uint")
        if (res = 0) { ; WAIT_OBJECT_0
            KSub_Connected := true
            KSub_Log("SubPoll: pipe connected")
        }
        return
    }

    ; Read loop (bounded by bytes per tick)
    bytesProcessed := 0
    loop {
        avail := 0, bytesLeft := 0
        ok := DllCall("PeekNamedPipe"
            , "ptr", KSub_hPipe
            , "ptr", 0, "uint", 0
            , "uint*", 0
            , "uint*", &avail
            , "uint*", &bytesLeft
            , "int")
        if (!ok) {
            gle := DllCall("GetLastError", "uint")
            if (gle = 109) { ; ERROR_BROKEN_PIPE
                KSub_Log("SubPoll: client disconnected (broken pipe) -> restarting")
                Komorebi_SubStart()
                return
            }
            return
        }

        if (avail = 0)
            break

        toRead := Min(avail, KSub_MaxBytesPerTick - bytesProcessed)
        if (toRead <= 0)
            break

        buf := Buffer(toRead)
        read := 0
        ok2 := DllCall("ReadFile"
            , "ptr", KSub_hPipe
            , "ptr", buf.Ptr
            , "uint", toRead
            , "uint*", &read
            , "ptr", 0
            , "int")
        if (!ok2) {
            gle := DllCall("GetLastError", "uint")
            if (gle = 109) {
                KSub_Log("SubPoll: client disconnected during read -> restarting")
                Komorebi_SubStart()
                return
            }
            return
        }

        if (read > 0) {
            chunk := StrGet(buf.Ptr, read, "UTF-8")
            KSub_LastEvent := A_TickCount
            KSub_ProcessChunk(chunk)
            bytesProcessed += read
            if (bytesProcessed >= KSub_MaxBytesPerTick)
                break
        } else {
            break
        }
    }

    ; Recycle if idle for a long time (handles komorebi restarts)
    idle := A_TickCount - KSub_LastEvent
    if (idle > KSub_IdleRecycleMs) {
        KSub_Log("SubPoll: idle " . idle . "ms -> recycling subscriber")
        Komorebi_SubStart()
    }
}

KSub_ProcessChunk(chunk) {
    global KSub_Buf
    KSub_Buf .= chunk
    while true {
        pos := InStr(KSub_Buf, "n")
        if (!pos)
            break
        line := RTrim(SubStr(KSub_Buf, 1, pos - 1), "r")
        KSub_Buf := SubStr(KSub_Buf, pos + 1)
        if (line != "")
            Komorebi_SubOnLine(line)
    }
}

; -------- Parse each JSON line --------
Komorebi_SubOnLine(line) {
    global KSub_Map, KSub_StateText

    hwnd := 0, ws := ""

    m := 0
    if RegExMatch(line, '"hwnd"\s*:\s*(\d+)', &m)
        hwnd := Integer(m[1])

    n := 0
    if RegExMatch(line, '"workspace_name"\s*:\s*"([^"]+)"', &n)
        ws := n[1]
    else if RegExMatch(line, '"workspace"\s*:\s*"([^"]+)"', &n)
        ws := n[1]
    else if InStr(line, '"workspace"') && RegExMatch(line, '"name"\s*:\s*"([^"]+)"', &n)
        ws := n[1]

    if (hwnd && ws != "") {
        KSub_Map[hwnd] := ws
        return
    }

    ; Full state update present on this line?
    if InStr(line, '"state"') {
        st := _KSub_ExtractStateJson(line)
        if (st != "" && st != "{}") {
            KSub_StateText := st
            if (hwnd) {
                try {
                    w := _Komorebi_FindWorkspaceNameByHwnd(st, hwnd) ; from your komorebi.ahk
                    if (w != "")
                        KSub_Map[hwnd] := w
                } catch as e {
                    ; ignore
                }
            }
        }
    }
}

; Extract the JSON object that follows the "state": key on this line
_KSub_ExtractStateJson(line) {
    posState := InStr(line, '"state"')
    if (!posState)
        return ""
    posColon := InStr(line, ":", false, posState)
    if (!posColon)
        return ""
    i := posColon + 1
    while (i <= StrLen(line) && SubStr(line, i, 1) ~= "\s")
        i += 1
    if (i > StrLen(line) || SubStr(line, i, 1) != "{")
        return ""
    depth := 0, start := i, j := i
    while (j <= StrLen(line)) {
        ch := SubStr(line, j, 1)
        if (ch = "{") {
            depth += 1
        } else if (ch = "}") {
            depth -= 1
            if (depth = 0)
                return SubStr(line, start, j - start + 1)
        } else if (ch = '"') {
            j += 1
            while (j <= StrLen(line)) {
                c := SubStr(line, j, 1)
                if (c = '"' && SubStr(line, j-1, 1) != "\")
                    break
                j += 1
            }
        }
        j += 1
    }
    return ""
}
---------------------
current komorebi_pump.ahk
-----------
#Requires AutoHotkey v2.0
; =============================================================================
; komorebi_pump.ahk — integrates Komorebi workspace/focus info into WindowStore
; Placeholder: calls are wrapped so you can later bind them to your real
; komorebi.ahk API (poll or event-driven). The pump shows how to feed the store.
; =============================================================================

; ---------- Tunables ----------------------------------------------------------
if !IsSet(KomoTimerIntervalMs)
    KomoTimerIntervalMs := 120

; ---------- Module state ------------------------------------------------------
global _KP_TimerOn       := false
global _KP_LastWSId      := ""
global _KP_LastWSName    := ""
global _KP_LastFocused   := 0

; ---------- Public API --------------------------------------------------------
KomorebiPump_Start() {
    global _KP_TimerOn, KomoTimerIntervalMs
    if (_KP_TimerOn)
        return
    _KP_TimerOn := true
    SetTimer(_KP_Tick, KomoTimerIntervalMs)
}

KomorebiPump_Stop() {
    global _KP_TimerOn
    if !_KP_TimerOn
        return
    _KP_TimerOn := false
    SetTimer(_KP_Tick, 0)
}

; ---------- Core (polling placeholder) ---------------------------------------
_KP_Tick() {
    ; 1) Current workspace (id + name)
    ws := _KP_TryGetCurrentWorkspace()  ; {id, name} or ""
    if (IsObject(ws)) {
        if (ws.id . "" != _KP_LastWSId . "" || ws.name . "" != _KP_LastWSName . "") {
            _KP_LastWSId   := ws.id . ""
            _KP_LastWSName := ws.name . ""
            WindowStore_SetCurrentWorkspace(_KP_LastWSId, _KP_LastWSName)
        }
    }

    ; 2) Focused hwnd (komorebi does NOT set isFocused; MRU owns that)
    f := _KP_TryGetFocusedHwnd()
    if (f && f != _KP_LastFocused) {
        _KP_LastFocused := f
        ; Ensure record exists so subsequent workspace hints land; no focus fields here.
        WindowStore_Ensure(f, 0, "komorebi")
    }

    ; 3) Per-window workspace mapping
    ;    Expected: [{ hwnd, wsId?, wsName? }, ...]
    map := _KP_TryMapAllWindows()
    if (IsObject(map)) {
        cur := WindowStore_GetCurrentWorkspace()
        for _, it in map {
            if (!IsObject(it) || !it.Has("hwnd"))
                continue
            hwnd := it.hwnd + 0

            hints := Map()
            if (it.Has("wsId"))
                hints["workspaceId"] := it.wsId . ""
            if (it.Has("wsName"))
                hints["workspaceName"] := it.wsName . ""

            ; Derive isOnCurrentWorkspace only if current + one of id/name are known
            if (hints.Has("workspaceId") && cur.id != "") {
                hints["isOnCurrentWorkspace"] := (hints["workspaceId"] = cur.id)
            } else if (hints.Has("workspaceName") && cur.name != "") {
                hints["isOnCurrentWorkspace"] := (hints["workspaceName"] = cur.name)
            }

            ; Always funnel via Ensure so unknown hwnds are minimally enumerated
            WindowStore_Ensure(hwnd, hints, "komorebi")
        }
    }
}


; ---------- Binding shims (replace with your real Komorebi calls) ------------
; You can switch these to call functions from your komorebi.ahk when ready.

_KP_TryGetCurrentWorkspace() {
    ; Expected return: { id: "2", name: "dev" } or ""
    ; Placeholder: attempt to call Komorebi_GetCurrentWorkspace() if it exists.
    try {
        if (IsSet(Komorebi_GetCurrentWorkspace) && (Komorebi_GetCurrentWorkspace is Func)) {
            return Komorebi_GetCurrentWorkspace.Call()
        }
    } catch {
    }
    return ""  ; unknown (no change)
}

_KP_TryGetFocusedHwnd() {
    ; Expected return: UInt hwnd or 0
    try {
        if (IsSet(Komorebi_GetFocusedHwnd) && (Komorebi_GetFocusedHwnd is Func)) {
            return Komorebi_GetFocusedHwnd.Call() + 0
        }
    } catch {
    }
    return 0
}

_KP_TryMapAllWindows() {
    ; Expected return: [{ hwnd, wsId?, wsName? }, ...]  or ""
    try {
        if (IsSet(Komorebi_MapAllWindows) && (Komorebi_MapAllWindows is Func)) {
            return Komorebi_MapAllWindows.Call()
        }
    } catch {
    }
    return ""
}

--------------
ok, so again, commentary. 

komorebi.ahk contains _Komorebi_GetStateText(). it runs a cmd line to get the komorebi state, and should be able to fill in all hwnd -> workspace pairs from there
it also handles figureing out the right monitor and workspace to active when we activate a hwnd in another workspace then our own

but i later had the idea that we can just subscribe to komorebi updates.
thats what komorebi_sub.ahk does. it was also supposed to handle disconnects, etc

but the _Komorebi_GetStateText() was kept as like a full initial state check. but not sure if i ever used it that way?

but I'm an idiot and you helped me code these so I dont 100% understand how they are working

i think the intent was it would be intelligent with cache and fast and slow pathes like
use state command to build full cache
use active pipe in sub to update cache
when asked for an hwind -> workspace, pull from cache, if not there, do another full state pull

like we added to the windowstore API both workspacename and ID, but are any of these functions ever actually getting ID?

When I check how alttab.ahk and gui.ahk used this, they only ever used it like this:
_GetWorkspaceForHwnd(hwnd) {
    ws := ""
    try {
        if Komorebi_SubTryMap(hwnd, &ws) && (ws != "")
            return ws
    } catch {
    }
    return ""
}

as for the sub, all I can tell you is, its working. when i have debug logging on, i see my debug logs get filled like this
2025-09-11 21:06:42.332  [komorebi] FindWorkspace: hwnd=1313228 => workspace='Main'
2025-09-11 21:06:46.098  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'
2025-09-11 21:06:50.005  [komorebi] FindWorkspace: hwnd=1313228 => workspace='Main'
2025-09-11 21:06:51.012  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'
2025-09-11 21:06:52.631  [komorebi] FindWorkspace: hwnd=1313228 => workspace='Main'
2025-09-11 21:06:53.317  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'
2025-09-11 21:06:54.449  [komorebi] FindWorkspace: hwnd=1313228 => workspace='Main'
2025-09-11 21:06:54.451  [komorebi] FindWorkspace: hwnd=1313228 => workspace='Main'
2025-09-11 21:06:54.467  [komorebi] FindWorkspace: hwnd=28646558 => workspace='Main'
2025-09-11 21:06:54.476  [komorebi] FindWorkspace: hwnd=134456 => workspace='Media'
2025-09-11 21:06:54.486  [komorebi] FindWorkspace: hwnd=4789820 => workspace='Media'
2025-09-11 21:06:54.501  [komorebi] FindWorkspace: hwnd=591480 => workspace='Media'
2025-09-11 21:06:56.458  [komorebi] FindWorkspace: hwnd=591480 => workspace='Media'
2025-09-11 21:06:57.224  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Media'
2025-09-11 21:06:57.856  [komorebi] FindWorkspace: hwnd=1313228 => workspace='Main'
2025-09-11 21:06:57.858  [komorebi] FindWorkspace: hwnd=1313228 => workspace='Main'
2025-09-11 21:06:57.868  [komorebi] FindWorkspace: hwnd=28646558 => workspace='Main'
2025-09-11 21:06:57.874  [komorebi] FindWorkspace: hwnd=134456 => workspace='Media'
2025-09-11 21:06:57.882  [komorebi] FindWorkspace: hwnd=4789820 => workspace='Media'
2025-09-11 21:06:57.887  [komorebi] FindWorkspace: hwnd=591480 => workspace='Media'
2025-09-11 21:06:59.863  [komorebi] FindWorkspace: hwnd=1313228 => workspace='Main'
2025-09-11 21:07:00.244  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'
2025-09-11 21:07:01.802  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'

like there you can see that I moved 12848910 from Main to media and back. it never shows as a "window moved" or "new workspace focused"
but could we get those style and Im just not doing it properly?

The komorebi_pump.ahk is what you made when I asked you to stub out how a pump would need to interact with our new WindowStore API

so no code, lets discuss, how should we do this?
it makes sense to me to brake it up

komorebi.ahk - queries to komorebic - full state, window activation, etc
komorebi_sub.ahk - subscription, maintenance, action in response to events
komorebi_pump.ahk - called from windowstore as needed, handle queues

but maybe they could be combined / simplified?

for komorebi.ahk, when it pulls in the full state, it can update all HWINDs with workspaces
with komorebi_sub, when its logging something like this
2025-09-11 21:07:01.802  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'
then cant it just use our ensure call to update that hwnds workspace (handles and window->workspace changes) or insert if new
if workspace has changed, call WindowStore_SetCurrentWorkspace because it knows the current?

so if im understanding, these current komorebi files can handle all the use cases we already need? if not, what research do we need to do?

do you see the existing komorebi function working any different then im describing, or does how you see it change our plan or direction? 

oh and does WindowStore_SetCurrentWorkspace, the list.ahk and our API, does it check if the currently being set workspace is different and if so, perform an action? because something needs to kick off some actions in response to a workspace change,
mainly: 
- run a freh winenum
- schedule any unknown icons in the new current to be filled in 

respond with thoughts and planning, no code yet
no we wont synthesize ids, if we dont use them, they can just be unused in the api for now, i dont see the harm

so is the only change in komorebi.ahk this:
(Optional) Enhance komorebi.ahk to export a tiny helper that enumerates all hwnds for the current workspace from state so, on focus change, you can immediately Ensure() that small set (nice for snappy UIs).
do you know enough from the current .ahk to do this? or do you need me to provide you with the output of a komorebic state command (they are biiiiiig)?

we dont need to do anything else to komorebi.ahk? if the sub isn't running, and _Komorebi_GetStateText() is called, how does that get fed back into the WindowStore? 

ooooh, the pump will right? because the pump will call _Komorebi_FindWorkspaceNameByHwnd() when it needs it? 

so the pump will request when it needs it, and komorebi.ahk will use its existing cache or pull a new state if needs.

komorebi_sub will feed in changes as they occur with ensure().

correct me if im wrong, otherwise we can move on to generating the code update.

commentary only no code for now
thats sounds perfect. lets go one at a time so we stay on track

give me the full function ADD / REPLACE / REMOVE for komorebi.ahk to fit our new WindowStore API paradigm 

add all helpers you recommend 
nice. lets do komorebi_sub now. its not clear to me where, but the part of it that is writing these debug entries:
2025-09-11 21:07:01.802  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'
we want to hook into
we want to do two additional things
we want to take the workspace as save it to something like LastSeenWorkspace

Anytime we get a new entry, if LastSeenWorkspace = Workpsace in our new entry
we just use our API ensure() with the HWND
if the LastSeenWorkspace is not equal to the workspace in the new entry
update LastSeenWorkspace
update WindowStore_SetCurrentWorkspace
ensure the hwnd
call into winenum.ahk to do a full check of everything

i think thats it, if you have anything else to do go ahead.

give me the full function ADD / REPLACE / REMOVE for our komorebi_sub.ahk
perfect. last piece now. as a reminder, the current komorebi.ahk is
----------
; ================== komorebi.ahk ==================
; Single source for Komorebi helpers.
; Depends on: _Log(msg) and RunTry(cmdLine) from helpers.ahk
; Ensure helpers.ahk is #included before this file.

if !IsSet(DebugKomorebi)
    global DebugKomorebi := false

; --- Tiny state TTL cache (avoid re-spawning komorebic state repeatedly)
global KState_Text := ""
global KState_Stamp := 0
global KState_TTL := 180   ; ms

; --- LRU cache for hwnd -> (mIdx, wsIdx, wsName)
global KLRU_Map := Map()    ; hwnd -> {mIdx:Int, wsIdx:Int, wsName:Str}
global KLRU_Order := []     ; keeps recency order of hwnds
global KLRU_Cap := 256


; --- Internal logging wrapper (routes to _Log when DebugKomorebi = true)
_KLog(msg) {
    global DebugKomorebi
    if (DebugKomorebi)
        _Log("[komorebi] " . msg)
}

; --- Quote helper for command lines
_KQuote(s) {
    if !IsSet(s)
        return '""'
    if InStr(s, '"')
        return '"' . StrReplace(s, '"', '""') . '"'
    if InStr(s, ' ')
        return '"' . s . '"'
    return s
}

; --- Run a CLI and capture its stdout to a temp file, then read it back
_KRunCaptureToText(cmd, &outText) {
    tmp := A_Temp . "\komorebi_cap_" . A_TickCount . "_" . Random(1000,9999) . ".tmp"
    ; Run via cmd so we can use redirection
    full := 'cmd.exe /c ' . cmd . ' > ' . _KQuote(tmp) . ' 2>&1'
    code := RunTry(full)
    outText := ""
    try {
        if FileExist(tmp)
            outText := FileRead(tmp, "UTF-8")
    }
    try FileDelete(tmp)
    return code
}

_KLRU_Touch(hwnd) {
    global KLRU_Order
    ; remove any existing
    for i, h in KLRU_Order
        if (h = hwnd) {
            KLRU_Order.RemoveAt(i)
            break
        }
    KLRU_Order.InsertAt(1, hwnd)
}

_KLRU_Put(hwnd, mIdx, wsIdx, wsName) {
    global KLRU_Map, KLRU_Order, KLRU_Cap
    KLRU_Map[hwnd] := { mIdx: mIdx, wsIdx: wsIdx, wsName: wsName }
    _KLRU_Touch(hwnd)
    ; evict if needed
    while (KLRU_Order.Length > KLRU_Cap) {
        old := KLRU_Order.RemoveAt(KLRU_Order.Length)
        if (KLRU_Map.Has(old))
            KLRU_Map.Delete(old)
    }
}

_KLRU_Get(hwnd, &mIdx, &wsIdx, &wsName) {
    global KLRU_Map
    if !KLRU_Map.Has(hwnd) {
        mIdx := -1, wsIdx := -1, wsName := ""
        return false
    }
    v := KLRU_Map[hwnd]
    mIdx := v.mIdx, wsIdx := v.wsIdx, wsName := v.wsName
    _KLRU_Touch(hwnd)
    return true
}


Komorebi_IsAvailable() {
    global KomorebicExe
    return (IsSet(KomorebicExe) && KomorebicExe != "" && FileExist(KomorebicExe))
}

; --- For startup sanity checks
Komorebi_DebugPing() {
    global KomorebicExe
    _KLog("DebugPing: starting…")
    _KLog("DebugPing: KomorebicExe='" . KomorebicExe . "'")
    _KLog("IsAvailable=" . (Komorebi_IsAvailable() ? "true" : "false"))

    if Komorebi_IsAvailable() {
        exeQ := _KQuote(KomorebicExe)
        verTxt := ""
        code := _KRunCaptureToText(exeQ . " --version", &verTxt)
        _KLog("DebugPing: '--version' exit=" . code)
        if (StrLen(Trim(verTxt)) > 0)
            _KLog("DebugPing: version='" . Trim(verTxt) . "'")
    }
}

; --- Get the raw JSON state from komorebi
_Komorebi_GetStateText() {
    global KomorebicExe, KState_Text, KState_Stamp, KState_TTL
    if !Komorebi_IsAvailable()
        return ""

    ; TTL reuse
    now := A_TickCount
    if (KState_Text != "" && (now - KState_Stamp) < KState_TTL)
        return KState_Text

    exeQ := _KQuote(KomorebicExe)
    txt := ""
    code := _KRunCaptureToText(exeQ . " state", &txt)
    _KLog("GetState: exit=" . code . " bytes=" . StrLen(txt))

    if (code = 0 && StrLen(txt))
        KState_Text := txt, KState_Stamp := now
    else
        KState_Text := "", KState_Stamp := 0

    return txt
}


; --- Find the workspace *name* that contains a specific hwnd by scanning the JSON text.
;     Strategy: find the first occurrence of "hwnd": <hwnd>, then walk backward to the
;     nearest preceding "name": "<...>" that also has "containers" before the hwnd.
_Komorebi_FindWorkspaceNameByHwnd(stateText, hwnd) {
    if (stateText = "" || !hwnd)
        return ""

    m := 0
    pos := RegExMatch(stateText, '"hwnd"\s*:\s*' . hwnd . '\b', &m, 1)
    if (pos = 0) {
        _KLog("FindWorkspace: hwnd not found in state")
        return ""
    }

    back := SubStr(stateText, 1, pos)
    names := []
    searchPos := 1
    mm := 0
    while (p := RegExMatch(back, '"name"\s*:\s*"([^"]+)"', &mm, searchPos)) {
        names.Push({ pos: p, name: mm[1], len: StrLen(mm[0]) })
        searchPos := p + StrLen(mm[0])
    }
    if (names.Length = 0) {
        _KLog("FindWorkspace: no name entries before hwnd")
        return ""
    }

    i := names.Length
    loop {
        if (i <= 0)
            break
        cand := names[i]
        block := SubStr(stateText, cand.pos, pos - cand.pos)
        if InStr(block, '"containers"') {
            ws := cand.name
            _KLog("FindWorkspace: hwnd=" . hwnd . " => workspace='" . ws . "'")
            return ws
        }
        i -= 1
    }

    _KLog("FindWorkspace: could not resolve workspace name for hwnd=" . hwnd)
    return ""
}

; --- DWMWA_CLOAKED check
_Komorebi_IsCloaked(hwnd) {
    buf := Buffer(4, 0)
    ; DWMWA_CLOAKED = 14
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hwnd, "uint", 14, "ptr", buf.Ptr, "uint", 4, "int")
    if (hr != 0)
        return false
    return (NumGet(buf, 0, "UInt") != 0)
}

_Komorebi_WaitUncloak(hwnd, waitMs := 300) {
    deadline := A_TickCount + Abs(waitMs)
    loop {
        if !_Komorebi_IsCloaked(hwnd)
            return true
        if (A_TickCount >= deadline)
            break
        Sleep 12
    }
    return !_Komorebi_IsCloaked(hwnd)
}

; === NEW ===
; Robustly find (monitorIndex, workspaceIndex) for the workspace containing the given hwnd.
; Also returns the workspace name (wsName). Returns true on success, false otherwise.
_Komorebi_FindMonitorWorkspaceIndexByHwnd(stateText, hwnd, &mIdx, &wsIdx, &wsName) {
    mIdx := -1, wsIdx := -1, wsName := ""
    if (stateText = "" || !hwnd)
        return false

    ; Absolute position of the target hwnd in the full JSON
    mh := 0
    hx := RegExMatch(stateText, '"hwnd"\s*:\s*' . hwnd . '\b', &mh, 1)
    if (hx = 0) {
        _KLog("IdxFinder: hwnd not found in state")
        return false
    }

    ; Find each monitor's *workspaces* object by anchoring on:
    ;   "workspaces": { ... } , "last_focused_workspace"
    ; The capture group 1 is the *content* of the workspaces object.
    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"last_focused_workspace"'
    posMon := 1
    mm := 0
    curMon := 0
    wsContent := "", wsContentAbsStart := 0
    foundMon := false

    while (p := RegExMatch(stateText, patMon, &mm, posMon)) {
        ; mm.Pos(0) .. mm.Pos(0)+mm.Len(0)-1 is the entire "workspaces":{...},"last_focused_workspace"
        blockStart := mm.Pos(0)
        blockEnd   := mm.Pos(0) + mm.Len(0) - 1

        if (blockStart <= hx && hx <= blockEnd) {
            wsContent := mm[1]
            wsContentAbsStart := mm.Pos(1)  ; absolute start of the captured content
            mIdx := curMon
            foundMon := true
            break
        }

        posMon := mm.Pos(0) + mm.Len(0)
        curMon += 1
    }

    if !foundMon {
        _KLog("IdxFinder: containing workspaces block not found around hwnd")
        return false
    }

    ; Inside the selected monitor's workspaces content, find the last "name" *before* hx
    ; That "name" corresponds to the workspace owning the hwnd.
    patName := 's)"name"\s*:\s*"([^"]+)"'
    posN := 1
    mn := 0
    idx := 0
    lastIdx := -1
    lastName := ""
    lastAbs := 0

    while (q := RegExMatch(wsContent, patName, &mn, posN)) {
        absPos := wsContentAbsStart + q - 1
        if (absPos < hx) {
            lastIdx := idx
            lastName := mn[1]
            lastAbs := absPos
        } else {
            break
        }
        posN := mn.Pos(0) + mn.Len(0)
        idx += 1
    }

    if (lastIdx < 0) {
        _KLog("IdxFinder: no workspace name found before hwnd inside selected monitor")
        return false
    }

    wsIdx  := lastIdx
    wsName := lastName
    _KLog("IdxFinder: resolved mIdx=" . mIdx . " wsIdx=" . wsIdx . " wsName='" . wsName . "'")
    return true
}


; Run komorebic with args, hidden; return exit code
Kom_RunWait(args) {
    global KomorebicExe
    return RunWait('"' KomorebicExe '" ' . args, , "Hide")
}


; --- Main entry used by helpers.ActivateHwnd for OtherWorkspace
;     1) Read state
;     2) Resolve monitor/workspace index that contains hwnd (and log name)
;     3) komorebic focus-monitor <mIdx>, then focus-workspace <wsIdx>
;     4) Wait for uncloaked; return true/false
Komorebi_FocusHwnd(hwnd) {
    global KomorebicExe
    if !Komorebi_IsAvailable() {
        _KLog("Komorebi_FocusHwnd: komorebic.exe not found or path not set")
        return false
    }

    cloakedStart := _Komorebi_IsCloaked(hwnd)
    _KLog("Komorebi_FocusHwnd: hwnd=" . hwnd . " cloakedStart=" . (cloakedStart ? "true" : "false"))

    ; ---------- FAST PATH: subscription map ----------
    wsFast := ""
    if Komorebi_SubTryMap(hwnd, &wsFast) && (wsFast != "") {
        _KLog("Komorebi_FocusHwnd: submap -> " . wsFast)
        if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsFast)) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 180) {
                _KLog("Komorebi_FocusHwnd: success (submap)")
                return true
            }
        }
        _KLog("Komorebi_FocusHwnd: submap focus attempt fell through")
    }

    ; ---------- FAST PATH 2: LRU (no state parse) ----------
    mIdx := -1, wsIdx := -1, wsNameLRU := ""
    if _KLRU_Get(hwnd, &mIdx, &wsIdx, &wsNameLRU) {
        if (mIdx >= 0 && wsIdx >= 0) {
            if (Kom_RunWait('focus-monitor ' . mIdx) = 0 && Kom_RunWait('focus-workspace ' . wsIdx) = 0) {
                Kom_RunWait('focus-window --hwnd ' . hwnd)
                if _Komorebi_WaitUncloak(hwnd, 180) {
                    _KLog("Komorebi_FocusHwnd: success (lru idx)")
                    return true
                }
            }
        }
        if (wsNameLRU != "") {
            if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsNameLRU)) = 0) {
                Kom_RunWait('focus-window --hwnd ' . hwnd)
                if _Komorebi_WaitUncloak(hwnd, 180) {
                    _KLog("Komorebi_FocusHwnd: success (lru name)")
                    return true
                }
            }
        }
        _KLog("Komorebi_FocusHwnd: LRU fell through")
    }

    ; ---------- Normal path: read (TTL-cached) state once ----------
    stateTxt := _Komorebi_GetStateText()
    if (stateTxt = "") {
        _KLog("Komorebi_FocusHwnd: state text empty, abort")
        return false
    }

    wsNameLog := _Komorebi_FindWorkspaceNameByHwnd(stateTxt, hwnd)
    if (wsNameLog != "")
        _KLog("Komorebi_FocusHwnd: workspace='" . wsNameLog . "'")

    mIdx := -1, wsIdx := -1, wsName := ""
    if _Komorebi_FindMonitorWorkspaceIndexByHwnd(stateTxt, hwnd, &mIdx, &wsIdx, &wsName) {
        if (Kom_RunWait('focus-monitor ' . mIdx) = 0 && Kom_RunWait('focus-workspace ' . wsIdx) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 220) {
                _KLog("Komorebi_FocusHwnd: success (index path)")
                _KLRU_Put(hwnd, mIdx, wsIdx, (wsName != "" ? wsName : wsNameLog))
                return true
            } else {
                _KLog("Komorebi_FocusHwnd: cloaked after index path")
            }
        } else {
            _KLog("Komorebi_FocusHwnd: focus-monitor/workspace failed (index path)")
        }
    } else {
        _KLog("Komorebi_FocusHwnd: failed to resolve indexes; trying name fallback")
    }

    ; ----- Fallback: by name ----------
    if (wsNameLog != "") {
        if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsNameLog)) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 220) {
                _KLog("Komorebi_FocusHwnd: success (fallback)")
                _KLRU_Put(hwnd, -1, -1, wsNameLog)
                return true
            }
        } else {
            _KLog("Komorebi_FocusHwnd: focus-named-workspace failed (fallback)")
        }
    }

    return false
}

; --- Optional: force-refresh Komorebi state cache (used by callers when needed)
Komorebi_InvalidateStateCache() {
    global KState_Text, KState_Stamp
    KState_Text := ""
    KState_Stamp := 0
}


; Return { id: "", name: "<workspace name>" } or "" if unknown.
; Tolerant parser: prefers explicit name keys; falls back to monitor workspaces + last_focused_workspace index.
Komorebi_GetCurrentWorkspace() {
    txt := _Komorebi_GetStateText()
    if (txt = "")
        return ""

    ; 1) Easy win: look for an explicit focused workspace name anywhere
    m := 0
    if RegExMatch(txt, '"focused_workspace_name"\s*:\s*"([^"]+)"', &m) {
        return { id: "", name: m[1] }
    }
    if RegExMatch(txt, '"current_workspace_name"\s*:\s*"([^"]+)"', &m) {
        return { id: "", name: m[1] }
    }

    ; 2) Walk monitor blocks that expose: "workspaces": { ... }, "last_focused_workspace": <idx|name>
    ; Group 1 = workspaces content, group 2 = name if present, group 3 = index if present
    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"(?:last_focused_workspace_name|last_focused_workspace)"\s*:\s*(?:"([^"]+)"|(\d+))'
    pos := 1, mm := 0
    while (p := RegExMatch(txt, patMon, &mm, pos)) {
        wsContent := mm[1]
        if (mm[2] != "") {
            return { id: "", name: mm[2] }
        }
        if (mm[3] != "") {
            idx := Integer(mm[3])
            ; iterate names within this workspaces object
            patName := 's)"name"\s*:\s*"([^"]+)"'
            posN := 1, mn := 0, i := 0
            while (q := RegExMatch(wsContent, patName, &mn, posN)) {
                if (i = idx)
                    return { id: "", name: mn[1] }
                posN := mn.Pos(0) + mn.Len(0)
                i += 1
            }
        }
        pos := mm.Pos(0) + mm.Len(0)
    }

    ; 3) Last resort: any plausible top-level current/last name signal
    if RegExMatch(txt, '"last_focused_workspace_name"\s*:\s*"([^"]+)"', &m)
        return { id: "", name: m[1] }

    return ""
}




; Return UInt hwnd of focused window per komorebi state, or 0 if unavailable.
; Tries multiple tolerant patterns.
Komorebi_GetFocusedHwnd() {
    txt := _Komorebi_GetStateText()
    if (txt = "")
        return 0

    m := 0
    ; Common shapes we might see:
    if RegExMatch(txt, '"focused_window"\s*:\s*\{[^}]*"hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    if RegExMatch(txt, '"focused_hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    if RegExMatch(txt, '"last_focused_window"\s*:\s*\{[^}]*"hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])

    return 0
}

; Return [{ hwnd, wsName }, ...] using a single pass over state text.
; We scan each monitor's "workspaces" block; for each workspace's "name", we collect "hwnd" values until the next workspace.
Komorebi_MapAllWindows() {
    txt := _Komorebi_GetStateText()
    if (txt = "")
        return ""

    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"(?:last_focused_workspace|last_focused_workspace_name)"'
    pos := 1, mm := 0
    out := []
    seen := Map()

    while (p := RegExMatch(txt, patMon, &mm, pos)) {
        wsContent := mm[1]
        ; iterate workspace names with positions
        patName := 's)"name"\s*:\s*"([^"]+)"'
        posN := 1, mn := 0
        names := []  ; [{name, startRel, endRel}]
        while (q := RegExMatch(wsContent, patName, &mn, posN)) {
            names.Push({ name: mn[1], startRel: mn.Pos(0), endRel: mn.Pos(0) + mn.Len(0) - 1 })
            posN := mn.Pos(0) + mn.Len(0)
        }
        if (names.Length = 0) {
            pos := mm.Pos(0) + mm.Len(0)
            continue
        }
        totalLen := StrLen(wsContent)
        ; for each workspace segment, collect hwnds
        i := 1
        while (i <= names.Length) {
            segStart := names[i].startRel
            segEnd   := (i < names.Length) ? (names[i+1].startRel - 1) : totalLen
            segment  := SubStr(wsContent, segStart, segEnd - segStart + 1)
            ; collect hwnds within this workspace segment
            ph := 0, posH := 1, mh := 0
            while (r := RegExMatch(segment, '"hwnd"\s*:\s*(\d+)', &mh, posH)) {
                hw := Integer(mh[1])
                if (hw > 0 && !seen.Has(hw)) {
                    out.Push({ hwnd: hw, wsName: names[i].name })
                    seen[hw] := true
                }
                posH := mh.Pos(0) + mh.Len(0)
            }
            i += 1
        }
        pos := mm.Pos(0) + mm.Len(0)
    }

    return out
}


; Return [hwnd, ...] for the currently focused workspace, or "" if unknown.
; Uses current workspace name + same segmentation approach as MapAllWindows().
Komorebi_ListCurrentWorkspaceHwnds() {
    cur := Komorebi_GetCurrentWorkspace()
    if (!IsObject(cur) || cur.name = "")
        return ""

    txt := _Komorebi_GetStateText()
    if (txt = "")
        return ""

    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"(?:last_focused_workspace|last_focused_workspace_name)"'
    pos := 1, mm := 0

    while (p := RegExMatch(txt, patMon, &mm, pos)) {
        wsContent := mm[1]
        ; enumerate workspace names w/ positions
        patName := 's)"name"\s*:\s*"([^"]+)"'
        posN := 1, mn := 0
        names := []
        while (q := RegExMatch(wsContent, patName, &mn, posN)) {
            names.Push({ name: mn[1], startRel: mn.Pos(0), endRel: mn.Pos(0) + mn.Len(0) - 1 })
            posN := mn.Pos(0) + mn.Len(0)
        }
        if (names.Length = 0) {
            pos := mm.Pos(0) + mm.Len(0)
            continue
        }
        totalLen := StrLen(wsContent)

        ; find the segment matching the current workspace name
        i := 1
        while (i <= names.Length) {
            if (names[i].name != cur.name) {
                i += 1
                continue
            }
            segStart := names[i].startRel
            segEnd   := (i < names.Length) ? (names[i+1].startRel - 1) : totalLen
            segment  := SubStr(wsContent, segStart, segEnd - segStart + 1)
            ; collect hwnds
            hwnds := []
            posH := 1, mh := 0
            while (r := RegExMatch(segment, '"hwnd"\s*:\s*(\d+)', &mh, posH)) {
                hw := Integer(mh[1])
                if (hw > 0)
                    hwnds.Push(hw)
                posH := mh.Pos(0) + mh.Len(0)
            }
            return hwnds
        }
        pos := mm.Pos(0) + mm.Len(0)
    }
    return ""
}

----------
and the current komorebi_pump is
--------------
#Requires AutoHotkey v2.0
; =============================================================================
; komorebi_pump.ahk — integrates Komorebi workspace/focus info into WindowStore
; Placeholder: calls are wrapped so you can later bind them to your real
; komorebi.ahk API (poll or event-driven). The pump shows how to feed the store.
; =============================================================================

; ---------- Tunables ----------------------------------------------------------
if !IsSet(KomoTimerIntervalMs)
    KomoTimerIntervalMs := 120

; ---------- Module state ------------------------------------------------------
global _KP_TimerOn       := false
global _KP_LastWSId      := ""
global _KP_LastWSName    := ""
global _KP_LastFocused   := 0

; ---------- Public API --------------------------------------------------------
KomorebiPump_Start() {
    global _KP_TimerOn, KomoTimerIntervalMs
    if (_KP_TimerOn)
        return
    _KP_TimerOn := true
    SetTimer(_KP_Tick, KomoTimerIntervalMs)
}

KomorebiPump_Stop() {
    global _KP_TimerOn
    if !_KP_TimerOn
        return
    _KP_TimerOn := false
    SetTimer(_KP_Tick, 0)
}

; ---------- Core (polling placeholder) ---------------------------------------
_KP_Tick() {
    ; 1) Current workspace (id + name)
    ws := _KP_TryGetCurrentWorkspace()  ; {id, name} or ""
    if (IsObject(ws)) {
        if (ws.id . "" != _KP_LastWSId . "" || ws.name . "" != _KP_LastWSName . "") {
            _KP_LastWSId   := ws.id . ""
            _KP_LastWSName := ws.name . ""
            WindowStore_SetCurrentWorkspace(_KP_LastWSId, _KP_LastWSName)
        }
    }

    ; 2) Focused hwnd (komorebi does NOT set isFocused; MRU owns that)
    f := _KP_TryGetFocusedHwnd()
    if (f && f != _KP_LastFocused) {
        _KP_LastFocused := f
        ; Ensure record exists so subsequent workspace hints land; no focus fields here.
        WindowStore_Ensure(f, 0, "komorebi")
    }

    ; 3) Per-window workspace mapping
    ;    Expected: [{ hwnd, wsId?, wsName? }, ...]
    map := _KP_TryMapAllWindows()
    if (IsObject(map)) {
        cur := WindowStore_GetCurrentWorkspace()
        for _, it in map {
            if (!IsObject(it) || !it.Has("hwnd"))
                continue
            hwnd := it.hwnd + 0

            hints := Map()
            if (it.Has("wsId"))
                hints["workspaceId"] := it.wsId . ""
            if (it.Has("wsName"))
                hints["workspaceName"] := it.wsName . ""

            ; Derive isOnCurrentWorkspace only if current + one of id/name are known
            if (hints.Has("workspaceId") && cur.id != "") {
                hints["isOnCurrentWorkspace"] := (hints["workspaceId"] = cur.id)
            } else if (hints.Has("workspaceName") && cur.name != "") {
                hints["isOnCurrentWorkspace"] := (hints["workspaceName"] = cur.name)
            }

            ; Always funnel via Ensure so unknown hwnds are minimally enumerated
            WindowStore_Ensure(hwnd, hints, "komorebi")
        }
    }
}


; ---------- Binding shims (replace with your real Komorebi calls) ------------
; You can switch these to call functions from your komorebi.ahk when ready.

_KP_TryGetCurrentWorkspace() {
    ; Expected return: { id: "2", name: "dev" } or ""
    ; Placeholder: attempt to call Komorebi_GetCurrentWorkspace() if it exists.
    try {
        if (IsSet(Komorebi_GetCurrentWorkspace) && (Komorebi_GetCurrentWorkspace is Func)) {
            return Komorebi_GetCurrentWorkspace.Call()
        }
    } catch {
    }
    return ""  ; unknown (no change)
}

_KP_TryGetFocusedHwnd() {
    ; Expected return: UInt hwnd or 0
    try {
        if (IsSet(Komorebi_GetFocusedHwnd) && (Komorebi_GetFocusedHwnd is Func)) {
            return Komorebi_GetFocusedHwnd.Call() + 0
        }
    } catch {
    }
    return 0
}

_KP_TryMapAllWindows() {
    ; Expected return: [{ hwnd, wsId?, wsName? }, ...]  or ""
    try {
        if (IsSet(Komorebi_MapAllWindows) && (Komorebi_MapAllWindows is Func)) {
            return Komorebi_MapAllWindows.Call()
        }
    } catch {
    }
    return ""
}
-------
if im understanding right, the pump wont call into komorebi_sub, just komorebi.ahk.

this pump was a layout - just to record how we will interact with Window Store API, not actually wired into our komorebi files. now that you have seen and updated komorebi.ahk and komorebi_sub.ahk, give me a full replacement for komorebi_pump now that we know how to wire them together 
i notice you have the pump handling if workspace changed. i thought we had that in komorebi_sub? or is it added here as a fallback if komorebi sub is not running/misbehaving? if thats the case should it also trigger a full winenum if the workspace changed? or now thats two places doing that and its wasteful? 
OK, we've now touched everything that owns any data or adds into the Window Store API.

We haven't touched the pure consumers of the API, like altlogic.ahk. Which is good. I want to perfect the producer side first.

So, before we move on to consumers, lets do a recap.

Below is all files we've build or refactored to use the new WindowStore API.

Before we move on, check very carefully, is this all looking good? Any errors, oversights, or big changes we should make, such as performance or thread blocking or anything important?

--------------
﻿#Requires AutoHotkey v2.0
; =============================================================================
; icon_pump.ahk — resolves per-window icons (HICON) and updates WindowStore
; Strategy:
;   1) Try WM_GETICON / class icon (CopyIcon before storing).
;   2) Fallback to process EXE icon, cached per EXE (store master in WS cache,
;      CopyIcon per row).
;   3) Light re-try with attempt cap to avoid tight loops.
; =============================================================================

; ---------- Tunables ----------------------------------------------------------
if !IsSet(IconBatchPerTick)
    IconBatchPerTick := 16
if !IsSet(IconTimerIntervalMs)
    IconTimerIntervalMs := 80
if !IsSet(IconMaxAttempts)
    IconMaxAttempts := 4

; Skip attempts for obviously non-productive states
if !IsSet(IconSkipHidden)              ; skip when OtherWorkspace/minimized/invisible
    IconSkipHidden := true
if !IsSet(IconIdleBackoffMs)           ; cooldown set when we skip due to state
    IconIdleBackoffMs := 1500

; Backoff after failed attempts (no auto-requeue; we rely on future “tickles”)
if !IsSet(IconAttemptBackoffMs)        ; base backoff after a failed try
    IconAttemptBackoffMs := 300
if !IsSet(IconAttemptBackoffMultiplier) ; optional exponential growth
    IconAttemptBackoffMultiplier := 1.8
if !IsSet(IconGiveUpBackoffMs)         ; after hitting max attempts, set a longer cooldown
    IconGiveUpBackoffMs := 5000


; ---------- Module state ------------------------------------------------------
global _IP_TimerOn      := false
global _IP_Attempts     := Map()  ; hwnd -> attempts

; ---------- Public API --------------------------------------------------------
IconPump_Start() {
    global _IP_TimerOn, IconTimerIntervalMs
    if (_IP_TimerOn)
        return
    _IP_TimerOn := true
    SetTimer(_IP_Tick, IconTimerIntervalMs)
}

IconPump_Stop() {
    global _IP_TimerOn
    if !_IP_TimerOn
        return
    _IP_TimerOn := false
    SetTimer(_IP_Tick, 0)
}

; ---------- Core --------------------------------------------------------------
_IP_Tick() {
    global IconBatchPerTick, _IP_Attempts
    global IconMaxAttempts, IconSkipHidden, IconIdleBackoffMs
    global IconAttemptBackoffMs, IconAttemptBackoffMultiplier, IconGiveUpBackoffMs

    hwnds := WindowStore_PopIconBatch(IconBatchPerTick)
    if (!IsObject(hwnds) || hwnds.Length = 0)
        return

    for _, hwnd in hwnds {
        hwnd := hwnd + 0
        rec := WindowStore_GetByHwnd(hwnd)
        if (!rec)
            continue
        ; Process may have vanished
        if (!WinExist("ahk_id " hwnd))
            continue
        ; Already has icon
        if (rec.iconHicon)
            continue

        ; Skip states that are unlikely to yield an icon right now
        if (IconSkipHidden) {
            if (rec.state = "OtherWorkspace" || rec.isMinimized || !rec.isVisible) {
                _IP_SetCooldown(hwnd, IconIdleBackoffMs)
                continue
            }
        }

        ; Try to resolve from the window first
        h := _IP_TryResolveFromWindow(hwnd)

        ; Fallback via process EXE icon (cached master per exe)
        if (!h) {
            exe := rec.exePath
            if (exe = "" && rec.pid > 0)
                exe := _IP_GetProcessPath(rec.pid)
            if (exe != "") {
                hCopy := WindowStore_GetExeIconCopy(exe)
                if (!hCopy) {
                    master := _IP_ExtractExeIcon(exe)
                    if (master) {
                        WindowStore_ExeIconCachePut(exe, master)  ; store owns master
                        hCopy := DllCall("user32\CopyIcon", "ptr", master, "ptr")
                    }
                }
                h := hCopy
            }
        }

        if (h) {
            ; Success: set icon and clear cooldown
            WindowStore_UpdateFields(hwnd, { iconHicon: h, iconCooldownUntilTick: 0 }, "icons")
            _IP_Attempts[hwnd] := 0
            continue
        }

        ; Failure: bounded retries across future tickles (no immediate requeue loop)
        tries := _IP_Attempts.Has(hwnd) ? (_IP_Attempts[hwnd] + 1) : 1
        _IP_Attempts[hwnd] := tries

        if (tries < IconMaxAttempts) {
            ; Set a backoff; we won't requeue now. A later “tickle” will re-enqueue
            ; when cooldown expires, thanks to _WS_RefreshNeeds().
            step := IconAttemptBackoffMs
            if (IconAttemptBackoffMultiplier > 1) {
                ; simple exponential backoff
                step := Floor(IconAttemptBackoffMs * (IconAttemptBackoffMultiplier ** (tries - 1)))
            }
            _IP_SetCooldown(hwnd, step)
        } else {
            ; We’re done for now; set a longer cooldown. Future activation/workspace
            ; changes will “tickle” and allow another attempt later.
            _IP_SetCooldown(hwnd, IconGiveUpBackoffMs)
        }
    }
}


; ---------- Icon resolution helpers ------------------------------------------
_IP_TryResolveFromWindow(hWnd) {
    ; Attempts WM_GETICON (SMALL2, SMALL, BIG), then class icons.
    WM_GETICON   := 0x7F
    ICON_SMALL2  := 2
    ICON_SMALL   := 0
    ICON_BIG     := 1
    GCLP_HICONSM := -34
    GCLP_HICON   := -14

    try {
        h := SendMessage(WM_GETICON, ICON_SMALL2, 0, , "ahk_id " hWnd)
        if (!h)
            h := SendMessage(WM_GETICON, ICON_SMALL, 0, , "ahk_id " hWnd)
        if (!h)
            h := SendMessage(WM_GETICON, ICON_BIG,   0, , "ahk_id " hWnd)
        if (!h)
            h := DllCall("user32\GetClassLongPtrW", "ptr", hWnd, "int", GCLP_HICONSM, "ptr")
        if (!h)
            h := DllCall("user32\GetClassLongPtrW", "ptr", hWnd, "int", GCLP_HICON,   "ptr")
        if (h) {
            return DllCall("user32\CopyIcon", "ptr", h, "ptr")  ; copy → store owns it
        }
    } catch {
    }
    return 0
}

_IP_GetProcessPath(pid) {
    ; PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
    hProc := DllCall("kernel32\OpenProcess", "uint", 0x1000, "int", 0, "uint", pid, "ptr")
    if (!hProc)
        return ""
    buf := Buffer(32767*2, 0), cch := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW", "ptr", hProc, "uint", 0, "ptr", buf.Ptr, "uint*", &cch, "int")
    DllCall("kernel32\CloseHandle", "ptr", hProc)
    return ok ? StrGet(buf.Ptr, "UTF-16") : ""
}

_IP_ExtractExeIcon(exePath) {
    ; Extract a single icon (prefer small), return HICON master (pump owns; cache owns after put).
    hSmall := 0, hLarge := 0
    try {
        got := DllCall("shell32\ExtractIconExW", "wstr", exePath, "int", 0, "ptr*", &hLarge, "ptr*", &hSmall, "uint", 1, "uint")
        if (hSmall) {
            if (hLarge) {
                try DllCall("user32\DestroyIcon", "ptr", hLarge)
            }
            return hSmall
        }
        if (hLarge) {
            return hLarge
        }
    } catch {
    }
    ; Try explorer.exe as last resort (usually present)
    try {
        win := A_WinDir . "\explorer.exe"
        got := DllCall("shell32\ExtractIconExW", "wstr", win, "int", 0, "ptr*", &hLarge, "ptr*", &hSmall, "uint", 1, "uint")
        if (hSmall) {
            if (hLarge) {
                try DllCall("user32\DestroyIcon", "ptr", hLarge)
            }
            return hSmall
        }
        if (hLarge) {
            return hLarge
        }
    } catch {
    }
    return 0
}

_IP_SetCooldown(hwnd, ms) {
    next := A_TickCount + (ms + 0)
    WindowStore_UpdateFields(hwnd, { iconCooldownUntilTick: next }, "icons")
}
--------------
Contents of komorebi.ahk
--------------
﻿; ================== komorebi.ahk ==================
; Single source for Komorebi helpers.
; Depends on: _Log(msg) and RunTry(cmdLine) from helpers.ahk
; Ensure helpers.ahk is #included before this file.

if !IsSet(DebugKomorebi)
    global DebugKomorebi := false

; --- Tiny state TTL cache (avoid re-spawning komorebic state repeatedly)
global KState_Text := ""
global KState_Stamp := 0
global KState_TTL := 180   ; ms

; --- LRU cache for hwnd -> (mIdx, wsIdx, wsName)
global KLRU_Map := Map()    ; hwnd -> {mIdx:Int, wsIdx:Int, wsName:Str}
global KLRU_Order := []     ; keeps recency order of hwnds
global KLRU_Cap := 256


; --- Internal logging wrapper (routes to _Log when DebugKomorebi = true)
_KLog(msg) {
    global DebugKomorebi
    if (DebugKomorebi)
        _Log("[komorebi] " . msg)
}

; --- Quote helper for command lines
_KQuote(s) {
    if !IsSet(s)
        return '""'
    if InStr(s, '"')
        return '"' . StrReplace(s, '"', '""') . '"'
    if InStr(s, ' ')
        return '"' . s . '"'
    return s
}

; --- Run a CLI and capture its stdout to a temp file, then read it back
_KRunCaptureToText(cmd, &outText) {
    tmp := A_Temp . "\komorebi_cap_" . A_TickCount . "_" . Random(1000,9999) . ".tmp"
    ; Run via cmd so we can use redirection
    full := 'cmd.exe /c ' . cmd . ' > ' . _KQuote(tmp) . ' 2>&1'
    code := RunTry(full)
    outText := ""
    try {
        if FileExist(tmp)
            outText := FileRead(tmp, "UTF-8")
    }
    try FileDelete(tmp)
    return code
}

_KLRU_Touch(hwnd) {
    global KLRU_Order
    ; remove any existing
    for i, h in KLRU_Order
        if (h = hwnd) {
            KLRU_Order.RemoveAt(i)
            break
        }
    KLRU_Order.InsertAt(1, hwnd)
}

_KLRU_Put(hwnd, mIdx, wsIdx, wsName) {
    global KLRU_Map, KLRU_Order, KLRU_Cap
    KLRU_Map[hwnd] := { mIdx: mIdx, wsIdx: wsIdx, wsName: wsName }
    _KLRU_Touch(hwnd)
    ; evict if needed
    while (KLRU_Order.Length > KLRU_Cap) {
        old := KLRU_Order.RemoveAt(KLRU_Order.Length)
        if (KLRU_Map.Has(old))
            KLRU_Map.Delete(old)
    }
}

_KLRU_Get(hwnd, &mIdx, &wsIdx, &wsName) {
    global KLRU_Map
    if !KLRU_Map.Has(hwnd) {
        mIdx := -1, wsIdx := -1, wsName := ""
        return false
    }
    v := KLRU_Map[hwnd]
    mIdx := v.mIdx, wsIdx := v.wsIdx, wsName := v.wsName
    _KLRU_Touch(hwnd)
    return true
}


Komorebi_IsAvailable() {
    global KomorebicExe
    return (IsSet(KomorebicExe) && KomorebicExe != "" && FileExist(KomorebicExe))
}

; --- For startup sanity checks
Komorebi_DebugPing() {
    global KomorebicExe
    _KLog("DebugPing: starting…")
    _KLog("DebugPing: KomorebicExe='" . KomorebicExe . "'")
    _KLog("IsAvailable=" . (Komorebi_IsAvailable() ? "true" : "false"))

    if Komorebi_IsAvailable() {
        exeQ := _KQuote(KomorebicExe)
        verTxt := ""
        code := _KRunCaptureToText(exeQ . " --version", &verTxt)
        _KLog("DebugPing: '--version' exit=" . code)
        if (StrLen(Trim(verTxt)) > 0)
            _KLog("DebugPing: version='" . Trim(verTxt) . "'")
    }
}

; --- Get the raw JSON state from komorebi
_Komorebi_GetStateText() {
    global KomorebicExe, KState_Text, KState_Stamp, KState_TTL
    if !Komorebi_IsAvailable()
        return ""

    ; TTL reuse
    now := A_TickCount
    if (KState_Text != "" && (now - KState_Stamp) < KState_TTL)
        return KState_Text

    exeQ := _KQuote(KomorebicExe)
    txt := ""
    code := _KRunCaptureToText(exeQ . " state", &txt)
    _KLog("GetState: exit=" . code . " bytes=" . StrLen(txt))

    if (code = 0 && StrLen(txt))
        KState_Text := txt, KState_Stamp := now
    else
        KState_Text := "", KState_Stamp := 0

    return txt
}


; --- Find the workspace *name* that contains a specific hwnd by scanning the JSON text.
;     Strategy: find the first occurrence of "hwnd": <hwnd>, then walk backward to the
;     nearest preceding "name": "<...>" that also has "containers" before the hwnd.
_Komorebi_FindWorkspaceNameByHwnd(stateText, hwnd) {
    if (stateText = "" || !hwnd)
        return ""

    m := 0
    pos := RegExMatch(stateText, '"hwnd"\s*:\s*' . hwnd . '\b', &m, 1)
    if (pos = 0) {
        _KLog("FindWorkspace: hwnd not found in state")
        return ""
    }

    back := SubStr(stateText, 1, pos)
    names := []
    searchPos := 1
    mm := 0
    while (p := RegExMatch(back, '"name"\s*:\s*"([^"]+)"', &mm, searchPos)) {
        names.Push({ pos: p, name: mm[1], len: StrLen(mm[0]) })
        searchPos := p + StrLen(mm[0])
    }
    if (names.Length = 0) {
        _KLog("FindWorkspace: no name entries before hwnd")
        return ""
    }

    i := names.Length
    loop {
        if (i <= 0)
            break
        cand := names[i]
        block := SubStr(stateText, cand.pos, pos - cand.pos)
        if InStr(block, '"containers"') {
            ws := cand.name
            _KLog("FindWorkspace: hwnd=" . hwnd . " => workspace='" . ws . "'")
            return ws
        }
        i -= 1
    }

    _KLog("FindWorkspace: could not resolve workspace name for hwnd=" . hwnd)
    return ""
}

; --- DWMWA_CLOAKED check
_Komorebi_IsCloaked(hwnd) {
    buf := Buffer(4, 0)
    ; DWMWA_CLOAKED = 14
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hwnd, "uint", 14, "ptr", buf.Ptr, "uint", 4, "int")
    if (hr != 0)
        return false
    return (NumGet(buf, 0, "UInt") != 0)
}

_Komorebi_WaitUncloak(hwnd, waitMs := 300) {
    deadline := A_TickCount + Abs(waitMs)
    loop {
        if !_Komorebi_IsCloaked(hwnd)
            return true
        if (A_TickCount >= deadline)
            break
        Sleep 12
    }
    return !_Komorebi_IsCloaked(hwnd)
}

; === NEW ===
; Robustly find (monitorIndex, workspaceIndex) for the workspace containing the given hwnd.
; Also returns the workspace name (wsName). Returns true on success, false otherwise.
_Komorebi_FindMonitorWorkspaceIndexByHwnd(stateText, hwnd, &mIdx, &wsIdx, &wsName) {
    mIdx := -1, wsIdx := -1, wsName := ""
    if (stateText = "" || !hwnd)
        return false

    ; Absolute position of the target hwnd in the full JSON
    mh := 0
    hx := RegExMatch(stateText, '"hwnd"\s*:\s*' . hwnd . '\b', &mh, 1)
    if (hx = 0) {
        _KLog("IdxFinder: hwnd not found in state")
        return false
    }

    ; Find each monitor's *workspaces* object by anchoring on:
    ;   "workspaces": { ... } , "last_focused_workspace"
    ; The capture group 1 is the *content* of the workspaces object.
    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"last_focused_workspace"'
    posMon := 1
    mm := 0
    curMon := 0
    wsContent := "", wsContentAbsStart := 0
    foundMon := false

    while (p := RegExMatch(stateText, patMon, &mm, posMon)) {
        ; mm.Pos(0) .. mm.Pos(0)+mm.Len(0)-1 is the entire "workspaces":{...},"last_focused_workspace"
        blockStart := mm.Pos(0)
        blockEnd   := mm.Pos(0) + mm.Len(0) - 1

        if (blockStart <= hx && hx <= blockEnd) {
            wsContent := mm[1]
            wsContentAbsStart := mm.Pos(1)  ; absolute start of the captured content
            mIdx := curMon
            foundMon := true
            break
        }

        posMon := mm.Pos(0) + mm.Len(0)
        curMon += 1
    }

    if !foundMon {
        _KLog("IdxFinder: containing workspaces block not found around hwnd")
        return false
    }

    ; Inside the selected monitor's workspaces content, find the last "name" *before* hx
    ; That "name" corresponds to the workspace owning the hwnd.
    patName := 's)"name"\s*:\s*"([^"]+)"'
    posN := 1
    mn := 0
    idx := 0
    lastIdx := -1
    lastName := ""
    lastAbs := 0

    while (q := RegExMatch(wsContent, patName, &mn, posN)) {
        absPos := wsContentAbsStart + q - 1
        if (absPos < hx) {
            lastIdx := idx
            lastName := mn[1]
            lastAbs := absPos
        } else {
            break
        }
        posN := mn.Pos(0) + mn.Len(0)
        idx += 1
    }

    if (lastIdx < 0) {
        _KLog("IdxFinder: no workspace name found before hwnd inside selected monitor")
        return false
    }

    wsIdx  := lastIdx
    wsName := lastName
    _KLog("IdxFinder: resolved mIdx=" . mIdx . " wsIdx=" . wsIdx . " wsName='" . wsName . "'")
    return true
}


; Run komorebic with args, hidden; return exit code
Kom_RunWait(args) {
    global KomorebicExe
    return RunWait('"' KomorebicExe '" ' . args, , "Hide")
}


; --- Main entry used by helpers.ActivateHwnd for OtherWorkspace
;     1) Read state
;     2) Resolve monitor/workspace index that contains hwnd (and log name)
;     3) komorebic focus-monitor <mIdx>, then focus-workspace <wsIdx>
;     4) Wait for uncloaked; return true/false
Komorebi_FocusHwnd(hwnd) {
    global KomorebicExe
    if !Komorebi_IsAvailable() {
        _KLog("Komorebi_FocusHwnd: komorebic.exe not found or path not set")
        return false
    }

    cloakedStart := _Komorebi_IsCloaked(hwnd)
    _KLog("Komorebi_FocusHwnd: hwnd=" . hwnd . " cloakedStart=" . (cloakedStart ? "true" : "false"))

    ; ---------- FAST PATH: subscription map ----------
    wsFast := ""
    if Komorebi_SubTryMap(hwnd, &wsFast) && (wsFast != "") {
        _KLog("Komorebi_FocusHwnd: submap -> " . wsFast)
        if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsFast)) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 180) {
                _KLog("Komorebi_FocusHwnd: success (submap)")
                return true
            }
        }
        _KLog("Komorebi_FocusHwnd: submap focus attempt fell through")
    }

    ; ---------- FAST PATH 2: LRU (no state parse) ----------
    mIdx := -1, wsIdx := -1, wsNameLRU := ""
    if _KLRU_Get(hwnd, &mIdx, &wsIdx, &wsNameLRU) {
        if (mIdx >= 0 && wsIdx >= 0) {
            if (Kom_RunWait('focus-monitor ' . mIdx) = 0 && Kom_RunWait('focus-workspace ' . wsIdx) = 0) {
                Kom_RunWait('focus-window --hwnd ' . hwnd)
                if _Komorebi_WaitUncloak(hwnd, 180) {
                    _KLog("Komorebi_FocusHwnd: success (lru idx)")
                    return true
                }
            }
        }
        if (wsNameLRU != "") {
            if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsNameLRU)) = 0) {
                Kom_RunWait('focus-window --hwnd ' . hwnd)
                if _Komorebi_WaitUncloak(hwnd, 180) {
                    _KLog("Komorebi_FocusHwnd: success (lru name)")
                    return true
                }
            }
        }
        _KLog("Komorebi_FocusHwnd: LRU fell through")
    }

    ; ---------- Normal path: read (TTL-cached) state once ----------
    stateTxt := _Komorebi_GetStateText()
    if (stateTxt = "") {
        _KLog("Komorebi_FocusHwnd: state text empty, abort")
        return false
    }

    wsNameLog := _Komorebi_FindWorkspaceNameByHwnd(stateTxt, hwnd)
    if (wsNameLog != "")
        _KLog("Komorebi_FocusHwnd: workspace='" . wsNameLog . "'")

    mIdx := -1, wsIdx := -1, wsName := ""
    if _Komorebi_FindMonitorWorkspaceIndexByHwnd(stateTxt, hwnd, &mIdx, &wsIdx, &wsName) {
        if (Kom_RunWait('focus-monitor ' . mIdx) = 0 && Kom_RunWait('focus-workspace ' . wsIdx) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 220) {
                _KLog("Komorebi_FocusHwnd: success (index path)")
                _KLRU_Put(hwnd, mIdx, wsIdx, (wsName != "" ? wsName : wsNameLog))
                return true
            } else {
                _KLog("Komorebi_FocusHwnd: cloaked after index path")
            }
        } else {
            _KLog("Komorebi_FocusHwnd: focus-monitor/workspace failed (index path)")
        }
    } else {
        _KLog("Komorebi_FocusHwnd: failed to resolve indexes; trying name fallback")
    }

    ; ----- Fallback: by name ----------
    if (wsNameLog != "") {
        if (Kom_RunWait('focus-named-workspace ' . _KQuote(wsNameLog)) = 0) {
            Kom_RunWait('focus-window --hwnd ' . hwnd)
            if _Komorebi_WaitUncloak(hwnd, 220) {
                _KLog("Komorebi_FocusHwnd: success (fallback)")
                _KLRU_Put(hwnd, -1, -1, wsNameLog)
                return true
            }
        } else {
            _KLog("Komorebi_FocusHwnd: focus-named-workspace failed (fallback)")
        }
    }

    return false
}

; --- Optional: force-refresh Komorebi state cache (used by callers when needed)
Komorebi_InvalidateStateCache() {
    global KState_Text, KState_Stamp
    KState_Text := ""
    KState_Stamp := 0
}


; Return { id: "", name: "<workspace name>" } or "" if unknown.
; Tolerant parser: prefers explicit name keys; falls back to monitor workspaces + last_focused_workspace index.
Komorebi_GetCurrentWorkspace() {
    txt := _Komorebi_GetStateText()
    if (txt = "")
        return ""

    ; 1) Easy win: look for an explicit focused workspace name anywhere
    m := 0
    if RegExMatch(txt, '"focused_workspace_name"\s*:\s*"([^"]+)"', &m) {
        return { id: "", name: m[1] }
    }
    if RegExMatch(txt, '"current_workspace_name"\s*:\s*"([^"]+)"', &m) {
        return { id: "", name: m[1] }
    }

    ; 2) Walk monitor blocks that expose: "workspaces": { ... }, "last_focused_workspace": <idx|name>
    ; Group 1 = workspaces content, group 2 = name if present, group 3 = index if present
    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"(?:last_focused_workspace_name|last_focused_workspace)"\s*:\s*(?:"([^"]+)"|(\d+))'
    pos := 1, mm := 0
    while (p := RegExMatch(txt, patMon, &mm, pos)) {
        wsContent := mm[1]
        if (mm[2] != "") {
            return { id: "", name: mm[2] }
        }
        if (mm[3] != "") {
            idx := Integer(mm[3])
            ; iterate names within this workspaces object
            patName := 's)"name"\s*:\s*"([^"]+)"'
            posN := 1, mn := 0, i := 0
            while (q := RegExMatch(wsContent, patName, &mn, posN)) {
                if (i = idx)
                    return { id: "", name: mn[1] }
                posN := mn.Pos(0) + mn.Len(0)
                i += 1
            }
        }
        pos := mm.Pos(0) + mm.Len(0)
    }

    ; 3) Last resort: any plausible top-level current/last name signal
    if RegExMatch(txt, '"last_focused_workspace_name"\s*:\s*"([^"]+)"', &m)
        return { id: "", name: m[1] }

    return ""
}




; Return UInt hwnd of focused window per komorebi state, or 0 if unavailable.
; Tries multiple tolerant patterns.
Komorebi_GetFocusedHwnd() {
    txt := _Komorebi_GetStateText()
    if (txt = "")
        return 0

    m := 0
    ; Common shapes we might see:
    if RegExMatch(txt, '"focused_window"\s*:\s*\{[^}]*"hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    if RegExMatch(txt, '"focused_hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    if RegExMatch(txt, '"last_focused_window"\s*:\s*\{[^}]*"hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])

    return 0
}

; Return [{ hwnd, wsName }, ...] using a single pass over state text.
; We scan each monitor's "workspaces" block; for each workspace's "name", we collect "hwnd" values until the next workspace.
Komorebi_MapAllWindows() {
    txt := _Komorebi_GetStateText()
    if (txt = "")
        return ""

    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"(?:last_focused_workspace|last_focused_workspace_name)"'
    pos := 1, mm := 0
    out := []
    seen := Map()

    while (p := RegExMatch(txt, patMon, &mm, pos)) {
        wsContent := mm[1]
        ; iterate workspace names with positions
        patName := 's)"name"\s*:\s*"([^"]+)"'
        posN := 1, mn := 0
        names := []  ; [{name, startRel, endRel}]
        while (q := RegExMatch(wsContent, patName, &mn, posN)) {
            names.Push({ name: mn[1], startRel: mn.Pos(0), endRel: mn.Pos(0) + mn.Len(0) - 1 })
            posN := mn.Pos(0) + mn.Len(0)
        }
        if (names.Length = 0) {
            pos := mm.Pos(0) + mm.Len(0)
            continue
        }
        totalLen := StrLen(wsContent)
        ; for each workspace segment, collect hwnds
        i := 1
        while (i <= names.Length) {
            segStart := names[i].startRel
            segEnd   := (i < names.Length) ? (names[i+1].startRel - 1) : totalLen
            segment  := SubStr(wsContent, segStart, segEnd - segStart + 1)
            ; collect hwnds within this workspace segment
            ph := 0, posH := 1, mh := 0
            while (r := RegExMatch(segment, '"hwnd"\s*:\s*(\d+)', &mh, posH)) {
                hw := Integer(mh[1])
                if (hw > 0 && !seen.Has(hw)) {
                    out.Push({ hwnd: hw, wsName: names[i].name })
                    seen[hw] := true
                }
                posH := mh.Pos(0) + mh.Len(0)
            }
            i += 1
        }
        pos := mm.Pos(0) + mm.Len(0)
    }

    return out
}


; Return [hwnd, ...] for the currently focused workspace, or "" if unknown.
; Uses current workspace name + same segmentation approach as MapAllWindows().
Komorebi_ListCurrentWorkspaceHwnds() {
    cur := Komorebi_GetCurrentWorkspace()
    if (!IsObject(cur) || cur.name = "")
        return ""

    txt := _Komorebi_GetStateText()
    if (txt = "")
        return ""

    patMon := 's)"workspaces"\s*:\s*\{(.*?)\}\s*,\s*"(?:last_focused_workspace|last_focused_workspace_name)"'
    pos := 1, mm := 0

    while (p := RegExMatch(txt, patMon, &mm, pos)) {
        wsContent := mm[1]
        ; enumerate workspace names w/ positions
        patName := 's)"name"\s*:\s*"([^"]+)"'
        posN := 1, mn := 0
        names := []
        while (q := RegExMatch(wsContent, patName, &mn, posN)) {
            names.Push({ name: mn[1], startRel: mn.Pos(0), endRel: mn.Pos(0) + mn.Len(0) - 1 })
            posN := mn.Pos(0) + mn.Len(0)
        }
        if (names.Length = 0) {
            pos := mm.Pos(0) + mm.Len(0)
            continue
        }
        totalLen := StrLen(wsContent)

        ; find the segment matching the current workspace name
        i := 1
        while (i <= names.Length) {
            if (names[i].name != cur.name) {
                i += 1
                continue
            }
            segStart := names[i].startRel
            segEnd   := (i < names.Length) ? (names[i+1].startRel - 1) : totalLen
            segment  := SubStr(wsContent, segStart, segEnd - segStart + 1)
            ; collect hwnds
            hwnds := []
            posH := 1, mh := 0
            while (r := RegExMatch(segment, '"hwnd"\s*:\s*(\d+)', &mh, posH)) {
                hw := Integer(mh[1])
                if (hw > 0)
                    hwnds.Push(hw)
                posH := mh.Pos(0) + mh.Len(0)
            }
            return hwnds
        }
        pos := mm.Pos(0) + mm.Len(0)
    }
    return ""
}

--------------
Contents of komorebi_pump.ahk
--------------
﻿#Requires AutoHotkey v2.0
; =============================================================================
; komorebi_pump.ahk — integrates Komorebi workspace/focus info into WindowStore
; Placeholder: calls are wrapped so you can later bind them to your real
; komorebi.ahk API (poll or event-driven). The pump shows how to feed the store.
; =============================================================================

; ---------- Tunables ----------------------------------------------------------
if !IsSet(KomoTimerIntervalMs)
    KomoTimerIntervalMs := 120

; ---------- Module state ------------------------------------------------------
global _KP_TimerOn       := false
global _KP_LastWSId      := ""
global _KP_LastWSName    := ""
global _KP_LastFocused   := 0

; ---------- Public API --------------------------------------------------------
KomorebiPump_Start() {
    global _KP_TimerOn, KomoTimerIntervalMs
    if (_KP_TimerOn)
        return
    _KP_TimerOn := true
    SetTimer(_KP_Tick, KomoTimerIntervalMs)
}

KomorebiPump_Stop() {
    global _KP_TimerOn
    if !_KP_TimerOn
        return
    _KP_TimerOn := false
    SetTimer(_KP_Tick, 0)
}

; ---------- Core (polling placeholder) ---------------------------------------
_KP_Tick() {
    ; 1) Current workspace (id + name)
    ws := _KP_TryGetCurrentWorkspace()  ; {id, name} or ""
    if (IsObject(ws)) {
        if (ws.id . "" != _KP_LastWSId . "" || ws.name . "" != _KP_LastWSName . "") {
            _KP_LastWSId   := ws.id . ""
            _KP_LastWSName := ws.name . ""
            WindowStore_SetCurrentWorkspace(_KP_LastWSId, _KP_LastWSName)
        }
    }

    ; 2) Focused hwnd (komorebi does NOT set isFocused; MRU owns that)
    f := _KP_TryGetFocusedHwnd()
    if (f && f != _KP_LastFocused) {
        _KP_LastFocused := f
        ; Ensure record exists so subsequent workspace hints land; no focus fields here.
        WindowStore_Ensure(f, 0, "komorebi")
    }

    ; 3) Per-window workspace mapping
    ;    Expected: [{ hwnd, wsId?, wsName? }, ...]
    map := _KP_TryMapAllWindows()
    if (IsObject(map)) {
        cur := WindowStore_GetCurrentWorkspace()
        for _, it in map {
            if (!IsObject(it) || !it.Has("hwnd"))
                continue
            hwnd := it.hwnd + 0

            hints := Map()
            if (it.Has("wsId"))
                hints["workspaceId"] := it.wsId . ""
            if (it.Has("wsName"))
                hints["workspaceName"] := it.wsName . ""

            ; Derive isOnCurrentWorkspace only if current + one of id/name are known
            if (hints.Has("workspaceId") && cur.id != "") {
                hints["isOnCurrentWorkspace"] := (hints["workspaceId"] = cur.id)
            } else if (hints.Has("workspaceName") && cur.name != "") {
                hints["isOnCurrentWorkspace"] := (hints["workspaceName"] = cur.name)
            }

            ; Always funnel via Ensure so unknown hwnds are minimally enumerated
            WindowStore_Ensure(hwnd, hints, "komorebi")
        }
    }
}


; ---------- Binding shims (replace with your real Komorebi calls) ------------
; You can switch these to call functions from your komorebi.ahk when ready.

_KP_TryGetCurrentWorkspace() {
    ; Expected return: { id: "2", name: "dev" } or ""
    ; Placeholder: attempt to call Komorebi_GetCurrentWorkspace() if it exists.
    try {
        if (IsSet(Komorebi_GetCurrentWorkspace) && (Komorebi_GetCurrentWorkspace is Func)) {
            return Komorebi_GetCurrentWorkspace.Call()
        }
    } catch {
    }
    return ""  ; unknown (no change)
}

_KP_TryGetFocusedHwnd() {
    ; Expected return: UInt hwnd or 0
    try {
        if (IsSet(Komorebi_GetFocusedHwnd) && (Komorebi_GetFocusedHwnd is Func)) {
            return Komorebi_GetFocusedHwnd.Call() + 0
        }
    } catch {
    }
    return 0
}

_KP_TryMapAllWindows() {
    ; Expected return: [{ hwnd, wsId?, wsName? }, ...]  or ""
    try {
        if (IsSet(Komorebi_MapAllWindows) && (Komorebi_MapAllWindows is Func)) {
            return Komorebi_MapAllWindows.Call()
        }
    } catch {
    }
    return ""
}
--------------
Contents of komorebi_sub.ahk
--------------
﻿; ================== komorebi_sub.ahk ==================
; Fast komorebi subscription bridge using a Named Pipe (no PowerShell, no files).
; - AHK hosts \\.\pipe\<name> (overlapped, non-blocking)
; - Launches one hidden: komorebic.exe subscribe-pipe <name>
; - Timer peeks & reads only when bytes are available (never blocks UI)
; - Maintains fast cache: hwnd -> workspace_name, plus last "state" JSON
; - Auto-reconnect & backoff

#Requires AutoHotkey v2.0

; -------- CONFIG --------
global KomorebicExe            := IsSet(KomorebicExe) ? KomorebicExe : "C:\Program Files\komorebi\bin\komorebic.exe"
global KSub_PollMs             := 50           ; timer cadence (lower = snappier)
global KSub_MaxBytesPerTick    := 65536        ; cap bytes processed per tick
global KSub_IdleRecycleMs      := 120000       ; recycle if no events this long (ms)
global KSub_MaxRestartBackoff  := 5000         ; ms

; -------- STATE --------
global KSub_PipeName := "tabby_" A_TickCount "_" Random(1000,9999)
global KSub_hPipe    := 0
global KSub_hEvent   := 0
global KSub_Over     := 0                       ; OVERLAPPED struct buffer
global KSub_Connected := false

global KSub_ClientPid := 0                      ; komorebic subscribe-pipe pid
global KSub_LastEvent := 0
global KSub_BackoffMs := 0
global KSub_LastStart := 0

global KSub_Buf := ""                           ; partial line buffer
global KSub_Map := Map()                        ; hwnd -> workspace_name
global KSub_StateText := ""                     ; last "state" JSON

; Track last workspace we observed (by name)
global KSub_LastWorkspaceName := ""
; Optional: control whether we kick a full winenum on workspace change
if !IsSet(KSub_RunRescanOnWSChange)
    KSub_RunRescanOnWSChange := true


; -------- Logging (safe if _Log missing) --------
KSub_Log(msg) {
    if (IsSet(DebugKomorebi) && DebugKomorebi) {
        try {
            _Log("[komorebi] " . msg)
        } catch as e {
            ; ignore logging errors
        }
    }
}

; -------- Public API --------
Komorebi_SubEnsure() {
    if (KSub_hPipe && KSub_Connected)
        return true
    return Komorebi_SubStart()
}

Komorebi_SubStart() {
    global KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    global KSub_ClientPid, KSub_LastEvent, KSub_BackoffMs, KSub_LastStart, KSub_PipeName

    Komorebi_SubStop()  ; clean slate

    ; Validate komorebic path
    if !(IsSet(KomorebicExe) && KomorebicExe != "" && FileExist(KomorebicExe)) {
        KSub_Log("SubStart: komorebic.exe not found; will retry")
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Backoff if crash-looping
    now := A_TickCount
    if (KSub_LastStart && now - KSub_LastStart < 3000) {
        KSub_BackoffMs := Min(KSub_MaxRestartBackoff, Max(500, KSub_BackoffMs * 2))
        Sleep KSub_BackoffMs
    } else {
        KSub_BackoffMs := 0
    }
    KSub_LastStart := A_TickCount

    ; Create overlapped Named Pipe server (message mode)
    PIPE_ACCESS_INBOUND   := 0x00000001
    FILE_FLAG_OVERLAPPED  := 0x40000000
    PIPE_TYPE_MESSAGE     := 0x00000004
    PIPE_READMODE_MESSAGE := 0x00000002
    PIPE_WAIT             := 0x00000000

    name := "\\.\pipe\" . KSub_PipeName
    KSub_hPipe := DllCall("CreateNamedPipeW"
        , "str", name
        , "uint", PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED
        , "uint", PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT
        , "uint", 1                 ; max instances
        , "uint", 65536             ; out buffer (unused for inbound)
        , "uint", 65536             ; in buffer
        , "uint", 0                 ; default timeout
        , "ptr", 0                  ; security attrs
        , "ptr")
    if (KSub_hPipe = 0 || KSub_hPipe = -1) {
        KSub_Log("SubStart: CreateNamedPipe failed")
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Create event for OVERLAPPED connect
    KSub_hEvent := DllCall("CreateEventW", "ptr", 0, "int", 1, "int", 0, "ptr", 0, "ptr")
    if (!KSub_hEvent) {
        KSub_Log("SubStart: CreateEvent failed")
        Komorebi_SubStop()
        SetTimer(Komorebi_SubPoll, KSub_PollMs)
        return false
    }

    ; Allocate OVERLAPPED and set hEvent (x64 offset 24, x86 offset 16)
    KSub_Over := Buffer(A_PtrSize=8 ? 32 : 20, 0)
    NumPut("ptr", KSub_hEvent, KSub_Over, (A_PtrSize=8) ? 24 : 16)

    ; Begin async connect
    ok := DllCall("ConnectNamedPipe", "ptr", KSub_hPipe, "ptr", KSub_Over.Ptr, "int")
    if (!ok) {
        gle := DllCall("GetLastError", "uint")
        if (gle = 997) { ; ERROR_IO_PENDING
            KSub_Connected := false
        } else if (gle = 535) { ; ERROR_PIPE_CONNECTED
            KSub_Connected := true
        } else {
            KSub_Log("SubStart: ConnectNamedPipe err=" . gle)
            Komorebi_SubStop()
            SetTimer(Komorebi_SubPoll, KSub_PollMs)
            return false
        }
    } else {
        KSub_Connected := true
    }

    ; Launch hidden komorebic subscriber (client)
    try {
        KSub_ClientPid := Run('"' KomorebicExe '" subscribe-pipe ' KSub_PipeName, , "Hide")
        KSub_Log("SubStart: spawned client pid=" . KSub_ClientPid . " pipe=" . KSub_PipeName)
    } catch as e {
        KSub_Log("SubStart: failed to start subscribe-pipe: " . e.Message)
        ; keep server alive; we may connect later
    }

    KSub_LastEvent := A_TickCount
    SetTimer(Komorebi_SubPoll, KSub_PollMs)
    return true
}

Komorebi_SubStop() {
    global KSub_ClientPid, KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    SetTimer(Komorebi_SubPoll, 0)

    if (KSub_ClientPid) {
        try {
            ProcessClose(KSub_ClientPid)
        } catch as e {
            ; ignore
        }
        KSub_ClientPid := 0
    }

    if (KSub_hPipe) {
        try {
            DllCall("DisconnectNamedPipe", "ptr", KSub_hPipe)
        } catch as e {
        }
        try {
            DllCall("CloseHandle", "ptr", KSub_hPipe)
        } catch as e {
        }
        KSub_hPipe := 0
    }
    if (KSub_hEvent) {
        try {
            DllCall("CloseHandle", "ptr", KSub_hEvent)
        } catch as e {
        }
        KSub_hEvent := 0
    }
    KSub_Over := 0
    KSub_Connected := false
    KSub_Log("SubStop: done")
}

; ---- Fast map lookup used by your Komorebi_FocusHwnd fast path ----
Komorebi_SubTryMap(hwnd, &ws) {
    global KSub_Map, KSub_StateText
    if (KSub_Map.Has(hwnd)) {
        ws := KSub_Map[hwnd]
        return (ws != "")
    }
    if (KSub_StateText != "") {
        try {
            w := _Komorebi_FindWorkspaceNameByHwnd(KSub_StateText, hwnd)
            if (w != "") {
                KSub_Map[hwnd] := w
                ws := w
                return true
            }
        } catch as e {
            ; ignore
        }
    }
    ws := ""
    return false
}

; -------- Timer: connect progress, read available bytes (non-blocking) --------
Komorebi_SubPoll() {
    global KSub_hPipe, KSub_hEvent, KSub_Over, KSub_Connected
    global KSub_ClientPid, KSub_LastEvent, KSub_IdleRecycleMs, KSub_MaxBytesPerTick

    if (!KSub_hPipe) {
        Komorebi_SubStart()
        return
    }

    ; If not connected yet, check the event
    if (!KSub_Connected) {
        res := DllCall("kernel32\WaitForSingleObject", "ptr", KSub_hEvent, "uint", 0, "uint")
        if (res = 0) { ; WAIT_OBJECT_0
            KSub_Connected := true
            KSub_Log("SubPoll: pipe connected")
        }
        return
    }

    ; Read loop (bounded by bytes per tick)
    bytesProcessed := 0
    loop {
        avail := 0, bytesLeft := 0
        ok := DllCall("PeekNamedPipe"
            , "ptr", KSub_hPipe
            , "ptr", 0, "uint", 0
            , "uint*", 0
            , "uint*", &avail
            , "uint*", &bytesLeft
            , "int")
        if (!ok) {
            gle := DllCall("GetLastError", "uint")
            if (gle = 109) { ; ERROR_BROKEN_PIPE
                KSub_Log("SubPoll: client disconnected (broken pipe) -> restarting")
                Komorebi_SubStart()
                return
            }
            return
        }

        if (avail = 0)
            break

        toRead := Min(avail, KSub_MaxBytesPerTick - bytesProcessed)
        if (toRead <= 0)
            break

        buf := Buffer(toRead)
        read := 0
        ok2 := DllCall("ReadFile"
            , "ptr", KSub_hPipe
            , "ptr", buf.Ptr
            , "uint", toRead
            , "uint*", &read
            , "ptr", 0
            , "int")
        if (!ok2) {
            gle := DllCall("GetLastError", "uint")
            if (gle = 109) {
                KSub_Log("SubPoll: client disconnected during read -> restarting")
                Komorebi_SubStart()
                return
            }
            return
        }

        if (read > 0) {
            chunk := StrGet(buf.Ptr, read, "UTF-8")
            KSub_LastEvent := A_TickCount
            KSub_ProcessChunk(chunk)
            bytesProcessed += read
            if (bytesProcessed >= KSub_MaxBytesPerTick)
                break
        } else {
            break
        }
    }

    ; Recycle if idle for a long time (handles komorebi restarts)
    idle := A_TickCount - KSub_LastEvent
    if (idle > KSub_IdleRecycleMs) {
        KSub_Log("SubPoll: idle " . idle . "ms -> recycling subscriber")
        Komorebi_SubStart()
    }
}

KSub_ProcessChunk(chunk) {
    global KSub_Buf
    KSub_Buf .= chunk
    while true {
        pos := InStr(KSub_Buf, "n")
        if (!pos)
            break
        line := RTrim(SubStr(KSub_Buf, 1, pos - 1), "r")
        KSub_Buf := SubStr(KSub_Buf, pos + 1)
        if (line != "")
            Komorebi_SubOnLine(line)
    }
}

; -------- Parse each JSON line --------
; -------- Parse each JSON line --------
Komorebi_SubOnLine(line) {
    global KSub_Map, KSub_StateText

    hwnd := 0, ws := ""

    m := 0
    if RegExMatch(line, '"hwnd"\s*:\s*(\d+)', &m)
        hwnd := Integer(m[1])

    n := 0
    if RegExMatch(line, '"workspace_name"\s*:\s*"([^"]+)"', &n)
        ws := n[1]
    else if RegExMatch(line, '"workspace"\s*:\s*"([^"]+)"', &n)
        ws := n[1]
    else if InStr(line, '"workspace"') && RegExMatch(line, '"name"\s*:\s*"([^"]+)"', &n)
        ws := n[1]

    ; Fast path: line explicitly carried hwnd + workspace
    if (hwnd && ws != "") {
        ; Route through our central handler (updates store + optional rescan)
        KSub_OnWorkspaceObservation(hwnd, ws)
        return
    }

    ; Full state update present on this line?
    if InStr(line, '"state"') {
        st := _KSub_ExtractStateJson(line)
        if (st != "" && st != "{}") {
            KSub_StateText := st
            ; If we also know a hwnd on this event, derive workspace from state
            if (hwnd) {
                try {
                    w := _Komorebi_FindWorkspaceNameByHwnd(st, hwnd) ; from komorebi.ahk
                    if (w != "") {
                        ; Use the same central handler so we set current WS, ensure(), and rescan if changed
                        KSub_OnWorkspaceObservation(hwnd, w)
                        return
                    }
                } catch {
                    ; ignore
                }
            }
        }
    }

    ; Otherwise nothing actionable on this line
}


; Extract the JSON object that follows the "state": key on this line
_KSub_ExtractStateJson(line) {
    posState := InStr(line, '"state"')
    if (!posState)
        return ""
    posColon := InStr(line, ":", false, posState)
    if (!posColon)
        return ""
    i := posColon + 1
    while (i <= StrLen(line) && SubStr(line, i, 1) ~= "\s")
        i += 1
    if (i > StrLen(line) || SubStr(line, i, 1) != "{")
        return ""
    depth := 0, start := i, j := i
    while (j <= StrLen(line)) {
        ch := SubStr(line, j, 1)
        if (ch = "{") {
            depth += 1
        } else if (ch = "}") {
            depth -= 1
            if (depth = 0)
                return SubStr(line, start, j - start + 1)
        } else if (ch = '"') {
            j += 1
            while (j <= StrLen(line)) {
                c := SubStr(line, j, 1)
                if (c = '"' && SubStr(line, j-1, 1) != "\")
                    break
                j += 1
            }
        }
        j += 1
    }
    return ""
}

; Handle an observation that a specific hwnd belongs to a workspaceName.
; - Updates fast map
; - If the workspace changed vs. last seen → set current WS, Ensure(hwnd, hints), and run a full rescan
; - If the workspace is unchanged → just Ensure(hwnd, hints)
KSub_OnWorkspaceObservation(hwnd, workspaceName) {
    global KSub_Map, KSub_LastWorkspaceName, KSub_RunRescanOnWSChange

    hwnd := hwnd + 0
    ws   := workspaceName . ""

    if (hwnd <= 0 || ws = "")
        return

    ; Keep local fast map fresh
    KSub_Map[hwnd] := ws

    ; Same workspace as last observation? Just ensure the row with hints.
    if (KSub_LastWorkspaceName != "" && KSub_LastWorkspaceName = ws) {
        try WindowStore_Ensure(hwnd, { workspaceName: ws, isOnCurrentWorkspace: true }, "komorebi")
        catch
            ; ignore
        return
    }

    ; Workspace changed → update “current workspace”, ensure hwnd, and optionally rescan
    KSub_LastWorkspaceName := ws

    ; 1) Tell the store the new current workspace
    try WindowStore_SetCurrentWorkspace("", ws)
    catch
        ; ignore

    ; 2) Ensure the hwnd exists and annotate it
    try WindowStore_Ensure(hwnd, { workspaceName: ws, isOnCurrentWorkspace: true }, "komorebi")
    catch
        ; ignore

    ; 3) Kick a fresh full enumeration so presence/z-order/state are synced
    if (KSub_RunRescanOnWSChange) {
        try WinList_EnumerateAll()
        catch
            ; ignore
    }
}


; Convenience wrapper if you ever want to trigger a rescan from elsewhere.
KSub_TriggerFullRescan() {
    try WinList_EnumerateAll()
    catch
        ; ignore
}


--------------
Contents of list.ahk
--------------
﻿#Requires AutoHotkey v2.0
;===============================================================================
; list.ahk  —  WindowStore (single source of truth)
; ------------------------------------------------------------------------------
; Purpose:
;   Centralized, in-memory store for window metadata. Everyone (winenum, MRU,
;   Komorebi, icon pump, AltLogic, GUI) reads/writes here instead of syncing
;   disparate structures. AltLogic owns session selection and just asks the
;   store for ordered projections.
;
; Design highlights:
;   - Batching: BeginBatch/EndBatch coalesce rev bumps (rev increments once per
;     meaningful change set). GetRev() exposes current global revision.
;   - Scans: BeginScan/EndScan provide the “seen this pass” bookkeeping.
;     EndScan hides missing windows immediately (present/presentNow=false) and
;     hard-removes after a grace period (MissingTTLms). Icons are destroyed on
;     hard removal; PID refcounts maintained.
;   - Upsert/Update/Ensure:
;       * UpsertWindow(records, source?) merges idempotently.
;       * UpdateFields(hwnd, patch, source?) applies partial updates.
;       * Ensure(hwnd, hints?, source?) guarantees a row exists. If unknown, it
;         calls the injected ByHwnd fetcher (set via SetFetchers), then merges
;         hints.
;   - Ownership (optional): you can enforce which module may write which fields.
;       * WindowStore_SetOwnershipPolicy(mode, allowed?) controls enforcement:
;           - "off"  : accept anything (today’s behavior).
;           - "warn" : accept everything but log when a non-owner writes a field.
;           - "strict": drop non-owned fields (with a warning).
;         Default policy (if you don’t set one): "off".
;   - Projections: GetProjection builds a filtered + sorted view (MRU/Z/etc).
;     It can return just hwnds (fast) or GUI-ready “items”.
;   - Meta: Set/GetCurrentWorkspace track the current workspace for projections.
;
; Threading:
;   AHK is single-threaded; store ops are lightweight. GUI should render from
;   cached projection and re-pull only when rev changes.
;
; Public API:
;   WindowStore_Init(config?)
;   WindowStore_BeginBatch()
;   WindowStore_EndBatch() -> {rev, changed}
;   WindowStore_BeginScan() -> scanId
;   WindowStore_EndScan(graceMs?) -> {hiddenNow, tombstoned, removed, rev}
;   WindowStore_SetFetchers({ByHwnd: Func})
;   WindowStore_SetOwnershipPolicy(mode := "off", allowedMap?)
;   WindowStore_Ensure(hwnd, hints := 0, source := "")
;   WindowStore_UpsertWindow(records, source := "") -> {added, updated, rev}
;   WindowStore_UpdateFields(hwnd, patch, source := "") -> {changed, rev}
;   WindowStore_RemoveWindow(hwnds) -> {removed, rev}
;   WindowStore_Has(hwnd) -> bool
;   WindowStore_GetByHwnd(hwnd) -> record?
;   WindowStore_GetProjection(opts?) -> {rev, hwnds, items?, meta}
;   WindowStore_GetIndexOf(hwnd, opts?) -> index? (1-based)
;   WindowStore_SetCurrentWorkspace(id, name?)
;   WindowStore_GetCurrentWorkspace() -> {id, name}
;
; GetProjection opts (defaults shown):
;   {
;     filter: {
;       presentOnly: true,
;       currentWorkspaceOnly: false,
;       blacklistMode: "exclude",   ; "exclude" | "include" | "only"
;       classes: [],                ; whitelist if provided
;       pids: []                    ; whitelist if provided
;     },
;     sort: "MRU",                  ; "MRU" | "Z" | "Title" | "Pid" | "ProcessName"
;     columns: "hwndsOnly"          ; "hwndsOnly" | "items"
;   }
;
; Record schema (per HWND): see _WS_NewRecord().
;===============================================================================

;============================== GLOBAL STATE ===================================

global gWS_Store            := Map()     ; hwnd (UInt) -> record (Object)
global gWS_Rev              := 0         ; global store revision (monotonic)
global gWS_Batching         := false     ; inside BeginBatch/EndBatch
global gWS_PendingRevBump   := false     ; accumulate rev bump during batch
global gWS_CurrentSweepId   := 0         ; 0 = no active sweep
global gWS_Config           := Map()     ; runtime config (MissingTTLms, etc.)

; --- Ownership enforcement (optional) ---
global gWS_OwnershipMode := "off"     ; "off" | "warn" | "strict"
; Map: source -> Map(set of allowed fields)
; e.g. gWS_AllowedFields["winenum"]["pid"] := true
global gWS_AllowedFields := Map()


; sensible defaults
gWS_Config["MissingTTLms"]        := 1200
gWS_Config["DefaultSort"]         := "MRU"
gWS_Config["NormalizeTitleMax"]   := 260    ; clamp super long titles
gWS_Config["TitleCollapseSpaces"] := true

global gWS_ScanId           := 0               ; monotonic scan token
global gWS_Meta             := Map()           ; meta store (current WS, etc.)
gWS_Meta["currentWSId"]     := ""
gWS_Meta["currentWSName"]   := ""

; De-duped work queues (used by pumps outside the store)
global gWS_Q_Pid            := Map()           ; pid -> true (needs process name)
global gWS_Q_Icon           := Map()           ; hwnd -> true (needs icon)
global gWS_Q_WS             := Map()           ; hwnd -> true (needs workspace)

; PID->processName cache + refcounts (drop name when last ref is gone)
global gWS_ProcCache        := Map()           ; pid -> processName
global gWS_ProcRef          := Map()           ; pid -> refcount

; Optional EXE->HICON cache (we keep one master HICON per exe; callers CopyIcon)
global gWS_ExeIconCache     := Map()           ; exePath -> hicon

; Injected fetchers (set by winenum): { ByHwnd: Func }
global gWS_Fetch_ByHwnd     := 0               ; function object or 0

;=============================== PUBLIC API ====================================

WindowStore_Init(config := 0) {
    global gWS_Config, gWS_OwnershipMode, gWS_AllowedFields
    if IsObject(config) {
        for k, v in config
            gWS_Config[k] := v
        ; Optional ownership wiring via config:
        if (config.Has("OwnershipMode")) {
            m := StrLower(config["OwnershipMode"] . "")
            if (m != "off" && m != "warn" && m != "strict")
                m := "off"
            gWS_OwnershipMode := m
        }
        if (config.Has("OwnershipAllowed") && IsObject(config["OwnershipAllowed"])) {
            WindowStore_SetOwnershipPolicy(gWS_OwnershipMode, config["OwnershipAllowed"])
        }
    }
}

WindowStore_BeginBatch() {
    global gWS_Batching, gWS_PendingRevBump
    gWS_Batching := true
    gWS_PendingRevBump := false
}

WindowStore_EndBatch() {
    global gWS_Batching, gWS_PendingRevBump, gWS_Rev
    changed := false
    if (gWS_PendingRevBump) {
        gWS_Rev += 1
        changed := true
    }
    gWS_Batching := false
    gWS_PendingRevBump := false
    return { rev: gWS_Rev, changed: changed }
}

WindowStore_Has(hwnd) {
    global gWS_Store
    return gWS_Store.Has(hwnd + 0)
}

WindowStore_SetFetchers(fns) {
    ; fns example: { ByHwnd: Func("WinList_EnumerateByHwnd") }
    global gWS_Fetch_ByHwnd
    gWS_Fetch_ByHwnd := 0
    if (IsObject(fns) && fns.Has("ByHwnd") && (fns.ByHwnd is Func))
        gWS_Fetch_ByHwnd := fns.ByHwnd
}

WindowStore_Ensure(hwnd, hints := 0, source := "") {
    global gWS_Store, gWS_Fetch_ByHwnd
    hwnd := hwnd + 0
    if (gWS_Store.Has(hwnd)) {
        if (IsObject(hints)) {
            patch := _WS_FilterPatchByOwnership(hints, source)
            WindowStore_UpdateFields(hwnd, patch, source)
        }
        return { record: gWS_Store[hwnd], existed: true }
    }
    ; Try injected fetcher
    if (gWS_Fetch_ByHwnd) {
        fetched := ""
        try fetched := gWS_Fetch_ByHwnd.Call([hwnd], IsObject(hints) ? hints : Map())
        catch {}
        ; fetcher should Upsert into the store; if not, we'll create skeleton below
    }
    if (!gWS_Store.Has(hwnd)) {
        WindowStore_UpsertWindow([{ hwnd: hwnd }], "internal")
    }
    if (IsObject(hints)) {
        patch2 := _WS_FilterPatchByOwnership(hints, source)
        WindowStore_UpdateFields(hwnd, patch2, source)
    }
    return { record: gWS_Store[hwnd], existed: false }
}


WindowStore_BeginScan() {
    global gWS_ScanId
    if (gWS_ScanId = 0x7FFFFFFF)
        gWS_ScanId := 0
    gWS_ScanId += 1
    return gWS_ScanId
}

WindowStore_EndScan(graceMs := "") {
    global gWS_Store, gWS_ScanId, gWS_Config
    now := _WS_Now()
    ttl := (graceMs != "" ? graceMs + 0 : (gWS_Config.Has("MissingTTLms") ? gWS_Config["MissingTTLms"] + 0 : 1200))

    hiddenNow := 0
    tombstoned := 0
    removed := 0
    changed := false

    ; pass 1: hide rows not seen this scan (presentNow=false), start tombstone
    for hwnd, rec in gWS_Store {
        if (rec.lastSeenScanId != gWS_ScanId) {
            if (rec.presentNow) {
                rec.presentNow := false
                rec.present := false
                changed := true
                hiddenNow += 1
            }
            if (rec.missingSinceTick = 0) {
                rec.missingSinceTick := now
                tombstoned += 1
                changed := true
            }
        } else {
            ; seen → ensure visible and clear tombstone marker
            if (!rec.presentNow || !rec.present) {
                rec.presentNow := true
                rec.present := true
                changed := true
            }
            if (rec.missingSinceTick) {
                rec.missingSinceTick := 0
                changed := true
            }
        }
    }

    ; pass 2: hard-remove beyond TTL
    doomed := []
    for hwnd, rec in gWS_Store {
        if (rec.missingSinceTick && (now - rec.missingSinceTick >= ttl))
            doomed.Push(hwnd)
    }
    if (doomed.Length) {
        tmp := WindowStore_RemoveWindow(doomed)
        removed += tmp.removed
        changed := changed || (tmp.removed > 0)
    }

    if (changed)
        _WS_RequestRevBump()

    ; clear current scan token
    gWS_ScanId := 0

    return { hiddenNow: hiddenNow, tombstoned: tombstoned, removed: removed, rev: WindowStore_GetRev() }
}

WindowStore_PopPidBatch(n := 32) {
    global gWS_Q_Pid
    out := []
    for pid, _ in gWS_Q_Pid {
        out.Push(pid + 0)
        gWS_Q_Pid.Delete(pid)
        if (out.Length >= n)
            break
    }
    return out
}

WindowStore_PopIconBatch(n := 32) {
    global gWS_Q_Icon, gWS_Store
    out := []
    for hwnd, _ in gWS_Q_Icon {
        hwnd := hwnd + 0
        out.Push(hwnd)
        gWS_Q_Icon.Delete(hwnd)
        if (gWS_Store.Has(hwnd)) {
            rec := gWS_Store[hwnd]
            ; Mark in-flight so a later tickle can re-enqueue (false→true transition).
            rec.needsIcon := false
        }
        if (out.Length >= n)
            break
    }
    return out
}


WindowStore_PopWSBatch(n := 32) {
    global gWS_Q_WS
    out := []
    for hwnd, _ in gWS_Q_WS {
        out.Push(hwnd + 0)
        gWS_Q_WS.Delete(hwnd)
        if (out.Length >= n)
            break
    }
    return out
}

WindowStore_SetCurrentWorkspace(id, name := "") {
    global gWS_Meta, gWS_Store
    prevId  := gWS_Meta["currentWSId"]
    prevNam := gWS_Meta["currentWSName"]

    gWS_Meta["currentWSId"]   := id . ""
    gWS_Meta["currentWSName"] := name . ""

    ; If rows already know their workspace, recompute isOnCurrentWorkspace
    changed := false
    for hwnd, rec in gWS_Store {
        known := (rec.workspaceId != "" || rec.workspaceName != "")
        wasOn := rec.isOnCurrentWorkspace
        nowOn := wasOn
        if (known) {
            if (rec.workspaceId != "")
                nowOn := (rec.workspaceId = gWS_Meta["currentWSId"])
            else
                nowOn := (rec.workspaceName = gWS_Meta["currentWSName"])
        } else {
            ; Unknown workspace → mark needsWS and enqueue
            rec.needsWS := true
            _WS_QueueWS(rec.hwnd)
        }
        if (nowOn != wasOn) {
            rec.isOnCurrentWorkspace := nowOn
            changed := true
        }
    }
    if (changed || id . "" != prevId . "" || name . "" != prevNam . "")
        _WS_RequestRevBump()
    return { id: gWS_Meta["currentWSId"], name: gWS_Meta["currentWSName"], rev: WindowStore_GetRev() }
}

WindowStore_GetCurrentWorkspace() {
    global gWS_Meta
    return { id: gWS_Meta["currentWSId"], name: gWS_Meta["currentWSName"] }
}

WindowStore_GetProcNameCached(pid) {
    global gWS_ProcCache
    return (pid > 0 && gWS_ProcCache.Has(pid)) ? (gWS_ProcCache[pid] . "") : ""
}

WindowStore_UpdateProcessName(pid, name) {
    ; Called by your proc-name pump once it resolves a name.
    global gWS_ProcCache, gWS_Store
    pid := pid + 0
    if (pid <= 0)
        return { updated: 0, rev: WindowStore_GetRev() }

    gWS_ProcCache[pid] := name . ""
    ; Fan-out to rows lacking a name
    updated := 0
    for hwnd, rec in gWS_Store {
        if (rec.pid = pid && rec.processName = "") {
            rec.processName := gWS_ProcCache[pid]
            updated += 1
            ; updating text should bump rev once; safe to set per-row then bump at end
        }
    }
    if (updated > 0)
        _WS_RequestRevBump()
    return { updated: updated, rev: WindowStore_GetRev() }
}

WindowStore_ExeIconCachePut(exePath, hIcon) {
    ; Store/replace the master icon for an exe. We own the previous and will destroy it.
    global gWS_ExeIconCache
    key := exePath . ""
    if (key = "")
        return
    if (gWS_ExeIconCache.Has(key)) {
        old := gWS_ExeIconCache[key]
        if (old)
            try DllCall("user32\DestroyIcon", "ptr", old)
    }
    gWS_ExeIconCache[key] := hIcon + 0
}

WindowStore_GetExeIconCopy(exePath) {
    ; Returns a CopyIcon() of the master (caller owns/destroys). 0 if none.
    global gWS_ExeIconCache
    key := exePath . ""
    if (key = "" || !gWS_ExeIconCache.Has(key))
        return 0
    master := gWS_ExeIconCache[key]
    if (!master)
        return 0
    return DllCall("user32\CopyIcon", "ptr", master, "ptr")
}

WindowStore_ClearExeIconCache() {
    global gWS_ExeIconCache
    for k, h in gWS_ExeIconCache {
        if (h)
            try DllCall("user32\DestroyIcon", "ptr", h)
    }
    gWS_ExeIconCache := Map()
}


WindowStore_UpsertWindow(records, source := "") {
    global gWS_Store, gWS_ScanId
    if !IsObject(records)
        records := [records]

    now := _WS_Now()
    added := 0, updated := 0
    changed := false

    for _, rawPatch in records {
        if (!IsObject(rawPatch) || !rawPatch.Has("hwnd"))
            continue
        hwnd := rawPatch.hwnd + 0

        ; Apply ownership filter before merge
        patch := _WS_FilterPatchByOwnership(rawPatch, source)

        rec := gWS_Store.Has(hwnd) ? gWS_Store[hwnd] : 0
        if (!rec) {
            rec := _WS_NewRecord(hwnd)
            gWS_Store[hwnd] := rec
            added += 1
            changed := true
        }

        oldPid := rec.pid
        if (_WS_MergeInto(rec, patch)) {
            updated += 1
            changed := true
        }

        ; pid refcount maintenance (after merge)
        if (rec.pid != oldPid)
            _WS_AdjustPidRefs(oldPid, rec.pid)

        ; mark seen in current scan (if any)
        if (gWS_ScanId > 0) {
            rec.lastSeenScanId := gWS_ScanId
        }
        rec.lastSeenTick := now
        rec.present      := true
        rec.presentNow   := true
        rec.missingSinceTick := 0

        ; recompute needs + enqueue if newly needed
        _WS_RefreshNeeds(rec)
    }

    if (changed)
        _WS_RequestRevBump()

    return { added: added, updated: updated, rev: WindowStore_GetRev() }
}



WindowStore_UpdateFields(hwnd, patch, source := "") {
    global gWS_Store
    if (!gWS_Store.Has(hwnd))
        return { changed: false, rev: WindowStore_GetRev() }

    ; Apply ownership filter
    filtered := _WS_FilterPatchByOwnership(patch, source)

    rec := gWS_Store[hwnd]
    oldPid := rec.pid
    changed := _WS_MergeInto(rec, filtered)

    if (rec.pid != oldPid)
        _WS_AdjustPidRefs(oldPid, rec.pid)

    _WS_RefreshNeeds(rec)

    if (changed)
        _WS_RequestRevBump()
    return { changed: changed, rev: WindowStore_GetRev() }
}



WindowStore_RemoveWindow(hwnds) {
    global gWS_Store, gWS_Q_Icon, gWS_Q_WS
    if !IsObject(hwnds)
        hwnds := [hwnds]

    removed := 0
    for _, h in hwnds {
        hwnd := h + 0
        if (!gWS_Store.Has(hwnd))
            continue
        rec := gWS_Store[hwnd]

        ; pid refcount + optional cache drop
        _WS_AdjustPidRefs(rec.pid, 0)

        ; cleanup icon
        if (rec.iconHicon) {
            try DllCall("user32\DestroyIcon", "ptr", rec.iconHicon)
        }

        ; remove from queues if present
        if (gWS_Q_Icon.Has(hwnd))
            gWS_Q_Icon.Delete(hwnd)
        if (gWS_Q_WS.Has(hwnd))
            gWS_Q_WS.Delete(hwnd)

        gWS_Store.Delete(hwnd)
        removed += 1
    }
    if (removed > 0)
        _WS_RequestRevBump()
    return { removed: removed, rev: WindowStore_GetRev() }
}


WindowStore_GetRev() {
    global gWS_Rev
    return gWS_Rev
}

WindowStore_GetByHwnd(hwnd) {
    global gWS_Store
    return gWS_Store.Has(hwnd) ? gWS_Store[hwnd] : 0
}

WindowStore_GetProjection(opts := 0) {
    ; Returns {rev, hwnds, items?, meta}
    global gWS_Config
    if (!IsObject(opts))
        opts := Map()

    filter := _WS_DefaultFilter()
    if (opts.Has("filter") && IsObject(opts.filter))
        filter := _WS_MergeFilter(filter, opts.filter)

    sortKey := opts.Has("sort") ? _WS_ValidateSort(opts.sort) : (gWS_Config["DefaultSort"] . "")
    cols    := opts.Has("columns") ? _WS_ValidateColumns(opts.columns) : "hwndsOnly"

    ; Build filtered list of records (presentOnly by default, etc).
    recs := _WS_FilterRecords(filter)

    ; Sort in-place per sortKey.
    _WS_SortRecords(recs, sortKey)

    ; Build outputs.
    hwnds := []
    for _, r in recs
        hwnds.Push(r.hwnd)

    out := { rev: WindowStore_GetRev(), hwnds: hwnds, meta: {
        count: _WS_TotalCount(), filteredCount: hwnds.Length, sortKey: sortKey
    }}

    if (cols = "items") {
        items := []
        total := recs.Length
        i := 1
        while (i <= total) {
            items.Push(_WS_ToGuiItem(recs[i], i, total))
            i += 1
        }
        out.items := items
    }
    return out
}

WindowStore_GetIndexOf(hwnd, opts := 0) {
    ; 1-based index of hwnd in the projection defined by opts; 0 if not present.
    proj := WindowStore_GetProjection(opts)
    i := 1
    while (i <= proj.hwnds.Length) {
        if (proj.hwnds[i] = hwnd)
            return i
        i += 1
    }
    return 0
}

;============================= INTERNAL HELPERS ================================

_WS_QueuePid(pid) {
    global gWS_Q_Pid
    if (pid > 0 && !gWS_Q_Pid.Has(pid))
        gWS_Q_Pid[pid] := true
}

_WS_QueueIcon(hwnd) {
    global gWS_Q_Icon
    if (hwnd > 0 && !gWS_Q_Icon.Has(hwnd))
        gWS_Q_Icon[hwnd] := true
}

_WS_QueueWS(hwnd) {
    global gWS_Q_WS
    if (hwnd > 0 && !gWS_Q_WS.Has(hwnd))
        gWS_Q_WS[hwnd] := true
}

_WS_RefreshNeeds(rec) {
    now := _WS_Now()

    ; --- Process name need ---
    needProc := (rec.pid > 0 && rec.processName = "")
    if (needProc && !rec.needsProcName)
        _WS_QueuePid(rec.pid)
    rec.needsProcName := needProc

    ; --- Workspace need ---
    needWS := (rec.workspaceId = "" && rec.workspaceName = "")
    if (needWS && !rec.needsWS)
        _WS_QueueWS(rec.hwnd)
    rec.needsWS := needWS

    ; --- Icon need (with cooldown + in-flight semantics) ---
    if (rec.iconHicon = 0) {
        canEnqueue := (rec.iconCooldownUntilTick = 0 || now >= rec.iconCooldownUntilTick)
        if (!rec.needsIcon && canEnqueue) {
            _WS_QueueIcon(rec.hwnd)  ; will be marked in-flight on pop
            rec.needsIcon := true
        } else {
            ; Either still cooling down or already in-flight; keep false so a future
            ; tickle after cooldown can re-enqueue.
            if (!canEnqueue)
                rec.needsIcon := false
        }
    } else {
        rec.needsIcon := false
    }
}

WindowStore_RequestIcon(hwnd) {
    global gWS_Store
    hwnd := hwnd + 0
    if (!gWS_Store.Has(hwnd))
        return false
    rec := gWS_Store[hwnd]
    rec.iconCooldownUntilTick := 0
    if (!rec.needsIcon) {
        _WS_QueueIcon(hwnd)
        rec.needsIcon := true
    }
    return true
}


_WS_AdjustPidRefs(oldPid, newPid) {
    global gWS_ProcRef, gWS_ProcCache
    if (oldPid = newPid)
        return
    if (oldPid > 0 && gWS_ProcRef.Has(oldPid)) {
        gWS_ProcRef[oldPid] -= 1
        if (gWS_ProcRef[oldPid] <= 0) {
            gWS_ProcRef.Delete(oldPid)
            ; Optional: drop cached name when last ref leaves
            if (gWS_ProcCache.Has(oldPid))
                gWS_ProcCache.Delete(oldPid)
        }
    }
    if (newPid > 0) {
        if (!gWS_ProcRef.Has(newPid))
            gWS_ProcRef[newPid] := 0
        gWS_ProcRef[newPid] += 1
    }
}

_WS_RequestRevBump() {
    global gWS_Batching, gWS_PendingRevBump, gWS_Rev
    if (gWS_Batching) {
        gWS_PendingRevBump := true
    } else {
        gWS_Rev += 1
    }
}

_WS_Now() {
    return A_TickCount + 0
}

_WS_Basename(path) {
    if (!path)
        return ""
    SplitPath(path, &fname)
    return fname
}

_WS_NormalizeTitle(s) {
    global gWS_Config
    if (s = "")
        return ""
    out := s . ""
    ; Replace CR/LF/tabs with spaces
    out := StrReplace(out, "r", " ")
    out := StrReplace(out, "n", " ")
    out := StrReplace(out, "t", " ")
    if gWS_Config["TitleCollapseSpaces"] {
        ; collapse runs of spaces
        while InStr(out, "  ")
            out := StrReplace(out, "  ", " ")
    }
    out := Trim(out, " t")
    max := gWS_Config["NormalizeTitleMax"] + 0
    if (max > 0 && StrLen(out) > max)
        out := SubStr(out, 1, max)
    return out
}

_WS_StateCanonical(s) {
    if (!s)
        return "Unknown"
    t := StrLower(Trim(s))
    if (t = "workspaceshowing")    {
      return "WorkspaceShowing"
    }
    if (t = "workspaceminimized")  {
      return "WorkspaceMinimized"
    }
    if (t = "workspacehidden")     {
      return "WorkspaceHidden"
    }
    if (t = "otherworkspace")      {
      return "OtherWorkspace"
    }
    return "Unknown"
}

_WS_NewRecord(hwnd) {
    now := _WS_Now()
    return {
        ; Identity / process
        hwnd: hwnd + 0,
        pid: 0,
        class: "",
        exePath: "",
        processName: "",

        ; Titles
        titleRaw: "",
        title: "",

        ; State
        state: "Unknown",
        zOrder: 0,
        isVisible: false,
        isMinimized: false,
        isOnCurrentWorkspace: false,
        isFocused: false,
        isBlacklisted: false,

        ; Workspace
        workspaceId: "",
        workspaceName: "",

        ; MRU / activity
        lastActivatedTick: 0,
        totalActiveMs: 0,
        mruRank: 0,

        ; Icons
        iconHicon: 0,
        iconKey: "",
        ; Pump control
        needsIcon: false,
        iconCooldownUntilTick: 0,

        ; Sweep / lifecycle
        present: true,
        presentNow: true,
        lastSeenScanId: 0,
        lastSeenSweep: 0,
        lastSeenTick: now,
        missingSinceTick: 0,
        firstSeenTick: now,

        ; Needs flags (other)
        needsProcName: false,
        needsWS: false,

        ; Record bookkeeping
        rev: 0
    }
}


WindowStore_SetOwnershipPolicy(mode := "off", allowedMap := 0) {
    global gWS_OwnershipMode, gWS_AllowedFields

    m := StrLower(mode . "")
    if (m != "off" && m != "warn" && m != "strict")
        m := "off"
    gWS_OwnershipMode := m

    ; Build defaults if not provided
    if (!IsObject(allowedMap)) {
        allowedMap := Map()
        allowedMap["winenum"] := _WS_MakeKeySet([
            "pid","class","title","titleRaw","state","zOrder",
            "isVisible","isMinimized","isBlacklisted",
            "present","presentNow","lastSeenScanId","lastSeenTick",
            ; optional extras some enumerators may send:
            "isCloaked","altTabEligible"
        ])
        allowedMap["mru"] := _WS_MakeKeySet([
            "lastActivatedTick","isFocused","totalActiveMs","mruRank"
        ])
        allowedMap["komorebi"] := _WS_MakeKeySet([
            "workspaceId","workspaceName","isOnCurrentWorkspace"
        ])
        allowedMap["icon"] := _WS_MakeKeySet([
            "iconHicon","iconKey"
        ])
        allowedMap["proc"] := _WS_MakeKeySet([
            "processName","exePath"
        ])
        ; You can add more sources later (e.g., "gui", "rules", etc.)
    }

    ; Normalize to Map(source -> Map(key -> true))
    tmp := Map()
    for src, set in allowedMap {
        if IsObject(set) {
            tmp[src] := _WS_MakeKeySet(set)
        }
    }
    gWS_AllowedFields := tmp
}

_WS_MakeKeySet(arr) {
    ; arr can be an Array or any iterable of strings
    s := Map()
    for _, k in arr {
        if (k != "")
            s[k . ""] := true
    }
    return s
}

_WS_OwnerAllowed(source, key) {
    global gWS_AllowedFields
    src := source . ""
    if (src = "" || !gWS_AllowedFields.Has(src))
        return false
    set := gWS_AllowedFields[src]
    return set.Has(key . "")
}

_WS_LogOwnerViolation(source, key, mode) {
    ; Keep logging light; can be improved to buffered log if needed.
    OutputDebug "WindowStore Ownership [" mode "]: source='" source "' cannot set field '" key "'"
}

_WS_FilterPatchByOwnership(patch, source) {
    global gWS_OwnershipMode
    if (!IsObject(patch))
        return patch
    mode := gWS_OwnershipMode
    if (mode = "off" || source = "")
        return patch

    if (mode = "warn") {
        for k, _ in patch {
            if !_WS_OwnerAllowed(source, k) {
                _WS_LogOwnerViolation(source, k, mode)
            }
        }
        return patch  ; accept all
    }

    ; strict: drop non-owned fields
    filtered := {}
    for k, v in patch {
        if _WS_OwnerAllowed(source, k) {
            filtered.%k% := v
        } else {
            _WS_LogOwnerViolation(source, k, mode)
        }
    }
    return filtered
}


; Merge patch object into rec. Returns true if any meaningful field changed.
_WS_MergeInto(rec, patch) {
    changed := false

    ; Identity / process
    if (patch.Has("pid"))           changed := changed || _WS_AssignIfDiff(rec, "pid", patch.pid + 0)
    if (patch.Has("class"))         changed := changed || _WS_AssignIfDiff(rec, "class", patch.class . "")
    if (patch.Has("exePath")) {
        path := patch.exePath . ""
        pname := _WS_Basename(path)
        changed := changed || _WS_AssignIfDiff(rec, "exePath", path)
        if (pname != "" && rec.processName != pname)
            rec.processName := pname, changed := true
    }
    if (patch.Has("processName"))   changed := changed || _WS_AssignIfDiff(rec, "processName", patch.processName . "")

    ; Titles
    if (patch.Has("titleRaw")) {
        raw := patch.titleRaw . ""
        norm := _WS_NormalizeTitle(raw)
        if (rec.titleRaw != raw)  rec.titleRaw := raw, changed := true
        if (rec.title    != norm) rec.title    := norm, changed := true
    } else if (patch.Has("title")) {
        norm := _WS_NormalizeTitle(patch.title . "")
        if (rec.title != norm) rec.title := norm, changed := true
    }

    ; State
    if (patch.Has("state"))                 changed := changed || _WS_AssignIfDiff(rec, "state", _WS_StateCanonical(patch.state))
    if (patch.Has("zOrder"))                changed := changed || _WS_AssignIfDiff(rec, "zOrder", patch.zOrder + 0)
    if (patch.Has("isVisible"))             changed := changed || _WS_AssignIfDiff(rec, "isVisible", !!patch.isVisible)
    if (patch.Has("isMinimized"))           changed := changed || _WS_AssignIfDiff(rec, "isMinimized", !!patch.isMinimized)
    if (patch.Has("isOnCurrentWorkspace"))  changed := changed || _WS_AssignIfDiff(rec, "isOnCurrentWorkspace", !!patch.isOnCurrentWorkspace)
    if (patch.Has("isFocused"))             changed := changed || _WS_AssignIfDiff(rec, "isFocused", !!patch.isFocused)
    if (patch.Has("isBlacklisted"))         changed := changed || _WS_AssignIfDiff(rec, "isBlacklisted", !!patch.isBlacklisted)

    ; Workspace
    if (patch.Has("workspaceId"))           changed := changed || _WS_AssignIfDiff(rec, "workspaceId", patch.workspaceId)
    if (patch.Has("workspaceName"))         changed := changed || _WS_AssignIfDiff(rec, "workspaceName", patch.workspaceName . "")

    ; MRU / activity
    if (patch.Has("lastActivatedTick")) {
        t := patch.lastActivatedTick + 0
        if (t != rec.lastActivatedTick)
            rec.lastActivatedTick := t, changed := true
    }
    if (patch.Has("totalActiveMs"))         changed := changed || _WS_AssignIfDiff(rec, "totalActiveMs", patch.totalActiveMs + 0)
    if (patch.Has("mruRank"))               changed := changed || _WS_AssignIfDiff(rec, "mruRank", patch.mruRank + 0)

    ; Icons
    if (patch.Has("iconHicon")) {
        newH := patch.iconHicon + 0
        if (newH != rec.iconHicon) {
            if (rec.iconHicon)
                try DllCall("user32\DestroyIcon", "ptr", rec.iconHicon)
            rec.iconHicon := newH, changed := true
        }
    }
    if (patch.Has("iconKey"))               changed := changed || _WS_AssignIfDiff(rec, "iconKey", patch.iconKey . "")
    if (patch.Has("iconCooldownUntilTick")) changed := changed || _WS_AssignIfDiff(rec, "iconCooldownUntilTick", patch.iconCooldownUntilTick + 0)

    return changed
}


_WS_AssignIfDiff(rec, key, val) {
    if (!rec.Has(key) || rec.%key% != val) {
        rec.%key% := val
        return true
    }
    return false
}

_WS_DefaultFilter() {
    return {
        presentOnly: true,
        currentWorkspaceOnly: false,
        blacklistMode: "exclude",
        classes: [],
        pids: []
    }
}

_WS_MergeFilter(base, override) {
    out := Map()
    ; copy base first
    for k, v in base
        out[k] := v
    ; overlay any provided keys
    for k, v in override
        out[k] := v
    ; normalize values
    out.presentOnly := !!out.presentOnly
    out.currentWorkspaceOnly := !!out.currentWorkspaceOnly
    bm := StrLower(out.blacklistMode . "")
    if (bm != "include" && bm != "only")
        bm := "exclude"
    out.blacklistMode := bm
    if !IsObject(out.classes) out.classes := []
    if !IsObject(out.pids)    out.pids := []
    return out
}

_WS_ValidateSort(s) {
    t := StrUpper(Trim(s . ""))
    if (t = "MRU" || t = "Z" || t = "TITLE" || t = "PID" || t = "PROCESSNAME")
        return t
    return "MRU"
}

_WS_ValidateColumns(c) {
    t := StrLower(Trim(c . ""))
    if (t = "items")
        return "items"
    return "hwndsOnly"
}

_WS_FilterRecords(filter) {
    global gWS_Store
    recs := []
    for hwnd, rec in gWS_Store {
        if (filter.presentOnly && !rec.present)
            continue
        if (filter.currentWorkspaceOnly && !rec.isOnCurrentWorkspace)
            continue
        if (filter.blacklistMode = "exclude" && rec.isBlacklisted)
            continue
        if (filter.blacklistMode = "only" && !rec.isBlacklisted)
            continue
        if (filter.classes.Length) {
            keep := false
            for _, cls in filter.classes
                if (rec.class = (cls . "")) {
                    keep := true
                    break
                }
            if !keep
                continue
        }
        if (filter.pids.Length) {
            keep2 := false
            for _, p in filter.pids
                if (rec.pid = (p + 0)) {
                    keep2 := true
                    break
                }
            if !keep2
                continue
        }
        recs.Push(rec)
    }
    return recs
}

_WS_SortRecords(recs, sortKey) {
    ; In-place sort of an array of record objects.
    if (sortKey = "MRU") {
        recs.Sort((a, b) => _WS_CompareDesc(a.lastActivatedTick, b.lastActivatedTick, a, b))
        return
    }
    if (sortKey = "Z") {
        ; Lower Z-order at front (or reverse if your Z means “on top” is smaller).
        recs.Sort((a, b) => _WS_CompareAsc(a.zOrder, b.zOrder, a, b))
        return
    }
    if (sortKey = "TITLE") {
        recs.Sort((a, b) => _WS_CompareStrAsc(a.title, b.title, a, b))
        return
    }
    if (sortKey = "PID") {
        recs.Sort((a, b) => _WS_CompareAsc(a.pid, b.pid, a, b))
        return
    }
    if (sortKey = "PROCESSNAME") {
        recs.Sort((a, b) => _WS_CompareStrAsc(a.processName, b.processName, a, b))
        return
    }
    ; default fallback
    recs.Sort((a, b) => _WS_CompareDesc(a.lastActivatedTick, b.lastActivatedTick, a, b))
}

_WS_CompareAsc(x, y, a, b) {
    if (x < y)  {
      return -1
    }
    if (x > y)  {
      return 1
    }
    ; tie-breakers for stability
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}
_WS_CompareDesc(x, y, a, b) {
    if (x > y)  {
      return -1
    }
    if (x < y)  {
      return 1
    }
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}
_WS_CompareStrAsc(x, y, a, b) {
    sx := x . "", sy := y . ""
    c := StrCompare(sx, sy, true)  ; case-insensitive
    if (c < 0) {
      return -1
    }
    if (c > 0) {
      return 1
    }
    if (a.hwnd < b.hwnd) {
      return -1
    }
    if (a.hwnd > b.hwnd) {
      return 1
    }
    return 0
}

_WS_TotalCount() {
    global gWS_Store
    c := 0
    for _, _ in gWS_Store
        c += 1
    return c
}

; Convert a record to a “raw GUI item” expected by NewGUI__BuildRowModel in your newgui.ahk.
_WS_ToGuiItem(rec, idx, total) {
    ; Subtext comes from state (shortened later by GUI code if configured).
    wsName := rec.workspaceName ? rec.workspaceName : ""
    return {
        Title: rec.title != "" ? rec.title : (rec.processName != "" ? rec.processName : "(untitled)"),
        State: rec.state,
        Hwnd:  rec.hwnd,
        Pid:   rec.pid,
        ZOrder: rec.zOrder,
        Class: rec.class,
        Workspace: wsName,

        ; optional extras (GUI won’t break if unused)
        ProcessName: rec.processName,
        WorkspaceId: rec.workspaceId,
        IsBlacklisted: rec.isBlacklisted,
        IsVisible: rec.isVisible,
        IsMinimized: rec.isMinimized,
        IsOnCurrentWorkspace: rec.isOnCurrentWorkspace,
        IsFocused: rec.isFocused,

        ; icon handle is available if you wire GUI to read it; otherwise the
        ; existing icon pump caches via hwnd anyway.
        HICON: rec.iconHicon
    }
}
--------------
Contents of mru.ahk
--------------
﻿#Requires AutoHotkey v2.0
;===============================================================================
; mru.ahk — focus/activation stream → annotate WindowStore
; Public:
;   MRU_Init()
;   MRU_GetList()              -> array of hwnds (most-recent-first) [debug]
;   MRU_SetDebounce(ms)        -> set activation debounce window in ms (0=off)
;   MRU_MoveToFront(hwnd)      -> (debug/back-compat)
;   MRU_Remove(hwnd)           -> (debug/back-compat)
; Notes:
;   - Requires WindowStore_Ensure / WindowStore_UpdateFields / WindowStore_RemoveWindow.
;   - Assumes winenum.ahk has registered its enumerate-by-hwnd fetcher with the store.
;===============================================================================

;------------------------------ Module state ----------------------------------
global _MRU_list := []           ; debug deque (most-recent-first)
global _MRU_msg  := 0
global _MRU_win  := 0

global _MRU_prevFocusedHwnd := 0 ; last hwnd we marked isFocused=true
global _MRU_lastActHwnd     := 0 ; for debounce
global _MRU_lastActTick     := 0

; Config: activation debounce window in ms (0 = off)
global MRU_ActivationDebounceMs := 0

; Optional: set to your overlay title to ignore its focus events
; global OverlayTitle := "Tabby Overlay"  ; (set elsewhere if you’d like)

;------------------------------ Public API ------------------------------------

MRU_Init() {
    global _MRU_msg, _MRU_win
    if (_MRU_msg)  ; already initialized
        return

    _MRU_win := Gui("-Caption +ToolWindow")
    _MRU_win.Hide()

    ; register hidden GUI as a shell hook window
    DllCall("RegisterShellHookWindow", "ptr", _MRU_win.Hwnd)

    ; get the message id for shell notifications and route it
    _MRU_msg := DllCall("RegisterWindowMessage", "str", "SHELLHOOK", "uint")
    OnMessage(_MRU_msg, MRU_OnShell)

    OnExit(_MRU_OnExit)
}

MRU_SetDebounce(ms) {
    global MRU_ActivationDebounceMs
    MRU_ActivationDebounceMs := Max(0, ms + 0)
}

MRU_GetList() {
    global _MRU_list
    return _MRU_list.Clone()   ; shallow copy for safety
}

MRU_MoveToFront(hwnd) {
    global _MRU_list
    hwnd := hwnd + 0
    if (hwnd = 0)
        return
    ; remove old occurrence
    for i, h in _MRU_list {
        if (h = hwnd) {
            _MRU_list.RemoveAt(i)
            break
        }
    }
    _MRU_list.InsertAt(1, hwnd)
}

MRU_Remove(hwnd) {
    global _MRU_list
    hwnd := hwnd + 0
    if (hwnd = 0)
        return
    for i, h in _MRU_list {
        if (h = hwnd) {
            _MRU_list.RemoveAt(i)
            break
        }
    }
}

;--------------------------- Shell hook handler -------------------------------

MRU_OnShell(wParam, lParam, msg, hwnd) {
    static HSHELL_WINDOWCREATED      := 1
    static HSHELL_WINDOWDESTROYED    := 2
    static HSHELL_WINDOWACTIVATED    := 4
    static HSHELL_RUDEAPPACTIVATED   := 0x8004

    if (lParam = 0)
        return

    switch wParam {
        case HSHELL_WINDOWCREATED:
            _MRU_OnCreated(lParam)

        case HSHELL_WINDOWDESTROYED:
            _MRU_OnDestroyed(lParam)

        case HSHELL_WINDOWACTIVATED, HSHELL_RUDEAPPACTIVATED:
            _MRU_OnActivated(lParam)
    }
}

;------------------------------ Event handling --------------------------------

_MRU_OnCreated(hwnd) {
    ; Seed the store quickly so background pumps can enrich later.
    try WindowStore_Ensure(hwnd, 0, "mru")
    catch
        ; ignore

    ; Keep debug deque in sync (optional)
    MRU_MoveToFront(hwnd)
}


_MRU_OnDestroyed(hwnd) {
    ; Clean store immediately to avoid “ghosts”.
    try WindowStore_RemoveWindow(hwnd)
    catch
        ; ignore
    ; Sync debug deque
    MRU_Remove(hwnd)
    ; Clear prev focus marker if it was this hwnd
    global _MRU_prevFocusedHwnd
    if (_MRU_prevFocusedHwnd = hwnd)
        _MRU_prevFocusedHwnd := 0
}

_MRU_OnActivated(hwnd) {
    ; Ignore our own AHK/overlay focus to prevent churn
    if (_MRU_ShouldIgnore(hwnd))
        return

    ; Debounce repeated activations (same hwnd within N ms)
    global MRU_ActivationDebounceMs, _MRU_lastActHwnd, _MRU_lastActTick
    now := A_TickCount
    if (MRU_ActivationDebounceMs > 0) {
        if (hwnd = _MRU_lastActHwnd && (now - _MRU_lastActTick) < MRU_ActivationDebounceMs)
            return
        _MRU_lastActHwnd := hwnd
        _MRU_lastActTick := now
    }

    ; Mark new focus & MRU in the store (owned by MRU)
    try WindowStore_Ensure(hwnd, { lastActivatedTick: now, isFocused: true }, "mru")
    catch
        ; ignore

    ; Clear focus flag on the previously focused window (if different)
    global _MRU_prevFocusedHwnd
    if (_MRU_prevFocusedHwnd && _MRU_prevFocusedHwnd != hwnd) {
        try WindowStore_UpdateFields(_MRU_prevFocusedHwnd, { isFocused: false }, "mru")
        catch
            ; ignore
    }
    _MRU_prevFocusedHwnd := hwnd

    ; Keep debug deque in sync
    MRU_MoveToFront(hwnd)
}


;------------------------------ Helpers ---------------------------------------

_MRU_ShouldIgnore(hwnd) {
    ; Ignore known AHK/overlay windows so they don’t pollute MRU.
    cls := _MRU_GetClass(hwnd)
    if (cls = "AutoHotkeyGUI")
        return true

    if (IsSet(OverlayTitle) && OverlayTitle) {
        ttl := ""
        try ttl := WinGetTitle("ahk_id " hwnd)
        if (ttl = OverlayTitle)
            return true
    }
    return false
}

_MRU_GetClass(hWnd) {
    buf := Buffer(256*2, 0)
    DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
    return StrGet(buf.Ptr, "UTF-16")
}

_MRU_OnExit(reason, code) {
    global _MRU_win
    try {
        if IsObject(_MRU_win)
            _MRU_win.Destroy()
    }
}

--------------
Contents of proc_pump.ahk
--------------
﻿#Requires AutoHotkey v2.0
; =============================================================================
; proc_pump.ahk — resolves PID→processName and fans out to WindowStore rows
; Notes:
;   - Uses QueryFullProcessImageNameW (fast, limited privilege).
;   - Updates the store-wide cache via WindowStore_UpdateProcessName(pid, name).
; =============================================================================

; ---------- Tunables ----------------------------------------------------------
if !IsSet(ProcBatchPerTick)
    ProcBatchPerTick := 16
if !IsSet(ProcTimerIntervalMs)
    ProcTimerIntervalMs := 100

; ---------- Module state ------------------------------------------------------
global _PP_TimerOn := false

; ---------- Public API --------------------------------------------------------
ProcPump_Start() {
    global _PP_TimerOn, ProcTimerIntervalMs
    if (_PP_TimerOn)
        return
    _PP_TimerOn := true
    SetTimer(_PP_Tick, ProcTimerIntervalMs)
}

ProcPump_Stop() {
    global _PP_TimerOn
    if !_PP_TimerOn
        return
    _PP_TimerOn := false
    SetTimer(_PP_Tick, 0)
}

; ---------- Core --------------------------------------------------------------
_PP_Tick() {
    global ProcBatchPerTick
    pids := WindowStore_PopPidBatch(ProcBatchPerTick)
    if (!IsObject(pids) || pids.Length = 0)
        return

    for _, pid in pids {
        pid := pid + 0
        if (pid <= 0)
            continue

        cached := WindowStore_GetProcNameCached(pid)
        if (cached != "") {
            ; Ensure any rows missing a name receive it.
            WindowStore_UpdateProcessName(pid, cached)
            continue
        }

        path := _PP_GetProcessPath(pid)
        if (path = "")
            continue

        name := _PP_Basename(path)
        if (name != "")
            WindowStore_UpdateProcessName(pid, name)
        ; (Optionally we could also store exePath per row, but icon pump can fetch path on demand.)
    }
}

; ---------- Helpers -----------------------------------------------------------
_PP_GetProcessPath(pid) {
    h := DllCall("kernel32\OpenProcess", "uint", 0x1000, "int", 0, "uint", pid, "ptr") ; QUERY_LIMITED
    if (!h)
        return ""
    buf := Buffer(32767*2, 0), cch := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW", "ptr", h, "uint", 0, "ptr", buf.Ptr, "uint*", &cch, "int")
    DllCall("kernel32\CloseHandle", "ptr", h)
    return ok ? StrGet(buf.Ptr, "UTF-16") : ""
}

_PP_Basename(path) {
    if (path = "")
        return ""
    SplitPath(path, &fn)
    return fn
}
--------------
Contents of winenum.ahk
--------------
﻿#Requires AutoHotkey v2.0
; =============================================================================
; winenum.ahk — fast Z-order enumeration with DWM cloaking info
; - Drives WindowStore sweeps (BeginScan/EndScan) so presence + TTL are consistent
; - Feeds ONLY base window facts to the store (title/class/pid/state/z/visibility)
; - Optional: mirror blacklisted/alt-tab-ineligible rows into store if enabled
; - Optional: fetch process name (off by default; proc_pump should handle it)
; - Adds single/batch enumerate-by-hwnd with hints
; - Provides a registration helper so WindowStore.Ensure() can call back here
; =============================================================================

; ----------------------------- Config toggles -------------------------------

; If true: when a window hits any blacklist or is alt-tab ineligible, still Upsert
; to the store with isBlacklisted=true (and altTabEligible=false). Default OFF.
global WN_RecordBlacklistInStore := false

; If true: fetch process name immediately (cost: OpenProcess + QueryFullProcessImageName)
; Default OFF; we prefer proc_pump to handle this.
global WN_FetchProcessName := false

; If true: apply Alt-Tab eligibility filter (WS_EX_TOOLWINDOW, owner-window, etc.)
; Default TRUE (matches old behavior)
if !IsSet(UseAltTabEligibility)
    global UseAltTabEligibility := true

; ----------------------------- Module state ---------------------------------
global _WN_all := []                 ; legacy return list
global _WN_zCounter := 0
global _WN_shell := 0

; scan id counter for sweeps
global _WN_scanIdSeq := 0

; debug buffer + throttle
global _WN_logbuf := ""
global _WN_traceLeft := 0
global _WN_traceDeadline := 0

; ------------------------------ Public API ----------------------------------

; Call once during init so WindowStore.Ensure() can delegate enumerate-by-hwnd.
; Expects WindowStore_SetFetchers({ EnumerateByHwnd: <Func> }) to exist in list.ahk.
WinEnum_RegisterWithStore() {
    try {
        if (IsSet(WindowStore_SetFetchers) && (WindowStore_SetFetchers is Func)) {
            ; Store expects a "ByHwnd" fetcher with (hwndsArray, hintsMap) signature.
            WindowStore_SetFetchers(Map("ByHwnd", WinEnum_Fetch_ByHwnd))
        }
    } catch {
        ; non-fatal
    }
}

; Begin a scan/sweep (wraps WindowStore_BeginSweep with a fresh token).
; Returns the scanId you must pass to EndScan.
WinEnum_BeginScan() {
    global _WN_scanIdSeq
    _WN_scanIdSeq += 1
    scanId := _WN_scanIdSeq
    try WindowStore_BeginSweep(scanId)
    catch {
        ; store may not be loaded yet, keep going
    }
    return scanId
}

; End a scan/sweep (wraps WindowStore_EndSweep) and returns its summary.
WinEnum_EndScan(scanId) {
    summary := ""
    try summary := WindowStore_EndSweep(scanId)
    catch {
        ; ignore
    }
    return summary
}

; Fetcher used by WindowStore.Ensure(): signature (hwndsArray, hintsMap)
; - Ignores hints here (ownership lives with the Ensure() caller).
; - Upserts only base facts with source="winenum".
WinEnum_Fetch_ByHwnd(hwnds, hints := "") {
    if (!IsObject(hwnds))
        hwnds := [hwnds]

    toStore := []
    for _, h in hwnds {
        hwnd := h + 0
        if (!hwnd)
            continue
        rec := _WN_ProbeOne(hwnd)
        if (rec.Has("forStore"))
            toStore.Push(rec.forStore)
    }
    if (toStore.Length) {
        try WindowStore_UpsertWindow(toStore, "winenum")
        catch {
            ; swallow—store may not be ready during early init
        }
    }
}


; Full desktop enumeration.
; - Drives a store sweep (BeginScan/EndScan).
; - Batches Upsert to the store; also returns legacy array for back-compat.
WinList_EnumerateAll() {
    global _WN_all, _WN_zCounter, _WN_shell
    global _WN_logbuf, _WN_traceLeft, _WN_traceDeadline
    global WN_RecordBlacklistInStore

    dbg       := (IsSet(DebugBlacklist) && DebugBlacklist)
    maxLines  := IsSet(DebugMaxLinesPerSession) ? DebugMaxLinesPerSession : 200
    maxMillis := IsSet(DebugMaxDurationMs)      ? DebugMaxDurationMs      : 200

    DllCall("LoadLibrary", "str", "dwmapi.dll")
    _WN_shell := DllCall("user32\GetShellWindow", "ptr")
    _WN_zCounter := 0
    _WN_all := []
    toStore := []

    ; start sweep + batch
    scanId := WinEnum_BeginScan()
    try WindowStore_BeginBatch()

    ; prepare debug budget
    if (dbg) {
        _WN_logbuf := ""
        _WN_traceLeft := maxLines
        _WN_traceDeadline := A_TickCount + maxMillis
        _WN_Log("=== WinList_EnumerateAll (begin) ===")
    } else {
        _WN_logbuf := ""
        _WN_traceLeft := 0
        _WN_traceDeadline := 0
    }

    enumCb := (hWnd, lParam) => _WN_EnumProc_ForAll(hWnd, &toStore)
    cb := CallbackCreate(enumCb, "Fast", 2)
    DllCall("user32\EnumWindows", "ptr", cb, "ptr", 0, "int")
    CallbackFree(cb)

    ; feed the store in one Upsert batch
    if (toStore.Length) {
        try WindowStore_UpsertWindow(toStore, "winenum")
        catch as e {
            _WN_Log("WindowStore_UpsertWindow(toStore) failed: " e.Message)
        }
    }

    ; end batch + sweep
    try WindowStore_EndBatch()
    summary := WinEnum_EndScan(scanId)

    if (dbg) {
        _WN_Log("=== WinList_EnumerateAll (end) ===")
        if (IsObject(summary))
            _WN_Log("hiddenNow=" summary.hiddenNow " tombstoned=" summary.tombstoned " removed=" summary.removed)
        _WN_FlushLog()
    }

    return _WN_all
}

; Single-window probe (accepts hints).
; - If hwnd is eligible/non-blacklisted, Upsert base facts (+hints) and return legacy row.
; - If blacklisted/ineligible, optionally mirror into store (flagged) when WN_RecordBlacklistInStore=true.
; hints: Map of fields to merge (e.g., { workspaceId: "2", workspaceName: "dev" }).
WinList_EnumerateByHwnd(hwnd, hints := "") {
    if (!hwnd)
        return {}
    rec := _WN_ProbeOne(hwnd)

    ; upsert only base facts with winenum source
    if (rec.Has("forStore")) {
        try WindowStore_UpsertWindow([rec.forStore], "winenum")
        catch as e {
            _WN_Log("WindowStore_UpsertWindow([one]) failed: " e.Message)
        }
    }
    return rec.Has("forList") ? rec.forList : {}
}


; Batch variant: input is an array of { hwnd, hints? }.
; Returns an array of legacy rows (like WinList_EnumerateAll()).
WinList_EnumerateByHwndMany(items) {
    if (!IsObject(items) || items.Length = 0)
        return []
    toStore := []
    legacy := []

    try WindowStore_BeginBatch()
    for _, it in items {
        hwnd := 0
        if (IsObject(it) && it.Has("hwnd"))
            hwnd := it.hwnd + 0
        else
            hwnd := it + 0
        if (!hwnd)
            continue

        rec := _WN_ProbeOne(hwnd)
        if (rec.Has("forStore"))
            toStore.Push(rec.forStore)
        if (rec.Has("forList"))
            legacy.Push(rec.forList)
    }

    if (toStore.Length) {
        try WindowStore_UpsertWindow(toStore, "winenum")
        catch as e {
            _WN_Log("WindowStore_UpsertWindow(batch one) failed: " e.Message)
        }
    }
    try WindowStore_EndBatch()
    return legacy
}


; ---------------------------- Enumeration core ------------------------------

_WN_EnumProc_ForAll(hWnd, &toStore) {
    global _WN_all, _WN_zCounter, _WN_shell
    if (hWnd = 0)
        return 1
    if (hWnd = _WN_shell) {
        _WN_zCounter += 1
        return 1
    }
    rec := _WN_ProbeOne(hWnd)
    if (rec.Has("forStore"))
        toStore.Push(rec.forStore)
    if (rec.Has("forList"))
        _WN_all.Push(rec.forList)
    _WN_zCounter += 1
    return 1
}

; Probe one HWND → apply filters and build:
; - forStore: minimal canonical patch for WindowStore (only known fields)
; - forList : legacy overlay record
_WN_ProbeOne(hWnd) {
    global _WN_zCounter, WN_RecordBlacklistInStore, WN_FetchProcessName, UseAltTabEligibility
    global BlacklistTitle, BlacklistClass, BlacklistPair

    out := {}

    cls := _GetClass(hWnd)
    ttl := _GetTitle(hWnd)

    ; HARD FILTER: skip known GDI+ helper windows
    if (_IsGdiPlusHelper(ttl, cls)) {
        _Trace("Skip GDI+ helper", ttl, cls)
        return out
    }

    ; Early blacklist checks
    isBList := false
    if (MatchAny(cls, BlacklistClass)) {
        _Trace("Hit Class list", ttl, cls), isBList := true
    } else if (!ttl) {
        ; Blank title: drop (match old behavior)
        return out
    } else if (MatchAny(ttl, BlacklistTitle)) {
        _Trace("Hit Title list", ttl, cls), isBList := true
    } else if (MatchPairs(ttl, cls, BlacklistPair)) {
        _Trace("Hit Pair list", ttl, cls), isBList := true
    }

    ; Visibility / minimized / cloaked
    isVisible := !!DllCall("user32\IsWindowVisible", "ptr", hWnd, "int")
    isMin     := !!DllCall("user32\IsIconic",        "ptr", hWnd, "int")

    cloakedBuf := Buffer(4, 0)
    hr := DllCall("dwmapi\DwmGetWindowAttribute", "ptr", hWnd, "uint", 14, "ptr", cloakedBuf.Ptr, "uint", 4, "int")
    isCloaked := (hr = 0) && (NumGet(cloakedBuf, 0, "UInt") != 0)

    state := "WorkspaceHidden"
    if (isCloaked)
        state := "OtherWorkspace"
    else if (isMin)
        state := "WorkspaceMinimized"
    else if (isVisible)
        state := "WorkspaceShowing"

    ; Alt-Tab eligibility (if toggled on)
    eligible := _IsAltTabEligible(hWnd, isVisible, isMin, isCloaked)
    if (UseAltTabEligibility && !eligible) {
        _Trace("Ineligible (Alt-Tab rules)", ttl, cls)
        if (WN_RecordBlacklistInStore) {
            pid := _GetPid(hWnd)
            ; prefer letting proc_pump fill processName later
            out.forStore := _WN_MakeStorePatch(hWnd, pid, cls, ttl, state, _WN_zCounter
                , isVisible, isMin, true, false)
        }
        return out
    }

    ; If blacklisted: either mirror to store (flagged) or drop
    if (isBList) {
        if (WN_RecordBlacklistInStore) {
            pid := _GetPid(hWnd)
            out.forStore := _WN_MakeStorePatch(hWnd, pid, cls, ttl, state, _WN_zCounter
                , isVisible, isMin, true, false)
        }
        return out
    }

    ; Eligible path
    pid := _GetPid(hWnd)

    ; Store patch (only fields recognized by WindowStore)
    patch := _WN_MakeStorePatch(hWnd, pid, cls, ttl, state, _WN_zCounter
        , isVisible, isMin, false, true)

    ; (Optionally attach processName for immediate UI—discouraged by default)
    if (WN_FetchProcessName && pid) {
        pname := _GetProcessName(pid)
        if (pname != "")
            patch.processName := pname
    }

    out.forStore := patch
    out.forList  := { Hwnd: hWnd, Title: ttl, Class: cls, Pid: pid, State: state, ZOrder: _WN_zCounter }
    return out
}

; Build a WindowStore patch with only known fields (store will normalize titles).
_WN_MakeStorePatch(hWnd, pid, cls, ttl, state, zOrder
    , isVisible, isMinimized, isBlacklisted, presentNow) {
    return {
        hwnd: hWnd,
        pid: pid,
        class: cls,
        title: ttl,
        state: state,
        zOrder: zOrder,
        isVisible: isVisible,
        isMinimized: isMinimized,
        isBlacklisted: isBlacklisted,
        ; present/lastSeen are handled by sweep + Upsert in the store;
        ; we still pass some friendly hints the store ignores gracefully:
        presentNow: presentNow,
        lastSeenTick: A_TickCount,
        source: "winenum"
    }
}

; ------------------------------ Helpers -------------------------------------

_GetTitle(hWnd) {
    buf := Buffer(512*2, 0)
    DllCall("user32\GetWindowTextW", "ptr", hWnd, "ptr", buf.Ptr, "int", 512, "int")
    s := StrGet(buf.Ptr, "UTF-16")
    return Trim(RegExReplace(s, "[\r\n\t]+", " "))
}

_GetClass(hWnd) {
    buf := Buffer(256*2, 0)
    DllCall("user32\GetClassNameW", "ptr", hWnd, "ptr", buf.Ptr, "int", 256, "int")
    return StrGet(buf.Ptr, "UTF-16")
}

_GetPid(hWnd) {
    pidBuf := Buffer(4, 0)
    DllCall("user32\GetWindowThreadProcessId", "ptr", hWnd, "ptr", pidBuf.Ptr, "uint")
    return NumGet(pidBuf, 0, "UInt")
}

_GetProcessName(pid) {
    if (!pid)
        return ""
    PROCESS_QUERY_LIMITED_INFORMATION := 0x1000
    hProc := DllCall("kernel32\OpenProcess","uint",PROCESS_QUERY_LIMITED_INFORMATION,"int",0,"uint",pid,"ptr")
    if (!hProc)
        return ""
    buf := Buffer(32767 * 2, 0), sz := 32767
    ok := DllCall("kernel32\QueryFullProcessImageNameW","ptr",hProc,"uint",0,"ptr",buf.Ptr,"uint*",sz,"int")
    DllCall("kernel32\CloseHandle","ptr",hProc)
    if (!ok)
        return ""
    full := StrGet(buf.Ptr, "UTF-16")
    SplitPath(full, &nameOnly)
    return nameOnly
}

_IsAltTabEligible(hWnd, isVisible, isMin, isCloaked) {
    ex := DllCall("user32\GetWindowLongPtrW", "ptr", hWnd, "int", -20, "ptr")
    WS_EX_TOOLWINDOW := 0x00000080
    WS_EX_APPWINDOW  := 0x00040000
    isTool := (ex & WS_EX_TOOLWINDOW) != 0
    isApp  := (ex & WS_EX_APPWINDOW)  != 0
    owner := DllCall("user32\GetWindow", "ptr", hWnd, "uint", 4, "ptr") ; GW_OWNER
    if (isTool)
        return false
    if !(owner = 0 || isApp)
        return false
    if !(isVisible || isMin || isCloaked)
        return false
    return true
}

; ---------- debug helpers (use your existing Normalize/Match) ----------------

_IsGdiPlusHelper(ttl, cls) {
    ttlN := NormalizeMatchText(ttl)
    clsN := NormalizeMatchText(cls)
    if (clsN != "GDI+Hook Window Class")
        return false
    return RegExMatch(ttlN, "^GDI\+Window \([^)]+\)$")
}

_Trace(tag, ttl, cls) {
    global _WN_traceLeft, _WN_traceDeadline
    dbg := (IsSet(DebugBlacklist) && DebugBlacklist)
    if !dbg
        return
    if (_WN_traceLeft <= 0 || (_WN_traceDeadline && A_TickCount > _WN_traceDeadline))
        return
    _WN_traceLeft -= 3
    _WN_Log("[" tag "]")
    _WN_Log("  Title: " ttl)
    _WN_Log("  Class: " cls)
}

_WN_Log(line) {
    global _WN_logbuf
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff")
    _WN_logbuf .= ts "  " line "rn"
}

_WN_GetLogPath() {
    if (IsSet(DebugLogPath) && DebugLogPath)
        return DebugLogPath
    return A_ScriptDir "\tabby_debug.log"
}

_WN_FlushLog() {
    global _WN_logbuf
    if (_WN_logbuf = "")
        return
    path := _WN_GetLogPath()
    SplitPath path, , &dir
    if (dir != "")
        try DirCreate(dir)
    ok := false
    try {
        FileAppend(_WN_logbuf, path, "UTF-8")
        ok := true
    } catch {
        try {
            FileAppend(_WN_logbuf, A_Temp "\tabby_debug.log", "UTF-8")
            ok := true
        } catch {
            ; give up
        }
    }
    _WN_logbuf := ""
}
--------------
OK, we've now touched everything that owns any data or adds into the Window Store API.

We haven't touched the pure consumers of the API, like altlogic.ahk. Which is good. I want to perfect the producer side first.

So, before we move on to consumers, lets do a recap.

Above is all files we've build or refactored to use the new WindowStore API.

Before we move on, check very carefully, is this all looking good? Any errors, oversights, or big changes we should make, such as performance or thread blocking or anything important?

Just planning for now - if you thing changes are need them flag them and we will follow them up in future prompts. 
Ok, lets tackle the first one. For the wineenum function mismatch with list.ahk, give me full function ADD / REPLACE / REMOVE block for winenum. lets leave list.ahk unless we have to. also you dont have to worry about backwards compatibly patches into winenum.ahk, we havent launched any of this yet we can edit the core code. 

unless its as simple as the function name but parameters are all the same, then you just point that out and i can find/replace.


For the second issue, the komorebi issues, looks like some sub issues. First your right is the way were logging:
2025-09-12 21:18:16.210  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'

I just tested how its logging. Your right, that could be are in main and activated another main window 12848910, or could mean we were in media and just switched to main and focused 12848910, or could mean I'm in game and just sent 12848910 to main but am still in game.

What i dont know is what to do about it. komrebi_sub has always been black magic to me, im not sure what we get from the komorebi subscription - like you say should act on explicit signals, but do we get explicit signals? where can I find a list of what signals we get? Or can I make a powershell and test it out and feed back to you? I literally dont know how to update komrebi_sub so we can get more explicity signaling on what is what. 

from my testing is would appear that we are able to keep the assumption that 
any entry like
2025-09-12 21:18:16.210  [komorebi] FindWorkspace: hwnd=12848910 => workspace='Main'
means that the current workspace of that hwnd is whats said, and we can use that to ensure(), but your right, we shouldnt use it to trigger "we have changed workspaces"

So how do we rectify that? like you said:
Your current “FindWorkspace” debug prints are coming from state sniffing, not from an explicit event—hence the logical hazard in (2).
so how do we fix? 
do we know enough from my working code or you web searching on how this works?
or can i do additional debug logging or an indepentent powershell test so we can see what we get across the subscription pipe?
or whats the next step? 
  ok, i output the schema like you said, but i'm hesitant to paste it here as its super long not sure if your context window could handle. these stand out brightly to me, could these help:
        "StateQuery": {
      "type": "string",
      "enum": [
        "FocusedMonitorIndex",
        "FocusedWorkspaceIndex",
        "FocusedContainerIndex",
        "FocusedWindowIndex",
        "FocusedWorkspaceName",
        "FocusedWorkspaceLayout",
        "FocusedContainerKind",
        "Version"
      ]
    },
    "SubscribeOptions": {
      "type": "object",
      "required": [
        "filter_state_changes"
      ],
      "properties": {
        "filter_state_changes": {
          "description": "Only emit notifications when the window manager state has changed",
          "type": "boolean"
        }
      }
    },
  
  
  
  =====================
other areas of not, snipped from varios places, are
=============
  
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Notification",
  "type": "object",
  "required": [
    "event",
    "state"
  ],
  "properties": {
    "event": {
      "$ref": "#/definitions/NotificationEvent"
    },
    "state": {
      "$ref": "#/definitions/State"
    }
  },


      "ApplicationIdentifier": {
      "type": "string",
      "enum": [
        "Exe",
        "Class",
        "Title",
        "Path"
      ]
    },


    "Monitor": {
      "type": "object",
      "required": [
        "device",
        "device_id",
        "id",
        "name",
        "size",
        "window_based_work_area_offset_limit",
        "work_area_size",
        "workspace_names",
        "workspaces"
      ],


        "workspace_names": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },



    "MonitorNotification": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ResolutionScalingChanged"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "WorkAreaChanged"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "DisplayConnectionChange"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "EnteringSuspendedState"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ResumingFromSuspendedState"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SessionLocked"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SessionUnlocked"
              ]
            }
          }
        }
      ]
    },
    "MoveBehaviour": {
      "oneOf": [
        {
          "description": "Swap the window container with the window container at the edge of the adjacent monitor",
          "type": "string",
          "enum": [
            "Swap"
          ]
        },
        {
          "description": "Insert the window container into the focused workspace on the adjacent monitor",
          "type": "string",
          "enum": [
            "Insert"
          ]
        },
        {
          "description": "Do nothing if trying to move a window container in the direction of an adjacent monitor",
          "type": "string",
          "enum": [
            "NoOp"
          ]
        }
      ]
    },
    "NotificationEvent": {
      "anyOf": [
        {
          "$ref": "#/definitions/WindowManagerEvent"
        },
        {
          "$ref": "#/definitions/SocketMessage"
        },
        {
          "$ref": "#/definitions/MonitorNotification"
        },
        {
          "$ref": "#/definitions/VirtualDesktopNotification"
        }
      ]
    },



       "Ring_for_Container": {
      "type": "object",
      "required": [
        "elements",
        "focused"
      ],
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Container"
          }
        },
        "focused": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      }
    },
    "Ring_for_Monitor": {
      "type": "object",
      "required": [
        "elements",
        "focused"
      ],
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Monitor"
          }
        },
        "focused": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      }
    },
    "Ring_for_Window": {
      "type": "object",
      "required": [
        "elements",
        "focused"
      ],
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Window"
          }
        },
        "focused": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      }
    },
    "Ring_for_Workspace": {
      "type": "object",
      "required": [
        "elements",
        "focused"
      ],
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Workspace"
          }
        },
        "focused": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      }
    },
    "Sizing": {
      "type": "string",
      "enum": [
        "Increase",
        "Decrease"
      ]
    },
    "SocketMessage": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleFocusWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleMoveWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "StackWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "UnstackWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleStack"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleStackIndex"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusStackWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "StackAll"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "UnstackAll"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/OperationDirection"
                },
                {
                  "$ref": "#/definitions/Sizing"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "ResizeWindowEdge"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/Axis"
                },
                {
                  "$ref": "#/definitions/Sizing"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "ResizeWindowAxis"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToLastWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToLastWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleMoveContainerToMonitor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToNamedWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleMoveContainerToWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleSendContainerToMonitor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleSendContainerToWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToMonitorWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToMonitorWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToNamedWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleMoveWorkspaceToMonitor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveWorkspaceToMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "SwapWorkspacesToMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ForceFocus"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Close"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Minimize"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Promote"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "PromoteFocus"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "PromoteWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "EagerFocus"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "LockMonitorWorkspaceContainer"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "UnlockMonitorWorkspaceContainer"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleLock"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleFloat"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleMonocle"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleMaximize"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleWindowContainerBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleFloatOverride"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/HidingBehaviour"
            },
            "type": {
              "type": "string",
              "enum": [
                "WindowHidingBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleCrossMonitorMoveBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/MoveBehaviour"
            },
            "type": {
              "type": "string",
              "enum": [
                "CrossMonitorMoveBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationBehaviour"
            },
            "type": {
              "type": "string",
              "enum": [
                "UnmanagedWindowOperationBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ManageFocusedWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "UnmanageFocusedWindow"
              ]
            }
          }
        },
        {





     {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "EnsureWorkspaces"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "EnsureNamedWorkspaces"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "NewWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleTiling"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Stop"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "StopIgnoreRestore"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "TogglePause"
              ]
            }
          }
        },



    "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleFocusMonitor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleFocusWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleFocusEmptyWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "FocusMonitorAtCursor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "FocusLastWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "CloseWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusWorkspaceNumbers"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusMonitorWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusNamedWorkspace"
              ]
            }
          }
        },

============
but thats just me scanning by eyeball.

as to your tests you asked, i tried but i guess i dont know how to get the results into my command window

Microsoft Windows [Version 10.0.26100.4946]
(c) Microsoft Corporation. All rights reserved.

C:\Users\codyj>komorebic subscribe
Subscribe to komorebi events using a Named Pipe

Usage: komorebic subscribe-pipe <NAMED_PIPE>

Arguments:
  <NAMED_PIPE>  Name of the pipe to send event notifications to (without
                "\\.\pipe\" prepended)

Options:
  -h, --help  Print help

C:\Users\codyj>komorebic subscribe test

C:\Users\codyj>

----------

if you tell me what to do to test further, i can.

also the rest of our alt-tab app is pretty complicated. we could make a stand alone proof of concept .ahk here to help with debugging or proving we know to differentia state events from focus events or whatever

let me know next steps 
yes, next step is a stand alone proof of concept script that prints to a console like output so we can validate your approach before going back and updating komorebi_sub. 

so a fully standalone ahk (not tied to our other code) that prints not the raw return from komorebi, but what action you think you are extracting to use in our full app. so it would print like
workspace changed to X detectected via FocusNamedWorkspace
workspace changed to Y detected via FocusWorkspaceNumbers
windowmap hwnd X to workspace Y via MoveContainerToWorkspaceNumber
windowmap hwnd A to workspace B via SendContainerToNamedWorkspace
etc
that way we can validate your plan, or if we find issues, we can then add debug outputs to nail it down
getting a syntax error here:
-------
    } else {
        Log(Format('Waiting for client: run  {} subscribe-pipe {}', KomorebicExe, PipeName))
    }
---
Expected 1 parameters, but got 0
Expected 1+ parameters, but got 0

if i execute anyway, I get:
Error: Missing "'"

Text:	Log(Format('Waiting for client: run  {} subscribe-pipe {}', KomorebicExe, Pipe…
Line:	31
File:	C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk
another syntax error here
TrySpawnClient() {
    global gClientPid, KomorebicExe, PipeName
    try {
        cmd := """" . KomorebicExe . """ subscribe-pipe " . PipeName
        gClientPid := Run(cmd, , "Hide")
        Log("Spawned: pid=" gClientPid " → " KomorebicExe " subscribe-pipe " PipeName)
    } catch as e {
        Log("WARN: failed to spawn client: " e.Message)
    }
}

specifically
cmd := """" . KomorebicExe . """ subscribe-pipe " . PipeName
did you mean to use '"?
ok, so it executes now, but its not showing anything in the console. not my komorebi events, but also...like nothing. from reading the code i should be getting at least success/failure messages for setting up the pipe, but this console is BLANK
getting an error on launch:
 Error: This value of type "File" has no method named "Flush".

	029: ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff")
	030: gOut.Write(ts "  " msg "
")
▶	031: gOut.Flush()
	032: }
	035: gPipe := 0

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (31) : [Log] gOut.Flush()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (44) : [Main] Log("=== komorebi-poc starting ===")
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (59) : [] Main()
> Auto-execute

also, this looks less complete then our other one? your previous output had way more matched event types like this

IsWorkspaceFocusEvent(t) {
    static S := Map(
        "FocusNamedWorkspace", true,
        "FocusWorkspaceNumber", true,
        "FocusWorkspaceNumbers", true,
        "FocusLastWorkspace", true,
        "CycleFocusWorkspace", true,
        "CycleFocusEmptyWorkspace", true,
        "FocusMonitorWorkspaceNumber", true,
        "FocusMonitorAtCursor", true,
        "FocusMonitorNumber", true,
        "CycleFocusMonitor", true
    )
    return S.Has(t)
}

IsWindowMoveSendEvent(t) {
    static S := Map(
        "MoveContainerToNamedWorkspace", true,
        "SendContainerToNamedWorkspace", true,
        "MoveContainerToWorkspaceNumber", true,
        "SendContainerToWorkspaceNumber", true,
        "MoveContainerToMonitorWorkspaceNumber", true,
        "SendContainerToMonitorWorkspaceNumber", true,
        "CycleMoveContainerToWorkspace", true,
        "CycleSendContainerToWorkspace", true,
        "CycleMoveContainerToMonitor", true,
        "CycleSendContainerToMonitor", true,
        "MoveContainerToMonitorNumber", true,
        "SendContainerToMonitorNumber", true,
        "MoveContainerToLastWorkspace", true,
        "SendContainerToLastWorkspace", true
    )
    return S.Has(t)
}
it launches now, but I'm still seeing nothing, not even
=== komorebi-poc starting ===
for the first log of this thing starting.

you seem to be really struggling with our POC console window. maybe just rewrite log() to output to log.txt or whatever, this thing doenst have to be pretty its just a POC
your back to  your quote problems with AHKv2 syntax. give me a full replacement for this function with AHKv2 syntax
TrySpawnClient() {
    global gClientPid, KomorebicExe, PipeName
    try {
        cmd := """" KomorebicExe """ subscribe-pipe " PipeName
        gClientPid := Run(cmd, , "Hide")
        Log("Spawned subscriber: pid=" gClientPid " -> " KomorebicExe " subscribe-pipe " PipeName)
    } catch as e {
        Log("WARN: failed to spawn client: " e.Message)
        Log("Start it manually in a terminal:")
        Log("  " KomorebicExe " subscribe-pipe " PipeName)
    }
}
2025-09-12 22:10:55.fff  === komorebi-poc starting ===
2025-09-12 22:10:55.fff  KomorebicExe = C:\Program Files\komorebi\bin\komorebic.exe
2025-09-12 22:10:55.fff  PipeName     = tabby_poc_549087578_7601
2025-09-12 22:10:55.fff  Log file     = C:\Users\codyj\Desktop\tabby\komorebi_poc.log
2025-09-12 22:10:55.fff  Pipe created. Waiting for client to connect …
2025-09-12 22:10:55.fff  You can also run manually: C:\Program Files\komorebi\bin\komorebic.exe subscribe-pipe tabby_poc_549087578_7601
2025-09-12 22:10:55.fff  Spawned subscriber: pid= -> "C:\Program Files\komorebi\bin\komorebic.exe" subscribe-pipe tabby_poc_549087578_7601
2025-09-12 22:10:55.fff  Client connected.
---- this is me changing wokspace via YASB clicks not sure if it uses name or id ------
2025-09-12 22:11:03.fff  workspace changed (will confirm via state) via FocusMonitorWorkspaceNumber args=[0,1]
2025-09-12 22:11:04.fff  workspace changed (will confirm via state) via FocusMonitorWorkspaceNumber args=[0,0]
2025-09-12 22:11:12.fff  workspace changed (will confirm via state) via FocusMonitorWorkspaceNumber args=[0,2]
2025-09-12 22:11:14.fff  workspace changed (will confirm via state) via FocusMonitorWorkspaceNumber args=[0,0]
-----------this is me chaning via alt + num shortcuts i assume are ID -------
2025-09-12 22:11:31.fff  workspace changed (will confirm via state) via FocusWorkspaceNumber args=[1]
2025-09-12 22:11:33.fff  workspace changed (will confirm via state) via FocusWorkspaceNumber args=[2]
2025-09-12 22:11:34.fff  workspace changed (will confirm via state) via FocusWorkspaceNumber args=[0]
----------- this is me moving a window beteen workspaces ------
2025-09-12 22:12:01.fff  windowmap hwnd unknown via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:12:03.fff  windowmap hwnd unknown via MoveContainerToWorkspaceNumber args=[2]
2025-09-12 22:12:03.fff  ReadFile failed: GLE=234
2025-09-12 22:12:04.fff  windowmap hwnd unknown via MoveContainerToWorkspaceNumber args=[0]
-----------this is me sending a window between worksapces -------------
2025-09-12 22:13:13.fff  windowmap hwnd unknown via SendContainerToWorkspaceNumber args=[1]
2025-09-12 22:13:14.fff  windowmap hwnd unknown via SendContainerToWorkspaceNumber args=[2]
2025-09-12 22:13:34.fff  === komorebi-poc exiting (Menu) ===

above results of tests
thoughts:
first two tests, we are getting worksapce change via #, but we dont seem to "confirm via state" or get the name
when I move windows, we know to what workspace ID but not to what workspace name, nor the hwnd of the window moved
same with sending
when i move windows, we should also be able to detect a workspace change because move means focus the new workspace as well, and we dont see that. 

do you have an idea on how to improve this, or would you like me to paste the full notification-schema from komorebic? 
my friend, you and these syntax issues :D 
_ExtractEventArgs(evtObj) {
    if (evtObj = "")
        return "[]"
    ; Try to grab the content array or simple content
    m := 0
    if RegExMatch(evtObj, '"content"\s*:\s*(\[[^\]]*\])', &m)
        return m[1]
    if RegExMatch(evtObj, '"content"\s*:\s*"([^"]+)"', &m)
        return "[""" m[1] """]"
    if RegExMatch(evtObj, '"content"\s*:\s*(\d+)', &m)
        return "[" m[1] "]"
    return "[]"
}
on line
        return "[""" m[1] """]"
remember ahkv2 syntax
function replace
ok, first, im getting a warning:
---------
Error: This local variable has not been assigned a value.
A global declaration inside the function may be required.

Specifically: gLastWsName

	246: If (wsName != "")
	246: {
▶	247: If (wsName != gLastWsName)
	247: {
	248: gLastWsName := wsName

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (247) : [HandleNotification] If (wsName != gLastWsName)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (222) : [Tick] HandleNotification(msg)
> Timer
----------
im pressing "continue" to get past it. so im able to log now, but not sure if that warning is the reason for the defficiency Im about to describe. Log file:
=========
2025-09-12 22:21:30.fff  workspace changed (will confirm via state) via FocusMonitorWorkspaceNumber args=[0,1]
2025-09-12 22:21:36.fff  workspace still 'Main' (confirmed via state)
2025-09-12 22:21:37.fff  workspace changed (will confirm via state) via FocusMonitorWorkspaceNumber args=[0,0]
2025-09-12 22:21:40.fff  workspace still 'Media' (confirmed via state)
2025-09-12 22:21:52.fff  workspace changed (will confirm via state) via FocusMonitorWorkspaceNumber args=[0,2]
2025-09-12 22:21:53.fff  workspace still 'Main' (confirmed via state)
2025-09-12 22:22:00.fff  workspace changed (will confirm via state) via FocusMonitorWorkspaceNumber args=[0,0]
2025-09-12 22:22:01.fff  workspace still 'Com' (confirmed via state)
======
so i started on Main, switch to Media, Switched to Main, Switched to Com, Then Switched to Main.
But the log is always like, one behind. when I switched to media, it said still on main. When i switched back to main, it said still on Media. I switched to com and it said still on main. etc.

now our moves and sends are MUCH better
========
2025-09-12 22:24:15.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:24:15.fff  windowmap hwnd 12848910 -> workspace 'Media' (from 'Main') via MoveContainerToWorkspaceNumber
2025-09-12 22:24:18.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[0]
2025-09-12 22:24:18.fff  windowmap hwnd 12848910 -> workspace 'Main' (from 'Media') via MoveContainerToWorkspaceNumber
2025-09-12 22:24:39.fff  window move/send detected via SendContainerToWorkspaceNumber args=[1]
2025-09-12 22:24:39.fff  windowmap hwnd 12848910 -> workspace 'Media' (from 'Main') via SendContainerToWorkspaceNumber
=======
looking good to me. lets fix the workspace issue and then we can discuss further  
ugh, no, seems like a regression
2025-09-12 22:30:23.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,1] (name unresolved)
2025-09-12 22:30:25.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,0] (name unresolved)
2025-09-12 22:30:33.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,2] (name unresolved)
2025-09-12 22:30:34.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,0] (name unresolved)
2025-09-12 22:30:44.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:30:44.fff  windowmap target unresolved via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:30:45.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[0]
2025-09-12 22:30:45.fff  windowmap target unresolved via MoveContainerToWorkspaceNumber args=[0]
we are getting workspace change ID, but not name
and on window stuff, now we are no longer getting hwnd and workspace name, which our last version did, we are only getting workspace #

side question - must we only listen to this pipe, or can we use it to send queries? 
we are still regressing further
2025-09-12 22:35:39.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,1] (name unresolved)
2025-09-12 22:35:40.fff  workspace NOW 'Main' via FocusMonitorWorkspaceNumber args=[0,0]
2025-09-12 22:35:46.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,1] (name unresolved)
2025-09-12 22:35:49.fff  workspace still 'Main' (from FocusMonitorWorkspaceNumber args=[0,0])
2025-09-12 22:35:52.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,1] (name unresolved)
2025-09-12 22:35:53.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,2] (name unresolved)
2025-09-12 22:35:54.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,1] (name unresolved)
2025-09-12 22:35:55.fff  workspace still 'Main' (from FocusMonitorWorkspaceNumber args=[0,0])
2025-09-12 22:36:05.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:36:05.fff  windowmap target unresolved via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:36:06.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[0]
2025-09-12 22:36:06.fff  windowmap hwnd unknown -> workspace 'Main' via MoveContainerToWorkspaceNumber
2025-09-12 22:36:16.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:36:16.fff  windowmap target unresolved via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:36:17.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[0]
2025-09-12 22:36:17.fff  windowmap hwnd unknown -> workspace 'Main' via MoveContainerToWorkspaceNumber
its only ever identifying main, the first workspace, none of the others

And on window moves, we missing hwnds (our n-2 version had hwnds) and only identifying the workspce if its main (our n-2 version always identified hwnd workspace names) 
we have regressed even further.

getting an error:
Error: Invalid index.

Specifically: 0

	636: If (monIdx < 0 || monIdx >= buckets.Length)
	637: Return ""
▶	639: wsBody := buckets[monIdx]
	643: keyPat := 's)"' . wsIdx . '"\s*:\s*\{'
	644: m2 := 0

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (639) : [Array.Prototype.__Item.Get] wsBody := buckets[monIdx]
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (639) : [_State_GetWorkspaceNameByIndex] wsBody := buckets[monIdx]
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (262) : [HandleNotification] wsName := _State_GetWorkspaceNameByIndex(stateObj, monIdx, wsIdx)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (228) : [Tick] HandleNotification(msg)
> Timer

and heres the log:
2025-09-12 22:41:04.fff  === komorebi-poc exiting (Single) ===
2025-09-12 22:41:04.fff  === komorebi-poc starting ===
2025-09-12 22:41:04.fff  KomorebicExe = C:\Program Files\komorebi\bin\komorebic.exe
2025-09-12 22:41:04.fff  PipeName     = tabby_poc_550896515_8552
2025-09-12 22:41:04.fff  Log file     = C:\Users\codyj\Desktop\tabby\komorebi_poc.log
2025-09-12 22:41:04.fff  Pipe created. Waiting for client to connect …
2025-09-12 22:41:04.fff  You can also run manually: C:\Program Files\komorebi\bin\komorebic.exe subscribe-pipe tabby_poc_550896515_8552
2025-09-12 22:41:04.fff  Spawned subscriber: pid= -> "C:\Program Files\komorebi\bin\komorebic.exe" subscribe-pipe tabby_poc_550896515_8552
2025-09-12 22:41:04.fff  Client connected.
2025-09-12 22:41:16.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,1] (name unresolved)
2025-09-12 22:41:19.fff  workspace change signal via FocusMonitorWorkspaceNumber args=[0,0] (name unresolved)
2025-09-12 22:41:26.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:41:26.fff  windowmap target unresolved via MoveContainerToWorkspaceNumber args=[1]
2025-09-12 22:41:28.fff  window move/send detected via MoveContainerToWorkspaceNumber args=[0]
2025-09-12 22:41:28.fff  windowmap target unresolved via MoveContainerToWorkspaceNumber args=[0]

OK, here is the full scheme
========
C:\Users\codyj>komorebic notification-schema
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Notification",
  "type": "object",
  "required": [
    "event",
    "state"
  ],
  "properties": {
    "event": {
      "$ref": "#/definitions/NotificationEvent"
    },
    "state": {
      "$ref": "#/definitions/State"
    }
  },
  "definitions": {
    "AnimationPrefix": {
      "type": "string",
      "enum": [
        "movement",
        "transparency"
      ]
    },
    "AnimationStyle": {
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "Linear",
            "EaseInSine",
            "EaseOutSine",
            "EaseInOutSine",
            "EaseInQuad",
            "EaseOutQuad",
            "EaseInOutQuad",
            "EaseInCubic",
            "EaseInOutCubic",
            "EaseInQuart",
            "EaseOutQuart",
            "EaseInOutQuart",
            "EaseInQuint",
            "EaseOutQuint",
            "EaseInOutQuint",
            "EaseInExpo",
            "EaseOutExpo",
            "EaseInOutExpo",
            "EaseInCirc",
            "EaseOutCirc",
            "EaseInOutCirc",
            "EaseInBack",
            "EaseOutBack",
            "EaseInOutBack",
            "EaseInElastic",
            "EaseOutElastic",
            "EaseInOutElastic",
            "EaseInBounce",
            "EaseOutBounce",
            "EaseInOutBounce"
          ]
        },
        {
          "type": "object",
          "required": [
            "CubicBezier"
          ],
          "properties": {
            "CubicBezier": {
              "type": "array",
              "items": [
                {
                  "type": "number",
                  "format": "double"
                },
                {
                  "type": "number",
                  "format": "double"
                },
                {
                  "type": "number",
                  "format": "double"
                },
                {
                  "type": "number",
                  "format": "double"
                }
              ],
              "maxItems": 4,
              "minItems": 4
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ApplicationIdentifier": {
      "type": "string",
      "enum": [
        "Exe",
        "Class",
        "Title",
        "Path"
      ]
    },
    "Axis": {
      "type": "string",
      "enum": [
        "Horizontal",
        "Vertical",
        "HorizontalAndVertical"
      ]
    },
    "Base16": {
      "type": "string",
      "enum": [
        "3024",
        "Apathy",
        "Apprentice",
        "Ashes",
        "AtelierCaveLight",
        "AtelierCave",
        "AtelierDuneLight",
        "AtelierDune",
        "AtelierEstuaryLight",
        "AtelierEstuary",
        "AtelierForestLight",
        "AtelierForest",
        "AtelierHeathLight",
        "AtelierHeath",
        "AtelierLakesideLight",
        "AtelierLakeside",
        "AtelierPlateauLight",
        "AtelierPlateau",
        "AtelierSavannaLight",
        "AtelierSavanna",
        "AtelierSeasideLight",
        "AtelierSeaside",
        "AtelierSulphurpoolLight",
        "AtelierSulphurpool",
        "Atlas",
        "AyuDark",
        "AyuLight",
        "AyuMirage",
        "Aztec",
        "Bespin",
        "BlackMetalBathory",
        "BlackMetalBurzum",
        "BlackMetalDarkFuneral",
        "BlackMetalGorgoroth",
        "BlackMetalImmortal",
        "BlackMetalKhold",
        "BlackMetalMarduk",
        "BlackMetalMayhem",
        "BlackMetalNile",
        "BlackMetalVenom",
        "BlackMetal",
        "Blueforest",
        "Blueish",
        "Brewer",
        "Bright",
        "Brogrammer",
        "BrushtreesDark",
        "Brushtrees",
        "Caroline",
        "CatppuccinFrappe",
        "CatppuccinLatte",
        "CatppuccinMacchiato",
        "CatppuccinMocha",
        "Chalk",
        "Circus",
        "ClassicDark",
        "ClassicLight",
        "Codeschool",
        "Colors",
        "Cupcake",
        "Cupertino",
        "DaOneBlack",
        "DaOneGray",
        "DaOneOcean",
        "DaOnePaper",
        "DaOneSea",
        "DaOneWhite",
        "DanqingLight",
        "Danqing",
        "Darcula",
        "Darkmoss",
        "Darktooth",
        "Darkviolet",
        "Decaf",
        "DefaultDark",
        "DefaultLight",
        "Dirtysea",
        "Dracula",
        "EdgeDark",
        "EdgeLight",
        "Eighties",
        "EmbersLight",
        "Embers",
        "Emil",
        "EquilibriumDark",
        "EquilibriumGrayDark",
        "EquilibriumGrayLight",
        "EquilibriumLight",
        "Eris",
        "Espresso",
        "EvaDim",
        "Eva",
        "EvenokDark",
        "EverforestDarkHard",
        "Everforest",
        "Flat",
        "Framer",
        "FruitSoda",
        "Gigavolt",
        "Github",
        "GoogleDark",
        "GoogleLight",
        "Gotham",
        "GrayscaleDark",
        "GrayscaleLight",
        "Greenscreen",
        "Gruber",
        "GruvboxDarkHard",
        "GruvboxDarkMedium",
        "GruvboxDarkPale",
        "GruvboxDarkSoft",
        "GruvboxLightHard",
        "GruvboxLightMedium",
        "GruvboxLightSoft",
        "GruvboxMaterialDarkHard",
        "GruvboxMaterialDarkMedium",
        "GruvboxMaterialDarkSoft",
        "GruvboxMaterialLightHard",
        "GruvboxMaterialLightMedium",
        "GruvboxMaterialLightSoft",
        "Hardcore",
        "Harmonic16Dark",
        "Harmonic16Light",
        "HeetchLight",
        "Heetch",
        "Helios",
        "Hopscotch",
        "HorizonDark",
        "HorizonLight",
        "HorizonTerminalDark",
        "HorizonTerminalLight",
        "HumanoidDark",
        "HumanoidLight",
        "IaDark",
        "IaLight",
        "Icy",
        "Irblack",
        "Isotope",
        "Jabuti",
        "Kanagawa",
        "Katy",
        "Kimber",
        "Lime",
        "Macintosh",
        "Marrakesh",
        "Materia",
        "MaterialDarker",
        "MaterialLighter",
        "MaterialPalenight",
        "MaterialVivid",
        "Material",
        "MeasuredDark",
        "MeasuredLight",
        "MellowPurple",
        "MexicoLight",
        "Mocha",
        "Monokai",
        "Moonlight",
        "Mountain",
        "Nebula",
        "NordLight",
        "Nord",
        "Nova",
        "Ocean",
        "Oceanicnext",
        "OneLight",
        "OnedarkDark",
        "Onedark",
        "OutrunDark",
        "OxocarbonDark",
        "OxocarbonLight",
        "Pandora",
        "PapercolorDark",
        "PapercolorLight",
        "Paraiso",
        "Pasque",
        "Phd",
        "Pico",
        "Pinky",
        "Pop",
        "Porple",
        "PreciousDarkEleven",
        "PreciousDarkFifteen",
        "PreciousLightWarm",
        "PreciousLightWhite",
        "PrimerDarkDimmed",
        "PrimerDark",
        "PrimerLight",
        "Purpledream",
        "Qualia",
        "Railscasts",
        "Rebecca",
        "RosePineDawn",
        "RosePineMoon",
        "RosePine",
        "Saga",
        "Sagelight",
        "Sakura",
        "Sandcastle",
        "SelenizedBlack",
        "SelenizedDark",
        "SelenizedLight",
        "SelenizedWhite",
        "Seti",
        "ShadesOfPurple",
        "ShadesmearDark",
        "ShadesmearLight",
        "Shapeshifter",
        "SilkDark",
        "SilkLight",
        "Snazzy",
        "SolarflareLight",
        "Solarflare",
        "SolarizedDark",
        "SolarizedLight",
        "Spaceduck",
        "Spacemacs",
        "Sparky",
        "StandardizedDark",
        "StandardizedLight",
        "Stella",
        "StillAlive",
        "Summercamp",
        "SummerfruitDark",
        "SummerfruitLight",
        "SynthMidnightDark",
        "SynthMidnightLight",
        "Tango",
        "Tarot",
        "Tender",
        "TerracottaDark",
        "Terracotta",
        "TokyoCityDark",
        "TokyoCityLight",
        "TokyoCityTerminalDark",
        "TokyoCityTerminalLight",
        "TokyoNightDark",
        "TokyoNightLight",
        "TokyoNightMoon",
        "TokyoNightStorm",
        "TokyoNightTerminalDark",
        "TokyoNightTerminalLight",
        "TokyoNightTerminalStorm",
        "TokyodarkTerminal",
        "Tokyodark",
        "TomorrowNightEighties",
        "TomorrowNight",
        "Tomorrow",
        "Tube",
        "Twilight",
        "UnikittyDark",
        "UnikittyLight",
        "UnikittyReversible",
        "Uwunicorn",
        "Vesper",
        "Vice",
        "Vulcan",
        "Windows10Light",
        "Windows10",
        "Windows95Light",
        "Windows95",
        "WindowsHighcontrastLight",
        "WindowsHighcontrast",
        "WindowsNtLight",
        "WindowsNt",
        "Woodland",
        "XcodeDusk",
        "Zenbones",
        "Zenburn"
      ]
    },
    "Base16ColourPalette": {
      "type": "object",
      "required": [
        "base_00",
        "base_01",
        "base_02",
        "base_03",
        "base_04",
        "base_05",
        "base_06",
        "base_07",
        "base_08",
        "base_09",
        "base_0a",
        "base_0b",
        "base_0c",
        "base_0d",
        "base_0e",
        "base_0f"
      ],
      "properties": {
        "base_00": {
          "$ref": "#/definitions/Colour"
        },
        "base_01": {
          "$ref": "#/definitions/Colour"
        },
        "base_02": {
          "$ref": "#/definitions/Colour"
        },
        "base_03": {
          "$ref": "#/definitions/Colour"
        },
        "base_04": {
          "$ref": "#/definitions/Colour"
        },
        "base_05": {
          "$ref": "#/definitions/Colour"
        },
        "base_06": {
          "$ref": "#/definitions/Colour"
        },
        "base_07": {
          "$ref": "#/definitions/Colour"
        },
        "base_08": {
          "$ref": "#/definitions/Colour"
        },
        "base_09": {
          "$ref": "#/definitions/Colour"
        },
        "base_0a": {
          "$ref": "#/definitions/Colour"
        },
        "base_0b": {
          "$ref": "#/definitions/Colour"
        },
        "base_0c": {
          "$ref": "#/definitions/Colour"
        },
        "base_0d": {
          "$ref": "#/definitions/Colour"
        },
        "base_0e": {
          "$ref": "#/definitions/Colour"
        },
        "base_0f": {
          "$ref": "#/definitions/Colour"
        }
      }
    },
    "Base16Value": {
      "type": "string",
      "enum": [
        "Base00",
        "Base01",
        "Base02",
        "Base03",
        "Base04",
        "Base05",
        "Base06",
        "Base07",
        "Base08",
        "Base09",
        "Base0A",
        "Base0B",
        "Base0C",
        "Base0D",
        "Base0E",
        "Base0F"
      ]
    },
    "BorderImplementation": {
      "oneOf": [
        {
          "description": "Use the adjustable komorebi border implementation",
          "type": "string",
          "enum": [
            "Komorebi"
          ]
        },
        {
          "description": "Use the thin Windows accent border implementation",
          "type": "string",
          "enum": [
            "Windows"
          ]
        }
      ]
    },
    "BorderStyle": {
      "oneOf": [
        {
          "description": "Use the system border style",
          "type": "string",
          "enum": [
            "System"
          ]
        },
        {
          "description": "Use the Windows 11-style rounded borders",
          "type": "string",
          "enum": [
            "Rounded"
          ]
        },
        {
          "description": "Use the Windows 10-style square borders",
          "type": "string",
          "enum": [
            "Square"
          ]
        }
      ]
    },
    "Catppuccin": {
      "type": "string",
      "enum": [
        "Frappe",
        "Latte",
        "Macchiato",
        "Mocha"
      ]
    },
    "CatppuccinValue": {
      "type": "string",
      "enum": [
        "Rosewater",
        "Flamingo",
        "Pink",
        "Mauve",
        "Red",
        "Maroon",
        "Peach",
        "Yellow",
        "Green",
        "Teal",
        "Sky",
        "Sapphire",
        "Blue",
        "Lavender",
        "Text",
        "Subtext1",
        "Subtext0",
        "Overlay2",
        "Overlay1",
        "Overlay0",
        "Surface2",
        "Surface1",
        "Surface0",
        "Base",
        "Mantle",
        "Crust"
      ]
    },
    "Colour": {
      "anyOf": [
        {
          "description": "Colour represented as RGB",
          "allOf": [
            {
              "$ref": "#/definitions/Rgb"
            }
          ]
        },
        {
          "description": "Colour represented as Hex",
          "allOf": [
            {
              "$ref": "#/definitions/Hex"
            }
          ]
        }
      ]
    },
    "Column": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "column",
            "configuration"
          ],
          "properties": {
            "column": {
              "type": "string",
              "enum": [
                "Primary"
              ]
            },
            "configuration": {
              "anyOf": [
                {
                  "$ref": "#/definitions/ColumnWidth"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "configuration"
          ],
          "properties": {
            "column": {
              "type": "string",
              "enum": [
                "Secondary"
              ]
            },
            "configuration": {
              "anyOf": [
                {
                  "$ref": "#/definitions/ColumnSplitWithCapacity"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "configuration"
          ],
          "properties": {
            "column": {
              "type": "string",
              "enum": [
                "Tertiary"
              ]
            },
            "configuration": {
              "$ref": "#/definitions/ColumnSplit"
            }
          }
        }
      ]
    },
    "ColumnSplit": {
      "type": "string",
      "enum": [
        "Horizontal",
        "Vertical"
      ]
    },
    "ColumnSplitWithCapacity": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "Horizontal"
          ],
          "properties": {
            "Horizontal": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "Vertical"
          ],
          "properties": {
            "Vertical": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ColumnWidth": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "WidthPercentage"
          ],
          "properties": {
            "WidthPercentage": {
              "type": "number",
              "format": "float"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Container": {
      "type": "object",
      "required": [
        "id",
        "windows"
      ],
      "properties": {
        "id": {
          "type": "string"
        },
        "windows": {
          "$ref": "#/definitions/Ring_for_Window"
        }
      }
    },
    "CustomLayout": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Column"
      }
    },
    "CycleDirection": {
      "type": "string",
      "enum": [
        "Previous",
        "Next"
      ]
    },
    "DefaultLayout": {
      "type": "string",
      "enum": [
        "BSP",
        "Columns",
        "Rows",
        "VerticalStack",
        "HorizontalStack",
        "UltrawideVerticalStack",
        "Grid",
        "RightMainVerticalStack"
      ]
    },
    "FloatingLayerBehaviour": {
      "oneOf": [
        {
          "description": "Tile new windows (unless they match a float rule or float override is active)",
          "type": "string",
          "enum": [
            "Tile"
          ]
        },
        {
          "description": "Float new windows",
          "type": "string",
          "enum": [
            "Float"
          ]
        }
      ]
    },
    "FocusFollowsMouseImplementation": {
      "oneOf": [
        {
          "description": "A custom FFM implementation (slightly more CPU-intensive)",
          "type": "string",
          "enum": [
            "Komorebi"
          ]
        },
        {
          "description": "The native (legacy) Windows FFM implementation",
          "type": "string",
          "enum": [
            "Windows"
          ]
        }
      ]
    },
    "Hex": {
      "type": "string",
      "format": "color-hex"
    },
    "HidingBehaviour": {
      "oneOf": [
        {
          "description": "END OF LIFE FEATURE: Use the SW_HIDE flag to hide windows when switching workspaces (has issues with Electron apps)",
          "type": "string",
          "enum": [
            "Hide"
          ]
        },
        {
          "description": "Use the SW_MINIMIZE flag to hide windows when switching workspaces (has issues with frequent workspace switching)",
          "type": "string",
          "enum": [
            "Minimize"
          ]
        },
        {
          "description": "Use the undocumented SetCloak Win32 function to hide windows when switching workspaces",
          "type": "string",
          "enum": [
            "Cloak"
          ]
        }
      ]
    },
    "IdWithIdentifier": {
      "type": "object",
      "required": [
        "id",
        "kind"
      ],
      "properties": {
        "id": {
          "type": "string"
        },
        "kind": {
          "$ref": "#/definitions/ApplicationIdentifier"
        },
        "matching_strategy": {
          "anyOf": [
            {
              "$ref": "#/definitions/MatchingStrategy"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "KomorebiTheme": {
      "oneOf": [
        {
          "description": "A theme from catppuccin-egui",
          "type": "object",
          "required": [
            "name",
            "palette"
          ],
          "properties": {
            "bar_accent": {
              "description": "Komorebi status bar accent (default: Blue)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "floating_border": {
              "description": "Border colour when the window is floating (default: Yellow)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "monocle_border": {
              "description": "Border colour when the container is in monocle mode (default: Pink)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "name": {
              "description": "Name of the Catppuccin theme (theme previews: https://github.com/catppuccin/catppuccin)",
              "allOf": [
                {
                  "$ref": "#/definitions/Catppuccin"
                }
              ]
            },
            "palette": {
              "type": "string",
              "enum": [
                "Catppuccin"
              ]
            },
            "single_border": {
              "description": "Border colour when the container contains a single window (default: Blue)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stack_border": {
              "description": "Border colour when the container contains multiple windows (default: Green)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_background": {
              "description": "Stackbar tab background colour (default: Base)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_focused_text": {
              "description": "Stackbar focused tab text colour (default: Green)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_unfocused_text": {
              "description": "Stackbar unfocused tab text colour (default: Text)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unfocused_border": {
              "description": "Border colour when the container is unfocused (default: Base)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unfocused_locked_border": {
              "description": "Border colour when the container is unfocused and locked (default: Red)",
              "anyOf": [
                {
                  "$ref": "#/definitions/CatppuccinValue"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "description": "A theme from base16-egui-themes",
          "type": "object",
          "required": [
            "name",
            "palette"
          ],
          "properties": {
            "bar_accent": {
              "description": "Komorebi status bar accent (default: Base0D)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "floating_border": {
              "description": "Border colour when the window is floating (default: Base09)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "monocle_border": {
              "description": "Border colour when the container is in monocle mode (default: Base0F)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "name": {
              "description": "Name of the Base16 theme (theme previews: https://tinted-theming.github.io/tinted-gallery/)",
              "allOf": [
                {
                  "$ref": "#/definitions/Base16"
                }
              ]
            },
            "palette": {
              "type": "string",
              "enum": [
                "Base16"
              ]
            },
            "single_border": {
              "description": "Border colour when the container contains a single window (default: Base0D)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stack_border": {
              "description": "Border colour when the container contains multiple windows (default: Base0B)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_background": {
              "description": "Stackbar tab background colour (default: Base01)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_focused_text": {
              "description": "Stackbar focused tab text colour (default: Base0B)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_unfocused_text": {
              "description": "Stackbar unfocused tab text colour (default: Base05)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unfocused_border": {
              "description": "Border colour when the container is unfocused (default: Base01)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unfocused_locked_border": {
              "description": "Border colour when the container is unfocused and locked (default: Base08)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "description": "A custom Base16 theme",
          "type": "object",
          "required": [
            "colours",
            "palette"
          ],
          "properties": {
            "bar_accent": {
              "description": "Komorebi status bar accent (default: Base0D)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "colours": {
              "description": "Colours of the custom Base16 theme palette",
              "allOf": [
                {
                  "$ref": "#/definitions/Base16ColourPalette"
                }
              ]
            },
            "floating_border": {
              "description": "Border colour when the window is floating (default: Base09)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "monocle_border": {
              "description": "Border colour when the container is in monocle mode (default: Base0F)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "palette": {
              "type": "string",
              "enum": [
                "Custom"
              ]
            },
            "single_border": {
              "description": "Border colour when the container contains a single window (default: Base0D)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stack_border": {
              "description": "Border colour when the container contains multiple windows (default: Base0B)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_background": {
              "description": "Stackbar tab background colour (default: Base01)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_focused_text": {
              "description": "Stackbar focused tab text colour (default: Base0B)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "stackbar_unfocused_text": {
              "description": "Stackbar unfocused tab text colour (default: Base05)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unfocused_border": {
              "description": "Border colour when the container is unfocused (default: Base01)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unfocused_locked_border": {
              "description": "Border colour when the container is unfocused and locked (default: Base08)",
              "anyOf": [
                {
                  "$ref": "#/definitions/Base16Value"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        }
      ]
    },
    "Layout": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "Default"
          ],
          "properties": {
            "Default": {
              "$ref": "#/definitions/DefaultLayout"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "Custom"
          ],
          "properties": {
            "Custom": {
              "$ref": "#/definitions/CustomLayout"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "MatchingRule": {
      "anyOf": [
        {
          "$ref": "#/definitions/IdWithIdentifier"
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/IdWithIdentifier"
          }
        }
      ]
    },
    "MatchingStrategy": {
      "type": "string",
      "enum": [
        "Legacy",
        "Equals",
        "StartsWith",
        "EndsWith",
        "Contains",
        "Regex",
        "DoesNotEndWith",
        "DoesNotStartWith",
        "DoesNotEqual",
        "DoesNotContain"
      ]
    },
    "Monitor": {
      "type": "object",
      "required": [
        "device",
        "device_id",
        "id",
        "name",
        "size",
        "window_based_work_area_offset_limit",
        "work_area_size",
        "workspace_names",
        "workspaces"
      ],
      "properties": {
        "container_padding": {
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "device": {
          "type": "string"
        },
        "device_id": {
          "type": "string"
        },
        "floating_layer_behaviour": {
          "anyOf": [
            {
              "$ref": "#/definitions/FloatingLayerBehaviour"
            },
            {
              "type": "null"
            }
          ]
        },
        "id": {
          "type": "integer",
          "format": "int"
        },
        "last_focused_workspace": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 0.0
        },
        "name": {
          "type": "string"
        },
        "serial_number_id": {
          "type": [
            "string",
            "null"
          ]
        },
        "size": {
          "$ref": "#/definitions/Rect"
        },
        "wallpaper": {
          "anyOf": [
            {
              "$ref": "#/definitions/Wallpaper"
            },
            {
              "type": "null"
            }
          ]
        },
        "window_based_work_area_offset": {
          "anyOf": [
            {
              "$ref": "#/definitions/Rect"
            },
            {
              "type": "null"
            }
          ]
        },
        "window_based_work_area_offset_limit": {
          "type": "integer",
          "format": "int"
        },
        "work_area_offset": {
          "anyOf": [
            {
              "$ref": "#/definitions/Rect"
            },
            {
              "type": "null"
            }
          ]
        },
        "work_area_size": {
          "$ref": "#/definitions/Rect"
        },
        "workspace_names": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "workspace_padding": {
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "workspaces": {
          "$ref": "#/definitions/Ring_for_Workspace"
        }
      }
    },
    "MonitorNotification": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ResolutionScalingChanged"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "WorkAreaChanged"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "DisplayConnectionChange"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "EnteringSuspendedState"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ResumingFromSuspendedState"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SessionLocked"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SessionUnlocked"
              ]
            }
          }
        }
      ]
    },
    "MoveBehaviour": {
      "oneOf": [
        {
          "description": "Swap the window container with the window container at the edge of the adjacent monitor",
          "type": "string",
          "enum": [
            "Swap"
          ]
        },
        {
          "description": "Insert the window container into the focused workspace on the adjacent monitor",
          "type": "string",
          "enum": [
            "Insert"
          ]
        },
        {
          "description": "Do nothing if trying to move a window container in the direction of an adjacent monitor",
          "type": "string",
          "enum": [
            "NoOp"
          ]
        }
      ]
    },
    "NotificationEvent": {
      "anyOf": [
        {
          "$ref": "#/definitions/WindowManagerEvent"
        },
        {
          "$ref": "#/definitions/SocketMessage"
        },
        {
          "$ref": "#/definitions/MonitorNotification"
        },
        {
          "$ref": "#/definitions/VirtualDesktopNotification"
        }
      ]
    },
    "OperationBehaviour": {
      "oneOf": [
        {
          "description": "Process komorebic commands on temporarily unmanaged/floated windows",
          "type": "string",
          "enum": [
            "Op"
          ]
        },
        {
          "description": "Ignore komorebic commands on temporarily unmanaged/floated windows",
          "type": "string",
          "enum": [
            "NoOp"
          ]
        }
      ]
    },
    "OperationDirection": {
      "type": "string",
      "enum": [
        "Left",
        "Right",
        "Up",
        "Down"
      ]
    },
    "PathBuf": {
      "type": "string"
    },
    "Rect": {
      "type": "object",
      "required": [
        "bottom",
        "left",
        "right",
        "top"
      ],
      "properties": {
        "bottom": {
          "description": "The bottom point in a Win32 Rect",
          "type": "integer",
          "format": "int32"
        },
        "left": {
          "description": "The left point in a Win32 Rect",
          "type": "integer",
          "format": "int32"
        },
        "right": {
          "description": "The right point in a Win32 Rect",
          "type": "integer",
          "format": "int32"
        },
        "top": {
          "description": "The top point in a Win32 Rect",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "Rgb": {
      "type": "object",
      "required": [
        "b",
        "g",
        "r"
      ],
      "properties": {
        "b": {
          "description": "Blue",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "g": {
          "description": "Green",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "r": {
          "description": "Red",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "Ring_for_Container": {
      "type": "object",
      "required": [
        "elements",
        "focused"
      ],
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Container"
          }
        },
        "focused": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      }
    },
    "Ring_for_Monitor": {
      "type": "object",
      "required": [
        "elements",
        "focused"
      ],
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Monitor"
          }
        },
        "focused": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      }
    },
    "Ring_for_Window": {
      "type": "object",
      "required": [
        "elements",
        "focused"
      ],
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Window"
          }
        },
        "focused": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      }
    },
    "Ring_for_Workspace": {
      "type": "object",
      "required": [
        "elements",
        "focused"
      ],
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Workspace"
          }
        },
        "focused": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        }
      }
    },
    "Sizing": {
      "type": "string",
      "enum": [
        "Increase",
        "Decrease"
      ]
    },
    "SocketMessage": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleFocusWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleMoveWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "StackWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "UnstackWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleStack"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleStackIndex"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusStackWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "StackAll"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "UnstackAll"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/OperationDirection"
                },
                {
                  "$ref": "#/definitions/Sizing"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "ResizeWindowEdge"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/Axis"
                },
                {
                  "$ref": "#/definitions/Sizing"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "ResizeWindowAxis"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToLastWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToLastWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleMoveContainerToMonitor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToNamedWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleMoveContainerToWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleSendContainerToMonitor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleSendContainerToWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToMonitorWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveContainerToMonitorWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "SendContainerToNamedWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleMoveWorkspaceToMonitor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveWorkspaceToMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "SwapWorkspacesToMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ForceFocus"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Close"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Minimize"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Promote"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "PromoteFocus"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "PromoteWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "EagerFocus"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "LockMonitorWorkspaceContainer"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "UnlockMonitorWorkspaceContainer"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleLock"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleFloat"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleMonocle"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleMaximize"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleWindowContainerBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleFloatOverride"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/HidingBehaviour"
            },
            "type": {
              "type": "string",
              "enum": [
                "WindowHidingBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleCrossMonitorMoveBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/MoveBehaviour"
            },
            "type": {
              "type": "string",
              "enum": [
                "CrossMonitorMoveBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/OperationBehaviour"
            },
            "type": {
              "type": "string",
              "enum": [
                "UnmanagedWindowOperationBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ManageFocusedWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "UnmanageFocusedWindow"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/Sizing"
                },
                {
                  "type": "integer",
                  "format": "int32"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "AdjustContainerPadding"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/Sizing"
                },
                {
                  "type": "integer",
                  "format": "int32"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "AdjustWorkspacePadding"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/DefaultLayout"
            },
            "type": {
              "type": "string",
              "enum": [
                "ChangeLayout"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleLayout"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/PathBuf"
            },
            "type": {
              "type": "string",
              "enum": [
                "ChangeLayoutCustom"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/Axis"
            },
            "type": {
              "type": "string",
              "enum": [
                "FlipLayout"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleWorkspaceWindowContainerBehaviour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleWorkspaceFloatOverride"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "int32"
                },
                {
                  "type": "integer",
                  "format": "int32"
                },
                {
                  "type": "integer",
                  "format": "int32"
                },
                {
                  "type": "integer",
                  "format": "int32"
                }
              ],
              "maxItems": 5,
              "minItems": 5
            },
            "type": {
              "type": "string",
              "enum": [
                "MonitorIndexPreference"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "DisplayIndexPreference"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "EnsureWorkspaces"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "EnsureNamedWorkspaces"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "NewWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleTiling"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Stop"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "StopIgnoreRestore"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "TogglePause"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "Retile"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "RetileWithResizeDimensions"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "QuickSave"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "QuickLoad"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/PathBuf"
            },
            "type": {
              "type": "string",
              "enum": [
                "Save"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/PathBuf"
            },
            "type": {
              "type": "string",
              "enum": [
                "Load"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleFocusMonitor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleFocusWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/CycleDirection"
            },
            "type": {
              "type": "string",
              "enum": [
                "CycleFocusEmptyWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusMonitorNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "FocusMonitorAtCursor"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "FocusLastWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "CloseWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusWorkspaceNumbers"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusMonitorWorkspaceNumber"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusNamedWorkspace"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "int32"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "ContainerPadding"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "type": "integer",
                  "format": "int32"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "NamedWorkspaceContainerPadding"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int32"
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusedWorkspaceContainerPadding"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "int32"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkspacePadding"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "type": "integer",
                  "format": "int32"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "NamedWorkspacePadding"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int32"
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusedWorkspacePadding"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "boolean"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkspaceTiling"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "type": "boolean"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "NamedWorkspaceTiling"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkspaceName"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "$ref": "#/definitions/DefaultLayout"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkspaceLayout"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/definitions/DefaultLayout"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "NamedWorkspaceLayout"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "$ref": "#/definitions/PathBuf"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkspaceLayoutCustom"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/definitions/PathBuf"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "NamedWorkspaceLayoutCustom"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "$ref": "#/definitions/DefaultLayout"
                }
              ],
              "maxItems": 4,
              "minItems": 4
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkspaceLayoutRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "$ref": "#/definitions/DefaultLayout"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "NamedWorkspaceLayoutRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "$ref": "#/definitions/PathBuf"
                }
              ],
              "maxItems": 4,
              "minItems": 4
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkspaceLayoutCustomRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "$ref": "#/definitions/PathBuf"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "NamedWorkspaceLayoutCustomRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "ClearWorkspaceLayoutRules"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "ClearNamedWorkspaceLayoutRules"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleWorkspaceLayer"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ReloadConfiguration"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/PathBuf"
            },
            "type": {
              "type": "string",
              "enum": [
                "ReplaceConfiguration"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/PathBuf"
            },
            "type": {
              "type": "string",
              "enum": [
                "ReloadStaticConfiguration"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "boolean"
            },
            "type": {
              "type": "string",
              "enum": [
                "WatchConfiguration"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "CompleteConfiguration"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "boolean"
            },
            "type": {
              "type": "string",
              "enum": [
                "AltFocusHack"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/KomorebiTheme"
            },
            "type": {
              "type": "string",
              "enum": [
                "Theme"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "boolean"
                },
                {
                  "anyOf": [
                    {
                      "$ref": "#/definitions/AnimationPrefix"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "Animation"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                },
                {
                  "anyOf": [
                    {
                      "$ref": "#/definitions/AnimationPrefix"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "AnimationDuration"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "AnimationFps"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/AnimationStyle"
                },
                {
                  "anyOf": [
                    {
                      "$ref": "#/definitions/AnimationPrefix"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "AnimationStyle"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "boolean"
            },
            "type": {
              "type": "string",
              "enum": [
                "Border"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WindowKind"
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                }
              ],
              "maxItems": 4,
              "minItems": 4
            },
            "type": {
              "type": "string",
              "enum": [
                "BorderColour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/BorderStyle"
            },
            "type": {
              "type": "string",
              "enum": [
                "BorderStyle"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int32"
            },
            "type": {
              "type": "string",
              "enum": [
                "BorderWidth"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int32"
            },
            "type": {
              "type": "string",
              "enum": [
                "BorderOffset"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/BorderImplementation"
            },
            "type": {
              "type": "string",
              "enum": [
                "BorderImplementation"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "boolean"
            },
            "type": {
              "type": "string",
              "enum": [
                "Transparency"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleTransparency"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            },
            "type": {
              "type": "string",
              "enum": [
                "TransparencyAlpha"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/Rect"
            },
            "type": {
              "type": "string",
              "enum": [
                "InvisibleBorders"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/StackbarMode"
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarMode"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/StackbarLabel"
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarLabel"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarFocusedTextColour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarUnfocusedTextColour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint32",
                  "minimum": 0.0
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarBackgroundColour"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int32"
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarHeight"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int32"
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarTabWidth"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int32"
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarFontSize"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": [
                "string",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "StackbarFontFamily"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/Rect"
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkAreaOffset"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "$ref": "#/definitions/Rect"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "MonitorWorkAreaOffset"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleWindowBasedWorkAreaOffset"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int32"
            },
            "type": {
              "type": "string",
              "enum": [
                "ResizeDelta"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 4,
              "minItems": 4
            },
            "type": {
              "type": "string",
              "enum": [
                "InitialWorkspaceRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "InitialNamedWorkspaceRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 4,
              "minItems": 4
            },
            "type": {
              "type": "string",
              "enum": [
                "WorkspaceRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 3,
              "minItems": 3
            },
            "type": {
              "type": "string",
              "enum": [
                "NamedWorkspaceRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                },
                {
                  "type": "integer",
                  "format": "uint",
                  "minimum": 0.0
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "ClearWorkspaceRules"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "ClearNamedWorkspaceRules"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ClearAllWorkspaceRules"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "EnforceWorkspaceRules"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SessionFloatRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SessionFloatRules"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ClearSessionFloatRules"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "IgnoreRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "ManageRule"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "IdentifyObjectNameChangeApplication"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "IdentifyTrayApplication"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "IdentifyLayeredApplication"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "IdentifyBorderOverflowApplication"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "State"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "GlobalState"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "VisibleWindows"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "MonitorInformation"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/StateQuery"
            },
            "type": {
              "type": "string",
              "enum": [
                "Query"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/FocusFollowsMouseImplementation"
                },
                {
                  "type": "boolean"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusFollowsMouse"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/FocusFollowsMouseImplementation"
            },
            "type": {
              "type": "string",
              "enum": [
                "ToggleFocusFollowsMouse"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "boolean"
            },
            "type": {
              "type": "string",
              "enum": [
                "MouseFollowsFocus"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleMouseFollowsFocus"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/ApplicationIdentifier"
                },
                {
                  "type": "string"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "RemoveTitleBar"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ToggleTitleBars"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "AddSubscriberSocket"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "type": "string"
                },
                {
                  "$ref": "#/definitions/SubscribeOptions"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "AddSubscriberSocketWithOptions"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "RemoveSubscriberSocket"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "AddSubscriberPipe"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "RemoveSubscriberPipe"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ApplicationSpecificConfigurationSchema"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "NotificationSchema"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SocketSchema"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "StaticConfigSchema"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "GenerateStaticConfig"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "integer",
              "format": "int"
            },
            "type": {
              "type": "string",
              "enum": [
                "DebugWindow"
              ]
            }
          }
        }
      ]
    },
    "StackbarLabel": {
      "type": "string",
      "enum": [
        "Process",
        "Title"
      ]
    },
    "StackbarMode": {
      "type": "string",
      "enum": [
        "Always",
        "Never",
        "OnStack"
      ]
    },
    "State": {
      "type": "object",
      "required": [
        "cross_monitor_move_behaviour",
        "float_override",
        "has_pending_raise_op",
        "is_paused",
        "monitor_usr_idx_map",
        "monitors",
        "mouse_follows_focus",
        "new_window_behaviour",
        "resize_delta",
        "unmanaged_window_operation_behaviour"
      ],
      "properties": {
        "cross_monitor_move_behaviour": {
          "$ref": "#/definitions/MoveBehaviour"
        },
        "float_override": {
          "type": "boolean"
        },
        "focus_follows_mouse": {
          "anyOf": [
            {
              "$ref": "#/definitions/FocusFollowsMouseImplementation"
            },
            {
              "type": "null"
            }
          ]
        },
        "has_pending_raise_op": {
          "type": "boolean"
        },
        "is_paused": {
          "type": "boolean"
        },
        "monitor_usr_idx_map": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "uint",
            "minimum": 0.0
          }
        },
        "monitors": {
          "$ref": "#/definitions/Ring_for_Monitor"
        },
        "mouse_follows_focus": {
          "type": "boolean"
        },
        "new_window_behaviour": {
          "$ref": "#/definitions/WindowContainerBehaviour"
        },
        "resize_delta": {
          "type": "integer",
          "format": "int32"
        },
        "unmanaged_window_operation_behaviour": {
          "$ref": "#/definitions/OperationBehaviour"
        },
        "work_area_offset": {
          "anyOf": [
            {
              "$ref": "#/definitions/Rect"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "StateQuery": {
      "type": "string",
      "enum": [
        "FocusedMonitorIndex",
        "FocusedWorkspaceIndex",
        "FocusedContainerIndex",
        "FocusedWindowIndex",
        "FocusedWorkspaceName",
        "FocusedWorkspaceLayout",
        "FocusedContainerKind",
        "Version"
      ]
    },
    "SubscribeOptions": {
      "type": "object",
      "required": [
        "filter_state_changes"
      ],
      "properties": {
        "filter_state_changes": {
          "description": "Only emit notifications when the window manager state has changed",
          "type": "boolean"
        }
      }
    },
    "ThemeOptions": {
      "type": "object",
      "properties": {
        "bar_accent": {
          "description": "Komorebi status bar accent (default: Base0D)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "floating_border": {
          "description": "Border colour when the window is floating (default: Base09)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "monocle_border": {
          "description": "Border colour when the container is in monocle mode (default: Base0F)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "single_border": {
          "description": "Border colour when the container contains a single window (default: Base0D)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "stack_border": {
          "description": "Border colour when the container contains multiple windows (default: Base0B)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "stackbar_background": {
          "description": "Stackbar tab background colour (default: Base01)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "stackbar_focused_text": {
          "description": "Stackbar focused tab text colour (default: Base0B)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "stackbar_unfocused_text": {
          "description": "Stackbar unfocused tab text colour (default: Base05)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "theme_variant": {
          "description": "Specify Light or Dark variant for theme generation (default: Dark)",
          "anyOf": [
            {
              "$ref": "#/definitions/ThemeVariant"
            },
            {
              "type": "null"
            }
          ]
        },
        "unfocused_border": {
          "description": "Border colour when the container is unfocused (default: Base01)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        },
        "unfocused_locked_border": {
          "description": "Border colour when the container is unfocused and locked (default: Base08)",
          "anyOf": [
            {
              "$ref": "#/definitions/Base16Value"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "ThemeVariant": {
      "type": "string",
      "enum": [
        "Dark",
        "Light"
      ]
    },
    "VirtualDesktopNotification": {
      "type": "string",
      "enum": [
        "EnteredAssociatedVirtualDesktop",
        "LeftAssociatedVirtualDesktop"
      ]
    },
    "Wallpaper": {
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "generate_theme": {
          "description": "Generate and apply Base16 theme for this wallpaper (default: true)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "path": {
          "description": "Path to the wallpaper image file",
          "allOf": [
            {
              "$ref": "#/definitions/PathBuf"
            }
          ]
        },
        "theme_options": {
          "description": "Specify Light or Dark variant for theme generation (default: Dark)",
          "anyOf": [
            {
              "$ref": "#/definitions/ThemeOptions"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "WinEvent": {
      "type": "string",
      "enum": [
        "AiaEnd",
        "AiaStart",
        "ConsoleCaret",
        "ConsoleEnd",
        "ConsoleEndApplication",
        "ConsoleLayout",
        "ConsoleStartApplication",
        "ConsoleUpdateRegion",
        "ConsoleUpdateScroll",
        "ConsoleUpdateSimple",
        "ObjectAcceleratorChange",
        "ObjectCloaked",
        "ObjectContentScrolled",
        "ObjectCreate",
        "ObjectDefActionChange",
        "ObjectDescriptionChange",
        "ObjectDestroy",
        "ObjectDragCancel",
        "ObjectDragComplete",
        "ObjectDragDropped",
        "ObjectDragEnter",
        "ObjectDragLeave",
        "ObjectDragStart",
        "ObjectEnd",
        "ObjectFocus",
        "ObjectHelpChange",
        "ObjectHide",
        "ObjectHostedObjectsInvalidated",
        "ObjectImeChange",
        "ObjectImeHide",
        "ObjectImeShow",
        "ObjectInvoked",
        "ObjectLiveRegionChanged",
        "ObjectLocationChange",
        "ObjectNameChange",
        "ObjectParentChange",
        "ObjectReorder",
        "ObjectSelection",
        "ObjectSelectionAdd",
        "ObjectSelectionRemove",
        "ObjectSelectionWithin",
        "ObjectShow",
        "ObjectStateChange",
        "ObjectTextEditConversionTargetChanged",
        "ObjectTextSelectionChanged",
        "ObjectUncloaked",
        "ObjectValueChange",
        "OemDefinedEnd",
        "OemDefinedStart",
        "SystemAlert",
        "SystemArrangementPreview",
        "SystemCaptureEnd",
        "SystemCaptureStart",
        "SystemContextHelpEnd",
        "SystemContextHelpStart",
        "SystemDesktopSwitch",
        "SystemDialogEnd",
        "SystemDialogStart",
        "SystemDragDropEnd",
        "SystemDragDropStart",
        "SystemEnd",
        "SystemForeground",
        "SystemImeKeyNotification",
        "SystemMenuEnd",
        "SystemMenuPopupEnd",
        "SystemMenuPopupStart",
        "SystemMenuStart",
        "SystemMinimizeEnd",
        "SystemMinimizeStart",
        "SystemMoveSizeEnd",
        "SystemMoveSizeStart",
        "SystemScrollingEnd",
        "SystemScrollingStart",
        "SystemSound",
        "SystemSwitchEnd",
        "SystemSwitchStart",
        "SystemSwitcherAppDropped",
        "SystemSwitcherAppGrabbed",
        "SystemSwitcherAppOverTarget",
        "SystemSwitcherCancelled",
        "UiaEventIdSEnd",
        "UiaEventIdStart",
        "UiaPropIdSEnd",
        "UiaPropIdStart"
      ]
    },
    "Window": {
      "type": "object",
      "required": [
        "hwnd"
      ],
      "properties": {
        "hwnd": {
          "type": "integer",
          "format": "int"
        }
      }
    },
    "WindowContainerBehaviour": {
      "oneOf": [
        {
          "description": "Create a new container for each new window",
          "type": "string",
          "enum": [
            "Create"
          ]
        },
        {
          "description": "Append new windows to the focused window container",
          "type": "string",
          "enum": [
            "Append"
          ]
        }
      ]
    },
    "WindowKind": {
      "type": "string",
      "enum": [
        "Single",
        "Stack",
        "Monocle",
        "Unfocused",
        "UnfocusedLocked",
        "Floating"
      ]
    },
    "WindowManagerEvent": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "Destroy"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "FocusChange"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "Hide"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "Cloak"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "Minimize"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "Show"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "Uncloak"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveResizeStart"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "MoveResizeEnd"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "MouseCapture"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/Window"
            },
            "type": {
              "type": "string",
              "enum": [
                "Manage"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/Window"
            },
            "type": {
              "type": "string",
              "enum": [
                "Unmanage"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "$ref": "#/definitions/Window"
            },
            "type": {
              "type": "string",
              "enum": [
                "Raise"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "content": {
              "type": "array",
              "items": [
                {
                  "$ref": "#/definitions/WinEvent"
                },
                {
                  "$ref": "#/definitions/Window"
                }
              ],
              "maxItems": 2,
              "minItems": 2
            },
            "type": {
              "type": "string",
              "enum": [
                "TitleUpdate"
              ]
            }
          }
        }
      ]
    },
    "Workspace": {
      "type": "object",
      "required": [
        "apply_window_based_work_area_offset",
        "containers",
        "floating_windows",
        "latest_layout",
        "layer",
        "layout",
        "layout_rules",
        "locked_containers",
        "resize_dimensions",
        "tile"
      ],
      "properties": {
        "apply_window_based_work_area_offset": {
          "type": "boolean"
        },
        "container_padding": {
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "containers": {
          "$ref": "#/definitions/Ring_for_Container"
        },
        "float_override": {
          "type": [
            "boolean",
            "null"
          ]
        },
        "floating_layer_behaviour": {
          "anyOf": [
            {
              "$ref": "#/definitions/FloatingLayerBehaviour"
            },
            {
              "type": "null"
            }
          ]
        },
        "floating_windows": {
          "$ref": "#/definitions/Ring_for_Window"
        },
        "latest_layout": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Rect"
          }
        },
        "layer": {
          "$ref": "#/definitions/WorkspaceLayer"
        },
        "layout": {
          "$ref": "#/definitions/Layout"
        },
        "layout_flip": {
          "anyOf": [
            {
              "$ref": "#/definitions/Axis"
            },
            {
              "type": "null"
            }
          ]
        },
        "layout_rules": {
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/Layout"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "locked_containers": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint",
            "minimum": 0.0
          },
          "uniqueItems": true
        },
        "maximized_window": {
          "anyOf": [
            {
              "$ref": "#/definitions/Window"
            },
            {
              "type": "null"
            }
          ]
        },
        "maximized_window_restore_idx": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 0.0
        },
        "monocle_container": {
          "anyOf": [
            {
              "$ref": "#/definitions/Container"
            },
            {
              "type": "null"
            }
          ]
        },
        "monocle_container_restore_idx": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 0.0
        },
        "name": {
          "type": [
            "string",
            "null"
          ]
        },
        "resize_dimensions": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/Rect"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "tile": {
          "type": "boolean"
        },
        "wallpaper": {
          "anyOf": [
            {
              "$ref": "#/definitions/Wallpaper"
            },
            {
              "type": "null"
            }
          ]
        },
        "window_container_behaviour": {
          "anyOf": [
            {
              "$ref": "#/definitions/WindowContainerBehaviour"
            },
            {
              "type": "null"
            }
          ]
        },
        "window_container_behaviour_rules": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/WindowContainerBehaviour"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "workspace_config": {
          "anyOf": [
            {
              "$ref": "#/definitions/WorkspaceConfig"
            },
            {
              "type": "null"
            }
          ]
        },
        "workspace_padding": {
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        }
      }
    },
    "WorkspaceConfig": {
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "apply_window_based_work_area_offset": {
          "description": "Apply this monitor's window-based work area offset (default: true)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "container_padding": {
          "description": "Container padding (default: global)",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "custom_layout": {
          "description": "END OF LIFE FEATURE: Custom Layout (default: None)",
          "anyOf": [
            {
              "$ref": "#/definitions/PathBuf"
            },
            {
              "type": "null"
            }
          ]
        },
        "custom_layout_rules": {
          "description": "END OF LIFE FEATURE: Custom layout rules (default: None)",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "string"
          }
        },
        "float_override": {
          "description": "Enable or disable float override, which makes it so every new window opens in floating mode (default: false)",
          "type": [
            "boolean",
            "null"
          ]
        },
        "floating_layer_behaviour": {
          "description": "Determine what happens to a new window when the Floating workspace layer is active (default: Tile)",
          "anyOf": [
            {
              "$ref": "#/definitions/FloatingLayerBehaviour"
            },
            {
              "type": "null"
            }
          ]
        },
        "initial_workspace_rules": {
          "description": "Initial workspace application rules",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/MatchingRule"
          }
        },
        "layout": {
          "description": "Layout (default: BSP)",
          "anyOf": [
            {
              "$ref": "#/definitions/DefaultLayout"
            },
            {
              "type": "null"
            }
          ]
        },
        "layout_flip": {
          "description": "Specify an axis on which to flip the selected layout (default: None)",
          "anyOf": [
            {
              "$ref": "#/definitions/Axis"
            },
            {
              "type": "null"
            }
          ]
        },
        "layout_rules": {
          "description": "Layout rules in the format of threshold => layout (default: None)",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/DefaultLayout"
          }
        },
        "name": {
          "description": "Name",
          "type": "string"
        },
        "wallpaper": {
          "description": "Specify a wallpaper for this workspace",
          "anyOf": [
            {
              "$ref": "#/definitions/Wallpaper"
            },
            {
              "type": "null"
            }
          ]
        },
        "window_container_behaviour": {
          "description": "Determine what happens when a new window is opened (default: Create)",
          "anyOf": [
            {
              "$ref": "#/definitions/WindowContainerBehaviour"
            },
            {
              "type": "null"
            }
          ]
        },
        "window_container_behaviour_rules": {
          "description": "Window container behaviour rules in the format of threshold => behaviour (default: None)",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/WindowContainerBehaviour"
          }
        },
        "workspace_padding": {
          "description": "Workspace padding (default: global)",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "workspace_rules": {
          "description": "Permanent workspace application rules",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/MatchingRule"
          }
        }
      }
    },
    "WorkspaceLayer": {
      "type": "string",
      "enum": [
        "Tiling",
        "Floating"
      ]
    }
  }
}

C:\Users\codyj>                      
=========
Here is what I expect our proof of concept to do. Baby steps on the way here are ok, but here is the end state
when I change workspaces, it should be a single like detection with the IDs and names
Example, 
Workspace Changed to "Name", ID 0, Monitor 0 via FocusMonitorWorkspaceNumber
Any window location change like move or send should do the same
window hwnd X move/send to Workspace Name, ID 2, Monitor 1, detected via MoveContainerToWorkspaceNumber args=[0] 

Also, we are no longer getting hwnd -> workpsace pairs. we never did in our proof of concept, but komorebi_sub does. this helps us keep a good up to date cache even when workspaces dont change. so I should expect to see that logged to
Focus Changed to HWND X in Workspace Name, ID 0, Monitor 2

I've given you the full JSON. Also check it to make sure our map of event types for what constitutes a workspace change or window move covers all relevant events. and see if you can find the event we need for just focus change in workspace

is there anything else in the schema of use to us in our proof of concept or full sub/pump setup or full alt-tab app that we should capture in the POC? 
take your maximum time, think this through

Dont bother patching the old version, weve done so too many times, give me a full new proof of concept. 
gottta clean up some syntax errors. remember this is AHKv2

in this block
    ; find first '{'
    local start := InStr(s, "{")
    if (!start) {
        ; no object start; keep buffer bounded
        if (StrLen(s) > 1_000_000)
            s := ""
        return ""
    }

it doesnt like 
        if (StrLen(s) > 1_000_000)
invalid symbol naming 1_000_000

In this block
        if (loc.mon >= 0 && loc.ws >= 0) {
            nm := loc.name
            if (nm = "")
                nm := _State_GetWorkspaceName(stateObj, loc.mon, loc.ws)
            Log("Focus Changed to HWND " . hwnd . " in Workspace """ . nm . """, ID " . loc.ws . ", Monitor " . loc.mon . " via FocusChange")
        } else {
            Log("Focus Changed to HWND " . hwnd . " (workspace unresolved) via FocusChange")
        }
it doesnt like the """


in this block
        if (haveDest && nm != "" && wsIdx >= 0 && monIdx >= 0) {
            Log("windowmap hwnd " . (hwnd ? hwnd : "unknown") . " -> workspace """ . nm . """ (ID " . wsIdx . ", Monitor " . monIdx . ") via " . t)
        } else {
            Log("windowmap target unresolved via " . t . " args=" . contentRaw)
        }
it doesnt like the """
more syntax errors

global PipeName     := "tabby_poc_" . A_TickCount . "_" . A_PID
A_PID is never assigned a value

    Log("=== komorebi-poc exiting (" . (A_ExitReason ? A_ExitReason : "Normal") . ") ===")
A_ExitReason never assigned a value


and again here
Error: This local variable has not been assigned a value.
A global declaration inside the function may be required.

Specifically: gPipe

	094: If (gConnected && gPipe)
	095: DllCall("FlushFileBuffers", "Ptr", gPipe, "Int")
▶	096: If (gPipe)
	096: {
	097: DllCall("DisconnectNamedPipe", "Ptr", gPipe, "Int")

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (96) : [Cleanup] If (gPipe)
> OnExit
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (45) : [ExitApp] ExitApp()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (45) : [Main] ExitApp()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (52) : [] Main()
> Auto-execute
dude
global PipeName := "tabby_poc_" . A_TickCount . "_" . A_Pid
doenst fix anything. A.Pid is still not yet declared by that point in the file

generates a warning
Warning: This global variable appears to never be assigned a value.

Specifically: A_Pid

	008: KomorebicExe := "C:\Program Files\komorebi\bin\komorebic.exe"
▶	009: PipeName := "tabby_poc_" . A_TickCount . "_" . A_Pid
	010: LogPath := A_ScriptDir . "\komorebi_poc.log"
	011: ReadChunk := 32768

For more details, read the documentation for #Warn.

worse off, if i continue pass the warning , I get this error

Error: This global variable has not been assigned a value.

Specifically: PipeName

	027: Log("=== komorebi-poc starting ===")
	028: Log("KomorebicExe = " . KomorebicExe)
▶	029: Log("PipeName     = " . PipeName)
	030: Log("Log file     = " . LogPath)
	032: If !FileExist(KomorebicExe)

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (29) : [Main] Log("PipeName     = " . PipeName)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Main()
> Auto-execute

and of course these pipe name errors result in the whole app failing
2025-09-12 23:01:40.fff  === komorebi-poc starting ===
2025-09-12 23:01:40.fff  KomorebicExe = C:\Program Files\komorebi\bin\komorebic.exe
2025-09-12 23:01:56.fff  Log file     = C:\Users\codyj\Desktop\tabby\komorebi_poc.log
2025-09-12 23:02:00.fff  Pipe created. Waiting for client to connect …
2025-09-12 23:02:00.fff  WARN: failed to spawn client: This global variable has not been assigned a value.
2025-09-12 23:02:00.fff  Start it manually in a terminal:
2025-09-12 23:02:01.fff  ERROR: ConnectNamedPipe failed (GLE=6)
2025-09-12 23:02:01.fff  === komorebi-poc exiting (Exit) ===
dude this code is a shitshow. stop telling me to patch it, you created it, fix it.
===========
#Requires AutoHotkey v2.0
; ---------------------------------------------------------------------------
; komorebi POC subscriber (AHK v2) — logs workspace changes, window moves/sends,
; and focus changes (HWND->workspace) with names and indices.
; ---------------------------------------------------------------------------

#Warn
#SingleInstance Force
SetWorkingDir A_ScriptDir

; --- Globals (declared; most are initialized in Main) ---
global KomorebicExe := "C:\Program Files\komorebi\bin\komorebic.exe"
global LogPath      := A_ScriptDir . "\komorebi_poc.log"
global ReadChunk    := 32768

; defer PipeName until after we know the script is running
global PipeName     := ""          ; will be set in Main()
global gPipe        := 0
global gConnected   := false
global gClientPid   := 0
global gLastWsName  := ""
global gLastWsIdx   := -1
global gLastMonIdx  := -1
global gOut := 0

OnExit(Cleanup)
Main()
return


Main() {
    global PipeName, KomorebicExe, LogPath
    if (!PipeName) {
        ; Use the current script PID without touching A_Pid (avoids #Warn noise)
        pid := ProcessExist()
        PipeName := "tabby_poc_" . A_TickCount . "_" . pid
    }

    Log("=== komorebi-poc starting ===")
    Log("KomorebicExe = " . KomorebicExe)
    Log("PipeName     = " . PipeName)
    Log("Log file     = " . LogPath)

    if !FileExist(KomorebicExe) {
        Log("ERROR: komorebic not found: " . KomorebicExe)
        ExitApp
    }

    CreatePipe()
    TrySpawnClient()
    WaitForClient()         ; blocks until client connects (or fast-fails)
    SetTimer(Tick, 50)      ; start reader loop
}

Main()

CreatePipe() {
    global PipeName, gPipe, KomorebicExe

    local name := "\\.\pipe\" . PipeName
    ; PIPE_ACCESS_INBOUND (server reads), byte/byte/wait, instances=1
    gPipe := DllCall("CreateNamedPipe"
        , "Str",  name
        , "UInt", 0x00000001           ; PIPE_ACCESS_INBOUND
        , "UInt", 0x00000000           ; PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT
        , "UInt", 1
        , "UInt", 65536, "UInt", 65536
        , "UInt", 0
        , "Ptr",  0
        , "Ptr")

    if (gPipe = 0 || gPipe = -1) {
        gle := A_LastError
        Log("ERROR: CreateNamedPipe failed (GLE=" . gle . ")")
        ExitApp
    }
    Log("Pipe created. Waiting for client to connect …")
    Log("You can also run manually: " . KomorebicExe . " subscribe-pipe " . PipeName)
}


; ---------- PIPE LIFECYCLE ----------
CreatePipeServer(name) {
    global gPipe
    local path := "\\.\pipe\" . name
    ; PIPE_ACCESS_INBOUND(0x00000001), PIPE_TYPE_BYTE(0x0), PIPE_READMODE_BYTE(0x0), PIPE_WAIT(0x0)
    gPipe := DllCall("CreateNamedPipe"
        , "Str", path
        , "UInt", 0x00000001            ; dwOpenMode
        , "UInt", 0x00000000            ; dwPipeMode
        , "UInt", 1                     ; nMaxInstances
        , "UInt", 0                     ; nOutBufferSize
        , "UInt", 64*1024               ; nInBufferSize
        , "UInt", 0                     ; nDefaultTimeOut
        , "Ptr",  0                     ; lpSecurityAttributes
        , "Ptr")
    return gPipe != 0
}

WaitForClient() {
    global gPipe, gConnected

    local ok := DllCall("ConnectNamedPipe", "Ptr", gPipe, "Ptr", 0, "Int")
    if (!ok) {
        gle := A_LastError
        if (gle = 535) {  ; ERROR_PIPE_CONNECTED
            gConnected := true
            Log("Client connected (already).")
            return
        }
        Log("ERROR: ConnectNamedPipe failed (GLE=" . gle . ")")
        ExitApp
    }
    gConnected := true
    Log("Client connected.")
}


TrySpawnClient() {
    global gClientPid, KomorebicExe, PipeName
    try {
        cmd := '"' . KomorebicExe . '" subscribe-pipe ' . PipeName
        gClientPid := Run(cmd, , "Hide")
        Log("Spawned subscriber: pid=" . gClientPid . " -> " . cmd)
    } catch as e {
        Log("WARN: failed to spawn client: " . e.Message)
        Log("Start it manually in a terminal:")
        Log("  " . KomorebicExe . " subscribe-pipe " . PipeName)
    }
}


Cleanup(reason := "", code := 0) {
    global gPipe, gConnected
    try {
        Log("=== komorebi-poc exiting (" . (reason != "" ? reason : "Normal") . ") ===")

        if (gConnected && gPipe)
            DllCall("FlushFileBuffers", "Ptr", gPipe)

        if (gPipe) {
            DllCall("DisconnectNamedPipe", "Ptr", gPipe)
            DllCall("CloseHandle", "Ptr", gPipe)
            gPipe := 0
        }
    } catch as e {
        ; ignore errors on shutdown
    }
}




GetLastError() => DllCall("GetLastError")

; ---------- LOGGING ----------
Log(msg) {
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff")
    FileAppend(ts . "  " . msg . "rn", LogPath, "UTF-8")
}

; ---------- TIMER: PUMP PIPE ----------
PumpPipe() {
    if (!gPipe)
        return

    ; Non-blocking peek to see how much to read
    local bytesRead := 0, totalAvail := 0, leftMsg := 0
    ok := DllCall("PeekNamedPipe", "Ptr", gPipe, "Ptr", 0, "UInt", 0, "UInt*", &bytesRead, "UInt*", &totalAvail, "UInt*", &leftMsg, "Int")
    if (!ok) {
        Log("PeekNamedPipe failed: GLE=" . GetLastError())
        return
    }
    if (totalAvail = 0)
        return

    ; Read what's available (cap to a chunk to avoid giant allocs)
    local toRead := (totalAvail > ReadChunk) ? ReadChunk : totalAvail
    buf := Buffer(toRead, 0)
    local got := 0
    ok := DllCall("ReadFile", "Ptr", gPipe, "Ptr", buf, "UInt", toRead, "UInt*", &got, "Ptr", 0, "Int")
    if (!ok) {
        Log("ReadFile failed: GLE=" . GetLastError())
        return
    }
    if (got > 0) {
        piece := StrGet(buf.Ptr, got, "UTF-8")
        gBuf .= piece
    }

    ; Extract as many complete JSON objects as possible
    while true {
        json := _ExtractOneJsonFromBuffer(&gBuf)
        if (json = "")
            break
        HandleNotification(json)
    }
}

; ---------- JSON-ish HELPERS (balanced scans, minimal decoding) ----------
_ExtractOneJsonFromBuffer(&s) {
    if (s = "")
        return ""

    ; find first '{'
    local start := InStr(s, "{")
    if (!start) {
        ; no object start; keep buffer bounded
        if (StrLen(s) > 1000000)
            s := ""
        return ""
    }

    ; scan for matching closing '}' at depth 0, skipping strings
    local i := start, depth := 0, inStr := false
    while (i <= StrLen(s)) {
        ch := SubStr(s, i, 1)
        if (!inStr) {
            if (ch = '"') {
                inStr := true
            } else if (ch = "{") {
                depth += 1
            } else if (ch = "}") {
                depth -= 1
                if (depth = 0) {
                    obj := SubStr(s, start, i - start + 1)
                    s := SubStr(s, i + 1)
                    return obj
                }
            }
        } else {
            if (ch = '"' && SubStr(s, i - 1, 1) != "\")
                inStr := false
        }
        i += 1
    }
    ; incomplete, wait for more data
    return ""
}

_Json_ExtractObjectByKey(text, key) {
    ; returns the balanced {...} value for "key": { ... }
    pat := '(?s)"' . key . '"\s*:\s*\{'
    m := 0
    if !RegExMatch(text, pat, &m)
        return ""
    start := m.Pos(0) + m.Len(0) - 1  ; at '{'
    return _BalancedObjectFrom(text, start)
}

_Json_ExtractArrayByKey(text, key) {
    pat := '(?s)"' . key . '"\s*:\s*\['
    m := 0
    if !RegExMatch(text, pat, &m)
        return ""
    start := m.Pos(0) + m.Len(0) - 1 ; at '['
    return _BalancedArrayFrom(text, start)
}

_BalancedObjectFrom(text, bracePos) {
    ; bracePos points to '{'
    local i := bracePos, depth := 0, inStr := false
    while (i <= StrLen(text)) {
        ch := SubStr(text, i, 1)
        if (!inStr) {
            if (ch = '"') {
                inStr := true
            } else if (ch = "{") {
                depth += 1
            } else if (ch = "}") {
                depth -= 1
                if (depth = 0)
                    return SubStr(text, bracePos, i - bracePos + 1)
            }
        } else {
            if (ch = '"' && SubStr(text, i - 1, 1) != "\")
                inStr := false
        }
        i += 1
    }
    return ""
}

_BalancedArrayFrom(text, brackPos) {
    ; brackPos points to '['
    local i := brackPos, depth := 0, inStr := false
    while (i <= StrLen(text)) {
        ch := SubStr(text, i, 1)
        if (!inStr) {
            if (ch = '"') {
                inStr := true
            } else if (ch = "[") {
                depth += 1
            } else if (ch = "]") {
                depth -= 1
                if (depth = 0)
                    return SubStr(text, brackPos, i - brackPos + 1)
            }
        } else {
            if (ch = '"' && SubStr(text, i - 1, 1) != "\")
                inStr := false
        }
        i += 1
    }
    return ""
}

_ArrayTopLevelSplit(arrayText) {
    ; Input: string like [ {...}, {...}, ... ]
    ; Output: array of element strings (without commas), preserving braces
    res := []
    if (arrayText = "")
        return res
    if (SubStr(arrayText, 1, 1) = "[")
        arrayText := SubStr(arrayText, 2)
    if (SubStr(arrayText, -1) = "]")
        arrayText := SubStr(arrayText, 1, -1)

    local i := 1, depthObj := 0, depthArr := 0, inStr := false, start := 1
    while (i <= StrLen(arrayText)) {
        ch := SubStr(arrayText, i, 1)
        if (!inStr) {
            if (ch = '"') {
                inStr := true
            } else if (ch = "{") {
                depthObj += 1
            } else if (ch = "}") {
                depthObj -= 1
            } else if (ch = "[") {
                depthArr += 1
            } else if (ch = "]") {
                depthArr -= 1
            } else if (ch = "," && depthObj = 0 && depthArr = 0) {
                piece := Trim(SubStr(arrayText, start, i - start))
                if (piece != "")
                    res.Push(piece)
                start := i + 1
            }
        } else {
            if (ch = '"' && SubStr(arrayText, i - 1, 1) != "\")
                inStr := false
        }
        i += 1
    }
    last := Trim(SubStr(arrayText, start))
    if (last != "")
        res.Push(last)
    return res
}

_Json_GetStringProp(objText, key) {
    m := 0
    if RegExMatch(objText, '(?s)"' . key . '"\s*:\s*"((?:\\.|[^"])*)"', &m)
        return _UnescapeJson(m[1])
    return ""
}
_Json_GetIntProp(objText, key) {
    m := 0
    if RegExMatch(objText, '(?s)"' . key . '"\s*:\s*(-?\d+)', &m)
        return Integer(m[1])
    return ""
}
_UnescapeJson(s) {
    ; minimal unescape for quotes and backslashes + common escapes
    s := StrReplace(s, '\"', '"')
    s := StrReplace(s, '\\', '\')
    s := StrReplace(s, '\/', '/')
    s := StrReplace(s, '\b', Chr(8))
    s := StrReplace(s, '\f', Chr(12))
    s := StrReplace(s, '\n', "n")
    s := StrReplace(s, '\r', "r")
    s := StrReplace(s, '\t', "t")
    return s
}

; ---------- EVENT PARSING ----------
_GetEventType(evtText) {
    m := 0
    if RegExMatch(evtText, '(?s)"type"\s*:\s*"([^"]+)"', &m)
        return m[1]
    return ""
}

_GetEventContentRaw(evtText) {
    ; returns: "", number string, quoted string, [array], {object}
    ; We only need array/int/string types for our use-cases.
    ; Try array first
    arr := _Json_ExtractArrayByKey(evtText, "content")
    if (arr != "")
        return arr
    ; Try quoted string
    m := 0
    if RegExMatch(evtText, '(?s)"content"\s*:\s*"((?:\\.|[^"])*)"', &m)
        return '"' . m[1] . '"'
    ; Integer
    if RegExMatch(evtText, '(?s)"content"\s*:\s*(-?\d+)', &m)
        return m[1]
    ; Object
    obj := _Json_ExtractObjectByKey(evtText, "content")
    if (obj != "")
        return obj
    return ""
}

_ParseContentToArray(contentRaw) {
    ; Normalize content to an Array of positional args:
    ; - "[1,2]" => [1,2]
    ; - "123"   => [123]
    ; - "\"Name\"" => ["Name"]
    ; - "{...}" => ["{...}"] (used by FocusChange second param object)
    args := []
    if (contentRaw = "")
        return args
    if (SubStr(contentRaw, 1, 1) = "[") {
        list := _ArrayTopLevelSplit(contentRaw)
        for each, it in list {
            it := Trim(it)
            if (SubStr(it, 1, 1) = '"') {
                args.Push(_UnescapeJson(SubStr(it, 2, -1)))
            } else if RegExMatch(it, '^-?\d+$') {
                args.Push(Integer(it))
            } else {
                args.Push(it) ; raw (object etc)
            }
        }
        return args
    }
    if (SubStr(contentRaw, 1, 1) = '"') {
        args.Push(_UnescapeJson(SubStr(contentRaw, 2, -1)))
        return args
    }
    if RegExMatch(contentRaw, '^-?\d+$') {
        args.Push(Integer(contentRaw))
        return args
    }
    args.Push(contentRaw)
    return args
}

; ---------- STATE HELPERS ----------
; Return monitors ring object + array of monitor objects + focused monitor idx
_State_GetMonitorsRing(stateText) {
    ring := _Json_ExtractObjectByKey(stateText, "monitors")
    return ring
}

_State_GetMonitorsArray(stateText) {
    ring := _State_GetMonitorsRing(stateText)
    elems := _Json_ExtractArrayByKey(ring, "elements")
    return _ArrayTopLevelSplit(elems)
}

_State_GetFocusedMonitorIndex(stateText) {
    ring := _State_GetMonitorsRing(stateText)
    return _Json_GetIntProp(ring, "focused")
}

_State_GetWorkspaceRingForMonitor(monObjText) {
    return _Json_ExtractObjectByKey(monObjText, "workspaces")
}

_State_GetWorkspaceArrayForMonitor(monObjText) {
    wsRing := _State_GetWorkspaceRingForMonitor(monObjText)
    wsArr := _Json_ExtractArrayByKey(wsRing, "elements")
    return _ArrayTopLevelSplit(wsArr)
}

_State_GetFocusedWorkspaceIndexForMonitor(monObjText) {
    wsRing := _State_GetWorkspaceRingForMonitor(monObjText)
    return _Json_GetIntProp(wsRing, "focused")
}

_State_GetWorkspaceName(stateText, monIdx, wsIdx) {
    mons := _State_GetMonitorsArray(stateText)
    if (monIdx < 0 || monIdx >= mons.Length)
        return ""
    monObj := mons[monIdx]
    wsArr := _State_GetWorkspaceArrayForMonitor(monObj)
    if (wsIdx < 0 || wsIdx >= wsArr.Length)
        return ""
    wsObj := wsArr[wsIdx]
    name := _Json_GetStringProp(wsObj, "name")
    if (name = "") {
        ; fallback: monitor.workspace_names { "N": "Name" }
        map := _Json_ExtractObjectByKey(monObj, "workspace_names")
        m := 0
        if RegExMatch(map, '(?s)"' . wsIdx . '"\s*:\s*"((?:\\.|[^"])*)"', &m)
            name := _UnescapeJson(m[1])
    }
    return name
}

_State_FindWorkspaceByName(stateText, wsName) {
    ; Search all monitors for workspace by "name"
    mons := _State_GetMonitorsArray(stateText)
    for mi, monObj in mons {
        wsArr := _State_GetWorkspaceArrayForMonitor(monObj)
        for wi, wsObj in wsArr {
            name := _Json_GetStringProp(wsObj, "name")
            if (name != "" && StrLower(name) = StrLower(wsName))
                return { mon: mi-1, ws: wi-1, name: name } ; arrays are 1-based in AHK; indices here 0-based
        }
        ; fallback: workspace_names mapping
        map := _Json_ExtractObjectByKey(monObj, "workspace_names")
        m := 0, pos := 1
        while RegExMatch(map, '(?s)"(\d+)"\s*:\s*"((?:\\.|[^"])*)"', &m, pos) {
            idx := Integer(m[1]), nm := _UnescapeJson(m[2])
            if (StrLower(nm) = StrLower(wsName))
                return { mon: mi-1, ws: idx, name: nm }
            pos := m.Pos(0) + m.Len(0)
        }
    }
    return { mon: -1, ws: -1, name: "" }
}

_State_FindWorkspaceOfHwnd(stateText, hwnd) {
    if (!hwnd)
        return { mon: -1, ws: -1, name: "" }
    mons := _State_GetMonitorsArray(stateText)
    for mi, monObj in mons {
        wsArr := _State_GetWorkspaceArrayForMonitor(monObj)
        for wi, wsObj in wsArr {
            ; quick search for "hwnd": <value> inside this workspace object
            if RegExMatch(wsObj, '(?s)"hwnd"\s*:\s*' . hwnd) {
                nm := _Json_GetStringProp(wsObj, "name")
                return { mon: mi-1, ws: wi-1, name: nm }
            }
        }
    }
    return { mon: -1, ws: -1, name: "" }
}

_State_GetFocusedHwnd(stateText) {
    ; Try windows ring: { "elements":[{"hwnd":...},...], "focused":N }
    winRing := _Json_ExtractObjectByKey(stateText, "windows")
    if (winRing != "") {
        idx := _Json_GetIntProp(winRing, "focused")
        arr := _Json_ExtractArrayByKey(winRing, "elements")
        if (arr != "") {
            list := _ArrayTopLevelSplit(arr)
            if (idx >= 0 && idx < list.Length) {
                wobj := list[idx+1]
                return _Json_GetIntProp(wobj, "hwnd")
            }
        }
    }
    ; Other known fallbacks (some builds):
    m := 0
    if RegExMatch(stateText, '(?s)"focused_window"\s*:\s*\{[^}]*"hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    if RegExMatch(stateText, '(?s)"focused_hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    if RegExMatch(stateText, '(?s)"last_focused_window"\s*:\s*\{[^}]*"hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    return 0
}

; ---------- EVENT TYPE GROUPS ----------
IsWorkspaceFocusEvent(t) {
    static S := Map(
        "FocusNamedWorkspace", true,
        "FocusWorkspaceNumber", true,
        "FocusWorkspaceNumbers", true,
        "FocusLastWorkspace", true,
        "CycleFocusWorkspace", true,
        "CycleFocusEmptyWorkspace", true,
        "FocusMonitorWorkspaceNumber", true,
        "FocusMonitorAtCursor", true,
        "FocusMonitorNumber", true,
        "CycleFocusMonitor", true
    )
    return S.Has(t)
}

IsWindowMoveSendEvent(t) {
    static S := Map(
        "MoveContainerToNamedWorkspace", true,
        "SendContainerToNamedWorkspace", true,
        "MoveContainerToWorkspaceNumber", true,
        "SendContainerToWorkspaceNumber", true,
        "MoveContainerToMonitorWorkspaceNumber", true,
        "SendContainerToMonitorWorkspaceNumber", true,
        "CycleMoveContainerToWorkspace", true,
        "CycleSendContainerToWorkspace", true,
        "CycleMoveContainerToMonitor", true,
        "CycleSendContainerToMonitor", true,
        "MoveContainerToMonitorNumber", true,
        "SendContainerToMonitorNumber", true,
        "MoveContainerToLastWorkspace", true,
        "SendContainerToLastWorkspace", true
    )
    return S.Has(t)
}

; ---------- HANDLE EACH NOTIFICATION ----------
HandleNotification(jsonLine) {
    ; jsonLine is a single full notification object
    evtObj := _Json_ExtractObjectByKey(jsonLine, "event")
    stateObj := _Json_ExtractObjectByKey(jsonLine, "state")
    if (evtObj = "" || stateObj = "") {
        Log("WARN: notification missing event or state")
        return
    }

    t := _GetEventType(evtObj)
    contentRaw := _GetEventContentRaw(evtObj)
    args := _ParseContentToArray(contentRaw)

    ; 1) Focus changes at the window level (WindowManagerEvent: FocusChange)
    if (t = "FocusChange") {
        ; content = [ WinEventName, { "hwnd": N } ]
        hwnd := 0
        if (args.Length >= 2) {
            obj := args[2]
            if (SubStr(obj, 1, 1) = "{")
                hwnd := _Json_GetIntProp(obj, "hwnd")
        }
        if (!hwnd) {
            ; fallback to state
            hwnd := _State_GetFocusedHwnd(stateObj)
        }
        loc := _State_FindWorkspaceOfHwnd(stateObj, hwnd)
        if (loc.mon >= 0 && loc.ws >= 0) {
            nm := loc.name
            if (nm = "")
                nm := _State_GetWorkspaceName(stateObj, loc.mon, loc.ws)
                Log("Focus Changed to HWND " . hwnd . " in Workspace " . Chr(34) . nm . Chr(34) . ", ID " . loc.ws . ", Monitor " . loc.mon . " via FocusChange")
        } else {
            Log("Focus Changed to HWND " . hwnd . " (workspace unresolved) via FocusChange")
        }
        return
    }

    ; 2) Workspace focus family
    if IsWorkspaceFocusEvent(t) {
        monIdx := _State_GetFocusedMonitorIndex(stateObj)
        wsIdx := -1
        resolved := false
        nm := ""

        switch t {
        case "FocusMonitorWorkspaceNumber":
            ; args = [mon, ws]
            if (args.Length >= 2) {
                monIdx := Integer(args[1])
                wsIdx := Integer(args[2])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                resolved := (nm != "")
                Log('Workspace Changed to "' . (nm != "" ? nm : "?") . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t . " args=" . contentRaw)
            } else {
                Log("workspace change signal via " . t . " args=" . contentRaw . " (malformed)")
            }
            return
        case "FocusWorkspaceNumber", "FocusWorkspaceNumbers":
            if (args.Length >= 1) {
                wsIdx := Integer(args[1])
                ; if this event doesn’t include monitor, take focused monitor from state
                monIdx := _State_GetFocusedMonitorIndex(stateObj)
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                Log('Workspace Changed to "' . (nm != "" ? nm : "?") . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t)
            } else {
                Log("workspace change signal via " . t . " (no args)")
            }
            return
        case "FocusNamedWorkspace":
            if (args.Length >= 1) {
                want := args[1]
                loc := _State_FindWorkspaceByName(stateObj, want)
                if (loc.mon >= 0) {
                    Log('Workspace Changed to "' . loc.name . '", ID ' . loc.ws . ", Monitor " . loc.mon . " via " . t)
                } else {
                    ; fall back to focused monitor & workspace
                    monIdx := _State_GetFocusedMonitorIndex(stateObj)
                    mons := _State_GetMonitorsArray(stateObj)
                    nm := ""
                    wsIdx := -1
                    if (monIdx >= 0 && monIdx < mons.Length) {
                        wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                        nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                    }
                    Log('Workspace Changed to "' . (nm != "" ? nm : want) . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t)
                }
            } else {
                Log("workspace change signal via " . t . " (no name)")
            }
            return
        case "FocusMonitorNumber":
            if (args.Length >= 1) {
                monIdx := Integer(args[1])
                mons := _State_GetMonitorsArray(stateObj)
                wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                Log('Workspace Changed to "' . (nm != "" ? nm : "?") . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t)
            } else {
                Log("workspace change signal via " . t . " (no monitor)")
            }
            return
        case "FocusMonitorAtCursor", "CycleFocusWorkspace", "CycleFocusEmptyWorkspace", "FocusLastWorkspace", "CycleFocusMonitor":
            monIdx := _State_GetFocusedMonitorIndex(stateObj)
            mons := _State_GetMonitorsArray(stateObj)
            if (monIdx >= 0 && monIdx < mons.Length) {
                wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                Log('Workspace Changed to "' . (nm != "" ? nm : "?") . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t)
            } else {
                Log("workspace change signal via " . t . " (name unresolved)")
            }
            return
        }

        ; default: fallthrough (shouldn’t get here)
        Log("workspace change signal via " . t . " args=" . contentRaw . " (name unresolved)")
        return
    }

    ; 3) Window move/send family
    if IsWindowMoveSendEvent(t) {
        ; Try to figure out destination monitor/workspace from args/state
        monIdx := _State_GetFocusedMonitorIndex(stateObj) ; default assumption
        wsIdx := -1
        nm := ""
        haveDest := false

        if (t = "MoveContainerToMonitorWorkspaceNumber" || t = "SendContainerToMonitorWorkspaceNumber") {
            if (args.Length >= 2) {
                monIdx := Integer(args[1])
                wsIdx := Integer(args[2])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                haveDest := true
            }
        } else if (t = "MoveContainerToWorkspaceNumber" || t = "SendContainerToWorkspaceNumber") {
            if (args.Length >= 1) {
                wsIdx := Integer(args[1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                haveDest := true
            }
        } else if (t = "MoveContainerToNamedWorkspace" || t = "SendContainerToNamedWorkspace") {
            if (args.Length >= 1) {
                want := args[1]
                loc := _State_FindWorkspaceByName(stateObj, want)
                if (loc.mon >= 0) {
                    monIdx := loc.mon, wsIdx := loc.ws, nm := loc.name
                    haveDest := true
                }
            }
        } else if (InStr(t, "CycleMoveContainerToMonitor") || InStr(t, "CycleSendContainerToMonitor")) {
            ; after the cycle, state should reflect the focused monitor & its focused workspace
            monIdx := _State_GetFocusedMonitorIndex(stateObj)
            mons := _State_GetMonitorsArray(stateObj)
            if (monIdx >= 0 && monIdx < mons.Length) {
                wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                haveDest := true
            }
        } else if (InStr(t, "CycleMoveContainerToWorkspace") || InStr(t, "CycleSendContainerToWorkspace") || t = "MoveContainerToLastWorkspace" || t = "SendContainerToLastWorkspace") {
            ; same — use post-state focused ws on focused monitor
            monIdx := _State_GetFocusedMonitorIndex(stateObj)
            mons := _State_GetMonitorsArray(stateObj)
            if (monIdx >= 0 && monIdx < mons.Length) {
                wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                haveDest := true
            }
        }

        Log("window move/send detected via " . t . " args=" . contentRaw)

        hwnd := _State_GetFocusedHwnd(stateObj) ; best-effort — often the moved window
        if (haveDest && nm != "" && wsIdx >= 0 && monIdx >= 0) {
            Log("windowmap hwnd " . (hwnd ? hwnd : "unknown") . " -> workspace " . Chr(34) . nm . Chr(34) . " (ID " . wsIdx . ", Monitor " . monIdx . ") via " . t)
        } else {
            Log("windowmap target unresolved via " . t . " args=" . contentRaw)
        }
        return
    }

    ; 4) Other events we might care to see for future wiring (minimal log)
    if (t = "Destroy" || t = "Manage" || t = "Unmanage" || t = "Raise" || t = "TitleUpdate" || t = "Show" || t = "Hide" || t = "Minimize" || t = "Uncloak" || t = "Cloak" || t = "MoveResizeStart" || t = "MoveResizeEnd") {
        Log("window-manager event " . t . " content=" . contentRaw)
        return
    }

    if (t = "ResolutionScalingChanged" || t = "WorkAreaChanged" || t = "DisplayConnectionChange" || t = "EnteringSuspendedState" || t = "ResumingFromSuspendedState" || t = "SessionLocked" || t = "SessionUnlocked") {
        Log("monitor event " . t)
        return
    }

    if (t = "EnteredAssociatedVirtualDesktop" || t = "LeftAssociatedVirtualDesktop") {
        Log("virtual-desktop event " . t)
        return
    }

    ; fallback: just show the type
    Log("other event " . t . " content=" . contentRaw)
}
=====
Warning: This local variable has the same name as a global variable.

Specifically: map  (in function _State_GetWorkspaceName)

	483: If (name = "")
	483: {
▶	485: map := _Json_ExtractObjectByKey(monObj, "workspace_names")
	486: m := 0
	487: If RegExMatch(map, '(?s)"' . wsIdx . '"\s*:\s*"((?:\\.|[^"])*)"', &m)

For more details, read the documentation for #Warn.

Warning: This local variable has the same name as a global variable.

Specifically: map  (in function _State_FindWorkspaceByName)

	501: Return { mon: mi-1, ws: wi-1, name: name }
	502: }
▶	504: map := _Json_ExtractObjectByKey(monObj, "workspace_names")
	505: m := 0, pos := 1
	506: While RegExMatch(map, '(?s)"(\d+)"\s*:\s*"((?:\\.|[^"])*)"', &m, pos)

For more details, read the documentation for #Warn.

Warning: This line will never execute, due to Return preceding it.

	052: SetTimer(Tick, 50)
	053: }
▶	055: Main()
	057: {
	060: name := "\\.\pipe\" . PipeName

For more details, read the documentation for #Warn.

Warning: This local variable appears to never be assigned a value.

Specifically: Tick

	050: TrySpawnClient()
	051: WaitForClient()
▶	052: SetTimer(Tick, 50)
	053: }
	055: Main()

For more details, read the documentation for #Warn.

Error: This local variable has not been assigned a value.

Specifically: Tick

	050: TrySpawnClient()
	051: WaitForClient()
▶	052: SetTimer(Tick, 50)
	053: }
	055: Main()

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (52) : [Main] SetTimer(Tick, 50)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (27) : [] Main()
> Auto-execute

this was your creation. tell me what full functions to ADD / REPLACE / REMOVE
for gods sake remember AHKv2 syntax
Error: Parameter #1 of SetTimer requires an Object, but received a String.

Specifically: Tick

	052: TrySpawnClient()
	053: WaitForClient()
▶	056: SetTimer("Tick", 50)
	057: }
	060: {

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [SetTimer] SetTimer("Tick", 50)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [Main] SetTimer("Tick", 50)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (28) : [] Main()
> Auto-execute

2025-09-12 23:20:12.fff  === komorebi-poc starting ===
2025-09-12 23:20:12.fff  KomorebicExe = C:\Program Files\komorebi\bin\komorebic.exe
2025-09-12 23:20:12.fff  PipeName     = tabby_poc_553244453_45112
2025-09-12 23:20:12.fff  Log file     = C:\Users\codyj\Desktop\tabby\komorebi_poc.log
2025-09-12 23:20:12.fff  Pipe created. Waiting for client to connect …
2025-09-12 23:20:12.fff  You can also run manually: C:\Program Files\komorebi\bin\komorebic.exe subscribe-pipe tabby_poc_553244453_45112
2025-09-12 23:20:12.fff  Spawned subscriber: pid= -> "C:\Program Files\komorebi\bin\komorebic.exe" subscribe-pipe tabby_poc_553244453_45112
2025-09-12 23:20:12.fff  Client connected.
2025-09-12 23:20:15.fff  === komorebi-poc exiting (Exit) ===
Error: Invalid base.

	052: TrySpawnClient()
	053: WaitForClient()
▶	056: SetTimer(Func("Tick"), 50)
	057: }
	060: {

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [Object.Call] SetTimer(Func("Tick"), 50)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [Main] SetTimer(Func("Tick"), 50)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (28) : [] Main()
> Auto-execute


Error: Parameter #1 of SetTimer requires an Object, but received an empty string.

	052: TrySpawnClient()
	053: WaitForClient()
▶	056: SetTimer(Func("Tick"), 50)
	057: }
	060: {

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [SetTimer] SetTimer(Func("Tick"), 50)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [Main] SetTimer(Func("Tick"), 50)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (28) : [] Main()
> Auto-execute

VS code says the error with
    SetTimer(Func("Tick"), 50)
is expected 0 parameters but got 1
BROTHER
STILL FULL OF ERRORS

Error: This local variable has not been assigned a value.

Specifically: inStr

	218: If (s = "")
	219: Return ""
▶	222: start := InStr(s, "{")
	223: If (!start)
	223: {

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (222) : [_ExtractOneJsonFromBuffer] start := InStr(s, "{")
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: start

	219: Return ""
	222: start := InStr(s, "{")
▶	223: If (!start)
	223: {
	225: If (StrLen(s) > 1000000)

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (223) : [_ExtractOneJsonFromBuffer] If (!start)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: start

	227: Return ""
	228: }
▶	231: i := start
	231: depth := 0
	231: inStr := 0

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (231) : [_ExtractOneJsonFromBuffer] i := start
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: i

	231: depth := 0
	231: inStr := 0
▶	232: While (i <= StrLen(s))
	232: {
	233: ch := SubStr(s, i, 1)

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (232) : [_ExtractOneJsonFromBuffer] While (i <= StrLen(s))
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: inStr

	218: If (s = "")
	219: Return ""
▶	222: start := InStr(s, "{")
	223: If (!start)
	223: {

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (222) : [_ExtractOneJsonFromBuffer] start := InStr(s, "{")
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: start

	219: Return ""
	222: start := InStr(s, "{")
▶	223: If (!start)
	223: {
	225: If (StrLen(s) > 1000000)

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (223) : [_ExtractOneJsonFromBuffer] If (!start)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: start

	227: Return ""
	228: }
▶	231: i := start
	231: depth := 0
	231: inStr := 0

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (231) : [_ExtractOneJsonFromBuffer] i := start
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: i

	231: depth := 0
	231: inStr := 0
▶	232: While (i <= StrLen(s))
	232: {
	233: ch := SubStr(s, i, 1)

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (232) : [_ExtractOneJsonFromBuffer] While (i <= StrLen(s))
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: inStr

	218: If (s = "")
	219: Return ""
▶	222: start := InStr(s, "{")
	223: If (!start)
	223: {

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (222) : [_ExtractOneJsonFromBuffer] start := InStr(s, "{")
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

Error: This local variable has not been assigned a value.

Specifically: start

	219: Return ""
	222: start := InStr(s, "{")
▶	223: If (!start)
	223: {
	225: If (StrLen(s) > 1000000)

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (223) : [_ExtractOneJsonFromBuffer] If (!start)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (208) : [PumpPipe] json := _ExtractOneJsonFromBuffer(&gBuf)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (173) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

here is the full program
=============
#Requires AutoHotkey v2.0
; ---------------------------------------------------------------------------
; komorebi POC subscriber (AHK v2) — logs workspace changes, window moves/sends,
; and focus changes (HWND->workspace) with names and indices.
; ---------------------------------------------------------------------------

#Warn
#SingleInstance Force
SetWorkingDir A_ScriptDir

; --- Globals (declared; most are initialized in Main) ---
global KomorebicExe := "C:\Program Files\komorebi\bin\komorebic.exe"
global LogPath      := A_ScriptDir . "\komorebi_poc.log"
global ReadChunk    := 32768

; defer PipeName until after we know the script is running
global PipeName     := ""          ; will be set in Main()
global gPipe        := 0
global gConnected   := false
global gClientPid   := 0
global gLastWsName  := ""
global gLastWsIdx   := -1
global gLastMonIdx  := -1
global gOut := 0
global gBuf := ""

OnExit(Cleanup)
Main()
return


Main() {
    global PipeName, KomorebicExe, LogPath

    ; build PipeName once we’re actually running (avoids A_Pid #Warn noise)
    if (!PipeName) {
        pid := ProcessExist()  ; current script pid
        PipeName := "tabby_poc_" . A_TickCount . "_" . pid
    }

    Log("=== komorebi-poc starting ===")
    Log("KomorebicExe = " . KomorebicExe)
    Log("PipeName     = " . PipeName)
    Log("Log file     = " . LogPath)

    if !FileExist(KomorebicExe) {
        Log("ERROR: komorebic not found: " . KomorebicExe)
        ExitApp
    }

    CreatePipe()
    TrySpawnClient()
    WaitForClient()

    ; v2: pass the function name as a string to avoid “local var not assigned” warnings
    SetTimer(() => Tick(), 50)
}


CreatePipe() {
    global PipeName, gPipe, KomorebicExe

    local name := "\\.\pipe\" . PipeName
    ; PIPE_ACCESS_INBOUND (server reads), byte/byte/wait, instances=1
    gPipe := DllCall("CreateNamedPipe"
        , "Str",  name
        , "UInt", 0x00000001           ; PIPE_ACCESS_INBOUND
        , "UInt", 0x00000000           ; PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT
        , "UInt", 1
        , "UInt", 65536, "UInt", 65536
        , "UInt", 0
        , "Ptr",  0
        , "Ptr")

    if (gPipe = 0 || gPipe = -1) {
        gle := A_LastError
        Log("ERROR: CreateNamedPipe failed (GLE=" . gle . ")")
        ExitApp
    }
    Log("Pipe created. Waiting for client to connect …")
    Log("You can also run manually: " . KomorebicExe . " subscribe-pipe " . PipeName)
}


; ---------- PIPE LIFECYCLE ----------
CreatePipeServer(name) {
    global gPipe
    local path := "\\.\pipe\" . name
    ; PIPE_ACCESS_INBOUND(0x00000001), PIPE_TYPE_BYTE(0x0), PIPE_READMODE_BYTE(0x0), PIPE_WAIT(0x0)
    gPipe := DllCall("CreateNamedPipe"
        , "Str", path
        , "UInt", 0x00000001            ; dwOpenMode
        , "UInt", 0x00000000            ; dwPipeMode
        , "UInt", 1                     ; nMaxInstances
        , "UInt", 0                     ; nOutBufferSize
        , "UInt", 64*1024               ; nInBufferSize
        , "UInt", 0                     ; nDefaultTimeOut
        , "Ptr",  0                     ; lpSecurityAttributes
        , "Ptr")
    return gPipe != 0
}

WaitForClient() {
    global gPipe, gConnected

    local ok := DllCall("ConnectNamedPipe", "Ptr", gPipe, "Ptr", 0, "Int")
    if (!ok) {
        gle := A_LastError
        if (gle = 535) {  ; ERROR_PIPE_CONNECTED
            gConnected := true
            Log("Client connected (already).")
            return
        }
        Log("ERROR: ConnectNamedPipe failed (GLE=" . gle . ")")
        ExitApp
    }
    gConnected := true
    Log("Client connected.")
}


TrySpawnClient() {
    global gClientPid, KomorebicExe, PipeName
    try {
        cmd := '"' . KomorebicExe . '" subscribe-pipe ' . PipeName
        local pid := 0
        Run(cmd, , "Hide", &pid)   ; v2: 4th param returns PID
        gClientPid := pid
        Log("Spawned subscriber: pid=" . gClientPid . " -> " . cmd)
    } catch as e {
        Log("WARN: failed to spawn client: " . e.Message)
        Log("Start it manually in a terminal:")
        Log("  " . KomorebicExe . " subscribe-pipe " . PipeName)
    }
}



Cleanup(reason := "", code := 0) {
    global gPipe, gConnected
    try {
        Log("=== komorebi-poc exiting (" . (reason != "" ? reason : "Normal") . ") ===")

        if (gConnected && gPipe)
            DllCall("FlushFileBuffers", "Ptr", gPipe)

        if (gPipe) {
            DllCall("DisconnectNamedPipe", "Ptr", gPipe)
            DllCall("CloseHandle", "Ptr", gPipe)
            gPipe := 0
        }
    } catch as e {
        ; ignore shutdown errors
    }
}





GetLastError() => DllCall("GetLastError")

; ---------- LOGGING ----------
Log(msg) {
    global LogPath
    ts := FormatTime(, "yyyy-MM-dd HH:mm:ss.fff")
    FileAppend(ts . "  " . msg . "rn", LogPath, "UTF-8")
}


; ---------- TIMER: PUMP PIPE ----------
Tick() {
    PumpPipe()
}

PumpPipe() {
    global gPipe, ReadChunk, gBuf

    if (!gPipe)
        return

    ; Non-blocking peek
    local bytesRead := 0, totalAvail := 0, leftMsg := 0
    ok := DllCall("PeekNamedPipe", "Ptr", gPipe, "Ptr", 0, "UInt", 0, "UInt*", &bytesRead, "UInt*", &totalAvail, "UInt*", &leftMsg, "Int")
    if (!ok) {
        Log("PeekNamedPipe failed: GLE=" . GetLastError())
        return
    }
    if (totalAvail = 0)
        return

    ; Read a bounded chunk
    local toRead := (totalAvail > ReadChunk) ? ReadChunk : totalAvail
    buf := Buffer(toRead, 0)
    local got := 0
    ok := DllCall("ReadFile", "Ptr", gPipe, "Ptr", buf, "UInt", toRead, "UInt*", &got, "Ptr", 0, "Int")
    if (!ok) {
        Log("ReadFile failed: GLE=" . GetLastError())
        return
    }
    if (got > 0) {
        piece := StrGet(buf.Ptr, got, "UTF-8")
        gBuf .= piece
    }

    ; Extract complete JSON objects
    while true {
        json := _ExtractOneJsonFromBuffer(&gBuf)
        if (json = "")
            break
        HandleNotification(json)
    }
}


; ---------- JSON-ish HELPERS (balanced scans, minimal decoding) ----------
_ExtractOneJsonFromBuffer(&s) {
    if (s = "")
        return ""

    ; find first '{'
    local start := InStr(s, "{")
    if (!start) {
        ; no object start; keep buffer bounded
        if (StrLen(s) > 1000000)
            s := ""
        return ""
    }

    ; scan for matching closing '}' at depth 0, skipping strings
    local i := start, depth := 0, inStr := false
    while (i <= StrLen(s)) {
        ch := SubStr(s, i, 1)
        if (!inStr) {
            if (ch = '"') {
                inStr := true
            } else if (ch = "{") {
                depth += 1
            } else if (ch = "}") {
                depth -= 1
                if (depth = 0) {
                    obj := SubStr(s, start, i - start + 1)
                    s := SubStr(s, i + 1)
                    return obj
                }
            }
        } else {
            if (ch = '"' && SubStr(s, i - 1, 1) != "\")
                inStr := false
        }
        i += 1
    }
    ; incomplete, wait for more data
    return ""
}

_Json_ExtractObjectByKey(text, key) {
    ; returns the balanced {...} value for "key": { ... }
    pat := '(?s)"' . key . '"\s*:\s*\{'
    m := 0
    if !RegExMatch(text, pat, &m)
        return ""
    start := m.Pos(0) + m.Len(0) - 1  ; at '{'
    return _BalancedObjectFrom(text, start)
}

_Json_ExtractArrayByKey(text, key) {
    pat := '(?s)"' . key . '"\s*:\s*\['
    m := 0
    if !RegExMatch(text, pat, &m)
        return ""
    start := m.Pos(0) + m.Len(0) - 1 ; at '['
    return _BalancedArrayFrom(text, start)
}

_BalancedObjectFrom(text, bracePos) {
    ; bracePos points to '{'
    local i := bracePos, depth := 0, inStr := false
    while (i <= StrLen(text)) {
        ch := SubStr(text, i, 1)
        if (!inStr) {
            if (ch = '"') {
                inStr := true
            } else if (ch = "{") {
                depth += 1
            } else if (ch = "}") {
                depth -= 1
                if (depth = 0)
                    return SubStr(text, bracePos, i - bracePos + 1)
            }
        } else {
            if (ch = '"' && SubStr(text, i - 1, 1) != "\")
                inStr := false
        }
        i += 1
    }
    return ""
}

_BalancedArrayFrom(text, brackPos) {
    ; brackPos points to '['
    local i := brackPos, depth := 0, inStr := false
    while (i <= StrLen(text)) {
        ch := SubStr(text, i, 1)
        if (!inStr) {
            if (ch = '"') {
                inStr := true
            } else if (ch = "[") {
                depth += 1
            } else if (ch = "]") {
                depth -= 1
                if (depth = 0)
                    return SubStr(text, brackPos, i - brackPos + 1)
            }
        } else {
            if (ch = '"' && SubStr(text, i - 1, 1) != "\")
                inStr := false
        }
        i += 1
    }
    return ""
}

_ArrayTopLevelSplit(arrayText) {
    ; Input: string like [ {...}, {...}, ... ]
    ; Output: array of element strings (without commas), preserving braces
    res := []
    if (arrayText = "")
        return res
    if (SubStr(arrayText, 1, 1) = "[")
        arrayText := SubStr(arrayText, 2)
    if (SubStr(arrayText, -1) = "]")
        arrayText := SubStr(arrayText, 1, -1)

    local i := 1, depthObj := 0, depthArr := 0, inStr := false, start := 1
    while (i <= StrLen(arrayText)) {
        ch := SubStr(arrayText, i, 1)
        if (!inStr) {
            if (ch = '"') {
                inStr := true
            } else if (ch = "{") {
                depthObj += 1
            } else if (ch = "}") {
                depthObj -= 1
            } else if (ch = "[") {
                depthArr += 1
            } else if (ch = "]") {
                depthArr -= 1
            } else if (ch = "," && depthObj = 0 && depthArr = 0) {
                piece := Trim(SubStr(arrayText, start, i - start))
                if (piece != "")
                    res.Push(piece)
                start := i + 1
            }
        } else {
            if (ch = '"' && SubStr(arrayText, i - 1, 1) != "\")
                inStr := false
        }
        i += 1
    }
    last := Trim(SubStr(arrayText, start))
    if (last != "")
        res.Push(last)
    return res
}

_Json_GetStringProp(objText, key) {
    m := 0
    if RegExMatch(objText, '(?s)"' . key . '"\s*:\s*"((?:\\.|[^"])*)"', &m)
        return _UnescapeJson(m[1])
    return ""
}
_Json_GetIntProp(objText, key) {
    m := 0
    if RegExMatch(objText, '(?s)"' . key . '"\s*:\s*(-?\d+)', &m)
        return Integer(m[1])
    return ""
}
_UnescapeJson(s) {
    ; minimal unescape for quotes and backslashes + common escapes
    s := StrReplace(s, '\"', '"')
    s := StrReplace(s, '\\', '\')
    s := StrReplace(s, '\/', '/')
    s := StrReplace(s, '\b', Chr(8))
    s := StrReplace(s, '\f', Chr(12))
    s := StrReplace(s, '\n', "n")
    s := StrReplace(s, '\r', "r")
    s := StrReplace(s, '\t', "t")
    return s
}

; ---------- EVENT PARSING ----------
_GetEventType(evtText) {
    m := 0
    if RegExMatch(evtText, '(?s)"type"\s*:\s*"([^"]+)"', &m)
        return m[1]
    return ""
}

_GetEventContentRaw(evtText) {
    ; returns: "", number string, quoted string, [array], {object}
    ; We only need array/int/string types for our use-cases.
    ; Try array first
    arr := _Json_ExtractArrayByKey(evtText, "content")
    if (arr != "")
        return arr
    ; Try quoted string
    m := 0
    if RegExMatch(evtText, '(?s)"content"\s*:\s*"((?:\\.|[^"])*)"', &m)
        return '"' . m[1] . '"'
    ; Integer
    if RegExMatch(evtText, '(?s)"content"\s*:\s*(-?\d+)', &m)
        return m[1]
    ; Object
    obj := _Json_ExtractObjectByKey(evtText, "content")
    if (obj != "")
        return obj
    return ""
}

_ParseContentToArray(contentRaw) {
    ; Normalize content to an Array of positional args:
    ; - "[1,2]" => [1,2]
    ; - "123"   => [123]
    ; - "\"Name\"" => ["Name"]
    ; - "{...}" => ["{...}"] (used by FocusChange second param object)
    args := []
    if (contentRaw = "")
        return args
    if (SubStr(contentRaw, 1, 1) = "[") {
        list := _ArrayTopLevelSplit(contentRaw)
        for each, it in list {
            it := Trim(it)
            if (SubStr(it, 1, 1) = '"') {
                args.Push(_UnescapeJson(SubStr(it, 2, -1)))
            } else if RegExMatch(it, '^-?\d+$') {
                args.Push(Integer(it))
            } else {
                args.Push(it) ; raw (object etc)
            }
        }
        return args
    }
    if (SubStr(contentRaw, 1, 1) = '"') {
        args.Push(_UnescapeJson(SubStr(contentRaw, 2, -1)))
        return args
    }
    if RegExMatch(contentRaw, '^-?\d+$') {
        args.Push(Integer(contentRaw))
        return args
    }
    args.Push(contentRaw)
    return args
}

; ---------- STATE HELPERS ----------
; Return monitors ring object + array of monitor objects + focused monitor idx
_State_GetMonitorsRing(stateText) {
    ring := _Json_ExtractObjectByKey(stateText, "monitors")
    return ring
}

_State_GetMonitorsArray(stateText) {
    ring := _State_GetMonitorsRing(stateText)
    elems := _Json_ExtractArrayByKey(ring, "elements")
    return _ArrayTopLevelSplit(elems)
}

_State_GetFocusedMonitorIndex(stateText) {
    ring := _State_GetMonitorsRing(stateText)
    return _Json_GetIntProp(ring, "focused")
}

_State_GetWorkspaceRingForMonitor(monObjText) {
    return _Json_ExtractObjectByKey(monObjText, "workspaces")
}

_State_GetWorkspaceArrayForMonitor(monObjText) {
    wsRing := _State_GetWorkspaceRingForMonitor(monObjText)
    wsArr := _Json_ExtractArrayByKey(wsRing, "elements")
    return _ArrayTopLevelSplit(wsArr)
}

_State_GetFocusedWorkspaceIndexForMonitor(monObjText) {
    wsRing := _State_GetWorkspaceRingForMonitor(monObjText)
    return _Json_GetIntProp(wsRing, "focused")
}

_State_GetWorkspaceName(stateText, monIdx, wsIdx) {
    mons := _State_GetMonitorsArray(stateText)
    if (monIdx < 0 || monIdx >= mons.Length)
        return ""
    monObj := mons[monIdx]
    wsArr := _State_GetWorkspaceArrayForMonitor(monObj)
    if (wsIdx < 0 || wsIdx >= wsArr.Length)
        return ""
    wsObj := wsArr[wsIdx]
    name := _Json_GetStringProp(wsObj, "name")
    if (name = "") {
        wsNamesMap := _Json_ExtractObjectByKey(monObj, "workspace_names")
        m := 0
        if RegExMatch(wsNamesMap, '(?s)"' . wsIdx . '"\s*:\s*"((?:\\.|[^"])*)"', &m)
            name := _UnescapeJson(m[1])
    }
    return name
}


_State_FindWorkspaceByName(stateText, wsName) {
    mons := _State_GetMonitorsArray(stateText)
    for mi, monObj in mons {
        wsArr := _State_GetWorkspaceArrayForMonitor(monObj)
        for wi, wsObj in wsArr {
            name := _Json_GetStringProp(wsObj, "name")
            if (name != "" && StrLower(name) = StrLower(wsName))
                return { mon: mi-1, ws: wi-1, name: name } ; 0-based indices
        }
        wsNamesMap := _Json_ExtractObjectByKey(monObj, "workspace_names")
        m := 0, pos := 1
        while RegExMatch(wsNamesMap, '(?s)"(\d+)"\s*:\s*"((?:\\.|[^"])*)"', &m, pos) {
            idx := Integer(m[1]), nm := _UnescapeJson(m[2])
            if (StrLower(nm) = StrLower(wsName))
                return { mon: mi-1, ws: idx, name: nm }
            pos := m.Pos(0) + m.Len(0)
        }
    }
    return { mon: -1, ws: -1, name: "" }
}


_State_FindWorkspaceOfHwnd(stateText, hwnd) {
    if (!hwnd)
        return { mon: -1, ws: -1, name: "" }
    mons := _State_GetMonitorsArray(stateText)
    for mi, monObj in mons {
        wsArr := _State_GetWorkspaceArrayForMonitor(monObj)
        for wi, wsObj in wsArr {
            ; quick search for "hwnd": <value> inside this workspace object
            if RegExMatch(wsObj, '(?s)"hwnd"\s*:\s*' . hwnd) {
                nm := _Json_GetStringProp(wsObj, "name")
                return { mon: mi-1, ws: wi-1, name: nm }
            }
        }
    }
    return { mon: -1, ws: -1, name: "" }
}

_State_GetFocusedHwnd(stateText) {
    ; Try windows ring: { "elements":[{"hwnd":...},...], "focused":N }
    winRing := _Json_ExtractObjectByKey(stateText, "windows")
    if (winRing != "") {
        idx := _Json_GetIntProp(winRing, "focused")
        arr := _Json_ExtractArrayByKey(winRing, "elements")
        if (arr != "") {
            list := _ArrayTopLevelSplit(arr)
            if (idx >= 0 && idx < list.Length) {
                wobj := list[idx+1]
                return _Json_GetIntProp(wobj, "hwnd")
            }
        }
    }
    ; Other known fallbacks (some builds):
    m := 0
    if RegExMatch(stateText, '(?s)"focused_window"\s*:\s*\{[^}]*"hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    if RegExMatch(stateText, '(?s)"focused_hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    if RegExMatch(stateText, '(?s)"last_focused_window"\s*:\s*\{[^}]*"hwnd"\s*:\s*(\d+)', &m)
        return Integer(m[1])
    return 0
}

; ---------- EVENT TYPE GROUPS ----------
IsWorkspaceFocusEvent(t) {
    static S := Map(
        "FocusNamedWorkspace", true,
        "FocusWorkspaceNumber", true,
        "FocusWorkspaceNumbers", true,
        "FocusLastWorkspace", true,
        "CycleFocusWorkspace", true,
        "CycleFocusEmptyWorkspace", true,
        "FocusMonitorWorkspaceNumber", true,
        "FocusMonitorAtCursor", true,
        "FocusMonitorNumber", true,
        "CycleFocusMonitor", true
    )
    return S.Has(t)
}

IsWindowMoveSendEvent(t) {
    static S := Map(
        "MoveContainerToNamedWorkspace", true,
        "SendContainerToNamedWorkspace", true,
        "MoveContainerToWorkspaceNumber", true,
        "SendContainerToWorkspaceNumber", true,
        "MoveContainerToMonitorWorkspaceNumber", true,
        "SendContainerToMonitorWorkspaceNumber", true,
        "CycleMoveContainerToWorkspace", true,
        "CycleSendContainerToWorkspace", true,
        "CycleMoveContainerToMonitor", true,
        "CycleSendContainerToMonitor", true,
        "MoveContainerToMonitorNumber", true,
        "SendContainerToMonitorNumber", true,
        "MoveContainerToLastWorkspace", true,
        "SendContainerToLastWorkspace", true
    )
    return S.Has(t)
}

; ---------- HANDLE EACH NOTIFICATION ----------
HandleNotification(jsonLine) {
    ; jsonLine is a single full notification object
    evtObj := _Json_ExtractObjectByKey(jsonLine, "event")
    stateObj := _Json_ExtractObjectByKey(jsonLine, "state")
    if (evtObj = "" || stateObj = "") {
        Log("WARN: notification missing event or state")
        return
    }

    t := _GetEventType(evtObj)
    contentRaw := _GetEventContentRaw(evtObj)
    args := _ParseContentToArray(contentRaw)

    ; 1) Focus changes at the window level (WindowManagerEvent: FocusChange)
    if (t = "FocusChange") {
        ; content = [ WinEventName, { "hwnd": N } ]
        hwnd := 0
        if (args.Length >= 2) {
            obj := args[2]
            if (SubStr(obj, 1, 1) = "{")
                hwnd := _Json_GetIntProp(obj, "hwnd")
        }
        if (!hwnd) {
            ; fallback to state
            hwnd := _State_GetFocusedHwnd(stateObj)
        }
        loc := _State_FindWorkspaceOfHwnd(stateObj, hwnd)
        if (loc.mon >= 0 && loc.ws >= 0) {
            nm := loc.name
            if (nm = "")
                nm := _State_GetWorkspaceName(stateObj, loc.mon, loc.ws)
                Log("Focus Changed to HWND " . hwnd . " in Workspace " . Chr(34) . nm . Chr(34) . ", ID " . loc.ws . ", Monitor " . loc.mon . " via FocusChange")
        } else {
            Log("Focus Changed to HWND " . hwnd . " (workspace unresolved) via FocusChange")
        }
        return
    }

    ; 2) Workspace focus family
    if IsWorkspaceFocusEvent(t) {
        monIdx := _State_GetFocusedMonitorIndex(stateObj)
        wsIdx := -1
        resolved := false
        nm := ""

        switch t {
        case "FocusMonitorWorkspaceNumber":
            ; args = [mon, ws]
            if (args.Length >= 2) {
                monIdx := Integer(args[1])
                wsIdx := Integer(args[2])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                resolved := (nm != "")
                Log('Workspace Changed to "' . (nm != "" ? nm : "?") . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t . " args=" . contentRaw)
            } else {
                Log("workspace change signal via " . t . " args=" . contentRaw . " (malformed)")
            }
            return
        case "FocusWorkspaceNumber", "FocusWorkspaceNumbers":
            if (args.Length >= 1) {
                wsIdx := Integer(args[1])
                ; if this event doesn’t include monitor, take focused monitor from state
                monIdx := _State_GetFocusedMonitorIndex(stateObj)
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                Log('Workspace Changed to "' . (nm != "" ? nm : "?") . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t)
            } else {
                Log("workspace change signal via " . t . " (no args)")
            }
            return
        case "FocusNamedWorkspace":
            if (args.Length >= 1) {
                want := args[1]
                loc := _State_FindWorkspaceByName(stateObj, want)
                if (loc.mon >= 0) {
                    Log('Workspace Changed to "' . loc.name . '", ID ' . loc.ws . ", Monitor " . loc.mon . " via " . t)
                } else {
                    ; fall back to focused monitor & workspace
                    monIdx := _State_GetFocusedMonitorIndex(stateObj)
                    mons := _State_GetMonitorsArray(stateObj)
                    nm := ""
                    wsIdx := -1
                    if (monIdx >= 0 && monIdx < mons.Length) {
                        wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                        nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                    }
                    Log('Workspace Changed to "' . (nm != "" ? nm : want) . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t)
                }
            } else {
                Log("workspace change signal via " . t . " (no name)")
            }
            return
        case "FocusMonitorNumber":
            if (args.Length >= 1) {
                monIdx := Integer(args[1])
                mons := _State_GetMonitorsArray(stateObj)
                wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                Log('Workspace Changed to "' . (nm != "" ? nm : "?") . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t)
            } else {
                Log("workspace change signal via " . t . " (no monitor)")
            }
            return
        case "FocusMonitorAtCursor", "CycleFocusWorkspace", "CycleFocusEmptyWorkspace", "FocusLastWorkspace", "CycleFocusMonitor":
            monIdx := _State_GetFocusedMonitorIndex(stateObj)
            mons := _State_GetMonitorsArray(stateObj)
            if (monIdx >= 0 && monIdx < mons.Length) {
                wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                Log('Workspace Changed to "' . (nm != "" ? nm : "?") . '", ID ' . wsIdx . ", Monitor " . monIdx . " via " . t)
            } else {
                Log("workspace change signal via " . t . " (name unresolved)")
            }
            return
        }

        ; default: fallthrough (shouldn’t get here)
        Log("workspace change signal via " . t . " args=" . contentRaw . " (name unresolved)")
        return
    }

    ; 3) Window move/send family
    if IsWindowMoveSendEvent(t) {
        ; Try to figure out destination monitor/workspace from args/state
        monIdx := _State_GetFocusedMonitorIndex(stateObj) ; default assumption
        wsIdx := -1
        nm := ""
        haveDest := false

        if (t = "MoveContainerToMonitorWorkspaceNumber" || t = "SendContainerToMonitorWorkspaceNumber") {
            if (args.Length >= 2) {
                monIdx := Integer(args[1])
                wsIdx := Integer(args[2])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                haveDest := true
            }
        } else if (t = "MoveContainerToWorkspaceNumber" || t = "SendContainerToWorkspaceNumber") {
            if (args.Length >= 1) {
                wsIdx := Integer(args[1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                haveDest := true
            }
        } else if (t = "MoveContainerToNamedWorkspace" || t = "SendContainerToNamedWorkspace") {
            if (args.Length >= 1) {
                want := args[1]
                loc := _State_FindWorkspaceByName(stateObj, want)
                if (loc.mon >= 0) {
                    monIdx := loc.mon, wsIdx := loc.ws, nm := loc.name
                    haveDest := true
                }
            }
        } else if (InStr(t, "CycleMoveContainerToMonitor") || InStr(t, "CycleSendContainerToMonitor")) {
            ; after the cycle, state should reflect the focused monitor & its focused workspace
            monIdx := _State_GetFocusedMonitorIndex(stateObj)
            mons := _State_GetMonitorsArray(stateObj)
            if (monIdx >= 0 && monIdx < mons.Length) {
                wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                haveDest := true
            }
        } else if (InStr(t, "CycleMoveContainerToWorkspace") || InStr(t, "CycleSendContainerToWorkspace") || t = "MoveContainerToLastWorkspace" || t = "SendContainerToLastWorkspace") {
            ; same — use post-state focused ws on focused monitor
            monIdx := _State_GetFocusedMonitorIndex(stateObj)
            mons := _State_GetMonitorsArray(stateObj)
            if (monIdx >= 0 && monIdx < mons.Length) {
                wsIdx := _State_GetFocusedWorkspaceIndexForMonitor(mons[monIdx+1])
                nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
                haveDest := true
            }
        }

        Log("window move/send detected via " . t . " args=" . contentRaw)

        hwnd := _State_GetFocusedHwnd(stateObj) ; best-effort — often the moved window
        if (haveDest && nm != "" && wsIdx >= 0 && monIdx >= 0) {
            Log("windowmap hwnd " . (hwnd ? hwnd : "unknown") . " -> workspace " . Chr(34) . nm . Chr(34) . " (ID " . wsIdx . ", Monitor " . monIdx . ") via " . t)
        } else {
            Log("windowmap target unresolved via " . t . " args=" . contentRaw)
        }
        return
    }

    ; 4) Other events we might care to see for future wiring (minimal log)
    if (t = "Destroy" || t = "Manage" || t = "Unmanage" || t = "Raise" || t = "TitleUpdate" || t = "Show" || t = "Hide" || t = "Minimize" || t = "Uncloak" || t = "Cloak" || t = "MoveResizeStart" || t = "MoveResizeEnd") {
        Log("window-manager event " . t . " content=" . contentRaw)
        return
    }

    if (t = "ResolutionScalingChanged" || t = "WorkAreaChanged" || t = "DisplayConnectionChange" || t = "EnteringSuspendedState" || t = "ResumingFromSuspendedState" || t = "SessionLocked" || t = "SessionUnlocked") {
        Log("monitor event " . t)
        return
    }

    if (t = "EnteredAssociatedVirtualDesktop" || t = "LeftAssociatedVirtualDesktop") {
        Log("virtual-desktop event " . t)
        return
    }

    ; fallback: just show the type
    Log("other event " . t . " content=" . contentRaw)
}
==========
you wrote it. "I" didnt do anything. Youve been told 1 million times in this thread to use AHKv2 syntax. Im losing it man.

im not patching anything. give it back to me, the full program, in AHKv2 syntax
Error: Invalid index.

Specifically: 0

	489: If (monIdx < 0 || monIdx >= mons.Length)
	490: Return ""
▶	491: monObj := mons[monIdx]
	492: wsArr := _State_GetWorkspaceArrayForMonitor(monObj)
	493: If (wsIdx < 0 || wsIdx >= wsArr.Length)

Call stack:
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (491) : [Array.Prototype.__Item.Get] monObj := mons[monIdx]
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (491) : [_State_GetWorkspaceName] monObj := mons[monIdx]
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (672) : [HandleNotification] nm := _State_GetWorkspaceName(stateObj, monIdx, wsIdx)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (209) : [PumpPipe] HandleNotification(json)
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (171) : [Tick] PumpPipe()
C:\Users\codyj\Desktop\tabby\komorebi_poc.ahk (56) : [] Return  Tick()
> Timer

ok, this runs, thank you well done. Focus Changes are logging perfectly . workstation changes are not, but they are generating this error so that might be why? and they log like this 
2025-09-12 23:31:51.fff  Workspace Changed to "?", ID 0, Monitor 0 via FocusWorkspaceNumber
so we are getting the ID and monitor right, just not the name

window move sends are logging like this:
window move/send detected via MoveContainerToWorkspaceNumber args=1
and are generating the error at the top of this message. they arent generating in our desired format
window hwnd X move/send to Workspace Name, ID 2, Monitor 1, detected via MoveContainerToWorkspaceNumber args=[0] 
where we would have hwnd, workspace name, workspace id, and monitor id. all I'm seeing is workspace #, and again, the error at the top of the prompt is generating

we are very close! let me know what functions to replace / add
This is awesome. We'll done. I'm backing it up. I especially like how you added logging for other events we might want to wire in the future. I'm already seeing value and have some follow up coding ideas.

That will wait until tomorrow I'm away from my computer. As I lie here, I had an idea I wanted to discuss.

For the full alt tab program, as you know I split it between a micro interceptor, a stand alone AHK program that sends one way IPC traffic and the alttab logic program. To get around Ahks single threaded nature, keep the interceptor speedy, and keep the interceptor dead simple as code and feature creep was making it buggy and unreliable. 

With the new Window Store API that we have so wonderfully built, I'm wondering if that too should run as a stand alone AHK? The window store and the producers into it would run in a dedicated process. The alt tab program would be in its own process, and would request projections from the window tsore process via IPC.

The interceptor, alt tab logic and gui, and window store and producers would be their own processes. Clean separation and all working without blocking each other.

Or, does that just introduce problems. The alt tab logic / gui portion would need to maintain 2 different ipcs, and maybe there would be race conditions or otherwise effect the snappiness we worked so hard to get with the micro interceptor. Or maybe it would slow down the alt tab gui having to request the projection via IPC instead of in thread.

Thoughts? No code just discussion. 
I was thinking the producers and the window store api would be a single process - as we have already built. But you specifically say have an inbound pipe from producers to B. Are you suggesting 4 processes then? Or 3? If three an inbound pipe isn't necessary for the store right, its just single thread process calls like we already built? Bundle the komorebi and wineum and mru ahks in one process with list.ahk as we already do? Or is it worth splitting the producers into their own process? At that point why not put each producer in its own process? At some point the IPC has to be way more over head then single threaded blocking? 

And if I understand, the subscription from the window store program to the altlogic/gui program would be delta messages right? So it gets the whole state, then deltas from there to be faster? Is it a one way push, the store only pushes into the logic/gui program, or can the logic program also make requests from the store? Maybe it doesn't need to, I was just wondering how it knows when to send a full projection vs deltas. Like full on first connect and then deltas from there? Are deltas forever a good idea or is that asking for possible data drift? What's best practice with deltas like that, every X versions or Y time send a full state? Or just rely on deltas being rock solid and never drifting? 
Alright, hopefully final questions on this new model. 

You mention a periodic rebase, then suggest by N deltas, T minutes, or a delta size > snapshot size comparison. Which do you suggest?

For the wire pattern, is json ok, or should we stick with compact binary schema? or binary? the goal would be to keep each process fast, im not worried about the "bandwidth" or size of packets, im worried about speed and blocking either side of the send/receive. But also keeping dev simple and the program easy to understand. what do you recommend?

you mention
------
Treat B as an actor: one event queue, process events sequentially, update state, emit one delta per turn (or coalesce over ~10–20ms to avoid storms).
--------
intriquing. is it worth coalescing? if im sitting in one window there will be zero events. its only when switching/creating/destroying/modifying windows or workspaces that any work will be generated. but, its likely more then one monitor (komorebi + mru) will fire for any one major windowing event. so do you expect its low enough event flow we dont bother, or is it worth coalescing? 

you mention
Optional SET_PREFS{projection_flags} at subscribe time (e.g., “exclude minimized”, “sort by MRU”).

thats a good idea I think. what should the prefs include during subscription? I'm thinking
1a. List of columns to include
1b. Or...list of columns to exclude? 
2. sort instructions (level 1 sort column + asc/desc, level 2 sort column + asc/desc)?

lastly, with window store having this model of subscribers to it, would it handle just one subscriber? Or could it handle multiple subscribers (like if I want to build a custom dock/taskbar replacement). Would multiple subscribers change our design, ie push us to do subscription manager in another process? 

Thought for 27s

Love where your head’s at. Here’s what I’d recommend, opinionated and practical.

1) Rebase / full-snapshot cadence

Use a simple hybrid so you’re safe without overthinking:

Primary: full snapshot every 10 minutes.

Also: full snapshot after 200 deltas (whichever comes first).

Opportunistic: if a single pending delta (or a burst coalesced delta) would be >50–70% of a full snapshot, just send a snapshot instead.

Why this combo?

Time-based protects against silent drift.

Count-based protects high-churn sessions.

Size-based avoids “death by delta” on big rearranges/renames.

If you want “one knob only”, pick time-based @ 5–10 min and you’ll be fine.

2) Wire format: JSON vs binary

JSON (framed) wins here: simpler, inspectable, and fast enough on local pipes.

Use length-prefixed frames (e.g., 4-byte little-endian length, then UTF-8 JSON). That avoids delimiter ambiguity and extra scanning.

Keep payloads lean:

Short keys (e.g., "ws", "mon", "hwnd", "title", "app", "min", "vis", "rank").

Numeric enums instead of strings where sensible.

No pretty printing; no whitespace.

If one day you truly need more speed, swap payload to MessagePack but keep the same framing and fields. (You can even negotiate {fmt:"json"|"msgpack"} in WELCOME.)

Given your constraints (local IPC, modest payloads, human debugging), JSON’s the right tradeoff.

3) Coalescing events

Yes, coalesce, lightly.

Many “one action” sequences fan out across producers (komorebi + MRU + Win events). Coalescing avoids spamming the UI and reduces redundant transforms.

Window: 10–20 ms.

On first event, start a short timer; queue everything; when the timer fires, fold the queue and emit one delta.

Cap at ~25 ms to keep UI “instant.”

Fold rules (examples):

CREATE then UPDATEs → one CREATE with final props.

Multiple UPDATEs on same hwnd → last-writer-wins by field.

MOVE between workspaces + rename in same burst → one UPDATE.

CREATE followed by DESTROY in same burst → drop (net no-op).

This keeps your actor single-threaded and the UI buttery without adding real complexity.

If you’re idle (no events), nothing runs—so the coalescer has negligible cost.

4) Subscription prefs (what C tells B)

A small, future-proof set:

a) Projection profile

columns: explicit include list (preferred), e.g. ["hwnd","title","app","mon","ws","rank","min"]

Rationale: include-list keeps payload minimal and avoids accidental coupling.

grouping: "none" | "monitor" | "workspace"

limits: { max_items: 120 }

thumbnails: { enabled: false } (or { size: 96 } if you ever add them)

b) Filters

minimized: "include" | "exclude" | "only"

visible: true|false|null (null = don’t care)

monitors: [ids] (empty → all)

workspaces: [ids] (empty → all)

apps_whitelist / apps_blacklist: ["ahk_exe ..."]

title_regex: string (optional)

c) Sort

sort: array of keys with dir, e.g.
[{ key:"rank", dir:"asc" }, { key:"mon", dir:"asc" }, { key:"ws", dir:"asc" }]

Keep it 1–2 levels; your Store should return data already sorted so the UI does zero work.

d) Transport knobs (optional)

fmt: "json" (future: "msgpack")

snap_interval_override: seconds (if a client wants a tighter/looser cadence)

max_delta_before_snapshot: bytes or ratio

This keeps C dumb and fast. Also allows multiple UIs to request different projections without forking B.

5) One subscriber vs many

Design B as a hub; multiple subscribers are fine.

Keep one canonical state + one global revision counter in B.

On each tick, apply producer events → one canonical delta.

For each subscriber:

Transform canonical delta → filtered/sorted projection delta (respecting that subscriber’s prefs).

Maintain per-subscriber last_sent_rev and a small send buffer.

If a subscriber falls behind (buffer cap exceeded), mark it stale and on the next opportunity send it a fresh snapshot and bump its last_sent_rev.

Backpressure: if a client doesn’t read, pause writing to that pipe and eventually drop/reconnect that subscriber (log it). This keeps B healthy.

You don’t need a separate “subscription manager” process unless you’re courting dozens of heavy clients. Keep it in B—it’s still a single actor loop, just with N outputs.

6) Snapshot vs delta policy (practical defaults)

On connect: WELCOME → SNAPSHOT{rev, hash, payload}.

Then: DELTA{rev, changes, new_hash}.

Periodic: snapshot every 10 min or 200 deltas, whichever first.

Opportunistic: if (estimated_delta_size > 0.6 * snapshot_size), send snapshot instead.

Gap/Corruption: if C sees a gap or hash mismatch, send RESYNC; B replies with a fresh snapshot.

Hashes can be a fast non-cryptographic digest of a normalized projection (e.g., sorted list of {id,mon,ws,rank,min} tuples). It’s just for drift detection.

TL;DR

3 processes; JSON over length-prefixed frames; tiny coalescing window (10–20 ms); include-list columns + filters + sort in prefs; multi-subscriber hub inside B with per-subscriber revs/buffers; snapshot every 10 min / 200 deltas / big change, with gap-resync + optional hash.

That’ll keep the system simple, inspectable, and fast without painting you into a corner.