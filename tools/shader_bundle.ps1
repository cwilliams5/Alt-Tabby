# shader_bundle.ps1 — Scans src/shaders/*.hlsl + *.json, generates:
#   src/lib/shader_bundle.ahk    — HLSL source functions + Shader_RegisterAll() + SHADER_NAMES
#   src/lib/shader_resources.ahk — @Ahk2Exe-AddResource directives + resource IDs + Shader_ExtractTextures()
#
# Usage: powershell -File tools/shader_bundle.ps1
#        powershell -File tools/shader_bundle.ps1 -Verbose

param(
    [switch]$Verbose
)

$ErrorActionPreference = 'Stop'

# Resolve paths relative to repo root (script lives in tools/)
$repoRoot = Split-Path -Parent (Split-Path -Parent $PSCommandPath)
$shaderDir = Join-Path $repoRoot 'src\shaders'
$libDir = Join-Path $repoRoot 'src\lib'
$resImgDir = Join-Path $repoRoot 'resources\img\shaders'
$bundlePath = Join-Path $libDir 'shader_bundle.ahk'
$resourcesPath = Join-Path $libDir 'shader_resources.ahk'

# Ensure output dirs exist
if (!(Test-Path $resImgDir)) { New-Item -ItemType Directory -Path $resImgDir -Force | Out-Null }

# Discover shaders: each .hlsl must have a matching .json
$hlslFiles = Get-ChildItem -Path $shaderDir -Filter '*.hlsl' | Sort-Object Name
if ($hlslFiles.Count -eq 0) {
    Write-Host "No .hlsl files found in $shaderDir"
    exit 0
}

$shaders = @()
foreach ($hlsl in $hlslFiles) {
    $baseName = $hlsl.BaseName
    $jsonPath = Join-Path $shaderDir "$baseName.json"
    if (!(Test-Path $jsonPath)) {
        Write-Warning "Skipping $baseName.hlsl - no matching .json metadata"
        continue
    }
    $meta = Get-Content $jsonPath -Raw | ConvertFrom-Json

    # Read HLSL source (explicit UTF-8 for em dashes etc.)
    $hlslSource = [System.IO.File]::ReadAllText($hlsl.FullName, [System.Text.UTF8Encoding]::new($false))

    # Sanitize name for AHK function: snake_case -> PascalCase
    $funcName = ($baseName -split '[_\-]' | ForEach-Object {
        $_.Substring(0,1).ToUpper() + $_.Substring(1).ToLower()
    }) -join ''

    # Registry key: camelCase version
    $regKey = $funcName.Substring(0,1).ToLower() + $funcName.Substring(1)

    # Extract metadata fields (PS 5.1 compatible — no inline if)
    $opacity = 1.0
    if ($meta.PSObject.Properties.Match('opacity').Count -gt 0) {
        $opacity = $meta.opacity
    }
    $iChannels = @()
    if ($meta.PSObject.Properties.Match('iChannels').Count -gt 0 -and $null -ne $meta.iChannels) {
        $iChannels = @($meta.iChannels)
    }

    $shader = @{
        BaseName    = $baseName
        FuncName    = $funcName
        RegKey      = $regKey
        DisplayName = $meta.name
        Opacity     = $opacity
        iChannels   = $iChannels
        HLSLSource  = $hlslSource
    }
    $shaders += $shader

    if ($Verbose) {
        Write-Host "  Found: $baseName -> $funcName (display: $($meta.name))"
    }
}

if ($shaders.Count -eq 0) {
    Write-Host "No valid shader pairs found."
    exit 0
}

Write-Host "Bundling $($shaders.Count) shader(s)..."

# ==================== Copy texture PNGs ====================
$nextResId = 100  # Start at 100 to avoid collision with existing IDs (max 25 currently)
$resourceEntries = @()

foreach ($shader in $shaders) {
    foreach ($ch in $shader.iChannels) {
        $srcPng = Join-Path $shaderDir $ch.file
        if (!(Test-Path $srcPng)) {
            Write-Warning "iChannel texture not found: $($ch.file) for shader $($shader.BaseName)"
            continue
        }
        $dstPng = Join-Path $resImgDir $ch.file
        Copy-Item $srcPng $dstPng -Force

        $constName = "RES_ID_SHADER_$($shader.FuncName.ToUpper())_I$($ch.index)"
        $resourceEntries += @{
            ConstName = $constName
            ResId     = $nextResId
            File      = $ch.file
            RelPath   = "..\resources\img\shaders\$($ch.file)"
        }
        $nextResId++

        if ($Verbose) {
            Write-Host "  Texture: $($ch.file) -> resId=$($resourceEntries[-1].ResId)"
        }
    }
}

# ==================== Generate shader_bundle.ahk ====================
$sb = New-Object System.Text.StringBuilder

[void]$sb.AppendLine('; AUTO-GENERATED by tools/shader_bundle.ps1 -- DO NOT EDIT')
[void]$sb.AppendLine('; Source: src/shaders/')
[void]$sb.AppendLine('; Regenerate: powershell -File tools/shader_bundle.ps1')
[void]$sb.AppendLine('#Requires AutoHotkey v2.0')
[void]$sb.AppendLine('#Warn VarUnset, Off')
[void]$sb.AppendLine('')

# SHADER_NAMES global (0=None, 1+=alphabetical order)
$nameList = '"None"'
foreach ($shader in $shaders) {
    $nameList += ', "' + $shader.DisplayName + '"'
}
[void]$sb.AppendLine("global SHADER_NAMES := [$nameList]")
[void]$sb.AppendLine('')

# Shader_RegisterAll()
[void]$sb.AppendLine('Shader_RegisterAll() {')
foreach ($shader in $shaders) {
    $fn = $shader.FuncName
    $rk = $shader.RegKey
    [void]$sb.AppendLine("    Shader_Register(`"$rk`", _Shader_HLSL_$fn(), _Shader_Meta_$fn())")
}
[void]$sb.AppendLine('}')
[void]$sb.AppendLine('')

# Per-shader HLSL + Meta functions
foreach ($shader in $shaders) {
    $fn = $shader.FuncName

    # HLSL function
    [void]$sb.AppendLine("_Shader_HLSL_$fn() {")
    [void]$sb.AppendLine('    return "')
    [void]$sb.AppendLine('    (')

    # Emit HLSL source line by line (inside AHK continuation section)
    $hlslLines = $shader.HLSLSource -split "`r?`n"
    foreach ($line in $hlslLines) {
        [void]$sb.AppendLine($line)
    }

    [void]$sb.AppendLine('    )"')
    [void]$sb.AppendLine('}')
    [void]$sb.AppendLine('')

    # Meta function
    [void]$sb.AppendLine("_Shader_Meta_$fn() {")

    # Build iChannels array string
    $chArray = '[]'
    if ($shader.iChannels.Count -gt 0) {
        $chEntries = @()
        foreach ($ch in $shader.iChannels) {
            $chEntries += '{index: ' + $ch.index + ', file: "' + $ch.file + '"}'
        }
        $chArray = '[' + ($chEntries -join ', ') + ']'
    }

    [void]$sb.AppendLine("    return {opacity: $($shader.Opacity), iChannels: $chArray}")
    [void]$sb.AppendLine('}')
    [void]$sb.AppendLine('')
}

# Write bundle file (UTF-8 with BOM for AHK compatibility)
[System.IO.File]::WriteAllText($bundlePath, $sb.ToString(), [System.Text.UTF8Encoding]::new($false))
Write-Host "  Generated: $bundlePath"

# ==================== Generate shader_resources.ahk ====================
$sr = New-Object System.Text.StringBuilder

[void]$sr.AppendLine('; AUTO-GENERATED by tools/shader_bundle.ps1 -- DO NOT EDIT')
[void]$sr.AppendLine('; Regenerate: powershell -File tools/shader_bundle.ps1')
[void]$sr.AppendLine('#Requires AutoHotkey v2.0')
[void]$sr.AppendLine('#Warn VarUnset, Off')
[void]$sr.AppendLine('')

# @Ahk2Exe-AddResource directives
foreach ($entry in $resourceEntries) {
    [void]$sr.AppendLine(";@Ahk2Exe-AddResource $($entry.RelPath), $($entry.ResId)")
}
if ($resourceEntries.Count -gt 0) { [void]$sr.AppendLine('') }

# Resource ID constants
foreach ($entry in $resourceEntries) {
    [void]$sr.AppendLine("global $($entry.ConstName) := $($entry.ResId)")
}
if ($resourceEntries.Count -gt 0) { [void]$sr.AppendLine('') }

# Shader_ExtractTextures() function
[void]$sr.AppendLine('Shader_ExtractTextures() {')
if ($resourceEntries.Count -gt 0) {
    $globals = ($resourceEntries | ForEach-Object { $_.ConstName }) -join ', '
    [void]$sr.AppendLine("    global $globals")
    [void]$sr.AppendLine('    if (!A_IsCompiled)')
    [void]$sr.AppendLine('        return  ; dev mode loads from src/shaders/ directly')
    [void]$sr.AppendLine('    DirCreate(A_Temp "\shaders")')
    foreach ($entry in $resourceEntries) {
        $cn = $entry.ConstName
        $fl = $entry.File
        [void]$sr.AppendLine("    ResourceExtractToTemp($cn, `"$fl`", A_Temp `"\shaders`")")
    }
} else {
    [void]$sr.AppendLine('    ; No textures to extract for current shaders')
}
[void]$sr.AppendLine('}')
[void]$sr.AppendLine('')

# Shader_GetTexturePath(fileName) helper
[void]$sr.AppendLine('; Get runtime path to a shader texture file.')
[void]$sr.AppendLine('; Compiled: extracted to %TEMP%\shaders\. Dev: loaded from src\shaders\ directly.')
[void]$sr.AppendLine('Shader_GetTexturePath(fileName) {')
[void]$sr.AppendLine('    if (A_IsCompiled)')
[void]$sr.AppendLine('        return A_Temp "\shaders\" fileName')
[void]$sr.AppendLine('    ; Dev mode: walk up from A_ScriptDir to find src/shaders/')
[void]$sr.AppendLine('    return A_ScriptDir "\shaders\" fileName')
[void]$sr.AppendLine('}')

[System.IO.File]::WriteAllText($resourcesPath, $sr.ToString(), [System.Text.UTF8Encoding]::new($false))
Write-Host "  Generated: $resourcesPath"

Write-Host "Done. $($shaders.Count) shader(s) bundled, $($resourceEntries.Count) texture(s) registered."
